---
title: "Java 锁的机制"
date: 2025-05-27 10:10:10 +0800
categories: [JAVA, JAVA 并发编程]
tags: [并发编程, JUC]
pin: false
toc: true
math: true
---

在 Java 中，锁的机制经历了多次优化和演变，主要包括无锁状态（Unlocked）、偏向锁（Biased Locking）、轻量级锁（Lightweight Locking）和重量级锁（Heavyweight Locking）。以下是它们的详细介绍：

## 无锁状态（Unlocked）：

无锁状态是指对象的锁标志位为“01”，表示该对象当前未被任何线程锁定。

- 在无锁状态下，对象的 Mark Word 中存储的是对象的哈希码、对象的年龄等信息。
- 这是对象锁的初始状态，没有任何线程持有该锁。

## 偏向锁（Biased Locking）：

偏向锁是一种优化机制，它假设锁在大部分时间里只会被一个线程持有。

- 当一个线程第一次获取锁时，锁会偏向该线程，后续该线程再次获取锁时无需进行复杂的同步操作。
- 偏向锁的锁标志位为“01”，Mark Word 中存储的是偏向线程的 ID。
- 如果有其他线程尝试获取锁，偏向锁会被撤销，并升级为轻量级锁。

> 从 JDK 15 开始，偏向锁被废弃，因为其带来的性能提升在现代应用中不再明显。

## 轻量级锁（Lightweight Locking）：

轻量级锁是偏向锁升级后的状态，用于处理多个线程交替执行同步块的情况。

- 当一个线程尝试获取锁时，如果锁标志位为“01”且偏向锁标志为“0”，则会尝试使用 CAS 操作将锁升级为轻量级锁。
- 轻量级锁的锁标志位为“00”，Mark Word 中存储的是指向当前线程栈帧中锁记录的指针。
- 如果多个线程竞争锁，轻量级锁可能会进一步升级为重量级锁。

## 重量级锁（Heavyweight Locking）：

重量级锁是传统的锁机制，通常与 synchronized 关键字相关。

- 重量级锁的锁标志位为“10”，Mark Word 中存储的是指向操作系统互斥锁的指针。
- 当线程尝试获取重量级锁时，如果锁已被其他线程持有，则当前线程会被阻塞，直到锁被释放。
- 重量级锁的实现依赖于操作系统的互斥锁，因此性能开销较大。

## 总结：

- 无锁状态是对象锁的初始状态，适用于未被同步操作访问的场景。
- 偏向锁适用于单线程反复访问锁的场景，能够减少同步开销，但在现代应用中逐渐被废弃。
- 轻量级锁适用于锁竞争不激烈的场景，能够减少线程阻塞和唤醒的开销。
- 重量级锁适用于锁竞争激烈的场景，虽然性能开销较大，但能保证严格的同步。
