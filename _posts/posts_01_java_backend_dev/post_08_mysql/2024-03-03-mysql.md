---
title: MySQL
date: 2024-03-03 06:00:00 +0800
categories: [Java Backend, MySQL]
tags: [MySQL]
toc: true
math: true
pin: false
render_with_liquid: false
---

## 什么是 MySQL？

MySQL 是一款广受欢迎的开源关系型数据库管理系统 (RDBMS)。 它将数据存储在由行和列组成的表中，并使用结构化查询语言 (SQL) 来进行数据的定义、操作、控制和查询。

### 核心定义与特点

- **关系型数据库 (RDBMS):** MySQL 基于关系模型来组织数据，这意味着数据被存储在预定义的、相互关联的表中。 这种结构化的数据存储方式，使得我们可以清晰地理解不同数据实体之间的关系，例如用户和订单之间的一对多关系。
- **开源与免费:** MySQL 是开源的，遵循 GNU 通用公共许可协议，任何人都可以免费下载、使用和根据需求修改其源代码。 这极大地降低了项目的开发成本，并且拥有一个庞大的社区，提供了丰富的文档和技术支持。 当然，MySQL 也提供商业版本以满足特定企业的需求。
- **SQL 语言:** MySQL 使用标准的 SQL 语言进行数据库操作。 这使得开发人员可以利用统一的语言进行数据的增删改查，降低了学习成本。
- **跨平台性:** MySQL 具有很好的兼容性，支持 Windows、Linux、macOS 等多种主流操作系统。
- **插件式存储引擎架构:** 这是 MySQL 一个非常重要的特性。它允许为不同的数据表选择不同的存储引擎，以满足特定场景的需求。 其中最常用的两个存储引擎是：
  - **InnoDB:** 是目前 MySQL 的默认事务型存储引擎。它支持事务安全 (ACID 特性)，支持行级锁定和外键，这对于需要高并发和数据一致性的应用（如电商、金融系统）至关重要。
  - **MyISAM:** 在早期的 MySQL 版本中是默认的存储引擎，它提供了较高的读取性能，但不支持事务和行级锁。

### 在 Java 后端开发中的重要性与应用

在日常开发中，MySQL 通常作为系统数据的持久化存储方案。 无论是用户信息、商品目录、订单记录还是业务日志，都会存储在 MySQL 中。

MySQL 之所以在 Java 后端开发中如此流行，主要有以下几个优点：

- **成熟稳定、功能完善:** 经过长时间的发展和广泛的应用验证，MySQL 非常成熟稳定，能够满足绝大多数业务场景的需求。
- **高性能:** MySQL 在处理 Web 应用方面表现出色，提供了高速的读写能力和优化的查询处理。
- **易用性与管理:** 提供了像 MySQL Workbench 这样的图形化管理工具，简化了数据库的设计、管理和维护工作。
- **良好的社区生态与丰富的文档:** 遇到问题时，可以很容易地在官方文档或活跃的开发者社区中找到解决方案。

典型的应用场景包括：

- **Web 应用与网站:** 作为动态网站和 Web 应用的首选数据库，常与 PHP、Java 等语言结合，用于开发内容管理系统（CMS）、电子商务平台、社交应用等。
- **企业级应用:** 在各类企业信息系统（如 ERP、CRM）中作为核心的数据存储。
- **联机事务处理系统 (OLTP):** 凭借其强大的事务支持和并发控制能力，非常适合用于需要保证数据一致性和可靠性的电子商务和金融交易等场景。

## MySQL 的常用命令？

关于 MySQL 的常用命令，我可以将其分为几个主要类别来详细阐述，分别是 DDL（数据定义语言）、DML（数据操作语言）、DQL（数据查询语言）和 DCL（数据控制语言）。这些命令构成了我们日常操作数据库的基础。

### 1. DDL (Data Definition Language) - 数据定义语言

DDL 主要用于定义或管理数据库的结构，比如创建、修改或删除数据库对象。

- **`CREATE`：** 用于创建数据库和表。

  - **创建数据库：**
    ```sql
    CREATE DATABASE database_name;
    ```
    例如，创建一个名为 `my_project` 的数据库。
  - **创建表：** 这是我们用得最多的 DDL 命令之一。在创建表时，需要定义列名、数据类型以及各种约束。
    ```sql
    CREATE TABLE table_name (
        column1 datatype constraints,
        column2 datatype constraints,
        ...
        PRIMARY KEY (column_name)
    );
    ```
    例如，创建一个 `users` 表：
    ```sql
    CREATE TABLE users (
        id INT AUTO_INCREMENT,
        username VARCHAR(50) NOT NULL UNIQUE,
        password VARCHAR(255) NOT NULL,
        email VARCHAR(100),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (id)
    );
    ```

- **`ALTER`：** 用于修改已存在的数据库表的结构。

  - **添加列：**
    ```sql
    ALTER TABLE table_name ADD COLUMN column_name datatype;
    ```
  - **修改列的数据类型或约束：**
    ```sql
    ALTER TABLE table_name MODIFY COLUMN column_name new_datatype;
    ```
  - **删除列：**
    ````sql
    ALTER TABLE table_name DROP COLUMN column_name;
    ```    *   **重命名表：**
    ```sql
    ALTER TABLE old_table_name RENAME TO new_table_name;
    ````

- **`DROP`：** 用于删除整个数据库或表。这是一个非常危险的操作，需要谨慎使用。

  - **删除表：**
    ```sql
    DROP TABLE table_name;
    ```
  - **删除数据库：**
    ```sql
    DROP DATABASE database_name;
    ```

- **`TRUNCATE`：** 用于快速删除表中的所有行，但保留表结构。与 `DELETE` 不同，`TRUNCATE` 通常更快，且不能回滚，也不会触发 DELETE 触发器。
  ```sql
  TRUNCATE TABLE table_name;
  ```

### 2. DML (Data Manipulation Language) - 数据操作语言

DML 用于管理数据库表中的数据，而不是表的结构。

- **`INSERT`：** 向表中插入新的数据行。

  ```sql
  INSERT INTO table_name (column1, column2, column3) VALUES (value1, value2, value3);
  ```

  也可以不指定列名，但值的顺序必须与表中列的顺序一致：

  ```sql
  INSERT INTO table_name VALUES (value1, value2, value3);
  ```

- **`UPDATE`：** 更新表中的现有数据。**非常重要的一点是，`UPDATE` 命令通常需要和 `WHERE` 子句一起使用，否则会更新表中的所有行。**

  ```sql
  UPDATE table_name
  SET column1 = new_value1, column2 = new_value2
  WHERE condition;
  ```

  例如，更新 `id` 为 1 的用户的邮箱：

  ```sql
  UPDATE users SET email = 'new_email@example.com' WHERE id = 1;
  ```

- **`DELETE`：** 从表中删除数据行。**同样，这个命令也必须谨慎使用，通常与 `WHERE` 子句结合，否则会删除表中的所有数据。**
  ```sql
  DELETE FROM table_name WHERE condition;
  ```
  例如，删除 `id` 为 2 的用户：
  ```sql
  DELETE FROM users WHERE id = 2;
  ```

### 3. DQL (Data Query Language) - 数据查询语言

DQL 用于从数据库中查询数据，这是我们日常开发中使用最频繁的部分。

- **`SELECT`：** 核心查询命令。
  - **查询所有列：**
    ```sql
    SELECT * FROM table_name;
    ```
  - **查询指定列：**
    ```sql
    SELECT column1, column2 FROM table_name;
    ```
  - **带条件的查询 (`WHERE`)：**
    ```sql
    SELECT * FROM users WHERE id = 1;
    ```
  - **排序 (`ORDER BY`)：** 可以按升序 (`ASC`，默认) 或降序 (`DESC`) 排序。
    ```sql
    SELECT * FROM users ORDER BY created_at DESC;
    ```
  - **限制返回数量 (`LIMIT`)：** 常用于分页。
    ```sql
    -- 从第0条开始，返回10条记录
    SELECT * FROM users LIMIT 10;
    -- 从第10条开始，返回10条记录 (常用于第二页)
    SELECT * FROM users LIMIT 10, 10;
    ```
  - **聚合函数 (`COUNT`, `SUM`, `AVG`, `MAX`, `MIN`) 和分组 (`GROUP BY`)：** 常用于统计分析。
    ```sql
    -- 统计每个部门的人数
    SELECT department, COUNT(*) FROM employees GROUP BY department;
    ```
  - **连接查询 (`JOIN`)：** 用于从多个表中获取数据。
    ```sql
    SELECT u.username, o.order_id
    FROM users u
    INNER JOIN orders o ON u.id = o.user_id;
    ```

### 4. DCL (Data Control Language) - 数据控制语言

DCL 用于管理数据库的访问权限和安全级别。

- **`GRANT`：** 授予用户或角色对数据库对象的特定权限。

  ```sql
  GRANT SELECT, INSERT ON my_project.* TO 'test_user'@'localhost';
  ```

  这条命令授予 `test_user` 用户在本地主机上对 `my_project` 数据库所有表的 `SELECT` 和 `INSERT` 权限。

- **`REVOKE`：** 撤销已授予的权限。

  ```sql
  REVOKE INSERT ON my_project.* FROM 'test_user'@'localhost';
  ```

- **`CREATE USER`：** 创建一个新的数据库用户。
  ```sql
  CREATE USER 'new_user'@'localhost' IDENTIFIED BY 'password';
  ```

## MySQL 中如何进行表的连接？

在 MySQL 中，表的连接（JOIN）是关系型数据库的核心操作之一，它允许我们根据某些相关的列将多个表中的行组合起来，从而进行更复杂的查询。

为了方便说明，我们假设有以下两张表：

**`employees` (员工表):**

| id  | name | department_id |
| --- | ---- | ------------- |
| 1   | 张三 | 1             |
| 2   | 李四 | 1             |
| 3   | 王五 | 2             |
| 4   | 赵六 | NULL          |

**`departments` (部门表):**

| id  | name       |
| --- | ---------- |
| 1   | 技术部     |
| 2   | 市场部     |
| 3   | 人力资源部 |

### 1. 内连接 (INNER JOIN)

内连接是最常用的一种连接类型。它会返回两个表中连接字段相匹配的行，也就是说，只有在两个表中都能找到匹配的记录时，才会出现在结果集中。

- **语法:**

  ```sql
  SELECT columns
  FROM table1
  INNER JOIN table2 ON table1.column_name = table2.column_name;
  ```

  `INNER` 关键字通常可以省略，直接写 `JOIN` 默认就是内连接。

- **示例:** 查询所有员工及其所在的部门名称。

  ```sql
  SELECT e.name, d.name
  FROM employees e
  INNER JOIN departments d ON e.department_id = d.id;
  ```

- **结果:**
  | name | name |
  | ---- | ------ |
  | 张三 | 技术部 |
  | 李四 | 技术部 |
  | 王五 | 市场部 |

  **分析:** 员工 "赵六" 因为 `department_id` 为 `NULL`，在 `departments` 表中没有匹配的 `id`，所以不会出现在结果里。同样，"人力资源部" 因为没有任何员工与之关联，也不会出现在结果里。

### 2. 左连接 (LEFT JOIN)

左连接会返回左表（`FROM` 子句后面的第一个表）的所有行，即使在右表中没有匹配的记录。对于右表中没有匹配的行，其对应的列将显示为 `NULL`。

- **语法:**

  ```sql
  SELECT columns
  FROM table1
  LEFT JOIN table2 ON table1.column_name = table2.column_name;
  ```

  `OUTER` 关键字可以省略。

- **示例:** 查询所有员工的信息，并显示他们所在的部门名称，即使某个员工没有分配部门。

  ```sql
  SELECT e.name, d.name
  FROM employees e
  LEFT JOIN departments d ON e.department_id = d.id;
  ```

- **结果:**
  | name | name |
  | ---- | ------ |
  | 张三 | 技术部 |
  | 李四 | 技术部 |
  | 王五 | 市场部 |
  | 赵六 | NULL |

  **分析:** 左表 `employees` 中的所有记录都被返回了。因为 "赵六" 的 `department_id` 在 `departments` 表中找不到匹配项，所以其对应的部门名称为 `NULL`。这个查询非常适合查找“某个实体以及它关联的实体信息，不管关联实体是否存在”的场景。

### 3. 右连接 (RIGHT JOIN)

右连接与左连接相反，它会返回右表的所有行，即使在左表中没有匹配的记录。对于左表中没有匹配的行，其对应的列将显示为 `NULL`。

- **语法:**

  ```sql
  SELECT columns
  FROM table1
  RIGHT JOIN table2 ON table1.column_name = table2.column_name;
  ```

- **示例:** 查询所有部门，并列出这些部门下的员工。

  ```sql
  SELECT e.name, d.name
  FROM employees e
  RIGHT JOIN departments d ON e.department_id = d.id;
  ```

- **结果:**
  | name | name |
  | ---- | ---------- |
  | 张三 | 技术部 |
  | 李四 | 技术部 |
  | 王五 | 市场部 |
  | NULL | 人力资源部 |

  **分析:** 右表 `departments` 中的所有记录都被返回了。因为 "人力资源部" 在 `employees` 表中找不到任何与之关联的员工，所以其对应的员工姓名为 `NULL`。这个查询常用于查找“有哪些实体还未被使用或关联”的场景，比如查找还没有员工的部门。

### 4. 全外连接 (FULL OUTER JOIN)

全外连接会返回左表和右表中的所有行。当某一行在另一个表中没有匹配时，另一个表的列会显示为 `NULL`。

- **注意:** **MySQL 本身不直接支持 `FULL OUTER JOIN` 语法。** 但是，我们可以通过 `LEFT JOIN` 和 `RIGHT JOIN` 的结果集使用 `UNION` 来模拟实现。

- **模拟语法:**

  ```sql
  SELECT columns FROM table1
  LEFT JOIN table2 ON table1.column_name = table2.column_name
  UNION
  SELECT columns FROM table1
  RIGHT JOIN table2 ON table1.column_name = table2.column_name;
  ```

- **示例:**

  ```sql
  SELECT e.name, d.name
  FROM employees e
  LEFT JOIN departments d ON e.department_id = d.id
  UNION
  SELECT e.name, d.name
  FROM employees e
  RIGHT JOIN departments d ON e.department_id = d.id;
  ```

- **结果:**
  | name | name |
  | ---- | ---------- |
  | 张三 | 技术部 |
  | 李四 | 技术部 |
  | 王五 | 市场部 |
  | 赵六 | NULL |
  | NULL | 人力资源部 |

  **分析:** 这个结果集合并了左连接和右连接的结果，并去除了重复的行（`UNION`默认去重），从而包含了所有员工和所有部门的信息。

### 5. 交叉连接 (CROSS JOIN)

交叉连接返回左表中的每一行与右表中的每一行的组合，即笛卡尔积。它不需要 `ON` 子句。

- **语法:**

  ```sql
  SELECT * FROM table1 CROSS JOIN table2;
  -- 或者
  SELECT * FROM table1, table2;
  ```

- **示例:**
  ```sql
  SELECT e.name, d.name FROM employees e CROSS JOIN departments d;
  ```
  结果将会是 4 \* 3 = 12 条记录，每个员工都会和每个部门匹配一次。这种连接在业务中不常用，除非需要生成所有可能的组合。

### 6. 自连接 (SELF JOIN)

自连接是一种特殊的连接，它指的是表与自身进行连接。这种连接通常用于处理表内具有层级关系的数据，例如员工与经理的关系（经理本身也是员工）。

- **示例:** 假设 `employees` 表还有一个 `manager_id` 列，指向其上级领导的 `id`。现在要查询每个员工及其经理的姓名。
  ```sql
  SELECT
      e1.name AS employee_name,
      e2.name AS manager_name
  FROM
      employees e1
  LEFT JOIN
      employees e2 ON e1.manager_id = e2.id;
  ```
  这里我们将 `employees` 表起了两个别名 `e1` 和 `e2`，把它当作两个独立的表来处理。

总结一下，`INNER JOIN` 用于查找两个表共有的部分，`LEFT/RIGHT JOIN` 用于以某一个表为基准查找数据，而模拟的 `FULL OUTER JOIN` 则用于展示两个表的所有数据。在实际开发中，`INNER JOIN` 和 `LEFT JOIN` 的使用频率是最高的。

## 数据库设计的三大范式？

数据库设计的三大范式是关系型数据库设计的核心理论，它们是我们在设计表结构时需要遵循的一系列准则，其主要目的是为了**消除数据冗余、减少数据异常（插入异常、更新异常、删除异常），并保证数据的一致性**。

### 第一范式 (1NF - First Normal Form)

**定义：** 确保表中的每一个列（字段）都是**不可再分的原子值**。

这是最基本、最核心的一条范式。它要求数据库表中的所有字段都是单一属性，不能是集合、数组或其他可再分的复杂结构。简而言之，一个字段只能有一个值，不能有多个值。

- **不符合 1NF 的例子：**
  假设有一个学生信息表，其中“联系方式”这一列存储了学生的多个电话号码。

  | StudentID | Name | ContactInfo              |
  | --------- | ---- | ------------------------ |
  | 1         | 张三 | 13800001111, 13900002222 |
  | 2         | 李四 | 13700003333              |

- **存在的问题：**

  1.  **无法进行有效的查询：** 如果想查询拥有 `139...` 这个号码的学生，就需要进行复杂的字符串匹配，效率低下且容易出错。
  2.  **数据冗余和维护困难：** 无法为每个电话号码单独添加备注信息（比如哪个是主号，哪个是备用号）。
  3.  **违反关系型数据库的基本原则。**

- **符合 1NF 的改造：**
  我们可以将“联系方式”拆分，创建一个新的“学生联系方式”表。

  **学生表 (Students):**

  | StudentID | Name |
  | --------- | ---- |
  | 1         | 张三 |
  | 2         | 李四 |

  **联系方式表 (Contacts):**

  | ContactID | StudentID | PhoneNumber |
  | --------- | --------- | ----------- |
  | 101       | 1         | 13800001111 |
  | 102       | 1         | 13900002222 |
  | 103       | 2         | 13700003333 |

  这样改造后，每一列都是原子性的，符合第一范式。

### 第二范式 (2NF - Second Normal Form)

**定义：** 在满足第一范式的基础上，**表中每一列都必须完全依赖于整个主键，而不能只依赖于主键的一部分**。

这个范式主要针对的是**联合主键（Composite Primary Key）**。如果一个表的主键是单一列，那么它只要满足第一范式，就自动满足第二范式。如果表是联合主键，就需要检查所有非主键列是否“完全依赖”于这个联合主键。

- **不符合 2NF 的例子：**
  假设有一个订单详情表，主键是 `(OrderID, ProductID)`。

  | OrderID | ProductID | ProductName | Quantity |
  | ------- | --------- | ----------- | -------- |
  | 1001    | P01       | 苹果手机    | 1        |
  | 1001    | P02       | 华为耳机    | 2        |
  | 1002    | P01       | 苹果手机    | 1        |

- **存在的问题：**
  主键是 `(OrderID, ProductID)`。

  - `Quantity`（数量）这个字段，它既依赖于 `OrderID` 也依赖于 `ProductID`，表示某个订单中某个产品的数量。所以它**完全依赖**于主键。
  - `ProductName`（产品名称）这个字段，它**只依赖于 `ProductID`**，与 `OrderID` 无关。无论哪个订单，只要 `ProductID` 是 `P01`，`ProductName` 就是“苹果手机”。这就产生了**部分依赖**。

  1.  **数据冗余：** “苹果手机”这个名称被存储了多次。
  2.  **更新异常：** 如果“苹果手机”要改名为“iPhone”，就需要更新所有包含 `P01` 的记录，容易遗漏。
  3.  **插入异常：** 如果想新增一个产品 `P03`，但还没有任何订单，就无法将这个产品信息插入到这个表中。
  4.  **删除异常：** 如果删除了 `1002` 号订单，那么关于 `P01` 是“苹果手机”的这条信息也就随之丢失了（假设这是唯一包含 P01 的订单）。

- **符合 2NF 的改造：**
  将表拆分为两个表，消除部分依赖。

  **订单详情表 (OrderDetails):**

  | OrderID | ProductID | Quantity |
  | ------- | --------- | -------- |
  | 1001    | P01       | 1        |
  | 1001    | P02       | 2        |
  | 1002    | P01       | 1        |

  **产品表 (Products):**

  | ProductID | ProductName |
  | --------- | ----------- |
  | P01       | 苹果手机    |
  | P02       | 华为耳机    |

### 第三范式 (3NF - Third Normal Form)

**定义：** 在满足第二范式的基础上，**任何非主键列都不能依赖于其他非主键列**。

简单来说，就是不能存在**传递依赖**。传递依赖指的是：A -> B, B -> C，那么 A -> C 就是一个传递依赖。在 3NF 中，非主键列 C 不能依赖于非主键列 B。

- **不符合 3NF 的例子：**
  假设有一个员工表，主键是 `EmployeeID`。

  | EmployeeID | Name | DepartmentID | DepartmentName |
  | ---------- | ---- | ------------ | -------------- |
  | E01        | 张三 | D01          | 技术部         |
  | E02        | 李四 | D02          | 市场部         |
  | E03        | 王五 | D01          | 技术部         |

- **存在的问题：**
  主键是 `EmployeeID`。

  - 依赖关系是：`EmployeeID` -> `DepartmentID`，以及 `DepartmentID` -> `DepartmentName`。
  - 这就导致了非主键列 `DepartmentName` 依赖于另一个非主键列 `DepartmentID`，形成了**传递依赖**。

  1.  **数据冗余：** “技术部”这个名称被存储了多次。
  2.  **更新异常：** 如果“技术部”要改名为“研发部”，就需要更新所有 `DepartmentID` 为 `D01` 的员工记录。
  3.  **插入异常：** 如果要新增一个“行政部”，但还没有员工属于这个部门，就无法将部门信息添加到员工表中。
  4.  **删除异常：** 如果“市场部”唯一的员工李四离职了，删除了他的记录，那么关于“市场部”的信息也就丢失了。

- **符合 3NF 的改造：**
  将表拆分为两个表，消除传递依赖。

  **员工表 (Employees):**

  | EmployeeID | Name | DepartmentID |
  | ---------- | ---- | ------------ |
  | E01        | 张三 | D01          |
  | E02        | 李四 | D02          |
  | E03        | 王五 | D01          |

  **部门表 (Departments):**

  | DepartmentID | DepartmentName |
  | ------------ | -------------- |
  | D01          | 技术部         |
  | D02          | 市场部         |

### 总结

- **1NF (原子性)：** 字段不可再分。
- **2NF (消除部分依赖)：** 所有非主键字段必须完全依赖整个主键（主要针对联合主键）。
- **3NF (消除传递依赖)：** 非主键字段之间不能有依赖关系，必须直接依赖于主键。

在实际的系统设计中，我们通常会遵循这三大范式，以获得一个结构良好、冗余小、没有数据异常的数据库模型。但这也不是绝对的，在某些特定场景下，比如为了查询性能的考虑，我们可能会故意违反范式，进行**反范式化（Denormalization）** 设计，例如增加一些冗余字段来避免大量的表连接（JOIN）操作。但这是一种用空间换时间的策略，需要谨慎权衡。

## MySQL 中的数据类型？

MySQL 提供了丰富的数据类型，用于满足各种数据存储需求。正确地选择数据类型对于数据库的性能、存储效率和数据的准确性都至关重要。作为后端开发，我们需要根据业务场景选择最合适的数据类型。

MySQL 的数据类型可以分为三大核心类别：**数值类型**、**字符串类型**以及**日期和时间类型**。此外，还有一些特殊类型如 JSON 和空间数据类型。

### 1. 数值类型 (Numeric Types)

数值类型用于存储各种数字，如年龄、价格、数量等。它们又可以细分为整数类型和浮点/定点数类型。

#### a. 整数类型 (Integer Types)

整数类型用于存储没有小数部分的数字。它们的区别在于存储空间和取值范围。选择时应遵循“够用即可”的原则，以节省存储空间。

| 类型                  | 存储空间 (Bytes) | 范围 (有符号)                                           | 范围 (无符号)                   | 常见用途                              |
| --------------------- | ---------------- | ------------------------------------------------------- | ------------------------------- | ------------------------------------- |
| **`TINYINT`**         | 1                | -128 到 127                                             | 0 到 255                        | 存储状态（如 0/1/2）、年龄、标志位    |
| **`SMALLINT`**        | 2                | -32,768 到 32,767                                       | 0 到 65,535                     | 较小的计数，如员工数量                |
| **`MEDIUMINT`**       | 3                | -8,388,608 到 8,388,607                                 | 0 到 16,777,215                 | 中等大小的计数                        |
| **`INT` / `INTEGER`** | 4                | -2,147,483,648 到 2,147,483,647                         | 0 到 4,294,967,295              | 最常用的整数类型，如用户 ID、订单 ID  |
| **`BIGINT`**          | 8                | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 | 0 到 18,446,744,073,709,551,615 | 海量数据的主键 ID、需要极大数值的场景 |

- **`UNSIGNED` 关键字**：如果确定数值不会是负数，可以使用 `UNSIGNED` 关键字，这会让数值的存储范围从 0 开始，上限扩大一倍。例如，主键 ID 通常都是正数，可以定义为 `INT UNSIGNED`。
- **`ZEROFILL`**：如果使用此选项，MySQL 会在数值前面自动填充 0 以达到指定的显示宽度，同时该列会自动变为 `UNSIGNED`。

#### b. 定点数类型 (Fixed-Point Type)

- **`DECIMAL(M, D)` / `NUMERIC(M, D)`**
  - **描述**：`DECIMAL` 用于存储**精确的小数值**，非常适合用于需要高精度计算的场景，比如**货币、金融数据**。 它以字符串形式存储，因此不会有精度损失。
  - **参数**：`M` 是总位数（精度），`D` 是小数点后的位数（标度）。例如 `DECIMAL(10, 2)` 可以存储最多 10 位数字，其中 2 位是小数，范围从 `-99999999.99` 到 `99999999.99`。
  - **为什么不用浮点数存钱？** 因为浮点数（`FLOAT`, `DOUBLE`）是近似值，在进行计算时可能会产生精度误差，这在金融领域是不可接受的。

#### c. 浮点数类型 (Floating-Point Types)

浮点数用于存储近似的小数值，适用于不需要极高精度的科学计算等场景。

| 类型         | 存储空间 (Bytes) | 精度                           | 描述                       |
| ------------ | ---------------- | ------------------------------ | -------------------------- |
| **`FLOAT`**  | 4                | 单精度，约 7 位十进制有效数字  | 存储较小的、非精确的小数值 |
| **`DOUBLE`** | 8                | 双精度，约 15 位十进制有效数字 | 存储较大的、非精确的小数值 |

### 2. 字符串类型 (String Types)

字符串类型用于存储文本数据，如姓名、地址、文章内容等。

| 类型             | 描述                                                                                                                                                                         | 常见用途                                                              |
| ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- |
| **`CHAR(N)`**    | **定长字符串**。`N` 的范围是 0 到 255。如果存入的字符串长度小于 `N`，它会在右侧用空格填充以达到指定长度。查询时，尾部的空格会被自动去除。存储和检索速度通常比 `VARCHAR` 快。 | 存储固定长度的数据，如 MD5 哈希值（32 位）、性别（'M'/'F'）、邮政编码 |
| **`VARCHAR(N)`** | **可变长字符串**。`N` 的范围理论上是 0 到 65,535。它只会使用必要的存储空间，外加 1 到 2 个字节来记录字符串的实际长度。这是最常用的字符串类型。                               | 姓名、标题、地址等长度不固定的文本                                    |
| **`TINYTEXT`**   | 可变长文本，最多存储 **255** 个字符。                                                                                                                                        | 较短的描述信息                                                        |
| **`TEXT`**       | 可变长文本，最多存储 **65,535** (64KB) 个字符。                                                                                                                              | 存储文章、评论等较长的文本                                            |
| **`MEDIUMTEXT`** | 可变长文本，最多存储 **16,777,215** (16MB) 个字符。                                                                                                                          | 存储非常长的文本，如 JSON 数据、日志                                  |
| **`LONGTEXT`**   | 可变长文本，最多存储 **4,294,967,295** (4GB) 个字符。                                                                                                                        | 存储极长的文本数据，如书籍、完整的文档                                |
| **`ENUM`**       | 枚举类型。只能从一个预定义的列表中选择一个值。例如 `ENUM('A', 'B', 'C')`。存储上非常高效，内部使用整数来表示。                                                               | 状态（'active', 'inactive'）、类型（'public', 'private'）             |
| **`SET`**        | 集合类型。可以从一个预定义的列表中选择零个或多个值。                                                                                                                         | 用户权限、标签（'sports', 'music', 'tech'）                           |

- **`CHAR` vs `VARCHAR` 的选择**：如果数据长度几乎都是固定的，比如手机号、MD5 值，使用 `CHAR` 性能会更好。如果数据长度变化很大，则 `VARCHAR` 更节省空间。

### 3. 日期和时间类型 (Date and Time Types)

这类数据类型专门用于处理时间相关的数据。

| 类型            | 存储空间 (Bytes) | 格式                        | 范围                                                       | 常见用途                                     |
| --------------- | ---------------- | --------------------------- | ---------------------------------------------------------- | -------------------------------------------- |
| **`DATE`**      | 3                | `YYYY-MM-DD`                | `'1000-01-01'` 到 `'9999-12-31'`                           | 存储生日、注册日期等，不关心具体时间         |
| **`TIME`**      | 3                | `HH:MM:SS`                  | `'-838:59:59'` 到 `'838:59:59'`                            | 存储持续时间或一天中的某个时间               |
| **`YEAR`**      | 1                | `YYYY`                      | 1901 到 2155                                               | 存储年份                                     |
| **`DATETIME`**  | 8                | `YYYY-MM-DD HH:MM:SS`       | `'1000-01-01 00:00:00'` 到 `'9999-12-31 23:59:59'`         | 存储固定的、具体的日期和时间，如订单创建时间 |
| **`TIMESTAMP`** | 4                | `YYYY-MM-DD HH:MM:SS` (UTC) | `'1970-01-01 00:00:01'` UTC 到 `'2038-01-19 03:14:07'` UTC | 记录数据的创建或修改时间，会自动处理时区转换 |

- **`DATETIME` vs `TIMESTAMP`**：
  - **存储和范围**：`DATETIME` 占用更多空间，范围更大。`TIMESTAMP` 有 "2038 年问题"。
  - **时区**：`DATETIME` 存储的是你插入时的字面值，与时区无关。而 `TIMESTAMP` 在存储时会将其从当前连接的时区转换为 UTC（世界标准时间），在检索时再从 UTC 转换回当前连接的时区。这使得 `TIMESTAMP` 非常适合用于国际化的应用。
  - **自动更新**：`TIMESTAMP` 类型的列可以设置为在行创建或更新时自动更新为当前时间，常用于 `created_at` 和 `updated_at` 字段。

### 4. 其他特殊类型

- **`JSON`**：从 MySQL 5.7 开始引入。 它允许你存储和操作 JSON 文档，并提供了一系列内置函数来高效地查询和处理 JSON 数据，避免了过去使用 `TEXT` 存储 JSON 时需要将数据读出到应用层再解析的麻烦。
- **空间数据类型 (Spatial Data Types)**：如 `GEOMETRY`, `POINT`, `LINESTRING` 等，用于存储地理位置信息，并可以进行地理空间相关的计算。

总结来说，为表的列选择正确的数据类型是一个重要的设计决策。它不仅影响存储需求，还直接关系到查询效率和数据的完整性。我们需要综合考虑数据的取值范围、精度要求、长度是否固定以及未来的扩展性来做出最佳选择。

## MySQL 中从数据库中移除数据的方法？

在 MySQL 中，从数据库移除数据有三种主要的方法，分别是 `DELETE`、`TRUNCATE` 和 `DROP`。这三个命令虽然都能移除数据，但它们的作用层面、执行方式、性能以及对数据库的影响有着本质的区别。

### 1. `DELETE` 命令

`DELETE` 是一个 DML（数据操作语言）命令，它用于**删除表中的一行或多行数据**。

- **作用层面：** 行（Row）级别。
- **语法：**

  ```sql
  -- 删除符合条件的特定行
  DELETE FROM table_name WHERE condition;

  -- 删除表中的所有行（谨慎操作！）
  DELETE FROM table_name;
  ```

- **核心特性：**

  1.  **可附带 `WHERE` 子句：** 这是 `DELETE` 最灵活的地方，可以精确地指定要删除的数据行。如果没有 `WHERE` 子句，它会删除表中的所有行。
  2.  **支持事务（Transactional）：** `DELETE` 操作是在事务日志中记录的。如果你在一个事务中执行了 `DELETE`，在事务提交（`COMMIT`）之前，你是可以通过 `ROLLBACK` 命令来撤销删除操作的。这对于保证数据操作的原子性至关重要。
  3.  **逐行删除：** MySQL 会逐行读取并删除符合条件的记录，并将每次删除都记录到日志中。因此，当删除大量数据时，性能会比较慢，并且会产生大量的日志文件。
  4.  **触发触发器（Triggers）：** 如果表上定义了 `ON DELETE` 类型的触发器，每删除一行，该触发器都会被执行一次。
  5.  **返回被删除的行数：** 执行后，`DELETE` 命令会返回一个整数，表示有多少行受到了影响（被删除）。
  6.  **不重置 `AUTO_INCREMENT`：** 使用 `DELETE` 删除所有数据后，表的自增计数器不会重置。如果再次插入新数据，新数据的主键 ID 会在之前的基础上继续增长。

- **适用场景：**
  - 需要删除表中的部分数据，例如“删除所有状态为已取消的订单”。
  - 需要在事务中进行删除操作，以便在出错时可以回滚。
  - 需要触发与删除相关的业务逻辑（通过触发器）。

### 2. `TRUNCATE` 命令

`TRUNCATE TABLE` 是一个 DDL（数据定义语言）命令，它用于**快速地删除一个表中的所有行**。

- **作用层面：** 表（Table）级别的数据清空。
- **语法：**
  ```sql
  TRUNCATE TABLE table_name;
  ```
- **核心特性：**

  1.  **不能使用 `WHERE` 子句：** `TRUNCATE` 只能一次性删除表中的所有数据，无法删除特定的行。
  2.  **通常不支持事务（或隐式提交）：** 尽管在技术上 `TRUNCATE` 是一条原子操作，但它通常会导致一次隐式的事务提交，因此执行后无法回滚。你不能把它放在一个事务块中期望能够 `ROLLBACK`。
  3.  **执行速度极快：** `TRUNCATE` 的效率远高于 `DELETE` 所有行。因为它不是逐行删除，而是通过释放存储表数据的数据页来实现的，类似于将表的结构保留，然后重新创建一个空表，所以开销非常小。
  4.  **不触发触发器：** 因为它不进行逐行操作，所以不会激活表上定义的 `DELETE` 触发器。
  5.  **重置 `AUTO_INCREMENT`：** 执行 `TRUNCATE` 后，表的自增计数器会重置为初始值（通常是 1）。
  6.  **锁定机制不同：** `TRUNCATE` 通常会获取一个表级的锁，在操作完成前会锁定整个表。

- **适用场景：**
  - 需要清空整张表的数据，并且不需要回滚，例如在测试前重置测试数据表。
  - 当表中的数据量非常大，使用 `DELETE` 耗时过长时，`TRUNCATE` 是一个高效的选择。

### 3. `DROP` 命令

`DROP` 也是一个 DDL（数据定义语言）命令，它的作用是**彻底地从数据库中移除整个数据库对象**，包括表、视图、索引、数据库等。

- **作用层面：** 数据库对象（Object）级别，如整个表。
- **语法：**

  ```sql
  -- 删除整张表
  DROP TABLE table_name;

  -- 删除整个数据库
  DROP DATABASE database_name;
  ```

- **核心特性：**

  1.  **删除所有内容：** `DROP TABLE` 不仅会删除表中的所有数据，还会删除表本身的定义（结构）、索引、约束、触发器等所有相关对象。
  2.  **不可回滚：** 这是一个毁灭性的操作，执行后无法恢复（除非有数据库备份）。
  3.  **释放所有空间：** 它会立即释放表所占用的所有磁盘空间。
  4.  **执行速度快：** 操作非常迅速，因为它只是更新系统的数据字典并释放空间。

- **适用场景：**
  - 确定不再需要某张表时，例如在项目重构后废弃的旧表。
  - 彻底移除一个数据库。

### 总结与对比

为了更清晰地展示它们的区别，我用一个表格来总结：

| 特性                 | `DELETE`                 | `TRUNCATE`                 | `DROP`                       |
| -------------------- | ------------------------ | -------------------------- | ---------------------------- |
| **操作对象**         | 表中的一行或多行数据     | 表中的所有数据             | 整个表（数据、结构、索引等） |
| **语言类型**         | DML (数据操作语言)       | DDL (数据定义语言)         | DDL (数据定义语言)           |
| **`WHERE` 子句**     | **可以**                 | 不可以                     | 不可以                       |
| **事务与回滚**       | **可以回滚**             | 不可回滚（或隐式提交）     | 不可回滚                     |
| **执行速度**         | 慢（逐行删除，记录日志） | **非常快**                 | 非常快                       |
| **触发器**           | **会触发**               | 不会触发                   | 不会触发                     |
| **`AUTO_INCREMENT`** | **不重置**               | **重置**                   | 随表一同删除                 |
| **返回信息**         | 返回被删除的行数         | 通常不返回行数（如返回 0） | 无                           |
| **危险程度**         | 较低（可控、可回滚）     | 中等（数据全清，不可回滚） | **极高**（表和数据永久消失） |

在日常开发中，`DELETE` 是最常用的，因为它提供了精细的控制。`TRUNCATE` 用于快速清空，尤其是在开发和测试环境中。`DROP` 则是终极的删除命令，必须在确认后果后才能使用。

## MySQL 中的 UNION 和 UNION ALL？

`UNION` 和 `UNION ALL` 是 MySQL 中用于合并两个或多个 `SELECT` 语句结果集的操作符。它们在需要从多个结构相似的表中查询数据并整合在一起时非常有用，但它们之间有一个关键且重要的区别，这个区别主要体现在**对重复数据的处理方式**以及由此带来的**性能差异**上。

### 基本概念和使用前提

首先，无论是 `UNION` 还是 `UNION ALL`，要使用它们，参与合并的 `SELECT` 语句必须遵循以下规则：

1.  **列数必须相同：** 每个 `SELECT` 语句查询的列数必须是相等的。
2.  **列的顺序必须一致：** 每个 `SELECT` 语句中列的出现顺序应该是一致的。
3.  **数据类型必须兼容：** 对应位置的列的数据类型必须相同或者是可以被 MySQL 隐式转换的兼容类型。

最终结果集的列名将由第一个 `SELECT` 语句的列名决定。

为了方便说明，我们假设有以下两张表：

**`customers_domestic` (国内客户表):**

| id  | name | city |
| --- | ---- | ---- |
| 1   | 张三 | 北京 |
| 2   | 李四 | 上海 |

**`customers_overseas` (海外客户表):**

| id  | name | city |
| --- | ---- | ---- |
| 3   | John | 纽约 |
| 2   | 李四 | 上海 |

注意，客户 "李四" 同时存在于两张表中，是一条重复的记录。

### 1. `UNION` 操作符

`UNION` 用于合并多个 `SELECT` 语句的结果集，并**自动去除结果集中的重复行**。

- **工作原理：** 当使用 `UNION` 时，MySQL 会将所有 `SELECT` 语句的结果集合并到一个临时表中，然后对这个临时表进行一次类似 `DISTINCT` 的操作，扫描并删除所有完全相同的行，最后返回这个去重后的结果集。

- **语法：**

  ```sql
  SELECT column1, column2 FROM table1
  UNION
  SELECT column1, column2 FROM table2;
  ```

- **示例：** 获取所有客户的名单，每个客户只显示一次。

  ```sql
  SELECT id, name, city FROM customers_domestic
  UNION
  SELECT id, name, city FROM customers_overseas;
  ```

- **结果：**

  | id  | name | city |
  | --- | ---- | ---- |
  | 1   | 张三 | 北京 |
  | 2   | 李四 | 上海 |
  | 3   | John | 纽约 |

  **分析：** 结果集中只有三行。重复的客户 "李四" (`2, '李四', '上海'`) 只出现了一次。这是因为 `UNION` 内部执行了去重操作。

### 2. `UNION ALL` 操作符

`UNION ALL` 同样用于合并多个 `SELECT` 语句的结果集，但它**不会进行任何去重操作**，而是简单地将所有结果直接拼接在一起。

- **工作原理：** `UNION ALL` 的执行过程非常直接，它只是将第二个 `SELECT` 的结果集直接追加到第一个 `SELECT` 结果集的末尾。因为它省去了去重的步骤，所以其执行效率通常比 `UNION` 更高。

- **语法：**

  ```sql
  SELECT column1, column2 FROM table1
  UNION ALL
  SELECT column1, column2 FROM table2;
  ```

- **示例：** 获取所有客户的记录，包括重复的。

  ```sql
  SELECT id, name, city FROM customers_domestic
  UNION ALL
  SELECT id, name, city FROM customers_overseas;
  ```

- **结果：**

  | id  | name | city |
  | --- | ---- | ---- |
  | 1   | 张三 | 北京 |
  | 2   | 李四 | 上海 |
  | 3   | John | 纽约 |
  | 2   | 李四 | 上海 |

  **分析：** 结果集中有四行。客户 "李四" 出现了两次，因为 `UNION ALL` 保留了所有原始记录。

### 核心区别与选择策略

| 特性           | `UNION`                                                         | `UNION ALL`                           |
| -------------- | --------------------------------------------------------------- | ------------------------------------- |
| **重复行处理** | **删除**重复行 (自动去重)                                       | **保留**所有行，包括重复行            |
| **性能/效率**  | **较低** (因为它需要进行排序和比较来去重)                       | **较高** (因为它只是简单地合并结果集) |
| **内部操作**   | 类似于 `(SELECT ... ) + (SELECT ...)` 之后再做一次 `DISTINCT`。 | 只是简单地将结果集拼接在一起。        |

**作为一名后端开发者，我们应该如何选择？**

1.  **根据业务需求决定：**

    - 如果业务场景要求返回一个**唯一的、不重复的**列表（例如，获取所有活跃用户的 ID），那么应该使用 `UNION`。
    - 如果业务场景需要的是一个**完整的、包含所有记录**的列表，即使有重复（例如，合并一月和二月的销售流水），那么应该使用 `UNION ALL`。

2.  **优先考虑性能：**
    - **如果可以确定合并的两个结果集之间不存在重复数据，或者业务上允许出现重复数据，那么应该毫不犹豫地选择 `UNION ALL`。** 这是因为它避免了不必要的排序和去重开销，性能会好得多。在处理大数据量时，这种性能差异会非常明显。
    - 只有在明确需要去重，并且无法通过其他更高效的方式（如在应用层处理）实现时，才使用 `UNION`。

可以简单地记作：**`UNION` = `UNION ALL` + `DISTINCT`**。

在实际开发中，大部分需要合并报表的场景，其实是不需要去重的，因此 `UNION ALL` 的使用频率会更高。

## MySQL 中的内置函数？

MySQL 提供了大量功能强大的内置函数，这些函数极大地增强了 SQL 语言的数据处理和分析能力。

### 1. 字符串函数 (String Functions)

字符串函数主要用于处理和操作字符串（`CHAR`, `VARCHAR`, `TEXT` 等）类型的数据。

- **`CONCAT(str1, str2, ...)`**：连接一个或多个字符串，将它们合并成一个字符串。

  - **示例：** `SELECT CONCAT('用户:', name, ', 城市:', city) AS user_info FROM users;`
  - **结果可能为：** "用户:张三, 城市:北京"

- **`LENGTH(str)`**：返回字符串 `str` 的字节长度。需要注意的是，对于多字节字符集（如 UTF-8），一个汉字可能占 3 个字节。

  - **示例：** `SELECT LENGTH('你好');`
  - **结果为：** `6`

- **`CHAR_LENGTH(str)`**：返回字符串 `str` 的字符数，这对于多字节字符集更为直观。

  - **示例：** `SELECT CHAR_LENGTH('你好');`
  - **结果为：** `2`

- **`SUBSTRING(str, pos, len)` / `SUBSTR(str, pos, len)`**：从字符串 `str` 的第 `pos` 个位置开始，截取 `len` 个字符。

  - **示例：** `SELECT SUBSTRING('Hello World', 7, 5);`
  - **结果为：** "World"

- **`UPPER(str)` 和 `LOWER(str)`**：分别将字符串转换为大写和小写。

  - **示例：** `SELECT UPPER('Hello'), LOWER('World');`
  - **结果为：** "HELLO", "world"

- **`TRIM([remstr FROM] str)`**：去除字符串 `str` 两端（或仅单侧，使用 `LTRIM` / `RTRIM`）的空格或指定的字符 `remstr`。

  - **示例：** `SELECT TRIM('  hello  ');`
  - **结果为：** "hello"

- **`REPLACE(str, from_str, to_str)`**：在字符串 `str` 中，将所有出现的 `from_str` 替换为 `to_str`。

  - **示例：** `SELECT REPLACE('这是一个测试', '测试', '例子');`
  - **结果为：** "这是一个例子"

- **`INSTR(str, substr)`**：返回子字符串 `substr` 在字符串 `str` 中第一次出现的位置，如果不存在则返回 0。
  - **示例：** `SELECT INSTR('MySQL is great', 'is');`
  - **结果为：** `7`

### 2. 数值函数 (Numeric Functions)

数值函数用于对数值类型（`INT`, `DECIMAL`, `FLOAT` 等）的数据进行数学运算。

- **`ABS(x)`**：返回数值 `x` 的绝对值。

  - **示例：** `SELECT ABS(-10.5);`
  - **结果为：** `10.5`

- **`ROUND(x, d)`**：将数值 `x` 四舍五入到 `d` 位小数。如果 `d` 省略，则四舍五入到整数。

  - **示例：** `SELECT ROUND(123.456, 2);`
  - **结果为：** `123.46`

- **`CEIL(x)` / `CEILING(x)`**：向上取整，返回大于或等于 `x` 的最小整数。

  - **示例：** `SELECT CEIL(9.01);`
  - **结果为：** `10`

- **`FLOOR(x)`**：向下取整，返回小于或等于 `x` 的最大整数。

  - **示例：** `SELECT FLOOR(9.99);`
  - **结果为：** `9`

- **`MOD(N, M)`**：取模运算，返回 `N` 除以 `M` 的余数。

  - **示例：** `SELECT MOD(10, 3);`
  - **结果为：** `1`

- **`RAND()`**：生成一个 0 到 1 之间的随机浮点数。
  - **示例：** `SELECT RAND();`
  - **结果为：** 一个随机数，如 `0.12345678`

### 3. 日期和时间函数 (Date and Time Functions)

这类函数用于处理日期和时间类型（`DATE`, `DATETIME`, `TIMESTAMP` 等）的数据。

- **`NOW()`**：返回当前的日期和时间 (`YYYY-MM-DD HH:MM:SS`)。
- **`CURDATE()`**：返回当前的日期 (`YYYY-MM-DD`)。
- **`CURTIME()`**：返回当前的时间 (`HH:MM:SS`)。

- **`DATE_FORMAT(date, format)`**：将日期 `date` 按照指定的 `format` 格式进行格式化。

  - **示例：** `SELECT DATE_FORMAT(NOW(), '%Y年%m月%d日 %H点%i分');`
  - **结果可能为：** "2025 年 11 月 15 日 22 点 28 分"

- **`DATE_ADD(date, INTERVAL expr unit)` / `DATE_SUB(date, INTERVAL expr unit)`**：对日期进行加减运算。

  - **示例：** `SELECT DATE_ADD('2025-01-01', INTERVAL 1 MONTH);`
  - **结果为：** "2025-02-01"

- **`DATEDIFF(date1, date2)`**：返回两个日期之间的天数差 (`date1` - `date2`)。

  - **示例：** `SELECT DATEDIFF('2025-12-31', '2025-01-01');`
  - **结果为：** `364`

- **`YEAR(date)` / `MONTH(date)` / `DAY(date)`**：分别从日期中提取年、月、日。
  - **示例：** `SELECT YEAR(CURDATE());`
  - **结果为：** `2025`

### 4. 聚合函数 (Aggregate Functions)

聚合函数通常与 `GROUP BY` 子句一起使用，对一组值进行计算并返回单个值。

- **`COUNT(expr)`**：计算行数。

  - `COUNT(*)` 或 `COUNT(1)`：计算表中的总行数。
  - `COUNT(column_name)`：计算指定列中非 `NULL` 值的行数。
  - `COUNT(DISTINCT column_name)`：计算指定列中唯一且非 `NULL` 值的行数。
  - **示例：** `SELECT COUNT(*) FROM users;`

- **`SUM(expr)`**：计算指定列的数值总和。

  - **示例：** `SELECT SUM(salary) FROM employees;`

- **`AVG(expr)`**：计算指定列的平均值。

  - **示例：** `SELECT AVG(price) FROM products;`

- **`MAX(expr)` 和 `MIN(expr)`**：分别返回指定列的最大值和最小值。

  - **示例：** `SELECT MAX(age), MIN(age) FROM students;`

- **`GROUP_CONCAT(expr)`**：这是一个非常有用的函数，它将 `GROUP BY` 分组后，同一组内的多个行的某个字段值连接成一个字符串。
  - **示例：** 查询每个部门下的所有员工姓名列表。
    ```sql
    SELECT department_id, GROUP_CONCAT(name SEPARATOR ';')
    FROM employees
    GROUP BY department_id;
    ```

### 5. 流程控制函数 (Control Flow Functions)

流程控制函数允许在 SQL 语句中实现条件逻辑。

- **`IF(expr1, expr2, expr3)`**：如果表达式 `expr1` 为真，则返回 `expr2`；否则返回 `expr3`。类似于三元运算符。

  - **示例：** `SELECT name, IF(gender = 1, '男', '女') AS gender_text FROM users;`

- **`IFNULL(expr1, expr2)`**：如果 `expr1` 不为 `NULL`，则返回 `expr1`；否则返回 `expr2`。

  - **示例：** `SELECT IFNULL(address, '地址未填写') FROM users;`

- **`CASE` 表达式**：这是实现更复杂 `if-then-else` 逻辑的标准方式。
  - **简单 CASE 表达式：**
    ```sql
    SELECT name,
           CASE grade
               WHEN 'A' THEN '优秀'
               WHEN 'B' THEN '良好'
               ELSE '及格'
           END AS grade_desc
    FROM scores;
    ```
  - **搜索 CASE 表达式：**
    ```sql
    SELECT name,
           CASE
               WHEN score >= 90 THEN '优秀'
               WHEN score >= 75 THEN '良好'
               ELSE '及格'
           END AS score_level
    FROM scores;
    ```

在日常开发中，熟练运用这些函数可以帮助我们更高效地进行数据查询和操作，避免在应用层进行不必要的数据处理。

## MySQL 中 count(列名)、count(\*) 和 count(1) 的区别？

`count(列名)`、`count(*)` 和 `count(1)` 都可以用来进行计数，但它们之间存在着关键的功能差异和性能差异。

### 1. 功能区别 (The Functional Difference)

这是三者最本质的区别，核心在于**对 `NULL` 值的处理**。

- **`count(列名)`**:

  - **功能**：统计指定 `列名` 中 **非 `NULL` 值** 的行的数量。
  - **一句话总结**：它会忽略值为 `NULL` 的行。
  - **示例**：假设我们有一个用户表 `users`，其中 `phone_number` 列允许为 `NULL`。
    ```sql
    -- 查询填写了手机号的用户数量
    SELECT count(phone_number) FROM users;
    ```
    这个查询结果会小于或等于表的总行数，因为它只计算了 `phone_number` 不为 `NULL` 的那些用户。

- **`count(*)`**:

  - **功能**：统计结果集中的**总行数**。
  - **一句话总结**：它不会忽略任何行，直接返回所有行的计数。
  - **误区澄清**：一个常见的误解是 `count(*)` 会读取表中所有的列，导致性能低下。**这是错误的**。这里的 `*` 只是一个语法符号，它告诉数据库服务器计算所有行，而不需要关心任何特定列的值。MySQL 优化器会智能地选择最高效的方式来完成这个计数。

- **`count(1)`**:
  - **功能**：与 `count(*)` 类似，也是统计结果集中的**总行数**。
  - **一句话总结**：它也不会忽略任何行。
  - **原理**：这里的 `1` 是一个常量（你也可以换成 `count(0)`、`count('any_string')` 等任何非 `NULL` 的常量）。对于每一行，数据库都会评估这个常量 `1`，因为它永远不是 `NULL`，所以每一行都会被计数。

**小结：**

- `count(列名)` 用于统计特定列的非空值数量。
- `count(*)` 和 `count(1)` 在功能上完全等价，都是用来统计表的总行数。

### 2. 性能与执行计划 (Performance and Execution Plan)

既然 `count(*)` 和 `count(1)` 功能相同，那么它们的性能是否有差异呢？这需要从 MySQL 优化器和存储引擎的层面来分析。

#### a. `count(*)` vs `count(1)`

- **结论先行**：在现代的 MySQL 版本（例如 5.7+ 和 8.0+）中，**`count(*)` 和 `count(1)` 的性能没有任何区别**。
- **优化器处理**：MySQL 的查询优化器会识别出 `count(1)` 的意图与 `count(*)` 相同，都是获取总行数。因此，它会将 `count(1)` 自动优化为 `count(*)`，并为它们生成完全相同的执行计划。所以，纠结于这两者谁更快是没有意义的。

#### b. `count(列名)` vs `count(*)` / `count(1)`

- **结论先行**：`count(*)` 和 `count(1)` 的性能通常**优于或等于** `count(列名)`。
- **执行计划分析**：
  1.  **对于 `count(*)` 和 `count(1)`**：优化器的目标是找到最快的方式来统计行数。它会**选择一个最小的可用索引**来扫描。为什么是最小的索引？因为索引比主键（聚簇索引）包含的数据少得多，扫描索引的 I/O 开销远小于扫描整个表数据。这个过程只需要遍历索引，不需要回到主键索引去读取完整的行数据。
  2.  **对于 `count(列名)`**：优化器必须扫描并检查 `列名` 这一列的值是否为 `NULL`。
      - 如果这个 `列名` 是一个**没有索引的普通列**，那么 MySQL 将不得不进行**全表扫描**，逐行读取数据并检查该列，性能会很差。
      - 如果这个 `列名` 是一个**有索引的列**，MySQL 会扫描这个索引。但它仍然需要获取列的值进行 `NULL` 判断，这个过程的效率通常不会超过 `count(*)` 直接利用最优索引进行计数的效率。

#### c. 存储引擎的影响

存储引擎对 `count` 的性能也有巨大影响，主要体现在 MyISAM 和 InnoDB 上。

- **MyISAM**：MyISAM 引擎内部维护了一个元数据，专门记录了表的总行数。因此，当你不带 `WHERE` 条件执行 `SELECT count(*) FROM table` 时，MyISAM 可以**直接返回这个预存的计数值**，速度极快，时间复杂度是 O(1)。
- **InnoDB**：InnoDB 是我们现在最常用的事务型存储引擎。由于它支持**MVCC（多版本并发控制）**，数据库在同一时间点对不同的事务可能呈现出不同的数据视图（即不同的行数）。因此，InnoDB 无法像 MyISAM 那样维护一个简单的行计数器。当执行 `count(*)` 时，InnoDB 必须通过扫描索引或全表扫描的方式来实时计算行数，时间复杂度是 O(N)。这也是为什么在大数据量的 InnoDB 表上执行 `count(*)` 会比较慢的原因。

### 3. 结论与最佳实践

1.  **功能上**：`count(列名)` 用于统计非空行，而 `count(*)` 和 `count(1)` 用于统计所有行。
2.  **性能上**：
    - `count(*)` 和 `count(1)` 性能相同，因为优化器会将它们视为等价。
    - 它们的性能通常优于 `count(列名)`。
3.  **最佳实践**：

    - **推荐使用 `count(*)`**。理由如下：

      - **标准和规范**：`count(*)` 是 SQL-92 标准中定义的官方、标准的写法，用于计算表的行数。
      - **语义清晰**：它的意图非常明确，就是“统计所有行”。
      - **无需担心性能**：MySQL 社区和官方文档都明确指出，`count(*)` 会被高效地优化。

    - **何时使用 `count(列名)`？**
      - 只有当你的业务需求是**明确地要统计某一列中非空记录的数量**时，才使用它。

总结一下，当需要统计表的总行数时，我们应该遵循标准，使用 `count(*)`，它清晰、规范，并且 MySQL 会为我们处理好底层的性能优化。

## MySQL 中 SELECT 语句的执行过程？

MySQL 服务器的架构在逻辑上是分层的，一个 `SELECT` 查询的生命周期会依次穿过这些层次。我可以将整个执行过程概括为以下几个关键步骤：

**查询流程示意图:**

`客户端 -> 连接器 -> [查询缓存] -> 分析器 -> 优化器 -> 执行器 -> 存储引擎 -> 客户端`

### 1. 客户端发送请求与连接处理 (Connection)

首先，客户端（比如一个 Java 应用程序）通过 TCP/IP 协议与 MySQL 服务器建立连接。

- **连接器 (Connector):** 服务器端的连接器负责处理客户端的连接请求。它会验证用户的身份（用户名和密码），并检查该用户拥有的权限。
- 一旦连接建立成功，连接器会将这个连接分配给一个工作线程。之后，该连接上的所有操作都由这个线程负责，直到连接断开。

### 2. 查询缓存 (Query Cache) - [已废弃但有必要了解]

在早期的 MySQL 版本中（8.0 版本之前），这是一个重要的环节。

- **工作机制:** 当收到一个 `SELECT` 查询后，服务器会先检查查询缓存。它会用一个大小写敏感的哈希算法计算查询语句的哈希值，然后在缓存中查找是否存在相同哈希值的结果集。
- **缓存命中 (Cache Hit):** 如果找到了，服务器会跳过后续所有复杂的步骤，直接从缓存中将结果返回给客户端。这个过程效率极高。
- **缓存未命中 (Cache Miss):** 如果没找到，则继续执行后续步骤，并在执行完毕后，将查询结果和查询语句的哈希存入缓存中。
- **为什么被废弃？** 查询缓存的失效机制非常粗暴。只要一个表的数据发生任何变化（`INSERT`, `UPDATE`, `DELETE`等），那么所有与这个表相关的查询缓存都会被清空。对于更新频繁的表来说，缓存的命中率极低，而维护缓存（检查、失效、写入）本身却带来了额外的开销。因此，从 MySQL 8.0 开始，这个功能被彻底移除了。

### 3. 分析器 (Parser & Preprocessor)

如果缓存未命中（或者在 8.0+版本中），查询语句会进入分析器。

- **第一步：词法分析 (Lexical Analysis):** MySQL 需要将你输入的 SQL 字符串分解成一个个独立的“词法单元”（Tokens）。例如，`SELECT name FROM users WHERE id = 1;` 会被分解为 `SELECT`, `name`, `FROM`, `users`, `WHERE`, `id`, `=`, `1` 这些独立的单元。
- **第二步：语法分析 (Syntactic Analysis):** 接着，语法分析器会根据 MySQL 的 SQL 语法规则，检查这些词法单元的组合是否合法，并最终生成一个数据结构——**“解析树” (Parse Tree)** 或称之为抽象语法树（AST）。如果你的 SQL 语句有语法错误，比如写成了 `SELECT name FROMM users`，那么在这个阶段就会报错。
- **第三步：预处理器 (Preprocessor):** 在这一步，会进一步检查解析树的语义。比如，检查表 `users` 是否存在，检查列 `name` 和 `id` 是否属于 `users` 表，解析 `*` 通配符为表的实际所有列名等。同时，也会验证用户的权限，看用户是否有权查询这张表。

### 4. 优化器 (Optimizer)

经过分析器，MySQL 已经完全理解了你要做什么。但“条条大路通罗马”，实现同一个查询目标可以有很多种不同的方法。优化器的核心任务就是**生成一个最佳的执行计划 (Execution Plan)**。

这是 MySQL 的大脑，也是决定查询性能最关键的一环。它会基于成本模型（Cost-Based Optimization）来做决策，这里的“成本”主要指 CPU 和 I/O 的开销。

优化器会做很多事情，比如：

- **选择最合适的索引：** 如果 `WHERE` 子句中的 `id` 列上有多个索引（例如一个主键索引，一个普通索引），优化器会根据索引的统计信息（如基数，Cardinality）来判断哪个索引能最快地筛选出数据。
- **决定表的连接顺序：** 对于多表 `JOIN` 查询，比如 `A JOIN B JOIN C`，优化器会分析不同的连接顺序（如 `(A-B)-C` 还是 `(B-C)-A`）所产生的成本，选择成本最低的那个顺序。
- **查询重写：** 优化器可能会对原始 SQL 进行等价改写，使其更易于执行。例如，它可能会将外连接（`LEFT JOIN`）在某些条件下转换为内连接（`INNER JOIN`），或者简化一些常量表达式。

最终，优化器会产出一个它认为最有效率的**执行计划**。我们可以通过 `EXPLAIN` 命令来查看 MySQL 为我们的查询选择了什么样的执行计划，这是我们进行 SQL 优化的最重要工具。

### 5. 执行器 (Executor)

当优化器确定了执行计划后，就轮到执行器来“动手”了。

- **执行入口：** 执行器是操作的入口，它会根据执行计划，调用下层的存储引擎提供的接口来完成操作。
- **执行过程：** 执行器会按照执行计划中的步骤，一步步地进行数据提取。例如，计划可能是：“使用 `users` 表的主键索引 `PRIMARY` 找到 `id=1` 的那一行数据”。执行器就会调用存储引擎的接口去执行这个查找操作。
- **数据处理：** 如果查询中有 `JOIN`，执行器会根据计划驱动一个表去另一个表中匹配数据。如果查询中有排序（`ORDER BY`），执行器会在获取所有数据后进行排序。

### 6. 存储引擎 (Storage Engine)

存储引擎是真正负责**数据的存储和提取**的组件。它位于 MySQL 架构的最底层，与磁盘进行交互。

- **接口交互：** 存储引擎是根据执行器通过 API 的指令来工作的。例如，执行器发出“获取下一行”的指令，存储引擎就从数据文件或内存（如 InnoDB 的 Buffer Pool）中读取数据并返回给执行器。
- **数据存取：** 像我们最常用的 InnoDB 存储引擎，它负责管理数据页、使用 B+树结构来存储索引和数据、处理事务、实现 MVCC 以及提供行级锁等。

### 7. 返回结果给客户端

执行器从存储引擎获取到所有满足条件的数据行后，会将结果集返回给客户端。如果是通过网络连接，这些数据会经过网络传输回到最初发起请求的应用程序中。

至此，一个 `SELECT` 查询的完整生命周期就结束了。这个过程虽然复杂，但正是这些组件的协同工作，才保证了数据库的强大功能和高效运行。

## MySQL 中 UPDATE 语句的执行过程？

`UPDATE` 语句的执行过程比 `SELECT` 要复杂得多，因为它涉及到数据的修改，必须通过一系列精密的机制来保证数据的**一致性（Consistency）**、**持久性（Durability）**和**隔离性（Isolation）**，也就是 ACID 特性中的关键部分。

同样，`UPDATE` 语句也会经历连接器、分析器、优化器、执行器等阶段，但其核心差异在于**执行器与存储引擎（以 InnoDB 为例）的交互方式**，以及引入了重要的日志系统：**Redo Log（重做日志）** 和 **Undo Log（回滚日志）**。

假设我们要执行这样一条 SQL：
`UPDATE users SET name = '张三' WHERE id = 1;`

### 第一阶段：与 `SELECT` 类似的前期流程

1.  **连接器 (Connector):** 客户端连接到 MySQL 服务器，进行权限验证。
2.  **分析器 (Parser):** 对 `UPDATE` 语句进行词法和语法分析，生成解析树。它会识别出这是一个更新操作，要更新的表是 `users`，更新的列是 `name`，值为 `'张三'`，条件是 `id = 1`。
3.  **优化器 (Optimizer):**
    - **确定查询计划：** 优化器会决定如何找到 `id = 1` 这一行。由于 `id` 通常是主键或有索引，优化器会决定使用主键索引来定位这条记录，这是最高效的方式。
    - **生成执行计划：** 最终产出一个执行计划，告诉执行器应该如何操作。

到此为止，`UPDATE` 的“查询”部分已经完成。接下来进入核心的“更新”部分。

### 第二阶段：执行器与 InnoDB 存储引擎的交互（核心流程）

执行器拿到执行计划后，会调用存储引擎的接口来执行更新。这里以 InnoDB 为例，它的内部操作是保证数据安全的关键。

**第 4 步：执行器调用引擎接口，准备更新**

执行器向 InnoDB 发出指令：“请更新 `users` 表中 `id=1` 的这一行”。

**第 5 步：InnoDB 引擎的内部操作**

InnoDB 收到指令后，并不会直接去修改磁盘上的数据文件，而是执行以下一系列操作：

1.  **查询数据页并加载到 Buffer Pool：**

    - InnoDB 会首先在其内存缓冲池 **Buffer Pool** 中查找 `id=1` 这条记录所在的数据页。
    - 如果数据页在 Buffer Pool 中（缓存命中），则直接使用。
    - 如果不在（缓存未命中），则会从磁盘（`.ibd` 文件）中将该数据页加载到 Buffer Pool 中。

2.  **写入 Undo Log（回滚日志）：**

    - 在对内存中的数据进行任何修改**之前**，InnoDB 会先记录 **Undo Log**。
    - **内容：** Undo Log 记录的是数据的**旧版本**。对于这条 `UPDATE` 语句，它会记录下 `id=1` 这一行修改前的内容（比如 `name` 原本是 `'李四'`）。
    - **作用：**
      - **事务回滚 (Rollback):** 如果事务执行失败或者用户手动执行 `ROLLBACK`，InnoDB 可以利用 Undo Log 将数据恢复到修改之前的状态。
      - **实现 MVCC (多版本并发控制):** 当其他事务需要读取这一行时，如果隔离级别允许（如读已提交、可重复读），InnoDB 可以从 Undo Log 中读取旧版本的数据提供给它们，从而实现非阻塞读。

3.  **在 Buffer Pool 中修改数据：**

    - 现在，InnoDB 可以在内存（Buffer Pool）中的数据页上，放心地将 `id=1` 这一行的 `name` 字段修改为 `'张三'`。
    - 此时，Buffer Pool 中的这个数据页就变成了 **“脏页” (Dirty Page)**，因为它已经被修改，但尚未同步到磁盘上的数据文件中。

4.  **写入 Redo Log（重做日志）：**
    - 接着，InnoDB 会记录 **Redo Log**。这是保证持久性的核心。
    - **内容：** Redo Log 记录的是**物理层面的修改**，即“在哪个数据页的哪个偏移量上，做了什么修改”。它记录的是数据**新版本**的内容。
    - **工作机制 (Write-Ahead Logging, WAL)：** 日志先行。在数据真正写入磁盘之前，必须先将这次操作的日志写入磁盘。即使数据库在此时宕机，只要 Redo Log 成功写入了，重启后就可以通过 Redo Log 来恢复这条已提交的修改，保证数据不丢失。
    - **Redo Log 的写入过程（Prepare 阶段）：** InnoDB 会将这个 Redo Log 记录写入 **Redo Log Buffer**（内存中），并将其标记为 **`prepare`** 状态。之后，它会根据一定的策略（通常是事务提交时）将 Redo Log Buffer 的内容刷入磁盘的 Redo Log 文件中。

### 第三阶段：执行器与日志系统协调（两阶段提交）

如果数据库开启了 `binlog`（用于主从复制和数据恢复），为了保证 `redo log`（InnoDB 引擎层）和 `binlog`（MySQL Server 层）的数据一致性，MySQL 会采用**两阶段提交 (Two-Phase Commit)** 策略。

**第 6 步：执行器写 Binlog**

- 当 InnoDB 完成 `redo log` 的 `prepare` 阶段后，会通知执行器。
- 执行器接收到通知后，会开始写 **Binlog**。Binlog 记录的是逻辑层面的 SQL 语句（或行的变更），如 `UPDATE users SET name = '张三' WHERE id = 1;`。

**第 7 步：提交事务 (Commit)**

- 执行器将 Binlog 成功写入磁盘文件后，会再次调用 InnoDB 的接口，通知它可以提交事务了。
- InnoDB 收到通知后，会将之前处于 `prepare` 状态的 Redo Log 修改为 **`commit`** 状态。

**至此，一个事务被认为是成功提交了。服务器可以向客户端返回“更新成功”的响应。**

**为什么需要两阶段提交？**
这是为了防止数据库在写入日志的过程中宕机导致主从不一致。试想一下：

- **如果先写 redo log 再写 binlog：** 假设 redo log 写完后宕机，binlog 没写。重启后，数据库通过 redo log 恢复了数据，但 binlog 中没有这次操作的记录，从库就不会同步这个修改，导致主从不一致。
- **如果先写 binlog 再写 redo log：** 假设 binlog 写完后宕机，redo log 没写。重启后，数据库因为没有 redo log 不会恢复数据，但 binlog 已经记录了这次操作，从库会执行这个修改，也导致主从不一致。
  两阶段提交保证了 redo log 和 binlog 的写入是一个原子操作。

### 第四阶段：后台刷脏页

最后，InnoDB 会在一个合适的时机（比如后台线程定时刷新，或者 Buffer Pool 空间不足时），将 Buffer Pool 中的“脏页”（即 `id=1` 那个被修改过的数据页）异步地刷入磁盘的数据文件中，完成数据的最终持久化。

### 总结

`UPDATE` 的执行过程可以概括为：

1.  通过优化器找到要更新的行。
2.  将旧数据写入 **Undo Log** 以便回滚。
3.  在内存（**Buffer Pool**）中修改数据。
4.  将修改内容写入 **Redo Log**（Prepare 状态）。
5.  将操作写入 **Binlog**。
6.  提交事务，将 **Redo Log** 标记为 Commit 状态。
7.  （后台）将内存中的脏页刷回磁盘。

这个流程通过 **WAL**（预写日志）、**两阶段提交**等机制，在性能（尽量操作内存）和数据安全（通过日志保证持久化和一致性）之间取得了完美的平衡。

## MySQL 的整体架构？

MySQL 的架构在逻辑上是一个**分层的、客户端/服务器（C/S）** 的模型。其最核心的特点是拥有一个**可插拔的存储引擎（Pluggable Storage Engines）** 架构，这使得 MySQL 能够灵活地适应不同的应用场景。

可以将其整体架构分为四个主要层次，自上而下分别是：

1.  **连接层 (Connection Layer)**
2.  **服务层 (Service Layer)**
3.  **存储引擎层 (Engine Layer)**
4.  **物理文件层 (File System Layer)**

### 1. 连接层 (Connection Layer)

这是架构的最顶层，主要负责处理客户端的连接请求。

- **客户端 (Clients):** 各种能够与 MySQL 服务器建立连接的应用程序，例如我们的 Java 应用（通过 JDBC）、Python 应用、命令行工具（如 `mysql`）、图形化工具（如 MySQL Workbench, DataGrip）等。
- **连接器 (Connectors):** 提供与 MySQL 服务器通信的 API。不同语言有不同的实现，比如 Java 的 `JDBC` 驱动。
- **连接池/线程处理 (Connection Pool / Thread Handling):**
  - **职责：** 负责接收和管理客户端的连接。当一个客户端连接请求到达时，它会进行身份认证（用户名和密码）和权限验证（该用户可以执行哪些操作）。
  - **工作模式：** 传统上，MySQL 采用“一个连接一个线程”的模型。每当有新的客户端连接，连接池会为其分配一个工作线程来专门处理该连接上的所有请求，直到连接断开。

### 2. 服务层 (Service Layer)

这是 MySQL 的**核心大脑**，所有跨存储引擎的功能都在这一层实现。它接收来自连接层的 SQL 请求，并进行一系列的处理。

- **SQL 接口 (SQL Interface):** 接收客户端发送的 SQL 命令（如 `SELECT`, `UPDATE`, `INSERT` 等），并返回查询结果。

- **解析器 (Parser):**

  - 对接收到的 SQL 语句进行**词法分析**和**语法分析**，检查 SQL 语句的语法是否正确。
  - 如果语法无误，它会将 SQL 语句转换成一个内部的数据结构，即**“解析树”（Abstract Syntax Tree, AST）**。

- **查询优化器 (Query Optimizer):**

  - **这是决定查询性能最关键的部分。** 优化器接收解析树，并根据一系列复杂的算法和成本估算，生成一个最优的**执行计划 (Execution Plan)**。
  - **优化内容包括：**
    - **选择最合适的索引：** 决定使用哪个索引来访问数据。
    - **决定表的连接顺序：** 在多表 `JOIN` 查询中，先连接哪两张表对性能影响巨大。
    - **重写查询：** 可能会对原始 SQL 进行等价的改写，以提高执行效率。
  - 我们可以通过 `EXPLAIN` 命令来查看优化器为我们生成的执行计划。

- **缓存与缓冲区 (Caches & Buffers):**

  - 服务层拥有自己的缓存机制。其中最著名的是**查询缓存 (Query Cache)**，但在 **MySQL 8.0 中已被完全移除**，因为它在高并发写入场景下维护成本极高且命中率低。
  - 除此之外，还有一些其他的缓存，如权限缓存等。

- **执行器 (Executor):**
  - 在优化器生成执行计划后，执行器负责调用存储引擎提供的 API 来**执行**这个计划。
  - 执行器会根据执行计划中的步骤，一步步地操作数据（比如打开表、扫描索引、返回数据行），并将最终的结果返回给客户端。

### 3. 存储引擎层 (Engine Layer)

这是 MySQL 架构中最具特色的部分。存储引擎层是**真正负责数据的存储和提取**的组件。它采用**插件式**设计，这意味着 MySQL 服务器通过统一的 API 与不同的存储引擎进行通信，而每个存储引擎都有其独特的特性和适用场景。

- **存储引擎 API:** 服务层通过这套标准的 API 与存储引擎交互，屏蔽了不同引擎间的差异。

- **常见的存储引擎:**
  - **InnoDB:**
    - **当前 MySQL 的默认存储引擎**。
    - **核心特性:** 支持**事务 (ACID)**、**行级锁定 (Row-Level Locking)**、**外键约束 (Foreign Keys)** 和**崩溃恢复**。它通过 **MVCC (多版本并发控制)** 来支持高并发读写。是绝大多数 OLTP（在线事务处理）应用的首选。
  - **MyISAM:**
    - MySQL 5.5 之前的默认引擎。
    - **核心特性:** **不支持事务和外键**，采用**表级锁定 (Table-Level Locking)**，读取性能非常高。适合用于读密集、对事务完整性要求不高的场景，如日志记录、数据仓库等。
  - **Memory (HEAP):**
    - 将所有数据存储在内存中，速度极快。
    - **核心特性:** 数据在数据库重启后会丢失。适用于存储临时数据或需要快速访问的查找表。

### 4. 物理文件层 (File System Layer)

这一层是物理介质，负责将数据和日志实际存储在服务器的硬盘上。

- **数据文件 (Data Files):**

  - 每个数据库都有一个对应的子目录。
  - 不同的存储引擎以不同的文件格式存储数据。例如，对于 InnoDB，通常每个表都有一个 `.ibd` 文件（如果开启了 `innodb_file_per_table`），用于存储该表的数据和索引。

- **日志文件 (Log Files):** 这些日志是保证数据安全和一致性的关键。
  - **重做日志 (Redo Log):** InnoDB 特有的物理日志，用于实现事务的**持久性**和**崩溃恢复**。
  - **回滚日志 (Undo Log):** InnoDB 特有的，用于事务的**原子性**（回滚操作）和实现 **MVCC**。
  - **二进制日志 (Binlog):** 这是 Server 层的日志，记录了所有对数据库进行修改的逻辑操作。主要用于**主从复制 (Replication)** 和**数据恢复 (Point-in-Time Recovery)**。

### 一个查询的旅程总结

1.  客户端应用通过**连接器**连接到 MySQL。
2.  **连接层**验证权限，并分配一个线程。
3.  **服务层**接收 SQL，**解析器**生成解析树。
4.  **优化器**根据解析树生成最优的**执行计划**。
5.  **执行器**调用**存储引擎层**的 API 来执行计划。
6.  **存储引擎**在**物理文件层**中查找或修改数据，并通过日志文件保证操作的安全性。
7.  结果最终通过服务层和连接层返回给客户端。

这种分层解耦的架构，特别是可插拔的存储引擎设计，赋予了 MySQL 极大的灵活性和强大的功能，使其能够胜任从小型网站到大型企业级应用等各种复杂场景。

## MySQL 中的存储引擎？

MySQL 的强大和灵活性在很大程度上归功于其**可插拔的存储引擎架构（Pluggable Storage Engine Architecture）**。我们可以把存储引擎理解为 MySQL 数据库中负责处理不同表类型的数据存储、检索以及实现底层 I/O 操作的“发动机”。

这种架构允许我们为同一个数据库中的不同表选择不同的存储引擎，从而可以根据业务场景的具体需求（如事务支持、并发性能、读写偏好等）进行精细化的优化。

### 1. InnoDB 存储引擎

**InnoDB 是当前 MySQL 的默认存储引擎，也是功能最全面、应用最广泛的引擎。** 对于任何需要高可靠性和高并发性的应用，InnoDB 都是首选。

- **核心特性：**

  1.  **支持事务（ACID 兼容）：** 这是 InnoDB 最重要的特性。它通过 Redo Log 和 Undo Log 保证了事务的原子性、一致性、隔离性和持久性。这对于金融、电商等对数据一致性要求极高的系统是必不可少的。
  2.  **行级锁定（Row-Level Locking）：** InnoDB 在操作数据时，只会锁定需要修改的行，而不是整个表。这极大地提高了在高并发写入场景下的性能，减少了锁冲突。
  3.  **多版本并发控制（MVCC）：** InnoDB 通过 MVCC 机制实现了非阻塞的读操作。这意味着“读不阻塞写，写不阻塞读”，大大提升了数据库的并发处理能力。
  4.  **支持外键（Foreign Key Constraints）：** 保证了数据的完整性和引用的一致性。
  5.  **崩溃安全恢复：** InnoDB 使用 Redo Log 机制，即使数据库异常宕机，也能在重启后自动恢复已提交但尚未写入数据文件的数据，保证了数据的持久性。
  6.  **聚簇索引：** InnoDB 的表是基于主键的聚簇索引结构来组织的，这意味着表数据本身就是按照主键顺序存储的。这使得基于主键的查询速度非常快。

- **适用场景：**
  - 绝大多数的 OLTP（在线事务处理）应用，如电商系统、金融系统、社交应用等。
  - 需要高并发写入、更新和删除操作的场景。
  - 对数据一致性和可靠性有严格要求的业务。
  - 简而言之，**对于绝大多数现代 Web 应用，选择 InnoDB 都是正确且安全的选择。**


### 2. MyISAM 存储引擎

MyISAM 是 MySQL 5.5 版本之前的默认存储引擎。虽然现在已被 InnoDB 取代，但在某些特定场景下仍有其用武之地。

- **核心特性：**

  1.  **不支持事务和外键：** 这是它与 InnoDB 最大的区别，也是其最大的局限性。操作不具备原子性，无法保证数据的强一致性。
  2.  **表级锁定（Table-Level Locking）：** MyISAM 在执行写入操作（INSERT, UPDATE, DELETE）时，会锁定整个数据表。这导致在高并发写入时性能会急剧下降，因为所有写操作都需要排队等待。
  3.  **极高的读取性能：** 由于其结构简单，没有事务和行级锁的开销，MyISAM 在纯读取或读多写少的场景下，性能表现非常出色。
  4.  **存储表的行数：** MyISAM 表会缓存整个表的总行数。因此，执行 `SELECT COUNT(*) FROM table` 这类不带 `WHERE` 条件的查询时，可以瞬间返回结果，速度极快。
  5.  **支持全文索引（Full-text Indexing）：** 曾是 MyISAM 的一个主要优势，但现在 InnoDB 也提供了很好的支持。

- **适用场景：**
  - 数据仓库、报表系统等读密集型应用。
  - 日志记录表，这类应用通常是批量插入，很少更新和删除。
  - 对事务完整性没有要求的业务。


### 3. Memory (HEAP) 存储引擎

Memory 存储引擎将所有数据都存储在内存中，提供了极高的访问速度。

- **核心特性：**

  1.  **数据存储在内存中：** 读写速度非常快，因为避免了磁盘 I/O。
  2.  **数据易失性：** 服务器一旦关闭或重启，Memory 表中的所有数据都会丢失。
  3.  **表级锁定：** 并发写入性能较差。
  4.  **默认使用哈希索引：** 这使得等值查询（`=`）非常快，但不适合范围查询（`<`, `>`）。也支持 B-Tree 索引。
  5.  **存储空间有限：** 表的大小受限于服务器的总内存。

- **适用场景：**
  - 用作临时表，存储中间查询结果。
  - 缓存不常变化但需要频繁访问的数据，如配置表、地区代码表等。
  - 需要快速数据交换的场景。


### 存储引擎对比总结

| 特性                | InnoDB                               | MyISAM                     | Memory (HEAP)            |
| ------------------- | ------------------------------------ | -------------------------- | ------------------------ |
| **事务支持 (ACID)** | **支持**                             | 不支持                     | 不支持                   |
| **锁定粒度**        | **行级锁定**                         | 表级锁定                   | 表级锁定                 |
| **外键约束**        | **支持**                             | 不支持                     | 不支持                   |
| **MVCC**            | **支持**                             | 不支持                     | 不支持                   |
| **崩溃恢复**        | **支持**                             | 不支持（可能导致数据损坏） | 不支持（数据直接丢失）   |
| **数据存储**        | 磁盘                                 | 磁盘                       | **内存**                 |
| **`COUNT(*)` 速度** | 较慢（需要扫描）                     | **极快**                   | 较慢（需要扫描）         |
| **索引结构**        | 聚簇索引                             | 非聚簇索引                 | 哈希索引（默认）、B-Tree |
| **主要应用场景**    | **所有 OLTP 应用，高并发，高可靠性** | 读密集、报表、日志         | 临时表、缓存             |

### 如何选择存储引擎？

作为后端开发者，选择存储引擎是一个重要的架构决策：

1.  **首选 InnoDB：** 如果你不确定用哪个，或者你的应用涉及任何形式的数据写入和更新，并且需要保证数据安全，那么 **InnoDB 永远是你的第一选择**。
2.  **考虑 MyISAM 的特定场景：** 只有当你的表是只读的，或者写入非常少，并且可以容忍事务的缺失和崩溃恢复的风险时，为了极致的读取性能或快速的 `COUNT(*)`，可以考虑 MyISAM。
3.  **使用 Memory 引擎作为辅助：** 当你需要一个生命周期短、速度极快的临时存储时，Memory 引擎是很好的工具。

### 如何查看和设置存储引擎？

- **查看所有支持的存储引擎：** `SHOW ENGINES;`
- **查看某个表的存储引擎：** `SHOW TABLE STATUS LIKE 'table_name';`
- **在创建表时指定引擎：** `CREATE TABLE my_table (...) ENGINE = InnoDB;`

## MySQL 中的日志？

MySQL 的日志系统是其架构中至关重要的组成部分，它们是保证数据安全、进行故障恢复、实现主从复制以及进行性能分析和审计的基础。

MySQL 的日志可以分为两大类：

1.  **Server 层日志**：由 MySQL Server 本身产生，所有存储引擎都可以使用。
2.  **Engine 层日志**：由特定的存储引擎（主要是 InnoDB）产生，用于实现其自身的特性。

### Server 层日志

#### 1. 二进制日志 (Binary Log / Binlog)

- **日志级别：** Server 层
- **用途：** 这是 MySQL 最重要的日志之一，主要用于**主从复制 (Replication)** 和**数据恢复 (Point-in-Time Recovery)**。
- **记录内容：** Binlog 以二进制格式记录了所有对数据库进行修改的**逻辑操作**（DDL 和 DML 语句），但不包括 `SELECT` 和 `SHOW` 等不修改数据的操作。
- **工作机制与格式：** Binlog 有三种记录格式：
  - **`STATEMENT`：** 基于语句的日志记录。记录原始的 SQL 语句。优点是日志文件小，缺点是在某些情况下（如使用了 `UUID()`, `NOW()` 等不确定性函数）可能会导致主从数据不一致。
  - **`ROW`：** 基于行的日志记录（**现代 MySQL 的默认格式**）。不记录 SQL 语句，而是记录每一行数据被修改前后的具体内容。优点是能够精确地复制每一处修改，非常安全，不会出现数据不一致问题。缺点是日志文件可能会比较大。
  - **`MIXED`：** 混合模式。MySQL 会在大多数情况下使用 `STATEMENT` 格式以节省空间，但在遇到可能导致数据不一致的不确定性函数时，会自动切换到 `ROW` 格式。
- **相关配置：**
  - `log_bin = /path/to/mysql-bin.log`：启用并指定 Binlog 文件路径。
  - `server_id = 1`：服务器的唯一 ID，在主从复制环境中必须设置。
  - `binlog_format = ROW`：设置 Binlog 的格式。

#### 2. 慢查询日志 (Slow Query Log)

- **日志级别：** Server 层
- **用途：** 主要用于**性能分析和优化**。
- **记录内容：** 记录所有执行时间超过指定阈值的 SQL 查询。这对于定位系统中性能低下的 SQL 语句非常有帮助。
- **工作机制：** 当一条查询的执行时间超过了 `long_query_time` 参数设定的秒数时，这条查询就会被记录到慢查询日志中。
- **相关配置：**
  - `slow_query_log = ON`：开启慢查询日志。
  - `slow_query_log_file = /path/to/slow-query.log`：指定日志文件路径。
  - `long_query_time = 2`：设置时间阈值，单位为秒（例如，超过 2 秒的查询被记录）。

#### 3. 错误日志 (Error Log)

- **日志级别：** Server 层
- **用途：** 这是 MySQL 中最重要的诊断日志，用于**故障排查**。
- **记录内容：** 记录 MySQL 服务器在启动、运行和关闭过程中遇到的所有严重错误、警告和一些关键的通知信息。当数据库无法启动或运行异常时，**我们应该首先查看此日志**。
- **相关配置：**
  - `log_error = /path/to/error.log`：指定错误日志的路径。

#### 4. 通用查询日志 (General Query Log)

- **日志级别：** Server 层
- **用途：** 主要用于**调试和审计**。
- **记录内容：** 记录所有到达 MySQL 服务器的连接和执行的每一条 SQL 语句，无论语句是否正确执行。
- **警告：** 因为它会记录所有操作，所以会产生巨大的日志量，对 I/O 性能影响极大。**严禁在生产环境中长时间开启**，仅在需要详细追踪特定问题时短暂使用。
- **相关配置：**
  - `general_log = ON`：开启通用查询日志。
  - `general_log_file = /path/to/general.log`：指定日志文件路径。

### Engine 层日志 (以 InnoDB 为例)

#### 1. 重做日志 (Redo Log)

- **日志级别：** Engine 层 (InnoDB 特有)
- **用途：** 实现事务的**持久性 (Durability)** 和**崩溃恢复 (Crash Recovery)**。
- **记录内容：** Redo Log 是**物理日志**。它记录的是“在哪个数据页的哪个偏移量上，做了什么修改”这类底层物理操作，而不是逻辑上的 SQL 语句。
- **工作机制 (WAL - Write-Ahead Logging)：** 这是 InnoDB 的核心机制之一。当数据发生修改时，InnoDB 会先将修改写入内存中的 Buffer Pool，然后将这些修改操作记录到 Redo Log 中。只要 Redo Log 成功写入磁盘，事务就可以被认为是已提交的，即使此时内存中的“脏页”还没有刷回磁盘。如果此时数据库宕机，重启后 InnoDB 会通过 Redo Log 来恢复这些已提交但未持久化的数据，从而保证数据不丢失。
- **特点：** Redo Log 的文件大小是固定的，采用**循环写入**的方式。当写到文件末尾后，会回到开头覆盖旧的日志。

#### 2. 回滚日志 (Undo Log)

- **日志级别：** Engine 层 (InnoDB 特有)
- **用途：** 实现事务的**原子性 (Atomicity)** 和**隔离性 (Isolation)** (通过 MVCC)。
- **记录内容：** Undo Log 记录的是与实际操作相反的逻辑操作，即数据的**旧版本**。
  - 当你 `INSERT` 一条记录时，Undo Log 就记录一条对应的 `DELETE`。
  - 当你 `UPDATE` 一条记录时，Undo Log 就记录下修改前的旧值。
- **工作机制：**
  - **事务回滚：** 当事务需要回滚时，InnoDB 会根据 Undo Log 的记录执行相反的操作，将数据恢复到事务开始前的状态。
  - **MVCC (多版本并发控制)：** 当一个事务需要读取某一行数据，而该行数据正在被另一个未提交的事务所修改时，InnoDB 会从 Undo Log 中读取该行的旧版本数据提供给这个读事务，从而实现了非阻塞的读操作。

### 总结与协同工作

这几种日志各司其职，协同工作，共同构成了 MySQL 的高可靠性。

- **Binlog** 和 **Redo Log** 是最容易混淆的，但它们的区别很关键：
  - **层次不同：** Binlog 是 Server 层的，所有引擎共享；Redo Log 是 InnoDB 层的。
  - **内容不同：** Binlog 是逻辑日志；Redo Log 是物理日志。
  - **用途不同：** Binlog 用于复制和恢复；Redo Log 用于崩溃恢复。
- 为了保证数据一致性（例如，在主库上 Redo Log 提交了，Binlog 也必须成功写入，这样从库才能同步），MySQL 在它们之间使用了**两阶段提交（Two-Phase Commit）** 机制。
