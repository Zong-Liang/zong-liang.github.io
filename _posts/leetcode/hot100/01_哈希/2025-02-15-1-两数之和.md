---
title: "1-两数之和"
date: 2025-02-15 17:22:39 +0800
categories: [LEETCODE, HOT100]
tags: [哈希, 简单]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/two-sum/) \| 难度: 简单

## 问题描述:

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出**和为目标值** `target` 的那**两个**整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

**示例 1：**

```java
输入: nums = [2,7,11,15], target = 9
输出: [0,1]
解释: 因为 nums[0] + nums[1] == 9, 返回 [0, 1]
```

**示例 2：**

```java
输入: nums = [3,2,4], target = 6
输出: [1,2]
```

**示例 3：**

```java
输入: nums = [3,3], target = 6
输出: [0,1]
```

进阶：你可以想出一个时间复杂度小于 $O(n^2)$ 的算法吗？

## 解题思路:

本题要求找出数组中和为目标值的两个整数的索引。有几种不同的解题思路，下面逐一分析：

### 方法一：暴力解法

最直接的方法是使用两重循环遍历数组，检查每一对数字的和是否等于目标值 `target`。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int n = nums.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = i + 1; j < n; j++) {
                if (nums[i] + nums[j] == target) {
                    return new int[] {i, j};
                }
            }
        }
        return new int[] {}; // 题目保证有解，此处不会执行到
    }
}
```

- **时间复杂度**：$O(n²)$，其中 $n$ 是数组长度。需要两重循环遍历所有可能的数字对。
- **空间复杂度**：$O(1)$，只使用了常数额外空间。

### 方法二：哈希表解法（一次遍历）

更优的解法是使用哈希表（`HashMap`），通过一次遍历数组来解决问题：

1. 遍历数组，对于每个元素 `nums[i]`，计算它与目标值的差值 `complement = target - nums[i]`
2. 检查哈希表中是否已存在这个差值（补数）
3. 如果存在，说明找到了一对和为 `target` 的数字，返回它们的索引
4. 如果不存在，将当前数字及其索引存入哈希表，继续遍历

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        // 创建哈希表, 用于存储数组元素的值和索引
        Map<Integer, Integer> map = new HashMap<>();

        // 遍历数组
        for (int i = 0; i < nums.length; i++) {
            // 计算当前元素与目标值的差值(补数)
            int complement = target - nums[i];

            // 检查哈希表中是否存在这个补数
            if (map.containsKey(complement)) {
                // 如果存在, 返回补数的索引和当前索引
                return new int[] { map.get(complement), i };
            }

            // 如果不存在, 将当前元素的值和索引添加到哈希表中
            map.put(nums[i], i);
        }

        // 题目保证有解, 这里不会执行到
        return new int[] {};
    }
}
```

- **时间复杂度**：$O(n)$，其中 $n$ 是数组长度。只需要遍历一次数组，对于每个元素，哈希表的查找操作的时间复杂度为 $O(1)$。
- **空间复杂度**：$O(n)$，其中 $n$ 是数组长度。主要是哈希表的开销，最坏情况下需要存储 $n-1$ 个元素。

这种方法通过"以空间换时间"的思想，将查找的时间复杂度从 $O(n)$ 降低到 $O(1)$。
