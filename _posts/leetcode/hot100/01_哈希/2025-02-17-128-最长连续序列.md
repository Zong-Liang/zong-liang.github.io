---
title: "128-最长连续序列"
date: 2025-02-17 20:06:17 +0800
categories: [LEETCODE, HOT100]
tags: [哈希, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/longest-consecutive-sequence/) \| 难度: 中等

## 问题描述:

给定一个未排序的整数数组 `nums`，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 $O(n)$ 的算法解决此问题。

**示例 1：**

```java
输入: nums = [100,4,200,1,3,2]
输出: 4
解释: 最长数字连续序列是 [1,2,3,4], 它的长度为 4
```

**示例 2：**

```java
输入: nums = [0,3,7,2,5,8,4,6,0,1]
输出: 9
```

**示例 3：**

```java
输入: nums = [1,0,1,2]
输出: 3
```

## 解题思路:

本题要求找出数组中最长连续序列的长度。连续序列是指数字在数值上连续，但在数组中的位置不要求连续。有几种不同的解题思路，下面逐一分析：

### 方法一：排序法

最直接的方法是先将数组排序，然后遍历数组找最长连续序列。

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        if (nums.length == 0) return 0;

        // 排序数组
        Arrays.sort(nums);

        int maxLength = 1;
        int currentLength = 1;

        for (int i = 1; i < nums.length; i++) {
            // 跳过重复元素
            if (nums[i] == nums[i - 1]) {
                continue;
            }
            // 如果当前数字是前一个数字的连续数字
            else if (nums[i] == nums[i - 1] + 1) {
                currentLength++;
            }
            // 如果不连续，重新开始计算
            else {
                maxLength = Math.max(maxLength, currentLength);
                currentLength = 1;
            }
        }

        return Math.max(maxLength, currentLength);
    }
}
```

**时间复杂度**：$O(n \log n)$，其中 $n$ 是数组长度。主要是排序的时间复杂度。

**空间复杂度**：$O(1)$，只使用了常数额外空间（不考虑排序所需的空间）。

### 方法二：哈希表法（推荐）

使用哈希表存储所有数字，对于每个可能作为连续序列起点的数字，向后查找连续序列的长度。

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        if (nums.length == 0) return 0;

        // 将所有数字存入哈希表
        Set<Integer> numSet = new HashSet<>();
        for (int num : nums) {
            numSet.add(num);
        }

        int maxLength = 0;

        for (int num : numSet) {
            // 只有当 num-1 不在集合中时，num 才可能是连续序列的起点
            if (!numSet.contains(num - 1)) {
                int currentNum = num;
                int currentLength = 1;

                // 向后查找连续的数字
                while (numSet.contains(currentNum + 1)) {
                    currentNum++;
                    currentLength++;
                }

                maxLength = Math.max(maxLength, currentLength);
            }
        }

        return maxLength;
    }
}
```

**时间复杂度**：$O(n)$，其中 $n$ 是数组长度。虽然有嵌套循环，但内层循环只会在找到序列起点时执行，每个数字最多被访问两次。

**空间复杂度**：$O(n)$，用于存储哈希表。

### 方法三：并查集法

使用并查集将连续的数字合并到同一个集合中，最后统计最大集合的大小。

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        if (nums.length == 0) return 0;

        UnionFind uf = new UnionFind();

        // 将所有数字加入并查集
        for (int num : nums) {
            uf.add(num);
        }

        // 合并相邻的数字
        for (int num : nums) {
            if (uf.contains(num + 1)) {
                uf.union(num, num + 1);
            }
        }

        return uf.getMaxSize();
    }

    class UnionFind {
        private Map<Integer, Integer> parent;
        private Map<Integer, Integer> size;

        public UnionFind() {
            parent = new HashMap<>();
            size = new HashMap<>();
        }

        public void add(int x) {
            if (!parent.containsKey(x)) {
                parent.put(x, x);
                size.put(x, 1);
            }
        }

        public boolean contains(int x) {
            return parent.containsKey(x);
        }

        public int find(int x) {
            if (parent.get(x) != x) {
                parent.put(x, find(parent.get(x)));
            }
            return parent.get(x);
        }

        public void union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);

            if (rootX != rootY) {
                if (size.get(rootX) < size.get(rootY)) {
                    int temp = rootX;
                    rootX = rootY;
                    rootY = temp;
                }
                parent.put(rootY, rootX);
                size.put(rootX, size.get(rootX) + size.get(rootY));
            }
        }

        public int getMaxSize() {
            return size.values().stream().max(Integer::compare).orElse(0);
        }
    }
}
```

**时间复杂度**：$O(n \alpha(n))$，其中 $n$ 是数组长度，$\alpha$ 是阿克曼函数的反函数，实际上近似为常数。

**空间复杂度**：$O(n)$，用于存储并查集。

### 方法四：动态规划（哈希表优化）

使用哈希表记录以每个数字结尾的连续序列长度。

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        if (nums.length == 0) return 0;

        // dp[i] 表示以数字 i 结尾的连续序列的长度
        Map<Integer, Integer> dp = new HashMap<>();
        int maxLength = 0;

        for (int num : nums) {
            if (!dp.containsKey(num)) {
                // 获取 num-1 结尾的序列长度
                int left = dp.getOrDefault(num - 1, 0);
                // 获取 num+1 开头的序列长度
                int right = dp.getOrDefault(num + 1, 0);

                // 当前序列长度
                int currentLength = left + right + 1;
                dp.put(num, currentLength);

                // 更新序列两端的长度值
                dp.put(num - left, currentLength);
                dp.put(num + right, currentLength);

                maxLength = Math.max(maxLength, currentLength);
            }
        }

        return maxLength;
    }
}
```

**时间复杂度**：$O(n)$，其中 $n$ 是数组长度。

**空间复杂度**：$O(n)$，用于存储哈希表。

**推荐使用方法二（哈希表法）**，它在时间复杂度为 $O(n)$ 的同时，代码简洁易懂，是该问题的最优解法。该方法的关键思想是通过判断 `num-1` 是否存在来确定连续序列的起点，避免重复计算。
