---
title: "283-移动零"
date: 2025-02-21 20:59:10 +0800
categories: [LEETCODE, HOT100]
tags: [双指针, 简单]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/move-zeroes/) \| 难度：简单

## 问题描述：

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意**，必须在不复制数组的情况下原地对数组进行操作。

**示例 1：**

```java
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2：**

```java
输入: nums = [0]
输出: [0]
```

**进阶：**你能尽量减少完成的操作次数吗？

## 解题思路:

这道题是"移动零"问题。要求将数组中的所有零移动到数组末尾，同时保持非零元素的相对顺序。关键是要求必须在原地操作，不能使用额外数组。

### 方法一：双指针法（推荐）

使用两个指针，一个指向当前处理的位置，另一个指向下一个非零元素应该放置的位置。

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int left = 0; // 指向下一个非零元素应该放置的位置

        // 遍历数组，将非零元素移到前面
        for (int right = 0; right < nums.length; right++) {
            if (nums[right] != 0) {
                nums[left] = nums[right];
                left++;
            }
        }

        // 将剩余位置填充为0
        while (left < nums.length) {
            nums[left] = 0;
            left++;
        }
    }
}
```

**时间复杂度**：$O(n)$，其中 $n$ 是数组长度。只需要两次遍历。

**空间复杂度**：$O(1)$，只使用了常数额外空间。

### 方法二：双指针优化版（减少写入次数）

在方法一的基础上，只有当需要交换时才进行操作，减少不必要的赋值。

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int left = 0; // 指向下一个非零元素应该放置的位置

        for (int right = 0; right < nums.length; right++) {
            if (nums[right] != 0) {
                // 只有当left != right时才需要交换
                if (left != right) {
                    nums[left] = nums[right];
                    nums[right] = 0;
                }
                left++;
            }
        }
    }
}
```

**时间复杂度**：$O(n)$，其中 $n$ 是数组长度。只需要一次遍历。

**空间复杂度**：$O(1)$，只使用了常数额外空间。

### 方法三：交换法

使用双指针，遇到非零元素就与左指针位置交换。

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int left = 0; // 指向下一个非零元素应该放置的位置

        for (int right = 0; right < nums.length; right++) {
            if (nums[right] != 0) {
                // 交换left和right位置的元素
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;
                left++;
            }
        }
    }
}
```

**时间复杂度**：$O(n)$，其中 $n$ 是数组长度。只需要一次遍历。

**空间复杂度**：$O(1)$，只使用了常数额外空间。

### 方法四：冒泡排序思想

类似冒泡排序，每次将零向后移动。

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int n = nums.length;

        // 进行n次冒泡
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n - 1; j++) {
                // 如果当前元素是0且下一个元素不是0，交换它们
                if (nums[j] == 0 && nums[j + 1] != 0) {
                    int temp = nums[j];
                    nums[j] = nums[j + 1];
                    nums[j + 1] = temp;
                }
            }
        }
    }
}
```

**时间复杂度**：$O(n^2)$，需要两重循环。

**空间复杂度**：$O(1)$，只使用了常数额外空间。

### 方法五：快慢指针变形

使用快慢指针的思想，慢指针指向已处理部分的末尾。

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int slow = 0; // 慢指针，指向已处理的非零元素部分的末尾

        for (int fast = 0; fast < nums.length; fast++) {
            if (nums[fast] != 0) {
                // 如果快慢指针不同，说明中间有零元素
                if (slow != fast) {
                    // 将非零元素移到前面，同时将原位置设为0
                    nums[slow] = nums[fast];
                    nums[fast] = 0;
                }
                slow++;
            }
        }
    }
}
```

**时间复杂度**：$O(n)$，其中 $n$ 是数组长度。只需要一次遍历。

**空间复杂度**：$O(1)$，只使用了常数额外空间。

**推荐使用方法一或方法二**，它们思路清晰，代码简洁，时间复杂度最优。方法一更容易理解，方法二在某些情况下写入次数更少，性能略好。

**核心思想**：

1. 使用双指针，一个指针遍历数组，另一个指针维护非零元素应该放置的位置
2. 先将所有非零元素移到数组前部，保持相对顺序
3. 然后将剩余位置填充为零
