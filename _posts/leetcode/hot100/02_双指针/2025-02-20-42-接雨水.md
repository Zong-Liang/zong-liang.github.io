---
title: "42-接雨水"
date: 2025-02-20 20:55:24 +0800
categories: [LEETCODE, HOT100]
tags: [双指针, 困难]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/trapping-rain-water/) \| 难度: 困难

## 问题描述:

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![img](../assets/img/posts/leetcode/p42_0.png)

```java
输入: height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
解释: 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图, 在这种情况下, 可以接 6 个单位的雨水 (蓝色部分表示雨水)
```

**示例 2：**

```java
输入: height = [4,2,0,3,2,5]
输出: 9
```

## 解题思路:

这道题是经典的"接雨水"问题。给定一个表示高度的数组，计算下雨后能接到多少雨水。

从图中可以看到，雨水只能在被更高的柱子包围的低洼处积累。关键是找到每个位置能接到的雨水量。

### 方法一：暴力解法

对于每个位置，找到它左边的最大高度和右边的最大高度，该位置能接到的雨水量就是 `min(左边最大高度, 右边最大高度) - 当前高度`（如果结果为正）。

```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        if (n <= 2) return 0;

        int result = 0;

        // 对每个位置计算能接到的雨水
        for (int i = 1; i < n - 1; i++) {
            // 找左边最大高度
            int leftMax = 0;
            for (int j = 0; j < i; j++) {
                leftMax = Math.max(leftMax, height[j]);
            }

            // 找右边最大高度
            int rightMax = 0;
            for (int j = i + 1; j < n; j++) {
                rightMax = Math.max(rightMax, height[j]);
            }

            // 计算当前位置能接到的雨水
            int water = Math.min(leftMax, rightMax) - height[i];
            if (water > 0) {
                result += water;
            }
        }

        return result;
    }
}
```

**时间复杂度**：$O(n^2)$，对每个位置都要遍历一次数组找最大值。

**空间复杂度**：$O(1)$，只使用了常数额外空间。

### 方法二：动态规划

预先计算每个位置左边和右边的最大高度，避免重复计算。

```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        if (n <= 2) return 0;

        // 预计算左边最大高度
        int[] leftMax = new int[n];
        leftMax[0] = height[0];
        for (int i = 1; i < n; i++) {
            leftMax[i] = Math.max(leftMax[i - 1], height[i]);
        }

        // 预计算右边最大高度
        int[] rightMax = new int[n];
        rightMax[n - 1] = height[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            rightMax[i] = Math.max(rightMax[i + 1], height[i]);
        }

        int result = 0;
        // 计算每个位置的雨水量
        for (int i = 1; i < n - 1; i++) {
            int water = Math.min(leftMax[i], rightMax[i]) - height[i];
            if (water > 0) {
                result += water;
            }
        }

        return result;
    }
}
```

**时间复杂度**：$O(n)$，需要三次遍历数组。

**空间复杂度**：$O(n)$，需要两个辅助数组存储左右最大值。

### 方法三：双指针（推荐）

使用双指针从两端向中间移动，实时维护左右最大值，空间复杂度优化到 $O(1)$。

```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        if (n <= 2) return 0;

        int left = 0, right = n - 1;
        int leftMax = 0, rightMax = 0;
        int result = 0;

        while (left < right) {
            if (height[left] < height[right]) {
                // 左边较低，处理左边
                if (height[left] >= leftMax) {
                    leftMax = height[left];
                } else {
                    result += leftMax - height[left];
                }
                left++;
            } else {
                // 右边较低，处理右边
                if (height[right] >= rightMax) {
                    rightMax = height[right];
                } else {
                    result += rightMax - height[right];
                }
                right--;
            }
        }

        return result;
    }
}
```

**时间复杂度**：$O(n)$，只需要一次遍历。

**空间复杂度**：$O(1)$，只使用了常数额外空间。

### 方法四：单调栈

使用栈来维护一个递减的高度序列，当遇到更高的柱子时，计算能接到的雨水。

```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        if (n <= 2) return 0;

        Stack<Integer> stack = new Stack<>();
        int result = 0;

        for (int i = 0; i < n; i++) {
            // 当前高度大于栈顶高度时，可能形成积水
            while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
                int top = stack.pop(); // 积水的底部

                if (stack.isEmpty()) break;

                int left = stack.peek(); // 左边界
                int width = i - left - 1; // 积水宽度
                int minHeight = Math.min(height[left], height[i]) - height[top];

                result += width * minHeight;
            }

            stack.push(i);
        }

        return result;
    }
}
```

**时间复杂度**：$O(n)$，每个元素最多入栈出栈一次。

**空间复杂度**：$O(n)$，栈的空间开销。

**推荐解法：双指针法**，因为它时间复杂度最优且空间复杂度为常数级别，代码也相对简洁易懂。
