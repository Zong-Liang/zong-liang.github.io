---
title: "11-盛水最多的容器"
date: 2025-02-18 20:51:18 +0800
categories: [LEETCODE, HOT100]
tags: [双指针, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/container-with-most-water/) \| 难度: 中等

## 问题描述:

给定一个长度为 `n` 的整数数组 `height`。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])`。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：** 你不能倾斜容器。

**示例 1：**

![img](../assets/img/posts/leetcode/p11_0.jpg)

```java
输入: [1,8,6,2,5,4,8,3,7]
输出: 49
解释: 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7], 在此情况下, 容器能够容纳水 (表示为蓝色部分) 的最大值为 49
```

**示例 2：**

```java
输入: height = [1,1]
输出: 1
```

## 解题思路:

本题要求在给定的高度数组中找到能够容纳最多水的容器。这是一个经典的双指针问题，核心思想是通过移动指针来寻找最大面积。有几种不同的解题思路，下面逐一分析：

### 方法一：暴力解法

最直接的方法是枚举所有可能的两条线，计算它们能够容纳的水量，找出最大值。

```java
class Solution {
    public int maxArea(int[] height) {
        int maxWater = 0;
        int n = height.length;

        // 枚举所有可能的两条线
        for (int i = 0; i < n - 1; i++) {
            for (int j = i + 1; j < n; j++) {
                // 计算当前容器能容纳的水量
                int width = j - i;
                int minHeight = Math.min(height[i], height[j]);
                int currentWater = width * minHeight;
                maxWater = Math.max(maxWater, currentWater);
            }
        }

        return maxWater;
    }
}
```

**时间复杂度**：$O(n^2)$，其中 $n$ 是数组长度。需要两重循环遍历所有可能的线对。

**空间复杂度**：$O(1)$，只使用了常数额外空间。

### 方法二：双指针法（推荐）

使用两个指针分别指向数组的开始和结束位置，通过移动较短的那条线来寻找更大的面积。

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int maxWater = 0;

        while (left < right) {
            // 计算当前容器的面积
            int width = right - left;
            int minHeight = Math.min(height[left], height[right]);
            int currentWater = width * minHeight;
            maxWater = Math.max(maxWater, currentWater);

            // 移动较短的那条线
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }

        return maxWater;
    }
}
```

**时间复杂度**：$O(n)$，其中 $n$ 是数组长度。每个元素最多被访问一次。

**空间复杂度**：$O(1)$，只使用了常数额外空间。

**双指针法的核心思想**：

1. 容器的面积由两条线中较短的那条决定
2. 当左右指针指向的线高度不同时，移动较短的线才有可能找到更大的面积
3. 如果移动较长的线，由于面积受较短线限制，且宽度减小，面积只会变小或不变

### 方法三：双指针优化版

在双指针的基础上，跳过一些明显不会产生更大面积的情况。

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int maxWater = 0;

        while (left < right) {
            int leftHeight = height[left];
            int rightHeight = height[right];
            int width = right - left;
            int minHeight = Math.min(leftHeight, rightHeight);
            int currentWater = width * minHeight;
            maxWater = Math.max(maxWater, currentWater);

            // 移动较短的线，并跳过相同或更短的线
            if (leftHeight < rightHeight) {
                while (left < right && height[left] <= leftHeight) {
                    left++;
                }
            } else {
                while (left < right && height[right] <= rightHeight) {
                    right--;
                }
            }
        }

        return maxWater;
    }
}
```

**时间复杂度**：$O(n)$，其中 $n$ 是数组长度。虽然有内层循环，但每个元素最多被访问一次。

**空间复杂度**：$O(1)$，只使用了常数额外空间。

### 方法四：分治法

将问题分解为子问题，递归求解。

```java
class Solution {
    public int maxArea(int[] height) {
        return divideAndConquer(height, 0, height.length - 1);
    }

    private int divideAndConquer(int[] height, int left, int right) {
        if (left >= right) return 0;

        // 计算当前左右边界的面积
        int currentArea = (right - left) * Math.min(height[left], height[right]);

        // 递归计算子问题
        int leftMax, rightMax;
        if (height[left] < height[right]) {
            leftMax = divideAndConquer(height, left + 1, right);
            rightMax = 0; // 剪枝：不需要计算右侧
        } else {
            leftMax = 0; // 剪枝：不需要计算左侧
            rightMax = divideAndConquer(height, left, right - 1);
        }

        return Math.max(currentArea, Math.max(leftMax, rightMax));
    }
}
```

**时间复杂度**：$O(n)$，每个元素最多被访问一次。

**空间复杂度**：$O(\log n)$，递归调用栈的深度。

**推荐使用方法二（双指针法）**，它是该问题的最优解法，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$，代码简洁易懂。核心思想是贪心策略：总是移动较短的线，因为移动较长的线不可能得到更大的面积。
