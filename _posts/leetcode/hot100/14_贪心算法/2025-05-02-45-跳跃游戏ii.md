---
title: "45-跳跃游戏II"
date: 2025-05-02 21:44:02 +0800
categories: [LEETCODE, HOT100]
tags: [贪心算法, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/jump-game-ii/) \| 难度: 中等

## 问题描述:

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]`
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

**示例 1：**

```java
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2; 从下标为 0 跳到下标为 1 的位置, 跳 1 步, 然后跳 3 步到达数组的最后一个位置
```

**示例 2：**

```java
输入: nums = [2,3,0,1,4]
输出: 2
```

## 解题思路：

这是一道关于跳跃游戏的问题。需要判断从数组起始位置能否到达数组的最后一个位置，每个元素的值表示在该位置可以跳跃的最大长度。

### 方法一：贪心算法（推荐）

核心思想是维护一个能够到达的最远位置，如果当前位置超过了最远位置，说明无法到达；否则更新最远位置。

**算法步骤：**

1. 初始化最远可达位置为 0
2. 遍历数组的每个位置（除了最后一个）
3. 如果当前位置超过最远可达位置，返回 false
4. 否则更新最远可达位置为当前位置+跳跃长度的最大值
5. 如果最远可达位置已经达到或超过最后一个位置，返回 true

```java
class Solution {
    public boolean canJump(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return true;
        }

        int maxReach = 0; // 能够到达的最远位置

        for (int i = 0; i < nums.length - 1; i++) {
            // 如果当前位置超过了最远可达位置，说明无法到达
            if (i > maxReach) {
                return false;
            }

            // 更新最远可达位置
            maxReach = Math.max(maxReach, i + nums[i]);

            // 如果已经可以到达最后一个位置，直接返回true
            if (maxReach >= nums.length - 1) {
                return true;
            }
        }

        return maxReach >= nums.length - 1;
    }
}
```

**时间复杂度：** $O(n)$，只需要遍历数组一次。

**空间复杂度：** $O(1)$，只使用常数额外空间。

### 方法二：动态规划

使用动态规划记录每个位置是否可达。

**算法步骤：**

1. 创建布尔数组 dp，dp[i]表示位置 i 是否可达
2. 初始化 dp[0] = true（起始位置可达）
3. 遍历数组，对于每个可达的位置，更新其能跳跃到的所有位置为可达
4. 返回 dp[n-1]

```java
class Solution {
    public boolean canJump(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return true;
        }

        int n = nums.length;
        boolean[] dp = new boolean[n];
        dp[0] = true; // 起始位置可达

        for (int i = 0; i < n; i++) {
            if (!dp[i]) {
                continue; // 当前位置不可达，跳过
            }

            // 从当前位置可以跳跃到的所有位置都标记为可达
            for (int j = 1; j <= nums[i] && i + j < n; j++) {
                dp[i + j] = true;

                // 如果已经可以到达最后一个位置，提前返回
                if (i + j == n - 1) {
                    return true;
                }
            }
        }

        return dp[n - 1];
    }
}
```

**时间复杂度：** $O(n^2)$，最坏情况下需要遍历所有位置的所有跳跃可能。

**空间复杂度：** $O(n)$，需要额外的 dp 数组。

### 方法三：从后往前贪心

从最后一个位置开始，向前寻找能够到达目标位置的最近位置。

**算法步骤：**

1. 初始化目标位置为最后一个位置
2. 从倒数第二个位置开始向前遍历
3. 如果当前位置能够跳跃到目标位置，更新目标位置为当前位置
4. 最后检查目标位置是否为起始位置

```java
class Solution {
    public boolean canJump(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return true;
        }

        int target = nums.length - 1; // 目标位置

        // 从倒数第二个位置开始向前遍历
        for (int i = nums.length - 2; i >= 0; i--) {
            // 如果当前位置能够跳跃到目标位置
            if (i + nums[i] >= target) {
                target = i; // 更新目标位置
            }
        }

        return target == 0; // 检查是否能从起始位置到达
    }
}
```

**时间复杂度：** $O(n)$，只需要遍历数组一次。

**空间复杂度：** $O(1)$，只使用常数额外空间。

### 方法四：递归 + 记忆化（了解即可）

使用递归搜索所有可能的跳跃路径，配合记忆化避免重复计算。

```java
class Solution {
    private Boolean[] memo;

    public boolean canJump(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return true;
        }

        memo = new Boolean[nums.length];
        return canJumpFromPosition(0, nums);
    }

    private boolean canJumpFromPosition(int position, int[] nums) {
        if (memo[position] != null) {
            return memo[position];
        }

        if (position == nums.length - 1) {
            return true;
        }

        int furthestJump = Math.min(position + nums[position], nums.length - 1);

        for (int nextPosition = position + 1; nextPosition <= furthestJump; nextPosition++) {
            if (canJumpFromPosition(nextPosition, nums)) {
                memo[position] = true;
                return true;
            }
        }

        memo[position] = false;
        return false;
    }
}
```

**时间复杂度：** $O(n^2)$，每个位置最多被访问一次。

**空间复杂度：** $O(n)$，递归栈和记忆化数组。

**推荐使用方法一（贪心算法）**，因为它时间和空间复杂度都最优，代码简洁易懂，是解决此类问题的标准方法。
