---
title: "763-划分字母区间"
date: 2025-05-05 21:45:15 +0800
categories: [LEETCODE, HOT100]
tags: [贪心算法, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/partition-labels/) \| 难度: 中等

## 问题描述:

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 `"ababcc"` 能够被分为 `["abab", "cc"]`，但类似 `["aba", "bcc"]` 或 `["ab", "ab", "cc"]` 的划分是非法的。

注意，划分结果需要满足: 将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

返回一个表示每个字符串片段的长度的列表。

**示例 1：**

```java
输入: s = "ababcbacadefegdehijhklij"
输出: [9,7,8]
解释: 划分结果为 "ababcbaca", "defegde", "hijhklij"; 每个字母最多出现在一个片段中, 像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的, 因为划分的片段数较少
```

**示例 2：**

```java
输入: s = "eccbbbbdec"
输出: [10]
```

## 解题思路：

这是一道关于划分字母区间的问题。需要将字符串划分为尽可能多的片段，使得同一字母最多只出现在一个片段中。

### 方法一：贪心算法（推荐）

核心思想是记录每个字符最后出现的位置，然后使用贪心策略划分区间。

**算法步骤：**

1. 遍历字符串，记录每个字符最后出现的位置
2. 再次遍历字符串，维护当前区间的结束位置
3. 当遍历到当前区间的结束位置时，说明找到了一个完整的片段
4. 记录片段长度，开始寻找下一个片段

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        if (s == null || s.length() == 0) {
            return new ArrayList<>();
        }

        // 记录每个字符最后出现的位置
        int[] lastIndex = new int[26];
        for (int i = 0; i < s.length(); i++) {
            lastIndex[s.charAt(i) - 'a'] = i;
        }

        List<Integer> result = new ArrayList<>();
        int start = 0;  // 当前片段的起始位置
        int end = 0;    // 当前片段的结束位置

        for (int i = 0; i < s.length(); i++) {
            // 更新当前片段的结束位置
            end = Math.max(end, lastIndex[s.charAt(i) - 'a']);

            // 如果当前位置就是片段的结束位置，记录片段长度
            if (i == end) {
                result.add(end - start + 1);
                start = i + 1; // 下一个片段的起始位置
            }
        }

        return result;
    }
}
```

**时间复杂度：** $O(n)$，需要遍历字符串两次。

**空间复杂度：** $O(1)$，只使用固定大小的数组存储 26 个字母的位置。

### 方法二：区间合并思想

将问题转化为区间合并问题，每个字符对应一个区间[first, last]。

**算法步骤：**

1. 记录每个字符第一次和最后一次出现的位置
2. 按照字符第一次出现的顺序，合并重叠的区间
3. 每个合并后的区间就是一个片段

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        if (s == null || s.length() == 0) {
            return new ArrayList<>();
        }

        // 记录每个字符第一次和最后一次出现的位置
        int[] first = new int[26];
        int[] last = new int[26];
        Arrays.fill(first, -1);

        for (int i = 0; i < s.length(); i++) {
            int ch = s.charAt(i) - 'a';
            if (first[ch] == -1) {
                first[ch] = i;
            }
            last[ch] = i;
        }

        List<Integer> result = new ArrayList<>();
        int start = 0;
        int end = 0;

        for (int i = 0; i < s.length(); i++) {
            int ch = s.charAt(i) - 'a';

            // 如果是字符第一次出现，可能需要扩展区间
            if (i == first[ch]) {
                end = Math.max(end, last[ch]);
            }

            // 如果到达区间末尾，记录片段
            if (i == end) {
                result.add(end - start + 1);
                start = i + 1;
            }
        }

        return result;
    }
}
```

**时间复杂度：** $O(n)$，遍历字符串。

**空间复杂度：** $O(1)$，使用固定大小的数组。

### 方法三：双指针法

使用双指针来确定每个片段的边界。

**算法步骤：**

1. 记录每个字符最后出现的位置
2. 使用左右指针确定片段边界
3. 右指针不断扩展，直到包含当前片段内所有字符的最后位置

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        if (s == null || s.length() == 0) {
            return new ArrayList<>();
        }

        // 记录每个字符最后出现的位置
        Map<Character, Integer> lastPos = new HashMap<>();
        for (int i = 0; i < s.length(); i++) {
            lastPos.put(s.charAt(i), i);
        }

        List<Integer> result = new ArrayList<>();
        int left = 0;

        while (left < s.length()) {
            int right = lastPos.get(s.charAt(left));

            // 扩展右边界，确保包含当前片段内所有字符的最后位置
            for (int i = left; i < right; i++) {
                right = Math.max(right, lastPos.get(s.charAt(i)));
            }

            // 记录片段长度
            result.add(right - left + 1);
            left = right + 1;
        }

        return result;
    }
}
```

**时间复杂度：** $O(n^2)$，最坏情况下内层循环可能遍历整个字符串。

**空间复杂度：** $O(1)$，HashMap 最多存储 26 个字符。

### 方法四：栈模拟

使用栈来模拟区间的扩展过程。

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        if (s == null || s.length() == 0) {
            return new ArrayList<>();
        }

        // 记录每个字符最后出现的位置
        int[] lastIndex = new int[26];
        for (int i = 0; i < s.length(); i++) {
            lastIndex[s.charAt(i) - 'a'] = i;
        }

        List<Integer> result = new ArrayList<>();
        Stack<int[]> stack = new Stack<>(); // [start, end]

        for (int i = 0; i < s.length(); i++) {
            int lastPos = lastIndex[s.charAt(i) - 'a'];

            if (stack.isEmpty()) {
                stack.push(new int[]{i, lastPos});
            } else {
                int[] top = stack.peek();
                if (i <= top[1]) {
                    // 在当前区间内，可能需要扩展
                    top[1] = Math.max(top[1], lastPos);
                } else {
                    // 超出当前区间，当前区间结束
                    result.add(top[1] - top[0] + 1);
                    stack.pop();
                    stack.push(new int[]{i, lastPos});
                }
            }
        }

        // 处理最后一个区间
        if (!stack.isEmpty()) {
            int[] last = stack.pop();
            result.add(last[1] - last[0] + 1);
        }

        return result;
    }
}
```

**时间复杂度：** $O(n)$，遍历字符串一次。

**空间复杂度：** $O(1)$，栈最多只有一个元素。

**推荐使用方法一（贪心算法）**，因为它思路清晰，代码简洁，时间和空间复杂度都最优。核心思想是：对于每个片段，我们需要找到该片段中所有字符最后出现位置的最大值，这就是该片段的结束位置。
