---
title: "55-跳跃游戏"
date: 2025-05-03 21:44:39 +0800
categories: [LEETCODE, HOT100]
tags: [贪心算法, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/jump-game/) \| 难度: 中等

## 问题描述:

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```java
输入: nums = [2,3,1,1,4]
输出: true
解释: 可以先跳 1 步, 从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标
```

**示例 2：**

```java
输入: nums = [3,2,1,0,4]
输出: false
解释: 无论怎样, 总会到达下标为 3 的位置; 但该下标的最大跳跃长度是 0, 所以永远不可能到达最后一个下标
```

## 解题思路：

这是一道关于跳跃游戏的问题。需要找到从数组起始位置跳到最后一个位置所需的最少跳跃次数，每个元素的值表示在该位置可以跳跃的最大长度。

### 方法一：贪心算法（推荐）

核心思想是在每一步中选择能够跳跃到最远位置的策略，尽可能减少跳跃次数。

**算法步骤：**

1. 维护当前跳跃能到达的最远边界和下一次跳跃能到达的最远位置
2. 遍历数组，不断更新下一次跳跃的最远位置
3. 当到达当前跳跃的边界时，必须进行下一次跳跃，跳跃次数+1
4. 更新边界为下一次跳跃的最远位置

```java
class Solution {
    public int jump(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return 0;
        }

        int jumps = 0;          // 跳跃次数
        int currentEnd = 0;     // 当前跳跃能到达的最远边界
        int farthest = 0;       // 下一次跳跃能到达的最远位置

        // 注意：i < nums.length - 1，不需要考虑最后一个位置
        for (int i = 0; i < nums.length - 1; i++) {
            // 更新下一次跳跃能到达的最远位置
            farthest = Math.max(farthest, i + nums[i]);

            // 如果到达了当前跳跃的边界，必须进行下一次跳跃
            if (i == currentEnd) {
                jumps++;
                currentEnd = farthest; // 更新边界

                // 如果已经能够到达最后一个位置，可以提前结束
                if (currentEnd >= nums.length - 1) {
                    break;
                }
            }
        }

        return jumps;
    }
}
```

**时间复杂度：** $O(n)$，只需要遍历数组一次。

**空间复杂度：** $O(1)$，只使用常数额外空间。

### 方法二：动态规划

使用动态规划记录到达每个位置所需的最少跳跃次数。

**算法步骤：**

1. 创建数组 dp，dp[i]表示到达位置 i 所需的最少跳跃次数
2. 初始化 dp[0] = 0（起始位置不需要跳跃）
3. 对于每个位置，尝试从前面的所有能够到达该位置的地方跳跃过来
4. 取最小值更新 dp[i]

```java
class Solution {
    public int jump(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return 0;
        }

        int n = nums.length;
        int[] dp = new int[n];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0; // 起始位置不需要跳跃

        for (int i = 0; i < n; i++) {
            if (dp[i] == Integer.MAX_VALUE) {
                continue; // 当前位置不可达
            }

            // 从位置i可以跳跃到的所有位置
            for (int j = 1; j <= nums[i] && i + j < n; j++) {
                dp[i + j] = Math.min(dp[i + j], dp[i] + 1);
            }
        }

        return dp[n - 1];
    }
}
```

**时间复杂度：** $O(n^2)$，最坏情况下需要遍历所有位置的所有跳跃可能。

**空间复杂度：** $O(n)$，需要额外的 dp 数组。

### 方法三：BFS 广度优先搜索

将问题看作图的最短路径问题，使用 BFS 求解。

**算法步骤：**

1. 使用队列进行 BFS，每次处理当前层的所有节点
2. 对于当前层的每个位置，计算其能跳跃到的所有位置
3. 如果能跳跃到最后一个位置，返回当前步数+1
4. 否则将新位置加入下一层继续搜索

```java
class Solution {
    public int jump(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return 0;
        }

        int n = nums.length;
        if (n == 1) return 0;

        Queue<Integer> queue = new LinkedList<>();
        boolean[] visited = new boolean[n];

        queue.offer(0);
        visited[0] = true;
        int steps = 0;

        while (!queue.isEmpty()) {
            int size = queue.size();
            steps++;

            for (int i = 0; i < size; i++) {
                int current = queue.poll();

                // 尝试从当前位置跳跃到所有可能的位置
                for (int j = 1; j <= nums[current]; j++) {
                    int next = current + j;

                    if (next >= n - 1) {
                        return steps; // 到达最后一个位置
                    }

                    if (!visited[next]) {
                        visited[next] = true;
                        queue.offer(next);
                    }
                }
            }
        }

        return -1; // 理论上不会到达这里
    }
}
```

**时间复杂度：** $O(n^2)$，最坏情况下需要访问所有位置和跳跃。

**空间复杂度：** $O(n)$，队列和 visited 数组。

### 方法四：优化的贪心算法

更直观的贪心实现方式。

```java
class Solution {
    public int jump(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return 0;
        }

        int jumps = 0;
        int i = 0;
        int n = nums.length;

        while (i < n - 1) {
            // 如果一步就能到达终点
            if (i + nums[i] >= n - 1) {
                jumps++;
                break;
            }

            // 找到下一步的最佳位置
            int maxReach = 0;
            int bestNext = i;

            for (int j = 1; j <= nums[i]; j++) {
                int nextPos = i + j;
                if (nextPos < n && nextPos + nums[nextPos] > maxReach) {
                    maxReach = nextPos + nums[nextPos];
                    bestNext = nextPos;
                }
            }

            i = bestNext;
            jumps++;
        }

        return jumps;
    }
}
```

**时间复杂度：** $O(n^2)$，最坏情况下每次都要搜索所有可能的跳跃位置。

**空间复杂度：** $O(1)$，只使用常数额外空间。

**推荐使用方法一（贪心算法）**，因为它时间复杂度最优，代码简洁，是解决此类问题的最佳方法。关键在于理解"边界"概念，在每个边界处必须做出跳跃决策。
