---
title: "74-搜索二维矩阵"
date: 2025-04-23 21:39:43 +0800
categories: [LEETCODE, HOT100]
tags: [二分查找, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/search-a-2d-matrix/) \| 难度: 中等

## 问题描述:

给你一个满足下述两条属性的 `m x n` 整数矩阵:

- 每行中的整数从左到右按非严格递增顺序排列。
- 每行的第一个整数大于前一行的最后一个整数。

给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。

**示例 1：**

![img](../assets/img/posts/leetcode/p74_0.jpg)

```java
输入: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出: true
```

**示例 2：**

![img](../assets/img/posts/leetcode/p74_1.jpg)

```java
输入: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出: false
```

## 解题思路：

这是一道搜索二维矩阵的问题。题目给出了一个 m×n 的二维整数矩阵，具有特殊的性质：每行的整数从左到右按非递减顺序排列，每行的第一个整数大于前一行的最后一个整数。需要判断给定的目标值 target 是否在矩阵中。

### 方法一：二分搜索法（推荐）

由于矩阵具有严格的排序性质，我们可以将整个二维矩阵看作一个一维的有序数组，然后使用二分搜索。

**算法步骤：**

1. 将二维矩阵的坐标映射到一维数组的索引
2. 使用二分搜索在一维索引范围内查找目标值
3. 通过除法和取余运算将一维索引转换回二维坐标
4. 比较矩阵中对应位置的值与目标值

**坐标转换公式：**

- 一维索引 `index` 对应的二维坐标为 `(index/n, index%n)`
- 其中 `n` 为矩阵的列数

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }

        int m = matrix.length;    // 行数
        int n = matrix[0].length; // 列数

        int left = 0;
        int right = m * n - 1;    // 最后一个元素的一维索引

        while (left <= right) {
            int mid = left + (right - left) / 2;

            // 将一维索引转换为二维坐标
            int row = mid / n;
            int col = mid % n;
            int midValue = matrix[row][col];

            if (midValue == target) {
                return true;
            } else if (midValue < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return false;
    }
}
```

**时间复杂度：** $O(\log(m \times n))$，其中 $m$ 是矩阵的行数，$n$ 是矩阵的列数。

**空间复杂度：** $O(1)$，只使用了常数额外空间。

### 方法二：两次二分搜索法

先用二分搜索确定目标值可能在哪一行，再在该行中用二分搜索查找目标值。

**算法步骤：**

1. 对每行的第一个元素进行二分搜索，找到目标值应该在的行
2. 在确定的行中进行二分搜索查找目标值

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }

        int m = matrix.length;
        int n = matrix[0].length;

        // 第一次二分搜索：确定目标行
        int targetRow = -1;
        int left = 0, right = m - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (matrix[mid][0] <= target) {
                targetRow = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        if (targetRow == -1) {
            return false;
        }

        // 第二次二分搜索：在目标行中查找
        left = 0;
        right = n - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            int midValue = matrix[targetRow][mid];

            if (midValue == target) {
                return true;
            } else if (midValue < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return false;
    }
}
```

**时间复杂度：** $O(\log m + \log n)$，其中 $m$ 是矩阵的行数，$n$ 是矩阵的列数。

**空间复杂度：** $O(1)$，只使用了常数额外空间。

**推荐使用方法一（一次二分搜索法）**，因为它利用了矩阵的完全有序性质，代码更简洁，时间复杂度也更优。
