---
title: "153-寻找旋转排序数组中的最小值"
date: 2025-04-22 21:40:04 +0800
categories: [LEETCODE, HOT100]
tags: [二分查找, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/) \| 难度: 中等

## 问题描述:

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到:

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

```java
输入: nums = [3,4,5,1,2]
输出: 1
解释: 原数组为 [1,2,3,4,5], 旋转 3 次得到输入数组
```

**示例 2：**

```java
输入: nums = [4,5,6,7,0,1,2]
输出: 0
解释: 原数组为 [0,1,2,4,5,6,7], 旋转 4 次得到输入数组
```

**示例 3：**

```java
输入: nums = [11,13,15,17]
输出: 11
解释: 原数组为 [11,13,15,17], 旋转 4 次得到输入数组
```

## 解题思路：

这是一道关于在旋转排序数组中查找最小值的问题。旋转排序数组是将有序数组从某个位置切分后，前后两部分互换位置形成的数组。需要在 O(log n)时间复杂度内找到最小值。

### 方法一：二分查找（推荐）

核心思想是利用旋转排序数组的特性：最小值位于旋转点，通过比较中点与右端点的值来判断最小值在哪一半，从而缩小搜索范围。

**算法步骤：**

1. 设置左右边界指针 left 和 right
2. 比较中点值与右端点值，判断最小值所在区间
3. 如果中点值小于右端点值，说明右半部分有序，最小值在左半部分
4. 如果中点值大于右端点值，说明旋转点在右半部分，最小值也在右半部分
5. 继续二分查找直到找到最小值

```java
class Solution {
    public int findMin(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }

        int left = 0, right = nums.length - 1;

        while (left < right) {
            int mid = left + (right - left) / 2;

            // 比较中点与右端点
            if (nums[mid] < nums[right]) {
                // 右半部分有序，最小值在左半部分（包括mid）
                right = mid;
            } else if (nums[mid] > nums[right]) {
                // 左半部分有序但不包含最小值，最小值在右半部分
                left = mid + 1;
            } else {
                // nums[mid] == nums[right]，无法判断，缩小搜索范围
                right--;
            }
        }

        return nums[left];
    }
}
```

**时间复杂度：** $O(\log n)$，标准二分查找的时间复杂度。

**空间复杂度：** $O(1)$，只使用常数额外空间。

### 方法二：比较中点与左端点的二分查找

另一种思路是比较中点与左端点的值来判断搜索方向。

```java
class Solution {
    public int findMin(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }

        int left = 0, right = nums.length - 1;

        while (left < right) {
            int mid = left + (right - left) / 2;

            // 比较中点与左端点
            if (nums[mid] > nums[left]) {
                // 如果右端点小于左端点，说明旋转点在右半部分
                if (nums[right] < nums[left]) {
                    left = mid + 1;
                } else {
                    // 没有旋转或旋转点在左半部分
                    right = mid;
                }
            } else if (nums[mid] < nums[left]) {
                // 旋转点在左半部分，最小值在左半部分（包括mid）
                right = mid;
            } else {
                // nums[mid] == nums[left]
                left++;
            }
        }

        return nums[left];
    }
}
```

**时间复杂度：** $O(\log n)$。

**空间复杂度：** $O(1)$。

### 方法三：简化版二分查找（无重复元素）

如果题目保证数组中无重复元素，可以使用更简洁的版本。

```java
class Solution {
    public int findMin(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }

        int left = 0, right = nums.length - 1;

        // 如果数组没有被旋转
        if (nums[left] <= nums[right]) {
            return nums[left];
        }

        while (left < right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] > nums[right]) {
                // 最小值在右半部分
                left = mid + 1;
            } else {
                // 最小值在左半部分（包括mid）
                right = mid;
            }
        }

        return nums[left];
    }
}
```

**时间复杂度：** $O(\log n)$。

**空间复杂度：** $O(1)$。

### 方法四：线性搜索（不推荐）

虽然简单，但不满足 O(log n)的时间复杂度要求。

```java
class Solution {
    public int findMin(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }

        int min = nums[0];
        for (int i = 1; i < nums.length; i++) {
            min = Math.min(min, nums[i]);
        }

        return min;
    }
}
```

**时间复杂度：** $O(n)$，线性扫描。

**空间复杂度：** $O(1)$。

### 关键点总结：

1. **旋转数组特性**：旋转后的数组可以分为两个有序部分，最小值位于旋转点
2. **比较策略**：通常比较中点与右端点更直观，避免边界情况的复杂处理
3. **重复元素处理**：当中点值等于端点值时，无法确定搜索方向，需要线性缩小范围
4. **终止条件**：当 left == right 时，指向的就是最小值

**推荐使用方法一（比较中点与右端点）**，因为它处理各种情况（包括重复元素）都比较简洁，逻辑清晰，且严格满足 O(log n)的时间复杂度要求。
