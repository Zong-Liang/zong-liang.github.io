---
title: "994-腐烂的橘子"
date: 2025-04-09 21:34:50 +0800
categories: [LEETCODE, HOT100]
tags: [图论, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/rotting-oranges/) \| 难度: 中等

## 问题描述:

在给定的 `m x n` 网格 `grid` 中，每个单元格可以有以下三个值之一:

- 值 `0` 代表空单元格；
- 值 `1` 代表新鲜橘子；
- 值 `2` 代表腐烂的橘子。

每分钟，腐烂的橘子**周围 4 个方向上相邻**的新鲜橘子都会腐烂。

返回 _直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`_。

**示例 1：**

![img](../assets/img/posts/leetcode/p994_0.png)

```
输入: grid = [[2,1,1],[1,1,0],[0,1,1]]
输出: 4
```

**示例 2：**

```java
输入: grid = [[2,1,1],[0,1,1],[1,0,1]]
输出: -1
解释: 左下角的橘子 (第 2 行, 第 0 列) 永远不会腐烂, 因为腐烂只会发生在 4 个方向上
```

**示例 3：**

```java
输入: grid = [[0,2]]
输出: 0
解释: 因为 0 分钟时已经没有新鲜橘子了, 所以答案就是 0
```

## 解题思路：

这是一道关于腐烂橘子的 BFS（广度优先搜索）问题。需要模拟腐烂过程，计算所有新鲜橘子变腐烂的最短时间。

### 核心思想

使用 BFS 模拟腐烂扩散过程，每一轮 BFS 代表 1 分钟的时间，腐烂橘子向 4 个方向扩散。

**算法步骤：**

1. 遍历网格，统计新鲜橘子数量，将所有腐烂橘子位置加入队列
2. 使用 BFS 逐层扩散：
   - 每轮处理当前队列中的所有腐烂橘子
   - 向 4 个方向扩散，将相邻的新鲜橘子变腐烂
   - 新腐烂的橘子加入队列，新鲜橘子计数减 1
3. 如果还有新鲜橘子剩余，返回-1；否则返回时间

```java
class Solution {
    public int orangesRotting(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }

        int m = grid.length;
        int n = grid[0].length;
        Queue<int[]> queue = new LinkedList<>();
        int freshCount = 0;

        // 统计新鲜橘子数量，将腐烂橘子位置加入队列
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    freshCount++;
                } else if (grid[i][j] == 2) {
                    queue.offer(new int[]{i, j});
                }
            }
        }

        // 如果没有新鲜橘子，直接返回0
        if (freshCount == 0) {
            return 0;
        }

        // 四个方向：上、下、左、右
        int[][] directions = {% raw %}{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}{% endraw %};
        int minutes = 0;

        // BFS扩散过程
        while (!queue.isEmpty()) {
            int size = queue.size();
            boolean hasRotten = false;

            // 处理当前轮次的所有腐烂橘子
            for (int i = 0; i < size; i++) {
                int[] current = queue.poll();
                int row = current[0];
                int col = current[1];

                // 向四个方向扩散
                for (int[] dir : directions) {
                    int newRow = row + dir[0];
                    int newCol = col + dir[1];

                    // 检查边界和是否为新鲜橘子
                    if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n
                        && grid[newRow][newCol] == 1) {

                        // 新鲜橘子变腐烂
                        grid[newRow][newCol] = 2;
                        queue.offer(new int[]{newRow, newCol});
                        freshCount--;
                        hasRotten = true;
                    }
                }
            }

            // 如果这轮有橘子腐烂，时间+1
            if (hasRotten) {
                minutes++;
            }
        }

        // 检查是否还有新鲜橘子
        return freshCount == 0 ? minutes : -1;
    }
}
```

**时间复杂度：** $O(m \times n)$，每个格子最多被访问一次。

**空间复杂度：** $O(m \times n)$，队列最多存储所有格子的位置。

**关键点：**

- 使用队列进行 BFS，每轮处理代表 1 分钟
- 统计新鲜橘子数量，用于判断是否全部腐烂
- 只有当这轮确实有橘子腐烂时，时间才+1
- 最后检查是否还有新鲜橘子剩余
