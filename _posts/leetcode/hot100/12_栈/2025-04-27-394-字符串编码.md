---
title: "394-字符串编码"
date: 2025-04-27 21:41:39 +0800
categories: [LEETCODE, HOT100]
tags: [栈, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/decode-string/) \| 难度: 中等

## 问题描述:

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。

**示例 1：**

```java
输入: s = "3[a]2[bc]"
输出: "aaabcbc"
```

**示例 2：**

```java
输入: s = "3[a2[c]]"
输出: "accaccacc"
```

**示例 3：**

```java
输入: s = "2[abc]3[cd]ef"
输出: "abcabccdcdcdef"
```

**示例 4：**

```java
输入: s = "abc3[cd]xyz"
输出: "abccdcdcdxyz"
```

**提示：**

- `s` 由小写英文字母、数字和方括号 `'[]'` 组成
- `s` 保证是一个 **有效** 的输入。
- `s` 中所有整数的取值范围为 `[1, 300]`

## 解题思路：

这是一道关于字符串解码的问题。给定一个经过编码的字符串，需要根据编码规则 `k[encoded_string]` 将其解码，其中 `k` 表示 `encoded_string` 重复 `k` 次。

### 方法一：栈（推荐）

核心思想是使用两个栈分别存储数字和字符串，遇到 `[` 时入栈，遇到 `]` 时出栈并进行字符串重复操作。

**算法步骤：**

1. 使用两个栈：`numStack` 存储重复次数，`strStack` 存储字符串
2. 遍历字符串的每个字符
3. 遇到数字时累积计算数值
4. 遇到 `[` 时将当前数字和字符串分别压入对应栈中
5. 遇到 `]` 时弹出栈顶元素进行字符串重复操作
6. 遇到字母时直接添加到当前字符串

```java
class Solution {
    public String decodeString(String s) {
        if (s == null || s.length() == 0) {
            return "";
        }

        Stack<Integer> numStack = new Stack<>();  // 存储重复次数
        Stack<String> strStack = new Stack<>();   // 存储字符串

        int num = 0;
        String currentStr = "";

        for (char c : s.toCharArray()) {
            if (Character.isDigit(c)) {
                // 累积计算数字（处理多位数）
                num = num * 10 + (c - '0');
            } else if (c == '[') {
                // 遇到 '[' 时，将当前数字和字符串压入栈
                numStack.push(num);
                strStack.push(currentStr);
                // 重置
                num = 0;
                currentStr = "";
            } else if (c == ']') {
                // 遇到 ']' 时，弹出栈顶元素进行重复操作
                int repeatTimes = numStack.pop();
                String prevStr = strStack.pop();

                // 将当前字符串重复指定次数，然后与前面的字符串拼接
                StringBuilder sb = new StringBuilder(prevStr);
                for (int i = 0; i < repeatTimes; i++) {
                    sb.append(currentStr);
                }
                currentStr = sb.toString();
            } else {
                // 遇到字母时直接添加到当前字符串
                currentStr += c;
            }
        }

        return currentStr;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是解码后字符串的长度。

**空间复杂度：** $O(n)$，栈的空间和字符串构建的空间。

### 方法二：递归

利用递归的特性来处理嵌套的编码字符串。

**算法步骤：**

1. 使用一个全局索引来跟踪当前处理的位置
2. 遇到数字时解析完整的数值
3. 遇到 `[` 时递归处理内部字符串
4. 遇到 `]` 时返回当前构建的字符串
5. 遇到字母时直接添加

```java
class Solution {
    private int index = 0;

    public String decodeString(String s) {
        if (s == null || s.length() == 0) {
            return "";
        }

        index = 0;
        return decode(s);
    }

    private String decode(String s) {
        StringBuilder result = new StringBuilder();

        while (index < s.length() && s.charAt(index) != ']') {
            if (Character.isDigit(s.charAt(index))) {
                // 解析数字
                int num = 0;
                while (index < s.length() && Character.isDigit(s.charAt(index))) {
                    num = num * 10 + (s.charAt(index) - '0');
                    index++;
                }

                // 跳过 '['
                index++;

                // 递归解析括号内的字符串
                String substr = decode(s);

                // 跳过 ']'
                index++;

                // 重复字符串
                for (int i = 0; i < num; i++) {
                    result.append(substr);
                }
            } else {
                // 普通字符直接添加
                result.append(s.charAt(index));
                index++;
            }
        }

        return result.toString();
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是解码后字符串的长度。

**空间复杂度：** $O(n)$，递归调用栈的空间。

### 方法三：优化的栈实现

使用 StringBuilder 优化字符串拼接性能。

```java
class Solution {
    public String decodeString(String s) {
        if (s == null || s.length() == 0) {
            return "";
        }

        Stack<Integer> numStack = new Stack<>();
        Stack<StringBuilder> strStack = new Stack<>();

        int num = 0;
        StringBuilder currentStr = new StringBuilder();

        for (char c : s.toCharArray()) {
            if (Character.isDigit(c)) {
                num = num * 10 + (c - '0');
            } else if (c == '[') {
                numStack.push(num);
                strStack.push(currentStr);
                num = 0;
                currentStr = new StringBuilder();
            } else if (c == ']') {
                int repeatTimes = numStack.pop();
                StringBuilder prevStr = strStack.pop();

                // 重复当前字符串
                String repeated = currentStr.toString();
                for (int i = 0; i < repeatTimes; i++) {
                    prevStr.append(repeated);
                }
                currentStr = prevStr;
            } else {
                currentStr.append(c);
            }
        }

        return currentStr.toString();
    }
}
```

### 方法四：正则表达式（不推荐，仅供参考）

使用正则表达式替换的方式，但效率较低且不易处理嵌套。

```java
class Solution {
    public String decodeString(String s) {
        // 持续替换直到没有可替换的模式
        while (s.contains("[")) {
            s = s.replaceAll("(\\d+)\\[([a-z]*)\\]",
                new java.util.function.Function<java.util.regex.MatchResult, String>() {
                    public String apply(java.util.regex.MatchResult match) {
                        int times = Integer.parseInt(match.group(1));
                        String str = match.group(2);
                        return str.repeat(times);
                    }
                }.toString());
        }
        return s;
    }
}
```

**推荐使用方法一（栈）**，因为它思路清晰、实现简单、处理嵌套情况能力强。栈是处理这类嵌套结构问题的经典数据结构，能够很好地保存和恢复上下文信息。
