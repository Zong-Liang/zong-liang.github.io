---
title: "739-每日温度"
date: 2025-04-28 21:41:50 +0800
categories: [LEETCODE, HOT100]
tags: [栈, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/daily-temperatures/) \| 难度: 中等

## 问题描述:

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

**示例 1：**

```java
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

**示例 2：**

```java
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

**示例 3：**

```java
输入: temperatures = [30,60,90]
输出: [1,1,0]
```

## 解题思路：

这是一道关于每日温度的问题。给定一个整数数组 `temperatures`，表示每天的温度，需要返回一个数组 `answer`，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

### 方法一：单调栈（推荐）

核心思想是使用单调递减栈来存储温度的索引，当遇到更高的温度时，弹出栈中所有比当前温度低的元素并计算天数差。

**算法步骤：**

1. 使用栈存储温度数组的索引
2. 遍历温度数组
3. 当当前温度大于栈顶索引对应的温度时，弹出栈顶并计算天数差
4. 将当前索引压入栈中
5. 栈中维持的是一个单调递减的温度序列

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        if (temperatures == null || temperatures.length == 0) {
            return new int[0];
        }

        int n = temperatures.length;
        int[] answer = new int[n];
        Stack<Integer> stack = new Stack<>();  // 存储索引

        for (int i = 0; i < n; i++) {
            // 当前温度大于栈顶索引对应的温度时，弹出栈顶
            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
                int prevIndex = stack.pop();
                answer[prevIndex] = i - prevIndex;  // 计算天数差
            }

            // 将当前索引压入栈
            stack.push(i);
        }

        // 栈中剩余的索引对应的天数都是0（默认值）
        return answer;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是温度数组的长度，每个元素最多进栈和出栈一次。

**空间复杂度：** $O(n)$，栈的空间复杂度。

### 方法二：暴力法

对于每一天，向后遍历寻找第一个更高的温度。

**算法步骤：**

1. 对于每一天，从下一天开始遍历
2. 找到第一个温度更高的天数
3. 计算天数差并存储结果

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        if (temperatures == null || temperatures.length == 0) {
            return new int[0];
        }

        int n = temperatures.length;
        int[] answer = new int[n];

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (temperatures[j] > temperatures[i]) {
                    answer[i] = j - i;
                    break;  // 找到第一个更高温度就停止
                }
            }
            // 如果没找到更高温度，answer[i] 保持默认值 0
        }

        return answer;
    }
}
```

**时间复杂度：** $O(n^2)$，最坏情况下需要对每个元素遍历其后的所有元素。

**空间复杂度：** $O(1)$，除了结果数组外只使用常数额外空间。

### 方法三：逆向遍历优化

从右向左遍历，利用已计算的结果来加速查找。

**算法步骤：**

1. 从右向左遍历温度数组
2. 对于每一天，利用右边已经计算好的结果来跳跃查找
3. 如果右边某天的温度更高，直接返回天数差
4. 否则跳到右边那天的下一个更高温度日继续查找

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        if (temperatures == null || temperatures.length == 0) {
            return new int[0];
        }

        int n = temperatures.length;
        int[] answer = new int[n];

        // 从右向左遍历
        for (int i = n - 2; i >= 0; i--) {
            int j = i + 1;

            // 寻找下一个更高温度的天数
            while (j < n) {
                if (temperatures[j] > temperatures[i]) {
                    answer[i] = j - i;
                    break;
                } else if (answer[j] == 0) {
                    // 如果 j 天之后没有更高温度，那么 i 天也没有
                    break;
                } else {
                    // 跳到 j 天的下一个更高温度日
                    j = j + answer[j];
                }
            }
        }

        return answer;
    }
}
```

**时间复杂度：** 平均 $O(n)$，最坏情况 $O(n^2)$。

**空间复杂度：** $O(1)$，除了结果数组外只使用常数额外空间。

### 方法四：数组模拟栈

使用数组代替栈来节省一些开销。

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        if (temperatures == null || temperatures.length == 0) {
            return new int[0];
        }

        int n = temperatures.length;
        int[] answer = new int[n];
        int[] stack = new int[n];  // 用数组模拟栈
        int top = -1;  // 栈顶指针

        for (int i = 0; i < n; i++) {
            // 当前温度大于栈顶索引对应的温度时，弹出栈顶
            while (top >= 0 && temperatures[i] > temperatures[stack[top]]) {
                int prevIndex = stack[top--];
                answer[prevIndex] = i - prevIndex;
            }

            // 将当前索引压入栈
            stack[++top] = i;
        }

        return answer;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是温度数组的长度。

**空间复杂度：** $O(n)$，数组模拟栈的空间。

**推荐使用方法一（单调栈）**，因为它时间复杂度最优，思路清晰，是解决这类"寻找下一个更大元素"问题的经典方法。单调栈在处理此类问题时非常高效，能够在线性时间内完成计算。
