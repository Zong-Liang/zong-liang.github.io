---
title: "84-柱状图中最大的矩形"
date: 2025-04-25 21:40:50 +0800
categories: [LEETCODE, HOT100]
tags: [栈, 困难]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/largest-rectangle-in-histogram/) \| 难度: 困难

## 问题描述:

给定 _n_ 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

**示例 1：**

![img](../assets/img/posts/leetcode/p84_0.jpg)

```java
输入: heights = [2,1,5,6,2,3]
输出: 10
解释: 最大的矩形为图中红色区域, 面积为 10
```

**示例 2：**

![img](../assets/img/posts/leetcode/p84_1.jpg)

```java
输入:  heights = [2,4]
输出:  4
```

## 解题思路：

这是一道关于柱状图中最大矩形的经典问题。给定一个表示柱状图中各个柱子高度的数组，需要找到能够勾勒出来的矩形的最大面积。

### 方法一：单调栈（推荐）

核心思想是利用单调递增栈来找到每个柱子左右两边第一个比它矮的柱子，从而确定以当前柱子为高度的最大矩形的宽度。

**算法步骤：**

1. 使用单调递增栈存储柱子的索引
2. 遍历每个柱子，如果当前柱子比栈顶柱子矮，则弹出栈顶并计算面积
3. 对于每个弹出的柱子，其左边界是新栈顶的下一个位置，右边界是当前位置
4. 为了处理边界情况，在数组前后各添加一个高度为 0 的柱子

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        if (heights == null || heights.length == 0) {
            return 0;
        }

        // 在数组前后各加一个0，便于处理边界情况
        int[] newHeights = new int[heights.length + 2];
        newHeights[0] = 0;
        newHeights[newHeights.length - 1] = 0;
        System.arraycopy(heights, 0, newHeights, 1, heights.length);

        Stack<Integer> stack = new Stack<>();
        int maxArea = 0;

        for (int i = 0; i < newHeights.length; i++) {
            // 当前柱子比栈顶柱子矮，需要计算以栈顶柱子为高度的矩形面积
            while (!stack.isEmpty() && newHeights[i] < newHeights[stack.peek()]) {
                int height = newHeights[stack.pop()];
                int width = i - stack.peek() - 1;
                maxArea = Math.max(maxArea, height * width);
            }
            stack.push(i);
        }

        return maxArea;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是数组长度，每个元素最多进栈和出栈一次。

**空间复杂度：** $O(n)$，栈的空间和辅助数组的空间。

### 方法二：分治法

对于每个区间，找到最矮的柱子，以它为高度计算矩形面积，然后递归处理左右两个子区间。

**算法步骤：**

1. 找到当前区间内最矮的柱子
2. 计算以该柱子高度为矩形高度的面积
3. 递归计算左右两个子区间的最大面积
4. 返回三者中的最大值

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        if (heights == null || heights.length == 0) {
            return 0;
        }
        return calculateArea(heights, 0, heights.length - 1);
    }

    private int calculateArea(int[] heights, int start, int end) {
        if (start > end) {
            return 0;
        }

        // 找到最小高度的索引
        int minIndex = start;
        for (int i = start; i <= end; i++) {
            if (heights[i] < heights[minIndex]) {
                minIndex = i;
            }
        }

        // 以最小高度为矩形高度的面积
        int area = heights[minIndex] * (end - start + 1);

        // 递归计算左右两部分
        int leftArea = calculateArea(heights, start, minIndex - 1);
        int rightArea = calculateArea(heights, minIndex + 1, end);

        return Math.max(area, Math.max(leftArea, rightArea));
    }
}
```

**时间复杂度：** 平均 $O(n \log n)$，最坏情况 $O(n^2)$（当数组单调递增或递减时）。

**空间复杂度：** $O(\log n)$，递归调用栈的空间。

### 方法三：暴力法（不推荐，仅供理解）

对于每个柱子，向左右两边扩展找到能形成的最大矩形。

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        if (heights == null || heights.length == 0) {
            return 0;
        }

        int maxArea = 0;

        for (int i = 0; i < heights.length; i++) {
            int height = heights[i];
            int left = i, right = i;

            // 向左扩展
            while (left >= 0 && heights[left] >= height) {
                left--;
            }

            // 向右扩展
            while (right < heights.length && heights[right] >= height) {
                right++;
            }

            int width = right - left - 1;
            maxArea = Math.max(maxArea, height * width);
        }

        return maxArea;
    }
}
```

**时间复杂度：** $O(n^2)$，对于每个柱子都要向两边扩展。

**空间复杂度：** $O(1)$，只使用了常数额外空间。

### 方法四：优化的单调栈（无需辅助数组）

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        if (heights == null || heights.length == 0) {
            return 0;
        }

        Stack<Integer> stack = new Stack<>();
        int maxArea = 0;

        for (int i = 0; i <= heights.length; i++) {
            int currHeight = i == heights.length ? 0 : heights[i];

            while (!stack.isEmpty() && currHeight < heights[stack.peek()]) {
                int height = heights[stack.pop()];
                int width = stack.isEmpty() ? i : i - stack.peek() - 1;
                maxArea = Math.max(maxArea, height * width);
            }

            stack.push(i);
        }

        return maxArea;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是数组长度。

**空间复杂度：** $O(n)$，栈的空间。

**推荐使用方法一或方法四（单调栈）**，因为它具有线性时间复杂度，是解决这类问题的最优解法。单调栈的核心思想是维护一个递增序列，当遇到较小元素时触发面积计算，这是处理柱状图问题的经典技巧。
