---
title: "155-最小栈"
date: 2025-04-26 21:41:23 +0800
categories: [LEETCODE, HOT100]
tags: [栈, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/min-stack/) \| 难度: 中等

## 问题描述:

设计一个支持 `push`，`pop`，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素 val 推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

**示例 1：**

```java
输入:
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出:
[null,null,null,null,-3,null,0,-2]

解释:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

**提示：**

- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用

## 解题思路：

这是一道关于设计最小栈的数据结构问题。需要实现一个栈，支持常规的 push、pop、top 操作，同时能在常数时间内检索到最小元素。

### 方法一：辅助栈（推荐）

核心思想是使用两个栈：一个主栈存储所有元素，一个辅助栈存储当前状态下的最小值。

**设计要点：**

1. 主栈正常存储所有元素
2. 辅助栈存储每个状态下的最小值
3. push 时同时更新两个栈
4. pop 时同时从两个栈弹出元素
5. getMin 直接返回辅助栈顶元素

```java
class MinStack {
    private Stack<Integer> stack;      // 主栈存储所有元素
    private Stack<Integer> minStack;   // 辅助栈存储最小值

    public MinStack() {
        stack = new Stack<>();
        minStack = new Stack<>();
    }

    public void push(int val) {
        stack.push(val);

        // 如果辅助栈为空，或者新元素小于等于当前最小值，则压入辅助栈
        if (minStack.isEmpty() || val <= minStack.peek()) {
            minStack.push(val);
        }
    }

    public void pop() {
        if (stack.isEmpty()) {
            return;
        }

        int val = stack.pop();

        // 如果弹出的元素是当前最小值，也要从辅助栈中弹出
        if (val == minStack.peek()) {
            minStack.pop();
        }
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}
```

**时间复杂度：** 所有操作都是 $O(1)$。

**空间复杂度：** $O(n)$，其中 $n$ 是栈中元素的数量，最坏情况下辅助栈存储所有元素。

### 方法二：单栈 + 最小值记录（空间优化）

使用一个栈，但在栈中存储差值，同时用一个变量记录当前最小值。

**设计要点：**

1. 用一个变量 min 记录当前最小值
2. 栈中存储元素与当前最小值的差值
3. 当差值小于 0 时，说明当前元素就是新的最小值

```java
class MinStack {
    private Stack<Long> stack;  // 存储差值
    private long min;           // 当前最小值

    public MinStack() {
        stack = new Stack<>();
    }

    public void push(int val) {
        if (stack.isEmpty()) {
            stack.push(0L);
            min = val;
        } else {
            // 存储与当前最小值的差值
            long diff = (long)val - min;
            stack.push(diff);

            // 如果差值小于0，更新最小值
            if (diff < 0) {
                min = val;
            }
        }
    }

    public void pop() {
        if (stack.isEmpty()) {
            return;
        }

        long diff = stack.pop();

        // 如果差值小于0，说明弹出的是最小值，需要恢复之前的最小值
        if (diff < 0) {
            min = min - diff;
        }
    }

    public int top() {
        long diff = stack.peek();

        // 如果差值小于0，栈顶元素就是当前最小值
        if (diff < 0) {
            return (int)min;
        } else {
            return (int)(min + diff);
        }
    }

    public int getMin() {
        return (int)min;
    }
}
```

**时间复杂度：** 所有操作都是 $O(1)$。

**空间复杂度：** $O(n)$，只使用一个栈的空间。

### 方法三：链表实现

使用链表节点存储值和当前最小值。

```java
class MinStack {
    private Node head;

    private class Node {
        int val;
        int min;
        Node next;

        Node(int val, int min, Node next) {
            this.val = val;
            this.min = min;
            this.next = next;
        }
    }

    public MinStack() {
        // 链表头为空
    }

    public void push(int val) {
        if (head == null) {
            head = new Node(val, val, null);
        } else {
            int currentMin = Math.min(val, head.min);
            head = new Node(val, currentMin, head);
        }
    }

    public void pop() {
        if (head != null) {
            head = head.next;
        }
    }

    public int top() {
        return head.val;
    }

    public int getMin() {
        return head.min;
    }
}
```

**时间复杂度：** 所有操作都是 $O(1)$。

**空间复杂度：** $O(n)$，每个节点存储额外的最小值信息。

### 方法四：改进的辅助栈（空间优化）

只在需要时向辅助栈添加元素，减少空间使用。

```java
class MinStack {
    private Stack<Integer> stack;
    private Stack<Integer> minStack;

    public MinStack() {
        stack = new Stack<>();
        minStack = new Stack<>();
    }

    public void push(int val) {
        stack.push(val);

        // 只有当辅助栈为空或新值小于等于当前最小值时才压入
        if (minStack.isEmpty() || val <= getMin()) {
            minStack.push(val);
        }
    }

    public void pop() {
        // 如果弹出的是最小值，也从辅助栈弹出
        if (stack.pop().equals(minStack.peek())) {
            minStack.pop();
        }
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}
```

**推荐使用方法一（辅助栈法）**，因为它思路清晰、实现简单、易于理解和调试。对于面试来说，这是最安全和经典的解法。如果追求空间优化，可以考虑方法二，但实现相对复杂一些。
