---
title: "20-有效的括号"
date: 2025-04-24 21:40:25 +0800
categories: [LEETCODE, HOT100]
tags: [栈, 简单]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/valid-parentheses/) \| 难度: 简单

## 问题描述:

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足:

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**示例 1：**

```java
输入: s = "()"
输出: true
```

**示例 2:**

```java
输入: s = "()[]{}"
输出: true
```

**示例 3:**

```java
输入: s = "()[]{}"
输出: true
```

**示例 4:**

```java
输入: s = "([])"
输出: true
```

**提示:** `s` 仅由括号 `'()[]{}'` 组成

## 解题思路：

这是一道关于有效括号判断的经典问题。需要判断给定的只包含 `'('`, `')'`, `'{'`, `'}'`, `'['`, `']'` 的字符串是否是有效的括号组合。

### 方法一：栈（推荐）

核心思想是利用栈的后进先出（LIFO）特性来匹配括号对。

**算法步骤：**

1. 使用栈来存储左括号
2. 遍历字符串中的每个字符
3. 如果是左括号，压入栈中
4. 如果是右括号，检查栈是否为空，以及栈顶元素是否与当前右括号匹配
5. 最后检查栈是否为空（所有左括号都有对应的右括号匹配）

```java
class Solution {
    public boolean isValid(String s) {
        if (s == null || s.length() % 2 != 0) {
            return false;
        }

        Stack<Character> stack = new Stack<>();

        for (char c : s.toCharArray()) {
            // 遇到左括号，压入栈中
            if (c == '(' || c == '[' || c == '{') {
                stack.push(c);
            }
            // 遇到右括号，检查匹配
            else {
                // 栈为空，说明没有对应的左括号
                if (stack.isEmpty()) {
                    return false;
                }

                char top = stack.pop();
                // 检查括号是否匹配
                if ((c == ')' && top != '(') ||
                    (c == ']' && top != '[') ||
                    (c == '}' && top != '{')) {
                    return false;
                }
            }
        }

        // 栈为空说明所有括号都匹配
        return stack.isEmpty();
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是字符串的长度，需要遍历字符串一次。

**空间复杂度：** $O(n)$，最坏情况下（全是左括号），栈中会存储所有字符。

### 方法二：使用 HashMap 优化（推荐）

使用 HashMap 存储括号对应关系，使代码更简洁易读。

```java
class Solution {
    public boolean isValid(String s) {
        if (s == null || s.length() % 2 != 0) {
            return false;
        }

        // 使用 HashMap 存储括号对应关系
        Map<Character, Character> map = new HashMap<>();
        map.put(')', '(');
        map.put(']', '[');
        map.put('}', '{');

        Stack<Character> stack = new Stack<>();

        for (char c : s.toCharArray()) {
            // 如果是右括号
            if (map.containsKey(c)) {
                // 栈为空或者栈顶元素不匹配
                if (stack.isEmpty() || stack.pop() != map.get(c)) {
                    return false;
                }
            }
            // 如果是左括号，压入栈中
            else {
                stack.push(c);
            }
        }

        return stack.isEmpty();
    }
}
```

### 方法三：字符替换法（仅供参考）

通过不断替换匹配的括号对来判断有效性，但效率较低。

```java
class Solution {
    public boolean isValid(String s) {
        if (s == null || s.length() % 2 != 0) {
            return false;
        }

        // 不断替换匹配的括号对
        while (s.contains("()") || s.contains("[]") || s.contains("{}")) {
            s = s.replace("()", "");
            s = s.replace("[]", "");
            s = s.replace("{}", "");
        }

        return s.isEmpty();
    }
}
```

**时间复杂度：** $O(n^2)$，因为需要多次遍历和替换字符串。

**空间复杂度：** $O(n)$，字符串替换过程中产生的临时字符串。

### 方法四：数组模拟栈（空间优化）

使用数组代替栈，节省一些空间开销。

```java
class Solution {
    public boolean isValid(String s) {
        if (s == null || s.length() % 2 != 0) {
            return false;
        }

        char[] stack = new char[s.length()];
        int top = -1;

        for (char c : s.toCharArray()) {
            if (c == '(' || c == '[' || c == '{') {
                stack[++top] = c;
            } else {
                if (top == -1) {
                    return false;
                }

                char leftChar = stack[top--];
                if ((c == ')' && leftChar != '(') ||
                    (c == ']' && leftChar != '[') ||
                    (c == '}' && leftChar != '{')) {
                    return false;
                }
            }
        }

        return top == -1;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是字符串的长度。

**空间复杂度：** $O(n)$，用于存储数组。

**推荐使用方法二（HashMap + 栈）**，因为它代码简洁、易于理解和维护，同时具有良好的时间和空间复杂度。方法一也是很好的选择，更加直观明了。
