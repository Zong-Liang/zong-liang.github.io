---
title: "41-缺失的第一个正数"
date: 2025-02-27 21:16:46 +0800
categories: [LEETCODE, HOT100]
tags: [普通数组, 困难]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/first-missing-positive/) \| 难度: 困难

## 问题描述:

给你一个未排序的整数数组 `nums`，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 $O(n)$ 并且只使用常数级别额外空间的解决方案。

**示例 1：**

```java
输入: nums = [1,2,0]
输出: 3
解释: 范围 [1,2] 中的数字都在数组中
```

**示例 2：**

```java
输入: nums = [3,4,-1,1]
输出: 2
解释: 1 在数组中, 但 2 没有
```

**示例 3：**

```java
输入: nums = [7,8,9,11,12]
输出: 1
解释: 最小的正数 1 没有出现
```

## 解题思路

这道题要求在未排序的整数数组中找到缺失的第一个正数。关键约束是时间复杂度 $O(n)$，空间复杂度 $O(1)$。

核心思想：将数组本身作为哈希表，通过原地修改来标记哪些正数已经存在。

### 方法一：原地哈希（最优解法）

利用数组索引和值的对应关系，将正数 `i` 放到索引 `i-1` 的位置上。

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;

        // 第一步：将数组中的非正数替换为 n+1
        for (int i = 0; i < n; i++) {
            if (nums[i] <= 0) {
                nums[i] = n + 1;
            }
        }

        // 第二步：使用符号标记存在性
        for (int i = 0; i < n; i++) {
            int num = Math.abs(nums[i]);
            if (num <= n) {
                // 将对应位置的数变为负数，表示该数存在
                nums[num - 1] = -Math.abs(nums[num - 1]);
            }
        }

        // 第三步：找第一个正数的位置
        for (int i = 0; i < n; i++) {
            if (nums[i] > 0) {
                return i + 1;
            }
        }

        // 如果1到n都存在，返回n+1
        return n + 1;
    }
}
```

**时间复杂度**：$O(n)$，三次遍历数组
**空间复杂度**：$O(1)$，只使用常数额外空间

### 方法二：置换法

将每个正数放到其"应该在"的位置上，即数字 `i` 放到索引 `i-1` 处。

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;

        // 将每个正数放到正确的位置
        for (int i = 0; i < n; i++) {
            // 当前数字在范围内且不在正确位置时，进行交换
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                // 交换 nums[i] 和 nums[nums[i] - 1]
                int temp = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i] = temp;
            }
        }

        // 找第一个不在正确位置的数
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }

        return n + 1;
    }
}
```

**时间复杂度**：$O(n)$，每个元素最多被交换一次
**空间复杂度**：$O(1)$，只使用常数额外空间

**推荐解法：原地哈希法（方法一）**，因为它完美满足 $O(n)$ 时间复杂度和 $O(1)$ 空间复杂度的要求，思路清晰且实现简洁。
