---
title: "189-轮转数组"
date: 2025-03-02 21:18:24 +0800
categories: [LEETCODE, HOT100]
tags: [普通数组, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/rotate-array/) \| 难度: 中等

## 问题描述:

给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**示例 1：**

```java
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```

**示例 2：**

```java
输入: nums = [-1,-100,3,99], k = 2
输出: [3,99,-1,-100]
解释:
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
```

**进阶：**

- 尽可能想出更多的解决方案，至少有**三种**不同的方法可以解决这个问题。
- 你可以使用空间复杂度为 $O(1)$ 的**原地**算法解决这个问题吗？

## 解题思路:

这道题是"轮转数组"问题。要求将数组中的元素向右轮转 $k$ 个位置，其中 $k$ 是非负数。关键是要求必须在原地操作，空间复杂度为 $O(1)$。

### 方法一：数组反转法（推荐）

通过三次反转操作来实现轮转：先反转整个数组，再分别反转前 $k$ 个和后 $n-k$ 个元素。

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n; // 处理k大于数组长度的情况

        // 反转整个数组
        reverse(nums, 0, n - 1);
        // 反转前k个元素
        reverse(nums, 0, k - 1);
        // 反转后n-k个元素
        reverse(nums, k, n - 1);
    }

    private void reverse(int[] nums, int start, int end) {
        while (start < end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        }
    }
}
```

**时间复杂度**：$O(n)$，其中 $n$ 是数组长度。需要三次遍历数组。

**空间复杂度**：$O(1)$，只使用了常数额外空间。

### 方法二：环状替换法

将每个元素直接放到它最终应该到达的位置，通过环状替换避免元素丢失。

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;

        int count = 0; // 已经移动的元素个数

        for (int start = 0; count < n; start++) {
            int current = start;
            int prev = nums[start];

            do {
                int next = (current + k) % n;
                int temp = nums[next];
                nums[next] = prev;
                prev = temp;
                current = next;
                count++;
            } while (start != current);
        }
    }
}
```

**时间复杂度**：$O(n)$，每个元素都会被移动一次。

**空间复杂度**：$O(1)$，只使用了常数额外空间。

### 方法三：使用额外数组

创建一个新数组，将每个元素放到正确的位置，然后复制回原数组。

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;

        int[] temp = new int[n];

        // 将每个元素放到新位置
        for (int i = 0; i < n; i++) {
            temp[(i + k) % n] = nums[i];
        }

        // 复制回原数组
        for (int i = 0; i < n; i++) {
            nums[i] = temp[i];
        }
    }
}
```

**时间复杂度**：$O(n)$，需要两次遍历数组。

**空间复杂度**：$O(n)$，需要额外的数组空间。

### 方法四：暴力法

每次向右轮转一位，重复 $k$ 次。

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;

        for (int i = 0; i < k; i++) {
            rotateOne(nums);
        }
    }

    private void rotateOne(int[] nums) {
        int n = nums.length;
        int last = nums[n - 1];

        // 将所有元素向右移动一位
        for (int i = n - 1; i > 0; i--) {
            nums[i] = nums[i - 1];
        }

        nums[0] = last;
    }
}
```

**时间复杂度**：$O(n \times k)$，每次轮转需要 $O(n)$ 时间，共 $k$ 次。

**空间复杂度**：$O(1)$，只使用了常数额外空间。

### 方法五：分块处理法

将数组分成若干块，每次处理一块元素的轮转。

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;

        if (k == 0) return;

        // 计算最大公约数，确定需要处理的起始点数量
        int gcd = gcd(n, k);

        for (int start = 0; start < gcd; start++) {
            int current = start;
            int prev = nums[start];

            do {
                int next = (current + k) % n;
                int temp = nums[next];
                nums[next] = prev;
                prev = temp;
                current = next;
            } while (start != current);
        }
    }

    private int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
}
```

**时间复杂度**：$O(n)$，每个元素都会被访问一次。

**空间复杂度**：$O(1)$，只使用了常数额外空间。

### 方法六：双指针交换法

使用双指针从两端开始交换元素，逐步完成轮转。

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;

        if (k == 0) return;

        // 先处理前n-k个元素和后k个元素的交换
        int left = 0, right = n - k;
        while (left < right && right + k - 1 < n) {
            for (int i = 0; i < k; i++) {
                swap(nums, left + i, right + i);
            }
            left += k;
        }

        // 递归处理剩余部分
        if (left < right) {
            rotate(Arrays.copyOfRange(nums, left, right + k), k - (right - left));
            System.arraycopy(nums, left, nums, left, right + k - left);
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

**时间复杂度**：$O(n)$，每个元素最多被处理常数次。

**空间复杂度**：$O(\log n)$，递归调用的栈空间。

**推荐使用方法一（数组反转法）**，它思路清晰，代码简洁，时间和空间复杂度都很优秀，是最经典的解法。

**核心思想**：

1. 关键观察：向右轮转 k 位等价于将数组分成两部分并交换位置
2. 数组反转法：通过三次反转实现位置交换，避免使用额外空间
3. 处理边界情况：k 可能大于数组长度，需要取模运算
4. 反转操作：[1,2,3,4,5,6,7] k=3 → [7,6,5,4,3,2,1] → [5,6,7,1,2,3,4]
