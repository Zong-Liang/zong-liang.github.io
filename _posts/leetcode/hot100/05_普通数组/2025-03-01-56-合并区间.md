---
title: "56-合并区间"
date: 2025-03-01 21:17:53 +0800
categories: [LEETCODE, HOT100]
tags: [普通数组, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/merge-intervals/) \| 难度: 中等

## 问题描述:

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]`。请你合并所有重叠的区间，并返回 _一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间_ 。

**示例 1：**

```java
输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]
```

**示例 2：**

```java
输入: intervals = [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间
```

## 解题思路:

这道题是"合并区间"问题。要求合并所有重叠的区间，并返回一个不重叠的区间数组。关键是要先对区间按起始位置排序，然后依次判断是否需要合并。

### 方法一：排序+遍历合并（推荐）

先按区间起始位置排序，然后遍历数组，依次判断当前区间是否与前一个区间重叠。

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if (intervals.length <= 1) {
            return intervals;
        }

        // 按起始位置排序
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);

        List<int[]> merged = new ArrayList<>();

        for (int[] interval : intervals) {
            // 如果结果列表为空，或当前区间与上一个区间不重叠
            if (merged.isEmpty() || merged.get(merged.size() - 1)[1] < interval[0]) {
                merged.add(interval);
            } else {
                // 合并区间：更新上一个区间的结束位置
                merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], interval[1]);
            }
        }

        return merged.toArray(new int[merged.size()][]);
    }
}
```

**时间复杂度**：$O(n \log n)$，主要是排序的时间复杂度。

**空间复杂度**：$O(n)$，存储结果的空间。

### 方法二：使用栈

利用栈的特性来处理区间合并，栈顶始终保持当前正在处理的区间。

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if (intervals.length <= 1) {
            return intervals;
        }

        // 按起始位置排序
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);

        Stack<int[]> stack = new Stack<>();
        stack.push(intervals[0]);

        for (int i = 1; i < intervals.length; i++) {
            int[] current = intervals[i];
            int[] top = stack.peek();

            // 如果当前区间与栈顶区间重叠
            if (current[0] <= top[1]) {
                // 合并区间
                top[1] = Math.max(top[1], current[1]);
            } else {
                // 不重叠，直接入栈
                stack.push(current);
            }
        }

        return stack.toArray(new int[stack.size()][]);
    }
}
```

**时间复杂度**：$O(n \log n)$，主要是排序的时间复杂度。

**空间复杂度**：$O(n)$，栈的空间。

### 方法三：原地修改

在原数组基础上进行合并，减少额外空间使用。

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if (intervals.length <= 1) {
            return intervals;
        }

        // 按起始位置排序
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);

        int writeIndex = 0; // 写入位置

        for (int readIndex = 1; readIndex < intervals.length; readIndex++) {
            // 如果当前区间与前一个已处理区间重叠
            if (intervals[writeIndex][1] >= intervals[readIndex][0]) {
                // 合并区间
                intervals[writeIndex][1] = Math.max(intervals[writeIndex][1], intervals[readIndex][1]);
            } else {
                // 不重叠，移动写入位置
                writeIndex++;
                intervals[writeIndex] = intervals[readIndex];
            }
        }

        // 返回有效部分
        return Arrays.copyOf(intervals, writeIndex + 1);
    }
}
```

**时间复杂度**：$O(n \log n)$，主要是排序的时间复杂度。

**空间复杂度**：$O(1)$，不考虑排序的额外空间。

### 方法四：递归分治

采用分治的思想，将区间数组分成两部分分别处理，然后合并结果。

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if (intervals.length <= 1) {
            return intervals;
        }

        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        return mergeHelper(intervals, 0, intervals.length - 1);
    }

    private int[][] mergeHelper(int[][] intervals, int left, int right) {
        if (left == right) {
            return new int[][]{intervals[left]};
        }

        int mid = left + (right - left) / 2;
        int[][] leftResult = mergeHelper(intervals, left, mid);
        int[][] rightResult = mergeHelper(intervals, mid + 1, right);

        return mergeTwoSortedIntervals(leftResult, rightResult);
    }

    private int[][] mergeTwoSortedIntervals(int[][] left, int[][] right) {
        List<int[]> result = new ArrayList<>();
        int i = 0, j = 0;

        while (i < left.length && j < right.length) {
            if (left[i][0] <= right[j][0]) {
                addInterval(result, left[i++]);
            } else {
                addInterval(result, right[j++]);
            }
        }

        while (i < left.length) {
            addInterval(result, left[i++]);
        }

        while (j < right.length) {
            addInterval(result, right[j++]);
        }

        return result.toArray(new int[result.size()][]);
    }

    private void addInterval(List<int[]> result, int[] interval) {
        if (result.isEmpty() || result.get(result.size() - 1)[1] < interval[0]) {
            result.add(interval);
        } else {
            result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], interval[1]);
        }
    }
}
```

**时间复杂度**：$O(n \log n)$，排序和分治的时间复杂度。

**空间复杂度**：$O(n)$，递归调用栈和临时数组的空间。

### 方法五：双指针滑动窗口

使用双指针维护当前合并区间的范围。

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if (intervals.length <= 1) {
            return intervals;
        }

        // 按起始位置排序
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);

        List<int[]> result = new ArrayList<>();
        int start = intervals[0][0];
        int end = intervals[0][1];

        for (int i = 1; i < intervals.length; i++) {
            // 如果当前区间与正在构建的区间重叠
            if (intervals[i][0] <= end) {
                // 扩展区间
                end = Math.max(end, intervals[i][1]);
            } else {
                // 不重叠，保存当前区间，开始新区间
                result.add(new int[]{start, end});
                start = intervals[i][0];
                end = intervals[i][1];
            }
        }

        // 添加最后一个区间
        result.add(new int[]{start, end});

        return result.toArray(new int[result.size()][]);
    }
}
```

**时间复杂度**：$O(n \log n)$，主要是排序的时间复杂度。

**空间复杂度**：$O(n)$，存储结果的空间。

**推荐使用方法一（排序+遍历合并）**，它思路最清晰，代码最简洁，也是最常用的解法。

**核心思想**：

1. 首先按区间起始位置排序，这样重叠的区间必然相邻
2. 遍历排序后的区间数组，判断当前区间是否与前一个区间重叠
3. 如果重叠就合并（更新结束位置），如果不重叠就添加新区间
4. 重叠判断条件：前一个区间的结束位置 >= 当前区间的开始位置
