---
title: "53-最大子数组和"
date: 2025-02-28 21:17:31 +0800
categories: [LEETCODE, HOT100]
tags: [普通数组, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/maximum-subarray/) \| 难度: 中等

## 问题描述:

给你一个整数数组 `nums`，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**是数组中的一个连续部分。

**示例 1：**

```java
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大, 为 6
```

**示例 2：**

```java
输入: nums = [1]
输出: 1
```

**示例 3：**

```java
输入: nums = [5,4,-1,7,8]
输出: 23
```

**进阶：**如果你已经实现复杂度为 $O(n)$ 的解法，尝试使用更为精妙的**分治法**求解。

## 解题思路:

这道题要求找到数组中和最大的连续子数组，并返回其和。这是经典的"最大子序和"问题，可以用多种方法解决。

### 方法一：动态规划（Kadane 算法）- 推荐

核心思想是遍历数组时，对于每个位置，决定是将当前元素加入之前的子数组，还是从当前元素重新开始一个新的子数组。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int maxSum = nums[0]; // 记录全局最大值
        int currentSum = nums[0]; // 记录以当前位置结尾的最大子数组和

        for (int i = 1; i < nums.length; i++) {
            // 选择：要么加入之前的子数组，要么重新开始
            currentSum = Math.max(nums[i], currentSum + nums[i]);
            // 更新全局最大值
            maxSum = Math.max(maxSum, currentSum);
        }

        return maxSum;
    }
}
```

**时间复杂度**：$O(n)$，其中 $n$ 是数组长度。只需要一次遍历。

**空间复杂度**：$O(1)$，只使用了常数额外空间。

### 方法二：分治法

将数组分为左右两部分，最大子数组要么在左半部分，要么在右半部分，要么跨越中点。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        return maxSubArrayHelper(nums, 0, nums.length - 1);
    }

    private int maxSubArrayHelper(int[] nums, int left, int right) {
        if (left == right) {
            return nums[left];
        }

        int mid = left + (right - left) / 2;

        // 左半部分的最大子数组
        int leftMax = maxSubArrayHelper(nums, left, mid);
        // 右半部分的最大子数组
        int rightMax = maxSubArrayHelper(nums, mid + 1, right);
        // 跨越中点的最大子数组
        int crossMax = maxCrossingSum(nums, left, mid, right);

        return Math.max(Math.max(leftMax, rightMax), crossMax);
    }

    private int maxCrossingSum(int[] nums, int left, int mid, int right) {
        // 从中点向左的最大子数组和
        int leftSum = Integer.MIN_VALUE;
        int sum = 0;
        for (int i = mid; i >= left; i--) {
            sum += nums[i];
            leftSum = Math.max(leftSum, sum);
        }

        // 从中点+1向右的最大子数组和
        int rightSum = Integer.MIN_VALUE;
        sum = 0;
        for (int i = mid + 1; i <= right; i++) {
            sum += nums[i];
            rightSum = Math.max(rightSum, sum);
        }

        return leftSum + rightSum;
    }
}
```

**时间复杂度**：$O(n \log n)$，分治的时间复杂度。

**空间复杂度**：$O(\log n)$，递归调用栈的深度。

### 方法三：前缀和优化

通过计算前缀和，将问题转化为找到两个前缀和的最大差值。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int[] prefixSum = new int[n + 1];

        // 计算前缀和
        for (int i = 0; i < n; i++) {
            prefixSum[i + 1] = prefixSum[i] + nums[i];
        }

        int maxSum = Integer.MIN_VALUE;
        int minPrefix = 0; // 记录到目前为止的最小前缀和

        for (int i = 1; i <= n; i++) {
            // 以当前位置结尾的最大子数组和 = 当前前缀和 - 之前的最小前缀和
            maxSum = Math.max(maxSum, prefixSum[i] - minPrefix);
            // 更新最小前缀和
            minPrefix = Math.min(minPrefix, prefixSum[i]);
        }

        return maxSum;
    }
}
```

**时间复杂度**：$O(n)$，需要两次遍历。

**空间复杂度**：$O(n)$，需要额外的前缀和数组。

### 方法四：暴力解法

枚举所有可能的子数组，计算它们的和并找出最大值。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int maxSum = Integer.MIN_VALUE;

        for (int i = 0; i < nums.length; i++) {
            int currentSum = 0;
            for (int j = i; j < nums.length; j++) {
                currentSum += nums[j];
                maxSum = Math.max(maxSum, currentSum);
            }
        }

        return maxSum;
    }
}
```

**时间复杂度**：$O(n^2)$，需要两重循环。

**空间复杂度**：$O(1)$，只使用了常数额外空间。

### 方法五：贪心算法

当累计和为负数时，重新开始计算，因为负数只会让后续的和变小。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int maxSum = nums[0];
        int currentSum = 0;

        for (int num : nums) {
            // 如果当前累计和为负，重新开始
            if (currentSum < 0) {
                currentSum = num;
            } else {
                currentSum += num;
            }
            maxSum = Math.max(maxSum, currentSum);
        }

        return maxSum;
    }
}
```

**时间复杂度**：$O(n)$，只需要一次遍历。

**空间复杂度**：$O(1)$，只使用了常数额外空间。

**推荐使用方法一（动态规划）**，它是解决此类问题的经典算法，思路清晰，时间和空间复杂度都很优秀。

**核心思想**：

1. 对于每个位置，维护以该位置结尾的最大子数组和
2. 状态转移：要么将当前元素加入之前的子数组，要么从当前元素重新开始
3. 同时记录全局最大值
