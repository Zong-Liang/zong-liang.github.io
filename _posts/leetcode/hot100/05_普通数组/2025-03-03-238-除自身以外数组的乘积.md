---
title: "238-除自身以外数组的乘积"
date: 2025-03-03 21:19:16 +0800
categories: [LEETCODE, HOT100]
tags: [普通数组, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/product-of-array-except-self/) \| 难度: 中等

## 问题描述:

给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。

题目数据**保证**数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位**整数范围内。

请**不要使用除法，**且在 $O(n)$ 时间复杂度内完成此题。

**示例 1：**

```java
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**示例 2：**

```java
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

**进阶：** 你可以在 $O(1)$ 的额外空间复杂度内完成这个题目吗？（出于对空间复杂度分析的目的，输出数组**不被视为**额外空间。）

## 解题思路

看这道题，这是要求除自身以外数组的乘积，不能使用除法，且要在常数空间内完成。这道题的核心思想是将每个位置的结果分解为两部分：该位置左边所有数的乘积 × 该位置右边所有数的乘积。

### 方法一：两次遍历（最优解）

先从左到右计算每个位置左边所有数的乘积，再从右到左计算右边所有数的乘积并直接更新结果。

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] answer = new int[n];

        // 第一次遍历：计算每个位置左边所有数的乘积
        answer[0] = 1; // 第一个元素左边没有数，乘积为1
        for (int i = 1; i < n; i++) {
            answer[i] = answer[i - 1] * nums[i - 1];
        }

        // 第二次遍历：从右往左，用一个变量记录右边的乘积
        int rightProduct = 1;
        for (int i = n - 1; i >= 0; i--) {
            answer[i] *= rightProduct; // 左边乘积 × 右边乘积
            rightProduct *= nums[i];   // 更新右边乘积
        }

        return answer;
    }
}
```

**时间复杂度**：$O(n)$，只需要两次遍历数组。

**空间复杂度**：$O(1)$，不算返回数组的话，只使用了常数额外空间。

### 方法二：左右乘积数组（便于理解）

先分别计算左边和右边的乘积数组，再相乘得到结果。

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] leftProducts = new int[n];
        int[] rightProducts = new int[n];
        int[] answer = new int[n];

        // 计算左边乘积数组
        leftProducts[0] = 1;
        for (int i = 1; i < n; i++) {
            leftProducts[i] = leftProducts[i - 1] * nums[i - 1];
        }

        // 计算右边乘积数组
        rightProducts[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            rightProducts[i] = rightProducts[i + 1] * nums[i + 1];
        }

        // 相乘得到结果
        for (int i = 0; i < n; i++) {
            answer[i] = leftProducts[i] * rightProducts[i];
        }

        return answer;
    }
}
```

**时间复杂度**：$O(n)$，需要三次遍历数组。

**空间复杂度**：$O(n)$，需要额外的左右乘积数组。

**推荐使用方法一（两次遍历）**，它满足题目要求的常数空间复杂度，效率最高。

**核心思想**：

1. 对于位置 i，结果 = 左边所有数乘积 × 右边所有数乘积
2. 先从左到右遍历，在结果数组中存储每个位置左边的乘积
3. 再从右到左遍历，用一个变量维护右边的乘积，直接与结果数组相乘
4. 这样避免了使用除法，也满足了空间复杂度要求

**示例 walkthrough**：

- nums = [1,2,3,4]
- 第一次遍历后：answer = [1,1,2,6] (每个位置左边的乘积)
- 第二次遍历：rightProduct 依次为 1,4,12,24，最终 answer = [24,12,8,6]
