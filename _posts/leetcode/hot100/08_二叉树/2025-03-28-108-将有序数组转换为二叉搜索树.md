---
title: "108-将有序数组转换为二叉搜索树"
date: 2025-03-28 21:29:47 +0800
categories: [LEETCODE, HOT100]
tags: [二叉树, 简单]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/) \| 难度: 简单

## 问题描述:

给你一个整数数组 `nums`，其中元素已经按**升序**排列，请你将其转换为一棵平衡二叉搜索树。

**示例 1：**

![img](../assets/img/posts/leetcode/p108_0.jpg)

```java
输入: nums = [-10,-3,0,5,9]
输出: [0,-3,9,-10,null,5]
解释: [0,-10,5,null,-3,null,9] 也将被视为正确答案:
```

![img](../assets/img/posts/leetcode/p108_1.jpg)

**示例 2：**

![img](../assets/img/posts/leetcode/p108_2.jpg)

```java
输入: nums = [1,3]
输出: [3,1]
解释: [1,null,3] 和 [3,1] 都是高度平衡二叉搜索树
```

**提示：**`nums` 按**严格递增**顺序排列。

## 解题思路：

这是一道关于将有序数组转换为平衡二叉搜索树的问题。需要利用数组已排序的特性，构建一棵高度平衡的 BST。

### 方法一：递归分治法（推荐）

核心思想是利用二分法的思想：

- 有序数组的中间元素作为根节点可以保证左右子树节点数量大致相等
- 左半部分构成左子树，右半部分构成右子树
- 递归地对左右子数组应用相同的策略

**算法步骤：**

1. 选择数组中间元素作为根节点
2. 递归地用左半部分数组构造左子树
3. 递归地用右半部分数组构造右子树
4. 返回构造好的根节点

```java
// 定义二叉树节点
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums == null || nums.length == 0) {
            return null;
        }

        return buildBST(nums, 0, nums.length - 1);
    }

    private TreeNode buildBST(int[] nums, int left, int right) {
        // 递归终止条件
        if (left > right) {
            return null;
        }

        // 选择中间位置作为根节点（偏左选择，保证平衡）
        int mid = left + (right - left) / 2;
        TreeNode root = new TreeNode(nums[mid]);

        // 递归构造左子树和右子树
        root.left = buildBST(nums, left, mid - 1);
        root.right = buildBST(nums, mid + 1, right);

        return root;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是数组长度，每个元素被访问一次。

**空间复杂度：** $O(\log n)$，递归调用栈的深度，树的高度为 $O(\log n)$。

### 方法二：迭代法（队列实现）

使用队列来模拟递归过程，每次处理一个区间范围。

**算法步骤：**

1. 创建队列存储待处理的节点和对应的数组区间
2. 从根节点开始，逐层构建树
3. 对每个节点，计算其对应区间的中点，创建左右子节点
4. 将左右子节点及其区间加入队列继续处理

```java
import java.util.*;

class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums == null || nums.length == 0) {
            return null;
        }

        // 创建根节点
        int mid = nums.length / 2;
        TreeNode root = new TreeNode(nums[mid]);

        // 使用队列存储待处理的节点和对应的区间信息
        Queue<Object[]> queue = new LinkedList<>();
        queue.offer(new Object[]{root, 0, nums.length - 1});

        while (!queue.isEmpty()) {
            Object[] current = queue.poll();
            TreeNode node = (TreeNode) current[0];
            int left = (Integer) current[1];
            int right = (Integer) current[2];

            int midIndex = left + (right - left) / 2;

            // 处理左子树
            if (left <= midIndex - 1) {
                int leftMid = left + (midIndex - 1 - left) / 2;
                node.left = new TreeNode(nums[leftMid]);
                queue.offer(new Object[]{node.left, left, midIndex - 1});
            }

            // 处理右子树
            if (midIndex + 1 <= right) {
                int rightMid = (midIndex + 1) + (right - (midIndex + 1)) / 2;
                node.right = new TreeNode(nums[rightMid]);
                queue.offer(new Object[]{node.right, midIndex + 1, right});
            }
        }

        return root;
    }
}
```

**时间复杂度：** $O(n)$，每个节点被处理一次。

**空间复杂度：** $O(n)$，队列最多存储 $O(n)$ 个元素。

### 方法三：随机化中点选择

为了让构造的树更加随机化，可以在选择中点时加入随机性。

```java
import java.util.Random;

class Solution {
    private Random random = new Random();

    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums == null || nums.length == 0) {
            return null;
        }

        return buildBST(nums, 0, nums.length - 1);
    }

    private TreeNode buildBST(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }

        // 随机选择中间位置（左中位数或右中位数）
        int mid = left + (right - left) / 2;
        if ((right - left) % 2 == 1) {
            mid += random.nextInt(2); // 随机选择左中位数或右中位数
        }

        TreeNode root = new TreeNode(nums[mid]);
        root.left = buildBST(nums, left, mid - 1);
        root.right = buildBST(nums, mid + 1, right);

        return root;
    }
}
```

**时间复杂度：** $O(n)$，每个元素被访问一次。

**空间复杂度：** $O(\log n)$，递归调用栈空间。

### 方法四：选择不同的中点策略

可以选择总是选择左中位数或右中位数来构建不同形态的平衡 BST。

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums == null || nums.length == 0) {
            return null;
        }

        return buildBST(nums, 0, nums.length - 1);
    }

    private TreeNode buildBST(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }

        // 总是选择右中位数
        int mid = left + (right - left + 1) / 2;

        TreeNode root = new TreeNode(nums[mid]);
        root.left = buildBST(nums, left, mid - 1);
        root.right = buildBST(nums, mid + 1, right);

        return root;
    }
}
```

**推荐使用方法一（递归分治法）**，因为它代码简洁清晰，时间和空间复杂度都最优，完美体现了分治思想。这种方法构造的 BST 保证是高度平衡的，且符合 BST 的性质（左子树所有节点值小于根节点，右子树所有节点值大于根节点）。
