---
title: "124-二叉树中的最大路径和"
date: 2025-03-30 21:31:08 +0800
categories: [LEETCODE, HOT100]
tags: [二叉树, 困难]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/binary-tree-maximum-path-sum/) \| 难度: 困难

## 问题描述:

二叉树中的**路径**被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中**至多出现一次**。该路径**至少包含一个**节点，且不一定经过根节点。

**路径和**是路径中各节点值的总和。

给你一个二叉树的根节点 `root`，返回其**最大路径和**。

**示例 1：**

![img](../assets/img/posts/leetcode/p124_0.jpg)

```java
输入: root = [1,2,3]
输出: 6
解释: 最优路径是 2 -> 1 -> 3, 路径和为 2 + 1 + 3 = 6
```

**示例 2：**

![img](../assets/img/posts/leetcode/p124_1.jpg)

```java
输入: root = [-10,9,20,null,null,15,7]
输出: 42
解释: 最优路径是 15 -> 20 -> 7, 路径和为 15 + 20 + 7 = 42
```

## 解题思路：

这是一道关于求二叉树中最大路径和的问题。路径可以从任意节点开始，到任意节点结束，但必须沿着父子节点的连接。

### 方法一：递归法（推荐）

核心思想是使用递归，对于每个节点，计算以该节点为起点向下的最大路径和，同时更新全局最大路径和。

关键理解：

- 对于每个节点，路径可能的情况：
  1. 只包含当前节点
  2. 当前节点 + 左子树路径
  3. 当前节点 + 右子树路径
  4. 当前节点 + 左子树路径 + 右子树路径（这种情况不能向上延伸）

**算法步骤：**

1. 定义递归函数，返回以当前节点为起点向下的最大路径和
2. 对于每个节点，计算左右子树的最大贡献值
3. 更新全局最大路径和（考虑通过当前节点的路径）
4. 返回当前节点能向上提供的最大贡献值

```java
// 定义二叉树节点
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    private int maxSum = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        maxGain(root);
        return maxSum;
    }

    /**
     * 计算以node为起点向下的最大路径和
     * @param node 当前节点
     * @return 以当前节点为起点向下的最大路径和
     */
    private int maxGain(TreeNode node) {
        if (node == null) {
            return 0;
        }

        // 递归计算左右子树的最大贡献值
        // 如果贡献值为负，则不选择该子树（用0代替）
        int leftGain = Math.max(maxGain(node.left), 0);
        int rightGain = Math.max(maxGain(node.right), 0);

        // 以当前节点为根的最大路径和（左子树 + 当前节点 + 右子树）
        int currentMaxPath = node.val + leftGain + rightGain;

        // 更新全局最大路径和
        maxSum = Math.max(maxSum, currentMaxPath);

        // 返回当前节点能向上提供的最大贡献值
        // 只能选择左子树或右子树中的一个（因为路径不能分叉）
        return node.val + Math.max(leftGain, rightGain);
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是二叉树中的节点数量，每个节点被访问一次。

**空间复杂度：** $O(h)$，其中 $h$ 是二叉树的高度，递归调用栈的深度。

### 方法二：后序遍历迭代实现

使用栈来模拟递归过程，通过后序遍历来处理每个节点。

```java
import java.util.*;

class Solution {
    public int maxPathSum(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int maxSum = Integer.MIN_VALUE;
        Map<TreeNode, Integer> gainMap = new HashMap<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode prev = null;

        while (root != null || !stack.isEmpty()) {
            // 向左子树深入
            if (root != null) {
                stack.push(root);
                root = root.left;
            } else {
                TreeNode peekNode = stack.peek();
                // 如果右子树存在且未被访问
                if (peekNode.right != null && prev != peekNode.right) {
                    root = peekNode.right;
                } else {
                    // 处理当前节点
                    int leftGain = peekNode.left != null ?
                        Math.max(gainMap.get(peekNode.left), 0) : 0;
                    int rightGain = peekNode.right != null ?
                        Math.max(gainMap.get(peekNode.right), 0) : 0;

                    // 更新最大路径和
                    int currentMaxPath = peekNode.val + leftGain + rightGain;
                    maxSum = Math.max(maxSum, currentMaxPath);

                    // 存储当前节点的最大贡献值
                    int currentGain = peekNode.val + Math.max(leftGain, rightGain);
                    gainMap.put(peekNode, currentGain);

                    prev = stack.pop();
                }
            }
        }

        return maxSum;
    }
}
```

**时间复杂度：** $O(n)$，每个节点被访问一次。

**空间复杂度：** $O(n)$，栈和哈希表的空间。

### 方法三：分治思想的明确实现

将问题分解为：经过根节点的最大路径和 vs 不经过根节点的最大路径和。

```java
class Solution {
    public int maxPathSum(TreeNode root) {
        Result result = maxPathSumHelper(root);
        return result.maxPathSum;
    }

    private Result maxPathSumHelper(TreeNode node) {
        if (node == null) {
            return new Result(Integer.MIN_VALUE, 0);
        }

        Result leftResult = maxPathSumHelper(node.left);
        Result rightResult = maxPathSumHelper(node.right);

        // 以当前节点为起点的最大路径和
        int maxSinglePath = node.val + Math.max(0, Math.max(leftResult.maxSinglePath, rightResult.maxSinglePath));

        // 经过当前节点的最大路径和
        int maxPathThroughRoot = node.val +
            Math.max(0, leftResult.maxSinglePath) +
            Math.max(0, rightResult.maxSinglePath);

        // 当前子树的最大路径和
        int maxPathSum = Math.max(maxPathThroughRoot,
            Math.max(leftResult.maxPathSum, rightResult.maxPathSum));

        return new Result(maxPathSum, maxSinglePath);
    }

    // 辅助类存储结果
    class Result {
        int maxPathSum;      // 子树中的最大路径和
        int maxSinglePath;   // 以根节点为起点的最大路径和

        Result(int maxPathSum, int maxSinglePath) {
            this.maxPathSum = maxPathSum;
            this.maxSinglePath = maxSinglePath;
        }
    }
}
```

**时间复杂度：** $O(n)$，每个节点被访问一次。

**空间复杂度：** $O(h)$，递归调用栈的深度。

**推荐使用方法一（递归法）**，因为它代码简洁、思路清晰、效率最高。关键是要理解路径的概念和递归函数的返回值含义：每个节点返回的是以该节点为起点向下延伸的最大路径和，而全局最大路径和则考虑了所有可能通过该节点的路径（包括左子树+当前节点+右子树的情况）。
