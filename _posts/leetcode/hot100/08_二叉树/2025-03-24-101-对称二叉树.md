---
title: "101-对称二叉树"
date: 2025-03-24 21:28:05 +0800
categories: [LEETCODE, HOT100]
tags: [二叉树, 简单]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/symmetric-tree/) \| 难度: 简单

## 问题描述:

给你一个二叉树的根节点 `root`， 检查它是否轴对称。

**示例 1：**

![img](../assets/img/posts/leetcode/p101_0.png)

```java
输入: root = [1,2,2,3,4,4,3]
输出: true
```

**示例 2：**

![img](../assets/img/posts/leetcode/p101_1.png)

```java
输入: root = [1,2,2,null,3,null,3]
输出: false
```

**进阶：**你可以运用递归和迭代两种方法解决这个问题吗？

## 解题思路：

这是一道关于判断二叉树是否对称的问题。需要检查一个二叉树是否沿着根节点的中轴线左右对称。

### 方法一：递归法（推荐）

核心思想是比较左子树和右子树是否镜像对称。两个树镜像对称的条件是：

- 它们的根节点值相同
- 第一个树的左子树和第二个树的右子树镜像对称
- 第一个树的右子树和第二个树的左子树镜像对称

**算法步骤：**

1. 如果根节点为空，返回 true（空树是对称的）
2. 调用辅助函数检查左右子树是否镜像对称
3. 辅助函数逻辑：
   - 如果两个节点都为空，返回 true
   - 如果只有一个节点为空，返回 false
   - 如果两个节点值不相等，返回 false
   - 递归检查 left.left 与 right.right，left.right 与 right.left

```java
// 定义二叉树节点
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }

        return isMirror(root.left, root.right);
    }

    private boolean isMirror(TreeNode left, TreeNode right) {
        // 两个节点都为空，镜像对称
        if (left == null && right == null) {
            return true;
        }

        // 只有一个节点为空，不对称
        if (left == null || right == null) {
            return false;
        }

        // 节点值不相等，不对称
        if (left.val != right.val) {
            return false;
        }

        // 递归检查：左子树的左孩子与右子树的右孩子，左子树的右孩子与右子树的左孩子
        return isMirror(left.left, right.right) && isMirror(left.right, right.left);
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是二叉树中的节点数量，每个节点被访问一次。

**空间复杂度：** $O(h)$，其中 $h$ 是二叉树的高度，主要是递归调用栈的空间。

### 方法二：迭代法（队列实现）

使用队列来模拟递归过程，每次将需要比较的两个节点入队。

**算法步骤：**

1. 如果根节点为空，返回 true
2. 创建队列，将根节点的左右子节点入队
3. 循环处理队列中的节点对：
   - 取出两个节点进行比较
   - 如果都为空，继续下一对
   - 如果只有一个为空或值不相等，返回 false
   - 按镜像顺序将子节点入队

```java
import java.util.*;

class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root.left);
        queue.offer(root.right);

        while (!queue.isEmpty()) {
            TreeNode left = queue.poll();
            TreeNode right = queue.poll();

            // 两个节点都为空，继续检查下一对
            if (left == null && right == null) {
                continue;
            }

            // 只有一个节点为空或值不相等，不对称
            if (left == null || right == null || left.val != right.val) {
                return false;
            }

            // 按镜像顺序将子节点加入队列
            queue.offer(left.left);
            queue.offer(right.right);
            queue.offer(left.right);
            queue.offer(right.left);
        }

        return true;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是二叉树中的节点数量。

**空间复杂度：** $O(w)$，其中 $w$ 是二叉树的最大宽度，队列中最多存储一层的节点。

### 方法三：中序遍历比较法

通过比较正常中序遍历和镜像中序遍历的结果来判断是否对称。

```java
import java.util.*;

class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }

        List<Integer> leftInorder = new ArrayList<>();
        List<Integer> rightInorder = new ArrayList<>();

        inorderLeft(root.left, leftInorder);
        inorderRight(root.right, rightInorder);

        return leftInorder.equals(rightInorder);
    }

    // 正常中序遍历：左-根-右
    private void inorderLeft(TreeNode node, List<Integer> result) {
        if (node == null) {
            result.add(null); // 用null标记空节点
            return;
        }

        inorderLeft(node.left, result);
        result.add(node.val);
        inorderLeft(node.right, result);
    }

    // 镜像中序遍历：右-根-左
    private void inorderRight(TreeNode node, List<Integer> result) {
        if (node == null) {
            result.add(null); // 用null标记空节点
            return;
        }

        inorderRight(node.right, result);
        result.add(node.val);
        inorderRight(node.left, result);
    }
}
```

**时间复杂度：** $O(n)$，需要遍历整个树两次。

**空间复杂度：** $O(n)$，存储遍历结果。

**推荐使用方法一（递归法）**，因为它思路清晰、代码简洁，且空间复杂度最优；如果不允许使用递归或担心栈溢出，可以考虑方法二（迭代法）。
