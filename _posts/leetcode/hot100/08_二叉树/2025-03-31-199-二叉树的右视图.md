---
title: "199-二叉树的右视图"
date: 2025-03-31 21:31:25 +0800
categories: [LEETCODE, HOT100]
tags: [二叉树, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/binary-tree-right-side-view/) \| 难度: 中等

## 问题描述:

给定一个二叉树的**根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

**示例 1：**

```java
输入: root = [1,2,3,null,5,null,4]
输出: [1,3,4]
```

**解释:**

![img](../assets/img/posts/leetcode/p119_0.png)

**示例 2：**

```java
输入: root = [1,2,3,4,null,null,null,5]
输出: [1,3,4,5]
```

**解释:**

![img](../assets/img/posts/leetcode/p119_1.png)

**示例 3：**

```java
输入: root = [1,null,3]
输出: [1,3]
```

**示例 4：**

```java
输入: root = []
输出: []
```

## 解题思路：

这是一道关于二叉树右视图的问题。需要从右侧观察二叉树，返回能看到的所有节点值。

### 方法一：层序遍历（推荐）

核心思想是使用 BFS 层序遍历，每层只保留最右边的节点。

**算法步骤：**

1. 使用队列进行层序遍历
2. 对每一层，记录该层的节点数量
3. 遍历该层所有节点，只将最后一个节点（最右边）加入结果
4. 继续处理下一层，直到遍历完整棵树

```java
import java.util.*;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) {
            return result;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();

            // 遍历当前层的所有节点
            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();

                // 如果是当前层的最后一个节点（最右边），加入结果
                if (i == levelSize - 1) {
                    result.add(node.val);
                }

                // 将下一层的节点加入队列
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
        }

        return result;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是二叉树的节点数。每个节点都会被访问一次。

**空间复杂度：** $O(w)$，其中 $w$ 是二叉树的最大宽度，队列中最多存储一层的所有节点。

### 方法二：深度优先遍历（DFS）

使用先序遍历的变种，优先遍历右子树，确保每层最先访问到的是最右边的节点。

**算法步骤：**

1. 使用递归进行深度优先遍历
2. 遍历顺序：根节点 → 右子树 → 左子树
3. 记录当前遍历的深度
4. 如果当前深度首次出现，说明这是该层最右边的节点

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        dfs(root, 0, result);
        return result;
    }

    private void dfs(TreeNode node, int depth, List<Integer> result) {
        if (node == null) {
            return;
        }

        // 如果当前深度首次出现，说明这是该层最右边的节点
        if (depth == result.size()) {
            result.add(node.val);
        }

        // 先遍历右子树，再遍历左子树
        dfs(node.right, depth + 1, result);
        dfs(node.left, depth + 1, result);
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是二叉树的节点数。每个节点都会被访问一次。

**空间复杂度：** $O(h)$，其中 $h$ 是二叉树的高度，递归调用栈的最大深度。

### 方法三：反向层序遍历

从右到左遍历每一层，每层的第一个节点就是右视图能看到的节点。

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) {
            return result;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            boolean isFirst = true;

            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();

                // 第一个节点就是最右边的节点
                if (isFirst) {
                    result.add(node.val);
                    isFirst = false;
                }

                // 先加右子树，再加左子树，保证右子树先被处理
                if (node.right != null) {
                    queue.offer(node.right);
                }
                if (node.left != null) {
                    queue.offer(node.left);
                }
            }
        }

        return result;
    }
}
```

**推荐使用方法一（层序遍历）**，因为它思路清晰，易于理解和调试。方法二（DFS）在某些情况下空间效率更高，但需要注意遍历顺序。
