---
title: "437-路径总和III"
date: 2025-04-04 21:33:07 +0800
categories: [LEETCODE, HOT100]
tags: [二叉树, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/path-sum-iii/) \| 难度: 中等

## 问题描述:

给定一个二叉树的根节点 `root`，和一个整数 `targetSum`，求该二叉树里节点值之和等于 `targetSum` 的**路径**的数目。

**路径**不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

**示例 1：**

![img](../assets/img/posts/leetcode/p437_0.jpg)

```java
输入: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出: 3
解释: 和等于 8 的路径有 3 条, 如图所示
```

**示例 2：**

```java
输入: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出: 3
```

## 解题思路：

这是一道关于二叉树路径总和的问题。需要找到二叉树中所有路径节点值之和等于目标值的路径数量，路径可以从任意节点开始和结束。

### 方法一：前缀和 + 哈希表（推荐）

核心思想是利用前缀和的思想，在遍历过程中记录从根节点到当前节点的路径和，并使用哈希表记录每个前缀和出现的次数。

**算法步骤：**

1. 使用哈希表记录前缀和出现的次数，初始化`prefixSum[0] = 1`
2. 深度优先遍历二叉树，维护当前路径的前缀和
3. 对于当前节点，检查`currentSum - targetSum`是否在哈希表中存在
4. 如果存在，说明有路径和等于 targetSum，累加到结果中
5. 更新哈希表，继续递归处理子节点
6. 回溯时需要恢复哈希表状态

```java
import java.util.*;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        // 前缀和映射，key为前缀和，value为出现次数
        Map<Long, Integer> prefixSumMap = new HashMap<>();
        // 初始化，前缀和为0的路径有1条（空路径）
        prefixSumMap.put(0L, 1);

        return dfs(root, 0L, targetSum, prefixSumMap);
    }

    private int dfs(TreeNode node, long currentSum, int targetSum,
                   Map<Long, Integer> prefixSumMap) {
        if (node == null) {
            return 0;
        }

        // 计算当前路径和
        currentSum += node.val;

        // 查找是否存在前缀和使得路径和等于targetSum
        // currentSum - prefixSum = targetSum
        // 即 prefixSum = currentSum - targetSum
        int pathCount = prefixSumMap.getOrDefault(currentSum - targetSum, 0);

        // 更新前缀和映射
        prefixSumMap.put(currentSum, prefixSumMap.getOrDefault(currentSum, 0) + 1);

        // 递归处理左右子树
        pathCount += dfs(node.left, currentSum, targetSum, prefixSumMap);
        pathCount += dfs(node.right, currentSum, targetSum, prefixSumMap);

        // 回溯：移除当前节点的前缀和
        prefixSumMap.put(currentSum, prefixSumMap.get(currentSum) - 1);

        return pathCount;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是二叉树的节点数。每个节点只访问一次。

**空间复杂度：** $O(n)$，哈希表最多存储 $n$ 个前缀和，递归栈深度为树的高度。

### 方法二：双重递归

对每个节点作为起点，计算以该节点开始的所有可能路径。

**算法步骤：**

1. 对每个节点调用辅助函数，计算以该节点为起点的路径数
2. 辅助函数递归计算从当前节点开始向下的所有路径
3. 对每个节点的左右子树递归调用主函数

```java
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return 0;
        }

        // 以当前节点为起点的路径数 + 左子树的路径数 + 右子树的路径数
        return pathSumFrom(root, targetSum) +
               pathSum(root.left, targetSum) +
               pathSum(root.right, targetSum);
    }

    // 计算以node为起点，目标和为targetSum的路径数
    private int pathSumFrom(TreeNode node, long targetSum) {
        if (node == null) {
            return 0;
        }

        int count = 0;
        // 如果当前节点值等于目标和，找到一条路径
        if (node.val == targetSum) {
            count = 1;
        }

        // 继续向下搜索
        count += pathSumFrom(node.left, targetSum - node.val);
        count += pathSumFrom(node.right, targetSum - node.val);

        return count;
    }
}
```

**时间复杂度：** $O(n^2)$，最坏情况下对每个节点都要遍历其子树。

**空间复杂度：** $O(h)$，其中 $h$ 是树的高度，递归调用栈的深度。

### 方法三：路径记录法

显式记录从根节点到当前节点的路径，然后检查所有子路径。

**算法步骤：**

1. 维护从根节点到当前节点的路径
2. 对于当前路径，检查所有以当前节点为终点的子路径
3. 统计和等于 targetSum 的子路径数量

```java
import java.util.*;

class Solution {
    private int result = 0;

    public int pathSum(TreeNode root, int targetSum) {
        List<Integer> path = new ArrayList<>();
        dfs(root, targetSum, path);
        return result;
    }

    private void dfs(TreeNode node, int targetSum, List<Integer> path) {
        if (node == null) {
            return;
        }

        // 将当前节点加入路径
        path.add(node.val);

        // 检查以当前节点为终点的所有子路径
        long sum = 0;
        for (int i = path.size() - 1; i >= 0; i--) {
            sum += path.get(i);
            if (sum == targetSum) {
                result++;
            }
        }

        // 递归处理子树
        dfs(node.left, targetSum, path);
        dfs(node.right, targetSum, path);

        // 回溯
        path.remove(path.size() - 1);
    }
}
```

**时间复杂度：** $O(n^2)$，对每个节点都要检查从该节点向上的所有路径。

**空间复杂度：** $O(h)$，路径长度最多为树的高度。

### 方法四：优化的路径记录

使用更高效的方式记录和计算路径和。

```java
class Solution {
    private int count = 0;

    public int pathSum(TreeNode root, int targetSum) {
        Map<Long, Integer> prefixSum = new HashMap<>();
        prefixSum.put(0L, 1);
        helper(root, 0L, targetSum, prefixSum);
        return count;
    }

    private void helper(TreeNode node, long currSum, int target,
                       Map<Long, Integer> prefixSum) {
        if (node == null) {
            return;
        }

        currSum += node.val;

        // 查找满足条件的路径
        count += prefixSum.getOrDefault(currSum - target, 0);

        // 更新前缀和
        prefixSum.put(currSum, prefixSum.getOrDefault(currSum, 0) + 1);

        // 递归处理子树
        helper(node.left, currSum, target, prefixSum);
        helper(node.right, currSum, target, prefixSum);

        // 回溯
        prefixSum.put(currSum, prefixSum.get(currSum) - 1);
    }
}
```

**推荐使用方法一（前缀和 + 哈希表）**，因为它时间复杂度最优，思路清晰，是解决此类问题的经典方法。通过前缀和技巧将问题转化为两数之差的查找问题，大大提高了效率。
