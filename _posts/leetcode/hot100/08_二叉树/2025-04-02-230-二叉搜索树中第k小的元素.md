---
title: "230-二叉搜索树中第k小的元素"
date: 2025-04-02 21:32:33 +0800
categories: [LEETCODE, HOT100]
tags: [二叉树, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/) \| 难度: 中等

## 问题描述:

给定一个二叉搜索树的根节点 `root`，和一个整数 `k`，请你设计一个算法查找其中第 `k` 小的元素（从 1 开始计数）。

**示例 1：**

![img](../assets/img/posts/leetcode/p230_0.jpg)

```
输入: root = [3,1,4,null,2], k = 1
输出: 1
```

**示例 2：**

![img](../assets/img/posts/leetcode/p230_1.jpg)

```
输入: root = [5,3,6,2,4,null,null,1], k = 3
输出: 3
```

**进阶：**如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 `k` 小的值，你将如何优化算法？

## 解题思路：

这是一道关于二叉搜索树中第 K 小元素的问题。需要在 BST 中找到第 K 小的节点值。

### 方法一：中序遍历（推荐）

核心思想是利用 BST 的性质：中序遍历 BST 得到的序列是有序的，因此第 K 个访问的节点就是第 K 小的元素。

**算法步骤：**

1. 对 BST 进行中序遍历（左 → 根 → 右）
2. 使用计数器记录已访问的节点数量
3. 当访问到第 K 个节点时，返回该节点的值
4. 可以提前终止遍历，无需遍历整棵树

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    private int count = 0;
    private int result = 0;

    public int kthSmallest(TreeNode root, int k) {
        inorder(root, k);
        return result;
    }

    private void inorder(TreeNode node, int k) {
        if (node == null || count >= k) {
            return;
        }

        // 遍历左子树
        inorder(node.left, k);

        // 处理当前节点
        count++;
        if (count == k) {
            result = node.val;
            return;
        }

        // 遍历右子树
        inorder(node.right, k);
    }
}
```

**时间复杂度：** $O(H + k)$，其中 $H$ 是树的高度。最坏情况下需要遍历到第 k 个节点。

**空间复杂度：** $O(H)$，递归调用栈的深度。

### 方法二：迭代中序遍历

使用栈模拟递归的中序遍历过程，避免使用类成员变量。

**算法步骤：**

1. 使用栈来模拟递归过程
2. 先将所有左子节点压入栈中
3. 弹出节点并计数，如果是第 K 个则返回
4. 处理右子树

```java
import java.util.*;

class Solution {
    public int kthSmallest(TreeNode root, int k) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode current = root;
        int count = 0;

        while (current != null || !stack.isEmpty()) {
            // 将所有左子节点压入栈
            while (current != null) {
                stack.push(current);
                current = current.left;
            }

            // 弹出节点并处理
            current = stack.pop();
            count++;

            // 如果是第K个节点，返回结果
            if (count == k) {
                return current.val;
            }

            // 转向右子树
            current = current.right;
        }

        return -1; // 不应该到达这里
    }
}
```

**时间复杂度：** $O(H + k)$，其中 $H$ 是树的高度。

**空间复杂度：** $O(H)$，栈的最大深度。

### 方法三：Morris 中序遍历

使用 Morris 遍历实现 O(1)空间复杂度的中序遍历。

**算法步骤：**

1. 使用 Morris 遍历，不需要额外的栈空间
2. 通过修改树的结构来实现遍历
3. 遍历完成后恢复树的原始结构

```java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        TreeNode current = root;
        int count = 0;

        while (current != null) {
            if (current.left == null) {
                // 处理当前节点
                count++;
                if (count == k) {
                    return current.val;
                }
                current = current.right;
            } else {
                // 找到中序遍历的前驱节点
                TreeNode predecessor = current.left;
                while (predecessor.right != null && predecessor.right != current) {
                    predecessor = predecessor.right;
                }

                if (predecessor.right == null) {
                    // 建立连接
                    predecessor.right = current;
                    current = current.left;
                } else {
                    // 恢复树结构并处理当前节点
                    predecessor.right = null;
                    count++;
                    if (count == k) {
                        return current.val;
                    }
                    current = current.right;
                }
            }
        }

        return -1; // 不应该到达这里
    }
}
```

**时间复杂度：** $O(H + k)$，其中 $H$ 是树的高度。

**空间复杂度：** $O(1)$，不使用额外的栈空间。

### 方法四：收集所有元素后排序

将所有节点值收集到列表中，然后返回第 K 小的元素。

```java
import java.util.*;

class Solution {
    public int kthSmallest(TreeNode root, int k) {
        List<Integer> values = new ArrayList<>();
        inorder(root, values);
        return values.get(k - 1);
    }

    private void inorder(TreeNode node, List<Integer> values) {
        if (node == null) {
            return;
        }

        inorder(node.left, values);
        values.add(node.val);
        inorder(node.right, values);
    }
}
```

**时间复杂度：** $O(n)$，需要遍历所有节点。

**空间复杂度：** $O(n)$，存储所有节点值。

**推荐使用方法一（递归中序遍历）**，因为它充分利用了 BST 的性质，思路清晰，代码简洁。如果对空间复杂度有严格要求，可以考虑方法三（Morris 遍历）。
