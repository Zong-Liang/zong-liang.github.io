---
title: "105-从前序和中序遍历序列构造二叉树"
date: 2025-03-27 21:29:16 +0800
categories: [LEETCODE, HOT100]
tags: [二叉树, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) \| 难度: 中等

## 问题描述:

给定两个整数数组 `preorder` 和 `inorder`，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

**示例 1：**

![img](../assets/img/posts/leetcode/p105_0.jpg)

```java
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

**示例 2：**

```java
输入: preorder = [-1], inorder = [-1]
输出: [-1]
```

**提示：**

- `preorder` 和 `inorder` 均**无重复**元素
- `inorder` 均出现在 `preorder`
- `preorder` **保证**为二叉树的前序遍历序列
- `inorder` **保证**为二叉树的中序遍历序列

## 解题思路：

这是一道关于从前序遍历和中序遍历序列构造二叉树的问题。需要利用前序遍历和中序遍历的特点来重建原始的二叉树结构。

### 方法一：递归分治法（推荐）

核心思想是利用前序遍历和中序遍历的性质：

- 前序遍历：根节点 → 左子树 → 右子树
- 中序遍历：左子树 → 根节点 → 右子树
- 前序遍历的第一个元素总是根节点
- 在中序遍历中找到根节点的位置，可以确定左右子树的范围

**算法步骤：**

1. 前序遍历的第一个元素作为根节点
2. 在中序遍历中找到根节点的位置，确定左右子树的节点数量
3. 根据左右子树的节点数量，在前序遍历中划分左右子树的范围
4. 递归构造左右子树
5. 返回构造好的根节点

```java
import java.util.*;

// 定义二叉树节点
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    private Map<Integer, Integer> inorderMap;
    private int preorderIndex;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        // 建立中序遍历值到索引的映射，便于快速查找根节点位置
        inorderMap = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            inorderMap.put(inorder[i], i);
        }

        preorderIndex = 0;
        return buildTreeHelper(preorder, 0, inorder.length - 1);
    }

    private TreeNode buildTreeHelper(int[] preorder, int inorderLeft, int inorderRight) {
        // 递归终止条件
        if (inorderLeft > inorderRight) {
            return null;
        }

        // 前序遍历的当前元素作为根节点
        int rootVal = preorder[preorderIndex++];
        TreeNode root = new TreeNode(rootVal);

        // 在中序遍历中找到根节点的位置
        int inorderRootIndex = inorderMap.get(rootVal);

        // 递归构造左子树（注意：必须先构造左子树，因为前序遍历是根-左-右的顺序）
        root.left = buildTreeHelper(preorder, inorderLeft, inorderRootIndex - 1);

        // 递归构造右子树
        root.right = buildTreeHelper(preorder, inorderRootIndex + 1, inorderRight);

        return root;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是节点数量。每个节点只被访问一次，哈希表查找为 $O(1)$。

**空间复杂度：** $O(n)$，哈希表存储空间和递归调用栈空间。

### 方法二：迭代法（栈实现）

使用栈来模拟递归过程，通过栈来维护当前路径上的节点。

**算法步骤：**

1. 使用栈存储前序遍历中尚未确定右子树的节点
2. 维护中序遍历的指针
3. 当栈顶元素与中序遍历当前元素相同时，说明该节点没有左子树或左子树已处理完
4. 继续匹配并出栈，直到不匹配，此时需要构造右子树

```java
import java.util.*;

class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (preorder.length == 0) {
            return null;
        }

        TreeNode root = new TreeNode(preorder[0]);
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);

        int inorderIndex = 0;

        for (int i = 1; i < preorder.length; i++) {
            int preorderVal = preorder[i];
            TreeNode node = stack.peek();

            // 如果栈顶节点不等于中序遍历当前元素，说明需要构造左子树
            if (node.val != inorder[inorderIndex]) {
                node.left = new TreeNode(preorderVal);
                stack.push(node.left);
            } else {
                // 栈顶节点等于中序遍历当前元素，需要处理右子树
                while (!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]) {
                    node = stack.pop();
                    inorderIndex++;
                }
                node.right = new TreeNode(preorderVal);
                stack.push(node.right);
            }
        }

        return root;
    }
}
```

**时间复杂度：** $O(n)$，每个节点被访问一次。

**空间复杂度：** $O(n)$，栈的空间复杂度。

### 方法三：递归法（数组切片版本）

直接对数组进行切片来划分子问题，代码更直观但效率稍低。

```java
import java.util.*;

class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (preorder.length == 0 || inorder.length == 0) {
            return null;
        }

        // 根节点是前序遍历的第一个元素
        TreeNode root = new TreeNode(preorder[0]);

        // 在中序遍历中找到根节点的位置
        int rootIndex = 0;
        for (int i = 0; i < inorder.length; i++) {
            if (inorder[i] == preorder[0]) {
                rootIndex = i;
                break;
            }
        }

        // 划分左右子树的前序和中序遍历数组
        int[] leftPreorder = Arrays.copyOfRange(preorder, 1, rootIndex + 1);
        int[] leftInorder = Arrays.copyOfRange(inorder, 0, rootIndex);
        int[] rightPreorder = Arrays.copyOfRange(preorder, rootIndex + 1, preorder.length);
        int[] rightInorder = Arrays.copyOfRange(inorder, rootIndex + 1, inorder.length);

        // 递归构造左右子树
        root.left = buildTree(leftPreorder, leftInorder);
        root.right = buildTree(rightPreorder, rightInorder);

        return root;
    }
}
```

**时间复杂度：** $O(n^2)$，每次需要线性查找根节点位置和数组切片操作。

**空间复杂度：** $O(n^2)$，数组切片产生的额外空间。

**推荐使用方法一（递归分治法配合哈希表）**，因为它时间复杂度最优，代码清晰易懂，是最经典的解法；如果需要避免递归或者有特殊要求，可以考虑方法二（迭代法）。
