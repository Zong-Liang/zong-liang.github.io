---
title: "102-二叉树的层序遍历"
date: 2025-03-25 21:28:24 +0800
categories: [LEETCODE, HOT100]
tags: [二叉树, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/binary-tree-level-order-traversal/) \| 难度: 中等

## 问题描述:

给你二叉树的根节点 `root`，返回其节点值的**层序遍历**。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

![img](../assets/img/posts/leetcode/p102_0.jpg)

```java
输入: root = [3,9,20,null,null,15,7]
输出: [[3],[9,20],[15,7]]
```

**示例 2：**

```java
输入: root = [1]
输出: [[1]]
```

**示例 3：**

```java
输入: root = []
输出: []
```

## 解题思路：

这是一道关于二叉树层序遍历的问题。需要从根节点开始，按层级顺序访问所有节点并返回每层的节点值。

### 方法一：广度优先搜索（BFS）- 队列实现（推荐）

核心思想是使用队列来实现层序遍历，每次处理一层的所有节点。

**算法步骤：**

1. 如果根节点为空，返回空列表
2. 创建队列存储待处理节点，将根节点入队
3. 当队列不为空时，循环处理：
   - 记录当前层的节点数量
   - 创建当前层的结果列表
   - 处理当前层的所有节点：取出节点值，将左右子节点入队
   - 将当前层结果添加到最终结果中

```java
import java.util.*;

// 定义二叉树节点
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();

        if (root == null) {
            return result;
        }

        // 使用队列存储节点
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            // 当前层的节点数量
            int levelSize = queue.size();
            List<Integer> currentLevel = new ArrayList<>();

            // 处理当前层的所有节点
            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();
                currentLevel.add(node.val);

                // 将下一层节点加入队列
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }

            // 将当前层结果添加到最终结果
            result.add(currentLevel);
        }

        return result;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是二叉树中的节点数量，每个节点被访问一次。

**空间复杂度：** $O(w)$，其中 $w$ 是二叉树的最大宽度（最多一层的节点数）。

### 方法二：深度优先搜索（DFS）- 递归实现

使用递归的方式，通过深度参数来确定当前节点属于哪一层。

**算法步骤：**

1. 使用递归函数，传入当前节点和深度参数
2. 如果结果列表的层数不够，创建新的层列表
3. 将当前节点值添加到对应层的列表中
4. 递归处理左右子树，深度加 1

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) {
            return result;
        }

        dfs(root, 0, result);
        return result;
    }

    private void dfs(TreeNode node, int level, List<List<Integer>> result) {
        if (node == null) {
            return;
        }

        // 如果当前层还没有列表，创建新的列表
        if (level >= result.size()) {
            result.add(new ArrayList<>());
        }

        // 将当前节点值添加到对应层
        result.get(level).add(node.val);

        // 递归处理左右子树
        dfs(node.left, level + 1, result);
        dfs(node.right, level + 1, result);
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是二叉树中的节点数量。

**空间复杂度：** $O(h)$，其中 $h$ 是二叉树的高度，主要是递归调用栈的空间。

**推荐使用方法一（BFS 队列实现）**，因为它更直观地体现了层序遍历的概念，且空间复杂度更稳定；如果需要节省空间或者偏好递归写法，可以考虑方法二（DFS 递归实现）。
