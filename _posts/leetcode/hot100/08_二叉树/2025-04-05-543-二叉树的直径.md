---
title: "543-二叉树的直径"
date: 2025-04-05 21:33:29 +0800
categories: [LEETCODE, HOT100]
tags: [二叉树, 简单]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/diameter-of-binary-tree/) \| 难度: 简单

## 问题描述:

给你一棵二叉树的根节点，返回该树的**直径**。

二叉树的**直径**是指树中任意两个节点之间最长路径的**长度**。这条路径可能经过也可能不经过根节点 `root`。

两节点之间路径的**长度**由它们之间边数表示。

**示例 1：**

![img](../assets/img/posts/leetcode/p543_0.jpg)

```java
输入: root = [1,2,3,4,5]
输出: 3
解释: 3, 取路径 [4,2,1,3] 或 [5,2,1,3] 的长度
```

**示例 2：**

```java
输入: root = [1,2]
输出: 1
```

## 解题思路：

这是一道关于二叉树直径的问题。需要找到二叉树中任意两个节点之间的最长路径长度。

### 方法一：深度优先搜索（推荐）

核心思想是对每个节点，计算通过该节点的最长路径，即左子树深度 + 右子树深度。同时维护全局最大值。

**算法步骤：**

1. 对每个节点，计算其左子树和右子树的最大深度
2. 通过当前节点的最长路径 = 左子树深度 + 右子树深度
3. 更新全局最大直径
4. 返回当前节点的最大深度（用于父节点计算）

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    private int maxDiameter = 0;

    public int diameterOfBinaryTree(TreeNode root) {
        maxDepth(root);
        return maxDiameter;
    }

    private int maxDepth(TreeNode node) {
        if (node == null) {
            return 0;
        }

        // 计算左右子树的最大深度
        int leftDepth = maxDepth(node.left);
        int rightDepth = maxDepth(node.right);

        // 更新通过当前节点的最长路径
        maxDiameter = Math.max(maxDiameter, leftDepth + rightDepth);

        // 返回当前节点的最大深度
        return Math.max(leftDepth, rightDepth) + 1;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是二叉树的节点数。每个节点只访问一次。

**空间复杂度：** $O(h)$，其中 $h$ 是二叉树的高度，递归调用栈的深度。

### 方法二：后序遍历优化

使用后序遍历的思想，在一次遍历中同时计算深度和直径。

**算法步骤：**

1. 使用后序遍历（左 → 右 → 根）
2. 对每个节点，先计算左右子树信息
3. 更新直径并返回当前子树的最大深度

```java
class Solution {
    private int diameter = 0;

    public int diameterOfBinaryTree(TreeNode root) {
        calculateDepth(root);
        return diameter;
    }

    private int calculateDepth(TreeNode node) {
        if (node == null) {
            return 0;
        }

        // 递归计算左右子树深度
        int left = calculateDepth(node.left);
        int right = calculateDepth(node.right);

        // 更新直径：当前节点为根的路径长度
        diameter = Math.max(diameter, left + right);

        // 返回以当前节点为根的子树的最大深度
        return 1 + Math.max(left, right);
    }
}
```

**时间复杂度：** $O(n)$，每个节点访问一次。

**空间复杂度：** $O(h)$，递归栈的深度。

### 方法三：分治法

将问题分解为子问题：每个节点的直径可能是左子树直径、右子树直径或通过根节点的路径。

**算法步骤：**

1. 对于每个节点，计算三个值：左子树直径、右子树直径、通过根的路径
2. 取三者的最大值作为当前子树的直径
3. 递归处理所有子树

```java
class Solution {
    public int diameterOfBinaryTree(TreeNode root) {
        if (root == null) {
            return 0;
        }

        // 三种情况的最大值
        int leftDiameter = diameterOfBinaryTree(root.left);
        int rightDiameter = diameterOfBinaryTree(root.right);
        int throughRoot = depth(root.left) + depth(root.right);

        return Math.max(Math.max(leftDiameter, rightDiameter), throughRoot);
    }

    private int depth(TreeNode node) {
        if (node == null) {
            return 0;
        }

        return 1 + Math.max(depth(node.left), depth(node.right));
    }
}
```

**时间复杂度：** $O(n^2)$，对每个节点都要计算深度。

**空间复杂度：** $O(h)$，递归调用栈的深度。

### 方法四：非递归实现

使用栈模拟递归过程，避免系统递归栈。

**算法步骤：**

1. 使用后序遍历的非递归实现
2. 维护节点到深度的映射
3. 在处理节点时更新直径

```java
import java.util.*;

class Solution {
    public int diameterOfBinaryTree(TreeNode root) {
        if (root == null) {
            return 0;
        }

        Stack<TreeNode> stack = new Stack<>();
        Map<TreeNode, Integer> depthMap = new HashMap<>();
        TreeNode current = root;
        TreeNode lastVisited = null;
        int maxDiameter = 0;

        while (current != null || !stack.isEmpty()) {
            if (current != null) {
                stack.push(current);
                current = current.left;
            } else {
                TreeNode peekNode = stack.peek();
                if (peekNode.right != null && lastVisited != peekNode.right) {
                    current = peekNode.right;
                } else {
                    // 处理当前节点
                    TreeNode node = stack.pop();

                    int leftDepth = depthMap.getOrDefault(node.left, 0);
                    int rightDepth = depthMap.getOrDefault(node.right, 0);

                    // 更新直径
                    maxDiameter = Math.max(maxDiameter, leftDepth + rightDepth);

                    // 记录当前节点的深度
                    depthMap.put(node, Math.max(leftDepth, rightDepth) + 1);

                    lastVisited = node;
                }
            }
        }

        return maxDiameter;
    }
}
```

**时间复杂度：** $O(n)$，每个节点访问一次。

**空间复杂度：** $O(n)$，栈和哈希表的空间。

### 方法五：返回多个值的优化

使用自定义类同时返回深度和直径信息。

```java
class Solution {
    class Result {
        int diameter;
        int depth;

        Result(int diameter, int depth) {
            this.diameter = diameter;
            this.depth = depth;
        }
    }

    public int diameterOfBinaryTree(TreeNode root) {
        return helper(root).diameter;
    }

    private Result helper(TreeNode node) {
        if (node == null) {
            return new Result(0, 0);
        }

        Result left = helper(node.left);
        Result right = helper(node.right);

        int currentDiameter = left.depth + right.depth;
        int maxDiameter = Math.max(currentDiameter, Math.max(left.diameter, right.diameter));
        int currentDepth = Math.max(left.depth, right.depth) + 1;

        return new Result(maxDiameter, currentDepth);
    }
}
```

**推荐使用方法一（深度优先搜索）**，因为它思路清晰，代码简洁，时间复杂度最优。通过一次遍历同时计算深度和更新直径，是解决此类问题的经典方法。
