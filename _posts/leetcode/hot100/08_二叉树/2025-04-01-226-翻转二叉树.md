---
title: "226-翻转二叉树"
date: 2025-04-01 21:31:47 +0800
categories: [LEETCODE, HOT100]
tags: [二叉树, 简单]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/invert-binary-tree/) \| 难度: 简单

## 问题描述:

给你一棵二叉树的根节点 `root`，翻转这棵二叉树，并返回其根节点。

**示例 1：**

![img](../assets/img/posts/leetcode/p226_0.jpg)

```
输入: root = [4,2,7,1,3,6,9]
输出: [4,7,2,9,6,3,1]
```

**示例 2：**

![img](../assets/img/posts/leetcode/p226_1.jpg)

```java
输入: root = [2,1,3]
输出: [2,3,1]
```

**示例 3：**

```java
输入: root = []
输出: []
```

## 解题思路：

这是一道关于二叉树翻转的问题。需要将二叉树进行左右翻转，即每个节点的左右子树互换位置。

### 方法一：递归翻转（推荐）

核心思想是递归地翻转每个节点的左右子树，然后交换当前节点的左右子节点。

**算法步骤：**

1. 处理边界情况：如果根节点为空，直接返回 null
2. 递归翻转左子树和右子树
3. 交换当前节点的左右子节点
4. 返回当前节点

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public TreeNode invertTree(TreeNode root) {
        // 边界情况：空节点直接返回
        if (root == null) {
            return null;
        }

        // 递归翻转左右子树
        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);

        // 交换当前节点的左右子节点
        root.left = right;
        root.right = left;

        return root;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是二叉树的节点数。每个节点都会被访问一次。

**空间复杂度：** $O(h)$，其中 $h$ 是二叉树的高度，递归调用栈的最大深度。

### 方法二：迭代翻转（使用栈）

使用栈模拟递归过程，避免递归调用。

**算法步骤：**

1. 使用栈存储待处理的节点
2. 将根节点入栈
3. 循环处理栈中的节点，交换每个节点的左右子节点
4. 将非空的子节点继续入栈处理

```java
import java.util.*;

class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return null;
        }

        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);

        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();

            // 交换左右子节点
            TreeNode temp = node.left;
            node.left = node.right;
            node.right = temp;

            // 将非空子节点入栈
            if (node.left != null) {
                stack.push(node.left);
            }
            if (node.right != null) {
                stack.push(node.right);
            }
        }

        return root;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是二叉树的节点数。每个节点都会被访问一次。

**空间复杂度：** $O(n)$，栈中最多存储所有节点。

### 方法三：层序遍历翻转

使用队列进行层序遍历，逐层翻转节点的左右子树。

**算法步骤：**

1. 使用队列进行层序遍历
2. 对每个节点，交换其左右子节点
3. 将非空的子节点加入队列继续处理
4. 直到队列为空

```java
import java.util.*;

class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return null;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();

            // 交换左右子节点
            TreeNode temp = node.left;
            node.left = node.right;
            node.right = temp;

            // 将非空子节点加入队列
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }

        return root;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是二叉树的节点数。每个节点都会被访问一次。

**空间复杂度：** $O(w)$，其中 $w$ 是二叉树的最大宽度，队列中最多存储一层的所有节点。

### 方法四：简化递归版本

更简洁的递归实现，直接在递归过程中完成交换。

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return null;
        }

        // 直接交换左右子树，并递归处理
        TreeNode temp = root.left;
        root.left = invertTree(root.right);
        root.right = invertTree(temp);

        return root;
    }
}
```

**推荐使用方法一（递归翻转）**，因为它思路清晰，代码简洁，是最直观的解决方案。方法三（层序遍历）在某些场景下空间效率更好，特别是对于深度很大但宽度较小的树。
