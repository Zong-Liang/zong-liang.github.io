---
title: "98-验证二叉搜索树"
date: 2025-03-23 21:27:53 +0800
categories: [LEETCODE, HOT100]
tags: [二叉树, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/validate-binary-search-tree/) \| 难度: 中等

## 问题描述:

给你一个二叉树的根节点 `root`，判断其是否是一个有效的二叉搜索树。

**有效**二叉搜索树定义如下：

- 节点的左子树只包含**小于**当前节点的数。
- 节点的右子树只包含**大于**当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1：**

![img](../assets/img/posts/leetcode/p98_0.jpg)

```
输入: root = [2,1,3]
输出: true
```

**示例 2：**

![img](../assets/img/posts/leetcode/p98_1.jpg)

```java
输入: root = [5,1,4,null,null,3,6]
输出: false
解释: 根节点的值是 5, 但是右子节点的值是 4
```

## 解题思路：

这是一道关于验证二叉搜索树的问题。二叉搜索树(BST)的定义是：对于树中每个节点，其左子树所有节点值都小于该节点值，右子树所有节点值都大于该节点值。

### 方法一：递归验证（推荐）

核心思想是为每个节点设定取值范围的上下界，递归验证每个节点是否在合法范围内。

**算法步骤：**

1. 对于根节点，取值范围是 `(Long.MIN_VALUE, Long.MAX_VALUE)`
2. 对于左子节点，取值范围是 `(下界, 当前节点值)`
3. 对于右子节点，取值范围是 `(当前节点值, 上界)`
4. 递归验证所有节点是否在合法范围内

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    private boolean validate(TreeNode node, long minVal, long maxVal) {
        // 空节点认为是合法的BST
        if (node == null) {
            return true;
        }

        // 检查当前节点值是否在合法范围内
        if (node.val <= minVal || node.val >= maxVal) {
            return false;
        }

        // 递归验证左子树和右子树
        return validate(node.left, minVal, node.val) &&
               validate(node.right, node.val, maxVal);
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是二叉树中节点的个数，每个节点访问一次。

**空间复杂度：** $O(n)$，递归调用栈的深度最坏情况下为 $n$（当树退化为链表时）。

### 方法二：中序遍历法

利用 BST 的中序遍历结果是递增序列的性质来验证。

**算法步骤：**

1. 对二叉树进行中序遍历
2. 检查遍历结果是否为严格递增序列
3. 可以在遍历过程中直接判断，无需存储整个序列

```java
class Solution {
    private long prev = Long.MIN_VALUE;

    public boolean isValidBST(TreeNode root) {
        return inorder(root);
    }

    private boolean inorder(TreeNode node) {
        if (node == null) {
            return true;
        }

        // 先遍历左子树
        if (!inorder(node.left)) {
            return false;
        }

        // 检查当前节点值是否大于前一个值
        if (node.val <= prev) {
            return false;
        }
        prev = node.val;

        // 再遍历右子树
        return inorder(node.right);
    }
}
```

**时间复杂度：** $O(n)$，需要遍历所有节点。

**空间复杂度：** $O(n)$，递归调用栈的空间复杂度。

### 方法三：迭代中序遍历

使用栈实现中序遍历的迭代版本。

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        long prev = Long.MIN_VALUE;
        TreeNode curr = root;

        while (curr != null || !stack.isEmpty()) {
            // 不断向左走，将所有左子节点压入栈
            while (curr != null) {
                stack.push(curr);
                curr = curr.left;
            }

            // 弹出栈顶节点并检查
            curr = stack.pop();
            if (curr.val <= prev) {
                return false;
            }
            prev = curr.val;

            // 转向右子树
            curr = curr.right;
        }

        return true;
    }
}
```

**时间复杂度：** $O(n)$，每个节点访问一次。

**空间复杂度：** $O(n)$，栈的空间复杂度。

### 方法四：递归验证（使用 Integer 包装类）

处理边界值时使用 Integer 包装类，更加优雅。

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        return validate(root, null, null);
    }

    private boolean validate(TreeNode node, Integer minVal, Integer maxVal) {
        if (node == null) {
            return true;
        }

        // 检查是否违反最小值约束
        if (minVal != null && node.val <= minVal) {
            return false;
        }

        // 检查是否违反最大值约束
        if (maxVal != null && node.val >= maxVal) {
            return false;
        }

        // 递归验证左子树和右子树
        return validate(node.left, minVal, node.val) &&
               validate(node.right, node.val, maxVal);
    }
}
```

**时间复杂度：** $O(n)$，每个节点访问一次。

**空间复杂度：** $O(n)$，递归调用栈的深度。

### 方法五：中序遍历存储列表

将中序遍历结果存储在列表中，然后检查是否递增。

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        List<Integer> inorderList = new ArrayList<>();
        inorder(root, inorderList);

        // 检查列表是否严格递增
        for (int i = 1; i < inorderList.size(); i++) {
            if (inorderList.get(i) <= inorderList.get(i - 1)) {
                return false;
            }
        }

        return true;
    }

    private void inorder(TreeNode node, List<Integer> list) {
        if (node == null) {
            return;
        }

        inorder(node.left, list);
        list.add(node.val);
        inorder(node.right, list);
    }
}
```

**时间复杂度：** $O(n)$，遍历所有节点并检查列表。

**空间复杂度：** $O(n)$，存储中序遍历结果和递归栈空间。

**推荐使用方法一（递归验证）**，因为它逻辑清晰，直接基于 BST 的定义进行验证，代码简洁易懂。如果想要避免使用 Long 类型处理边界情况，可以选择方法四。方法二（中序遍历法）也是很好的选择，利用了 BST 的重要性质。
