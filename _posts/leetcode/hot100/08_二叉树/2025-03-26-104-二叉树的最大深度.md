---
title: "104-二叉树的最大深度"
date: 2025-03-26 21:28:39 +0800
categories: [LEETCODE, HOT100]
tags: [二叉树, 简单]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/maximum-depth-of-binary-tree/) \| 难度: 简单

## 问题描述:

给定一个二叉树 `root`，返回其最大深度。

二叉树的**最大深度**是指从根节点到最远叶子节点的最长路径上的节点数。

**示例 1：**

![img](../assets/img/posts/leetcode/p104_0.jpg)

```java
输入: root = [3,9,20,null,null,15,7]
输出: 3
```

**示例 2：**

```java
输入: root = [1,null,2]
输出: 2
```

## 解题思路：

这是一道关于计算二叉树最大深度的问题。二叉树的最大深度是指从根节点到最远叶子节点的最长路径上的节点数。

### 方法一：递归法（推荐）

核心思想是利用递归的特性：一个二叉树的最大深度等于其左右子树最大深度的较大值加 1。

**算法步骤：**

1. 如果根节点为空，返回深度 0
2. 递归计算左子树的最大深度
3. 递归计算右子树的最大深度
4. 返回左右子树最大深度的较大值加 1

```java
// 定义二叉树节点
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public int maxDepth(TreeNode root) {
        // 基础情况：空节点深度为0
        if (root == null) {
            return 0;
        }

        // 递归计算左右子树的最大深度
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);

        // 返回较大深度加1（当前节点贡献1层）
        return Math.max(leftDepth, rightDepth) + 1;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是二叉树中的节点数量，每个节点被访问一次。

**空间复杂度：** $O(h)$，其中 $h$ 是二叉树的高度，主要是递归调用栈的空间。

### 方法二：层序遍历法（BFS）

使用广度优先搜索，逐层遍历二叉树，统计层数即为最大深度。

**算法步骤：**

1. 如果根节点为空，返回深度 0
2. 使用队列进行层序遍历
3. 每遍历完一层，深度加 1
4. 返回总层数

```java
import java.util.*;

class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int depth = 0;

        while (!queue.isEmpty()) {
            // 当前层的节点数量
            int levelSize = queue.size();
            depth++; // 进入新的一层

            // 处理当前层的所有节点
            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();

                // 将下一层节点加入队列
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
        }

        return depth;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是二叉树中的节点数量。

**空间复杂度：** $O(w)$，其中 $w$ 是二叉树的最大宽度（最多一层的节点数）。

### 方法三：深度优先搜索（DFS）- 迭代实现

使用栈来模拟递归过程，同时记录每个节点的深度。

**算法步骤：**

1. 如果根节点为空，返回深度 0
2. 使用栈存储节点和对应深度的配对
3. 遍历栈中所有节点，更新最大深度
4. 将子节点及其深度入栈

```java
import java.util.*;

class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        // 使用栈存储节点和深度的配对
        Stack<Pair<TreeNode, Integer>> stack = new Stack<>();
        stack.push(new Pair<>(root, 1));
        int maxDepth = 0;

        while (!stack.isEmpty()) {
            Pair<TreeNode, Integer> current = stack.pop();
            TreeNode node = current.getKey();
            int currentDepth = current.getValue();

            // 更新最大深度
            maxDepth = Math.max(maxDepth, currentDepth);

            // 将子节点及其深度入栈
            if (node.left != null) {
                stack.push(new Pair<>(node.left, currentDepth + 1));
            }
            if (node.right != null) {
                stack.push(new Pair<>(node.right, currentDepth + 1));
            }
        }

        return maxDepth;
    }

    // 简单的配对类
    class Pair<K, V> {
        private K key;
        private V value;

        public Pair(K key, V value) {
            this.key = key;
            this.value = value;
        }

        public K getKey() { return key; }
        public V getValue() { return value; }
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是二叉树中的节点数量。

**空间复杂度：** $O(h)$，其中 $h$ 是二叉树的高度，栈的最大深度。

**推荐使用方法一（递归法）**，因为它代码简洁、思路清晰，完美体现了树结构的递归特性；如果不允许使用递归或需要避免栈溢出，可以考虑方法二（BFS 层序遍历）。
