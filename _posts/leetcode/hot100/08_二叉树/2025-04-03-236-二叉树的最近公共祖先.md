---
title: "236-二叉树的最近公共祖先"
date: 2025-04-03 21:32:51 +0800
categories: [LEETCODE, HOT100]
tags: [二叉树, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/) \| 难度: 中等

## 问题描述:

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为: “对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

**示例 1：**

![img](../assets/img/posts/leetcode/p236_0.png)

```java
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3
```

**示例 2：**

![img](../assets/img/posts/leetcode/p236_0.png)

```java
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5, 因为根据定义最近公共祖先节点可以为节点本身
```

**示例 3：**

```java
输入: root = [1,2], p = 1, q = 2
输出: 1
```

## 解题思路：

这是一道关于二叉树最近公共祖先的问题。需要在给定的二叉树中找到两个指定节点 p 和 q 的最近公共祖先。

### 方法一：递归查找（推荐）

核心思想是利用递归的特性，如果当前节点是 p 或 q 中的一个，或者 p 和 q 分别在当前节点的左右子树中，那么当前节点就是最近公共祖先。

**算法步骤：**

1. 如果当前节点为空，返回 null
2. 如果当前节点等于 p 或 q，返回当前节点
3. 递归查找左子树和右子树
4. 如果左右子树都找到了节点，说明 p 和 q 分别在左右子树中，当前节点是 LCA
5. 如果只有一边找到了节点，返回找到的那一边

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 基础情况：节点为空或找到目标节点
        if (root == null || root == p || root == q) {
            return root;
        }

        // 在左子树中查找
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        // 在右子树中查找
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        // 如果左右子树都找到了节点，说明当前节点是LCA
        if (left != null && right != null) {
            return root;
        }

        // 返回非空的子树结果
        return left != null ? left : right;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是二叉树的节点数。最坏情况下需要遍历所有节点。

**空间复杂度：** $O(h)$，其中 $h$ 是二叉树的高度，递归调用栈的深度。

### 方法二：存储父节点路径

通过存储每个节点的父节点，然后找到从根到 p 和 q 的路径，最后找到路径的分叉点。

**算法步骤：**

1. 使用哈希表记录每个节点的父节点
2. 从根节点开始遍历，记录父子关系
3. 从 p 节点开始向上找到所有祖先节点
4. 从 q 节点开始向上查找，第一个在 p 祖先集合中的节点就是 LCA

```java
import java.util.*;

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 存储每个节点的父节点
        Map<TreeNode, TreeNode> parent = new HashMap<>();
        parent.put(root, null);

        // 遍历树，记录父子关系
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        // 当p和q的父节点都找到时停止
        while (!parent.containsKey(p) || !parent.containsKey(q)) {
            TreeNode node = queue.poll();

            if (node.left != null) {
                parent.put(node.left, node);
                queue.offer(node.left);
            }

            if (node.right != null) {
                parent.put(node.right, node);
                queue.offer(node.right);
            }
        }

        // 收集p的所有祖先节点
        Set<TreeNode> ancestors = new HashSet<>();
        TreeNode current = p;
        while (current != null) {
            ancestors.add(current);
            current = parent.get(current);
        }

        // 查找q的祖先中第一个也是p的祖先的节点
        current = q;
        while (!ancestors.contains(current)) {
            current = parent.get(current);
        }

        return current;
    }
}
```

**时间复杂度：** $O(n)$，需要遍历树来建立父子关系，然后遍历祖先路径。

**空间复杂度：** $O(n)$，存储父子关系的哈希表和队列。

### 方法三：路径记录法

记录从根节点到 p 和 q 的完整路径，然后比较路径找到最后一个公共节点。

**算法步骤：**

1. 找到从根节点到 p 的路径
2. 找到从根节点到 q 的路径
3. 比较两条路径，找到最后一个相同的节点

```java
import java.util.*;

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        List<TreeNode> pathToP = new ArrayList<>();
        List<TreeNode> pathToQ = new ArrayList<>();

        // 找到到达p和q的路径
        findPath(root, p, pathToP);
        findPath(root, q, pathToQ);

        // 找到最后一个公共节点
        TreeNode lca = null;
        int minLength = Math.min(pathToP.size(), pathToQ.size());

        for (int i = 0; i < minLength; i++) {
            if (pathToP.get(i) == pathToQ.get(i)) {
                lca = pathToP.get(i);
            } else {
                break;
            }
        }

        return lca;
    }

    private boolean findPath(TreeNode root, TreeNode target, List<TreeNode> path) {
        if (root == null) {
            return false;
        }

        path.add(root);

        if (root == target) {
            return true;
        }

        if (findPath(root.left, target, path) || findPath(root.right, target, path)) {
            return true;
        }

        path.remove(path.size() - 1); // 回溯
        return false;
    }
}
```

**时间复杂度：** $O(n)$，需要遍历树找到两条路径。

**空间复杂度：** $O(h)$，路径长度最多为树的高度。

### 方法四：迭代版本

使用栈模拟递归过程，避免递归调用。

```java
import java.util.*;

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        Stack<TreeNode> stack = new Stack<>();
        Map<TreeNode, TreeNode> parent = new HashMap<>();
        parent.put(root, null);
        stack.push(root);

        // 遍历直到找到p和q的父节点
        while (!parent.containsKey(p) || !parent.containsKey(q)) {
            TreeNode node = stack.pop();

            if (node.left != null) {
                parent.put(node.left, node);
                stack.push(node.left);
            }

            if (node.right != null) {
                parent.put(node.right, node);
                stack.push(node.right);
            }
        }

        // 找到p的所有祖先
        Set<TreeNode> ancestors = new HashSet<>();
        while (p != null) {
            ancestors.add(p);
            p = parent.get(p);
        }

        // 找到q的第一个公共祖先
        while (!ancestors.contains(q)) {
            q = parent.get(q);
        }

        return q;
    }
}
```

**推荐使用方法一（递归查找）**，因为它思路清晰，代码简洁，充分利用了二叉树的递归特性。这是解决 LCA 问题的经典方法，易于理解和实现。
