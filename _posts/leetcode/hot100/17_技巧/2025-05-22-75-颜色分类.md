---
title: "75-颜色分类"
date: 2025-05-22 21:50:53 +0800
categories: [LEETCODE, HOT100]
tags: [技巧, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/sort-colors/) \| 难度: 中等

## 问题描述:

给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)** 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。

必须在不使用库内置的 sort 函数的情况下解决这个问题。

**示例 1：**

```java
输入: nums = [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```

**示例 2：**

```java
输入: nums = [2,0,1]
输出: [0,1,2]
```

**进阶：** 你能想出一个仅使用常数空间的一趟扫描算法吗？

## 解题思路：

这是一道关于颜色分类的问题，也叫做"荷兰国旗问题"。需要将包含 0、1、2 三种颜色的数组进行排序，使相同颜色的元素相邻，并按照红色(0)、白色(1)、蓝色(2)的顺序排列。

### 方法一：三指针法（推荐）

使用三个指针来分别维护三个区域的边界，一次遍历完成排序。

**算法步骤：**

1. 使用三个指针：left 指向 0 区域的右边界，right 指向 2 区域的左边界，current 指向当前处理的元素
2. 遍历数组，根据当前元素的值进行不同操作：
   - 如果是 0，与 left 位置交换，left 和 current 都向右移动
   - 如果是 1，current 向右移动
   - 如果是 2，与 right 位置交换，right 向左移动，current 不动（因为交换过来的元素还需要处理）

```java
class Solution {
    public void sortColors(int[] nums) {
        int left = 0;      // 0区域的右边界
        int right = nums.length - 1;  // 2区域的左边界
        int current = 0;   // 当前处理的位置

        while (current <= right) {
            if (nums[current] == 0) {
                // 遇到红色，与left位置交换
                swap(nums, current, left);
                left++;
                current++;
            } else if (nums[current] == 1) {
                // 遇到白色，直接跳过
                current++;
            } else {
                // 遇到蓝色，与right位置交换
                swap(nums, current, right);
                right--;
                // current不移动，因为交换过来的元素还需要处理
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

**时间复杂度：** $O(n)$，只需要一次遍历。

**空间复杂度：** $O(1)$，只使用常数额外空间。

### 方法二：计数排序法

先统计每种颜色的数量，然后重新填充数组。

**算法步骤：**

1. 遍历数组，统计 0、1、2 的个数
2. 根据统计结果重新填充数组

```java
class Solution {
    public void sortColors(int[] nums) {
        int count0 = 0, count1 = 0, count2 = 0;

        // 统计每种颜色的数量
        for (int num : nums) {
            if (num == 0) count0++;
            else if (num == 1) count1++;
            else count2++;
        }

        // 重新填充数组
        int index = 0;
        // 填充红色(0)
        for (int i = 0; i < count0; i++) {
            nums[index++] = 0;
        }
        // 填充白色(1)
        for (int i = 0; i < count1; i++) {
            nums[index++] = 1;
        }
        // 填充蓝色(2)
        for (int i = 0; i < count2; i++) {
            nums[index++] = 2;
        }
    }
}
```

**时间复杂度：** $O(n)$，需要两次遍历。

**空间复杂度：** $O(1)$，只使用常数额外空间。

### 方法三：两次遍历法

第一次将所有 0 移到前面，第二次将所有 1 移到中间。

```java
class Solution {
    public void sortColors(int[] nums) {
        int n = nums.length;
        int ptr = 0;

        // 第一次遍历：将所有0移到前面
        for (int i = 0; i < n; i++) {
            if (nums[i] == 0) {
                swap(nums, i, ptr);
                ptr++;
            }
        }

        // 第二次遍历：将所有1移到中间
        for (int i = ptr; i < n; i++) {
            if (nums[i] == 1) {
                swap(nums, i, ptr);
                ptr++;
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

**时间复杂度：** $O(n)$，需要两次遍历。

**空间复杂度：** $O(1)$，只使用常数额外空间。

### 方法四：详细注释的三指针法

```java
class Solution {
    public void sortColors(int[] nums) {
        // p0: 下一个0应该放置的位置
        // p2: 下一个2应该放置的位置
        // curr: 当前正在检查的元素
        int p0 = 0, p2 = nums.length - 1, curr = 0;

        while (curr <= p2) {
            if (nums[curr] == 0) {
                // 将0交换到前面
                swap(nums, curr, p0);
                p0++;
                curr++;
            } else if (nums[curr] == 2) {
                // 将2交换到后面
                swap(nums, curr, p2);
                p2--;
                // curr不递增，因为从p2位置交换来的元素还未处理
            } else {
                // nums[curr] == 1，保持不动
                curr++;
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

### 算法原理解释：

三指针法的核心思想是将数组分为三个区域：

- `[0, left)`: 已经处理好的 0 区域
- `[left, current)`: 已经处理好的 1 区域
- `[current, right]`: 待处理区域
- `(right, n-1]`: 已经处理好的 2 区域

通过维护这三个区域的边界，确保每个元素都能被正确分类到对应区域。

**推荐使用方法一（三指针法）**，因为它只需要一次遍历，效率最高，且是这类问题的经典解法。如果追求代码简洁性，可以考虑方法二（计数排序法）。
