---
title: "136-只出现一次的数字"
date: 2025-05-23 21:51:06 +0800
categories: [LEETCODE, HOT100]
tags: [技巧, 简单]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/single-number/) \| 难度: 简单

## 问题描述:

给你一个**非空**整数数组 `nums`，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

**示例 1：**

```java
输入: nums = [2,2,1]
输出: 1
```

**示例 2：**

```java
输入: nums = [4,1,2,1,2]
输出: 4
```

**示例 3：**

```java
输入: nums = [1]
输出: 1
```

**提示：** 除了某个元素只出现一次以外，其余每个元素均出现两次。

## 解题思路：

这是一道关于找出数组中只出现一次的数字的问题。除了某个元素只出现一次外，其余每个元素均出现两次。需要设计线性时间复杂度且不使用额外空间的算法。

### 方法一：位运算异或法（推荐）

利用异或运算的性质：相同的数字异或结果为 0，任何数字与 0 异或结果为自己。

**算法步骤：**

1. 初始化结果为 0
2. 遍历数组，将所有数字进行异或运算
3. 由于相同的数字出现两次，异或后会变成 0，最终结果就是只出现一次的数字

**异或运算性质：**

- `a ^ a = 0`（相同数字异或为 0）
- `a ^ 0 = a`（任何数与 0 异或为自己）
- 异或运算满足交换律和结合律

```java
class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;

        // 将所有数字进行异或运算
        for (int num : nums) {
            result ^= num;
        }

        return result;
    }
}
```

**时间复杂度：** $O(n)$，只需要遍历数组一次。

**空间复杂度：** $O(1)$，只使用一个变量存储结果。

### 方法二：数学求和法

利用数学方法：2×(所有不重复数字的和) - 数组所有元素的和 = 只出现一次的数字。

```java
class Solution {
    public int singleNumber(int[] nums) {
        Set<Integer> set = new HashSet<>();
        int arraySum = 0;
        int setSum = 0;

        for (int num : nums) {
            arraySum += num;
            set.add(num);
        }

        for (int num : set) {
            setSum += num;
        }

        return 2 * setSum - arraySum;
    }
}
```

**时间复杂度：** $O(n)$。

**空间复杂度：** $O(n)$，需要额外的 Set 来存储不重复的数字。

### 方法三：HashMap 计数法

使用哈希表统计每个数字的出现次数，然后找出只出现一次的数字。

```java
class Solution {
    public int singleNumber(int[] nums) {
        Map<Integer, Integer> countMap = new HashMap<>();

        // 统计每个数字的出现次数
        for (int num : nums) {
            countMap.put(num, countMap.getOrDefault(num, 0) + 1);
        }

        // 找出只出现一次的数字
        for (Map.Entry<Integer, Integer> entry : countMap.entrySet()) {
            if (entry.getValue() == 1) {
                return entry.getKey();
            }
        }

        return -1; // 这种情况不会发生
    }
}
```

**时间复杂度：** $O(n)$。

**空间复杂度：** $O(n)$，需要额外的 HashMap 存储计数信息。

### 方法四：排序后查找法

先对数组排序，然后查找只出现一次的数字。

```java
class Solution {
    public int singleNumber(int[] nums) {
        Arrays.sort(nums);

        // 检查第一个元素
        if (nums.length == 1 || nums[0] != nums[1]) {
            return nums[0];
        }

        // 检查中间元素
        for (int i = 1; i < nums.length - 1; i += 2) {
            if (nums[i] != nums[i - 1]) {
                return nums[i - 1];
            }
            if (nums[i] != nums[i + 1]) {
                return nums[i];
            }
        }

        // 检查最后一个元素
        return nums[nums.length - 1];
    }
}
```

**时间复杂度：** $O(n \log n)$，主要是排序的时间复杂度。

**空间复杂度：** $O(1)$，如果不考虑排序的额外空间。

### 算法原理解释：

以示例 `[4,1,2,1,2]` 为例：

使用异或运算：

```
0 ^ 4 = 4
4 ^ 1 = 5 (二进制: 100 ^ 001 = 101)
5 ^ 2 = 7 (二进制: 101 ^ 010 = 111)
7 ^ 1 = 6 (二进制: 111 ^ 001 = 110)
6 ^ 2 = 4 (二进制: 110 ^ 010 = 100)
```

由于异或运算的交换律，可以理解为：

```
4 ^ 1 ^ 2 ^ 1 ^ 2 = 4 ^ (1 ^ 1) ^ (2 ^ 2) = 4 ^ 0 ^ 0 = 4
```

**推荐使用方法一（位运算异或法）**，因为它完美满足题目要求：线性时间复杂度且不使用额外空间，是这类问题的最优解法。
