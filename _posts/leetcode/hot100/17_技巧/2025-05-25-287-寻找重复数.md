---
title: "287-寻找重复数"
date: 2025-05-25 21:51:28 +0800
categories: [LEETCODE, HOT100]
tags: [技巧, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/find-the-duplicate-number/) \| 难度: 中等

## 问题描述:

给定一个包含 `n + 1` 个整数的数组 `nums`，其数字都在 `[1, n]` 范围内 (包括 `1` 和 `n`)，可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数**，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 $O(1)$ 的额外空间。

**示例 1：**

```java
输入: nums = [1,3,4,2,2]
输出: 2
```

**示例 2：**

```java
输入: nums = [3,1,3,4,2]
输出: 3
```

**示例 2：**

```java
输入: nums = [3,3,3,3,3]
输出: 3
```

**提示：** `nums` 中 **只有一个整数** 出现 **两次或多次**，其余整数均只出现 **一次**。

## 解题思路：

这是一道关于寻找重复数的问题。给定一个包含 n+1 个整数的数组，数字都在 [1, n] 范围内，其中只有一个数字出现两次或多次，需要找到这个重复的数字。

### 方法一：快慢指针法（Floyd 判圈算法）（推荐）

核心思想是将数组看作一个链表，利用数组值作为下标的特性，使用快慢指针找到环的入口，即重复数字。

**算法步骤：**

1. 将数组看作链表，`nums[i]` 是从位置 `i` 指向位置 `nums[i]` 的指针
2. 由于存在重复数字，必然会形成环
3. 使用快慢指针找到环中的相遇点
4. 从起点和相遇点同时开始，每次移动一步，再次相遇的点就是环的入口（重复数字）

```java
class Solution {
    public int findDuplicate(int[] nums) {
        // 第一步：使用快慢指针找到环中的相遇点
        int slow = nums[0];
        int fast = nums[0];

        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);

        // 第二步：寻找环的入口
        int ptr1 = nums[0];
        int ptr2 = slow;

        while (ptr1 != ptr2) {
            ptr1 = nums[ptr1];
            ptr2 = nums[ptr2];
        }

        return ptr1;
    }
}
```

**时间复杂度：** $O(n)$，最多遍历数组两次。

**空间复杂度：** $O(1)$，只使用常量级额外空间。

### 方法二：二分查找法

利用数字范围 [1, n] 的特性，通过二分查找确定重复数字的位置。

**算法步骤：**

1. 在 [1, n] 范围内进行二分查找
2. 对于中点 `mid`，统计数组中小于等于 `mid` 的数字个数
3. 如果个数大于 `mid`，说明重复数字在 [1, mid] 范围内
4. 否则重复数字在 [mid+1, n] 范围内

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int left = 1, right = nums.length - 1;

        while (left < right) {
            int mid = left + (right - left) / 2;
            int count = 0;

            // 统计小于等于mid的数字个数
            for (int num : nums) {
                if (num <= mid) {
                    count++;
                }
            }

            // 如果个数大于mid，说明重复数字在[1, mid]范围内
            if (count > mid) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        return left;
    }
}
```

**时间复杂度：** $O(n \log n)$，二分查找需要 $O(\log n)$ 次，每次需要 $O(n)$ 时间统计。

**空间复杂度：** $O(1)$，只使用常量级额外空间。

### 方法三：标记法（修改原数组）

利用数组下标和值的对应关系，通过标记访问过的位置来找到重复数字。

```java
class Solution {
    public int findDuplicate(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            int index = Math.abs(nums[i]);

            // 如果该位置已经被标记为负数，说明之前访问过
            if (nums[index] < 0) {
                return index;
            }

            // 标记为负数
            nums[index] = -nums[index];
        }

        return -1; // 不应该到达这里
    }
}
```

**时间复杂度：** $O(n)$，遍历数组一次。

**空间复杂度：** $O(1)$，但会修改原数组。

**推荐使用方法一（快慢指针法）**，因为它满足题目要求的 $O(1)$ 空间复杂度且不修改原数组，是最优解法。如果允许修改原数组，方法三也是不错的选择。
