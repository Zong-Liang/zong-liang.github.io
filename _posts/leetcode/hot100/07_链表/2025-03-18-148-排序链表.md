---
title: "148-排序链表"
date: 2025-03-18 21:26:11 +0800
categories: [LEETCODE, HOT100]
tags: [链表, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/sort-list/) \| 难度: 中等

## 问题描述:

给你链表的头结点 `head`，请将其按**升序**排列并返回**排序后的链表**。

**示例 1：**

![img](../assets/img/posts/leetcode/p148_0.jpg)

```java
输入: head = [4,2,1,3]
输出: [1,2,3,4]
```

**示例 2：**

![img](../assets/img/posts/leetcode/p148_1.jpg)

```java
输入: head = [-1,5,3,4,0]
输出: [-1,0,3,4,5]
```

**示例 3：**

```java
输入: head = []
输出: []
```

**进阶：**你可以在 $O(n log n)$ 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

## 解题思路：

这是一道关于链表排序的问题。需要对链表进行排序，要求时间复杂度为 $O(n \log n)$，空间复杂度为常数级别。

### 方法一：归并排序（自顶向下）（推荐）

核心思想是使用归并排序，通过递归分治的方式将链表不断拆分成单个节点，然后合并有序链表。

**算法步骤：**

1. 找到链表的中点，将链表分为两半
2. 递归地对两半分别进行排序
3. 合并两个已排序的链表
4. 返回合并后的链表头节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        // 找到链表中点，分割链表
        ListNode mid = getMid(head);
        ListNode left = head;
        ListNode right = mid.next;
        mid.next = null; // 切断链接

        // 递归排序左右两部分
        left = sortList(left);
        right = sortList(right);

        // 合并两个有序链表
        return merge(left, right);
    }

    // 找到链表中点（快慢指针法）
    private ListNode getMid(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        ListNode prev = null;

        while (fast != null && fast.next != null) {
            prev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }

        return prev; // 返回中点的前一个节点，便于分割
    }

    // 合并两个有序链表
    private ListNode merge(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;

        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                curr.next = l1;
                l1 = l1.next;
            } else {
                curr.next = l2;
                l2 = l2.next;
            }
            curr = curr.next;
        }

        // 连接剩余部分
        curr.next = (l1 != null) ? l1 : l2;

        return dummy.next;
    }
}
```

**时间复杂度：** $O(n \log n)$，其中 $n$ 是链表的长度。

**空间复杂度：** $O(\log n)$，递归调用栈的深度。

### 方法二：归并排序（自底向上）（空间优化）

使用迭代的方式实现归并排序，避免递归调用栈，实现 $O(1)$ 的空间复杂度。

**算法步骤：**

1. 从长度为 1 的子链表开始合并
2. 每轮将子链表长度翻倍
3. 在每轮中，依次合并相邻的两个子链表
4. 重复直到整个链表有序

```java
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        // 计算链表长度
        int length = getLength(head);
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        // 从子链表长度1开始，每次翻倍
        for (int size = 1; size < length; size *= 2) {
            ListNode prev = dummy;
            ListNode curr = dummy.next;

            while (curr != null) {
                ListNode left = curr;
                ListNode right = split(left, size);
                curr = split(right, size);

                prev = merge(prev, left, right);
            }
        }

        return dummy.next;
    }

    // 计算链表长度
    private int getLength(ListNode head) {
        int length = 0;
        while (head != null) {
            length++;
            head = head.next;
        }
        return length;
    }

    // 分割链表，返回第二部分的头节点
    private ListNode split(ListNode head, int size) {
        for (int i = 1; head != null && i < size; i++) {
            head = head.next;
        }
        if (head == null) return null;

        ListNode second = head.next;
        head.next = null;
        return second;
    }

    // 合并两个有序链表，返回合并后的尾节点
    private ListNode merge(ListNode prev, ListNode l1, ListNode l2) {
        ListNode curr = prev;

        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                curr.next = l1;
                l1 = l1.next;
            } else {
                curr.next = l2;
                l2 = l2.next;
            }
            curr = curr.next;
        }

        curr.next = (l1 != null) ? l1 : l2;

        // 移动到尾部
        while (curr.next != null) {
            curr = curr.next;
        }

        return curr;
    }
}
```

**时间复杂度：** $O(n \log n)$

**空间复杂度：** $O(1)$

### 方法三：快速排序（不推荐）

虽然可以实现，但在最坏情况下时间复杂度会退化到 O(n²)。

```java
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        return quickSort(head, null);
    }

    private ListNode quickSort(ListNode head, ListNode tail) {
        if (head == tail || head.next == tail) {
            return head;
        }

        ListNode[] partition = partition(head, tail);
        ListNode newHead = partition[0];
        ListNode pivot = partition[1];
        ListNode newTail = partition[2];

        // 递归排序左右两部分
        ListNode left = quickSort(newHead, pivot);
        ListNode right = quickSort(pivot.next, tail);

        // 连接结果
        ListNode curr = left;
        while (curr.next != pivot) {
            curr = curr.next;
        }
        curr.next = pivot;
        pivot.next = right;

        return left;
    }

    private ListNode[] partition(ListNode head, ListNode tail) {
        ListNode pivot = head;
        ListNode prev = head;
        ListNode curr = head.next;

        while (curr != tail) {
            if (curr.val < pivot.val) {
                prev = prev.next;
                int temp = prev.val;
                prev.val = curr.val;
                curr.val = temp;
            }
            curr = curr.next;
        }

        int temp = pivot.val;
        pivot.val = prev.val;
        prev.val = temp;

        return new ListNode[]{head, prev, tail};
    }
}
```

### 方法四：转换为数组排序（简单但不符合要求）

将链表转换为数组，排序后重构链表。

```java
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null) {
            return head;
        }

        // 转换为数组
        List<Integer> values = new ArrayList<>();
        ListNode curr = head;
        while (curr != null) {
            values.add(curr.val);
            curr = curr.next;
        }

        // 排序
        Collections.sort(values);

        // 重构链表
        curr = head;
        for (int val : values) {
            curr.val = val;
            curr = curr.next;
        }

        return head;
    }
}
```

**推荐使用方法二（自底向上归并排序）**，因为它既满足了 $O(n \log n)$ 的时间复杂度要求，又实现了 $O(1)$ 的空间复杂度。如果不要求常数空间，方法一（自顶向下归并排序）更容易理解和实现。
