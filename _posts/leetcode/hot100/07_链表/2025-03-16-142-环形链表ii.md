---
title: "142-环形链表II"
date: 2025-03-16 21:25:25 +0800
categories: [LEETCODE, HOT100]
tags: [链表, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/linked-list-cycle-ii/) \| 难度: 中等

## 问题描述:

给定一个链表的头节点 `head`，返回链表开始入环的第一个节点。_如果链表无环，则返回 `null`。_

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

**示例 1：**

![img](../assets/img/posts/leetcode/p142_0.png)

```java
输入: head = [3,2,0,-4], pos = 1
输出: 返回索引为 1 的链表节点
解释: 链表中有一个环, 其尾部连接到第二个节点
```

**示例 2：**

![img](../assets/img/posts/leetcode/p142_1.png)

```java
输入: head = [1,2], pos = 0
输出: 返回索引为 0 的链表节点
解释: 链表中有一个环, 其尾部连接到第一个节点
```

**示例 3：**

![img](../assets/img/posts/leetcode/p142_2.png)

```java
输入: head = [1], pos = -1
输出: 返回 null
解释: 链表中没有环
```

## 解题思路：

这是一道关于环形链表检测并返回环开始节点的问题。需要判断链表中是否存在环，如果存在环则返回环的起始节点，否则返回 null。

### 方法一：快慢指针法（Floyd 判圈算法）（推荐）

核心思想是先用快慢指针检测是否有环，如果有环，再利用数学关系找到环的起始节点。

**数学原理：**

- 设链表头到环起始点的距离为 a
- 环的长度为 b
- 快慢指针相遇点到环起始点的距离为 c
- 当快慢指针相遇时，慢指针走了 a + c 步，快指针走了 a + c + kb 步（k 为快指针在环中多走的圈数）
- 由于快指针速度是慢指针的 2 倍，所以：2(a + c) = a + c + kb
- 化简得：a = kb - c = (k-1)b + (b-c)
- 这意味着从头节点走 a 步和从相遇点走 a 步，都会到达环的起始点

**算法步骤：**

1. 使用快慢指针检测是否存在环
2. 如果存在环，将一个指针重置到头节点
3. 两个指针以相同速度移动，相遇点就是环的起始节点

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null) {
            return null;
        }

        // 第一阶段：使用快慢指针检测是否存在环
        ListNode slow = head;
        ListNode fast = head;

        // 检测环的存在
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            // 快慢指针相遇，说明存在环
            if (slow == fast) {
                break;
            }
        }

        // 如果没有环，返回null
        if (fast == null || fast.next == null) {
            return null;
        }

        // 第二阶段：寻找环的起始节点
        // 将慢指针重置到头节点，快指针留在相遇点
        slow = head;

        // 两指针以相同速度移动，相遇点即为环的起始节点
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }

        return slow;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是链表的长度。

**空间复杂度：** $O(1)$，只使用了两个指针的额外空间。

### 方法二：哈希表法

使用哈希表记录访问过的节点，第一个重复访问的节点就是环的起始点。

**算法步骤：**

1. 创建哈希集合存储访问过的节点
2. 遍历链表，检查当前节点是否已在集合中
3. 如果存在则返回该节点（环的起始点）
4. 如果遍历到链表末尾则返回 null

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        Set<ListNode> visited = new HashSet<>();

        while (head != null) {
            // 如果当前节点已访问过，说明这是环的起始点
            if (visited.contains(head)) {
                return head;
            }
            // 将当前节点加入已访问集合
            visited.add(head);
            head = head.next;
        }

        // 遍历结束，无环
        return null;
    }
}
```

**时间复杂度：** $O(n)$，需要遍历链表。

**空间复杂度：** $O(n)$，最坏情况下需要存储所有节点。

### 方法三：标记法（修改链表结构）

通过临时修改节点的 next 指针来标记访问过的节点。

**算法步骤：**

1. 遍历链表，将每个节点的 next 指针临时指向一个特殊节点
2. 如果发现某个节点的 next 已经指向特殊节点，说明找到了环的起始点
3. 恢复链表结构

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null) {
            return null;
        }

        // 创建一个特殊的标记节点
        ListNode marker = new ListNode(0);

        while (head != null) {
            // 如果当前节点的next指向标记节点，说明之前访问过
            if (head.next == marker) {
                return head;
            }

            // 保存原来的next节点
            ListNode next = head.next;

            // 将当前节点的next指向标记节点
            head.next = marker;

            // 移动到下一个节点
            head = next;
        }

        return null;
    }
}
```

**注意：** 这种方法会临时修改原链表结构，实际使用中需要谨慎。

### 方法四：优化的快慢指针（一次遍历检测）

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;

        // 寻找相遇点
        do {
            if (fast == null || fast.next == null) {
                return null; // 无环
            }
            slow = slow.next;
            fast = fast.next.next;
        } while (slow != fast);

        // 寻找环的起始点
        fast = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }

        return slow;
    }
}
```

**时间复杂度：** $O(n)$

**空间复杂度：** $O(1)$

**推荐使用方法一（快慢指针法）**，因为它空间效率高，不需要额外的数据结构，也不会修改原链表。这是 Floyd 判圈算法的完整版本，能够不仅检测环的存在，还能找到环的起始位置。
