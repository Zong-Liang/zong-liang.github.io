---
title: "141-环形链表"
date: 2025-03-15 21:25:01 +0800
categories: [LEETCODE, HOT100]
tags: [链表, 简单]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/linked-list-cycle/) \| 难度: 简单

## 问题描述:

给你一个链表的头节点 `head`，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意: `pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

_如果链表中存在环_ ，则返回 `true`。否则，返回 `false`。

**示例 1：**

![img](../assets/img/posts/leetcode/p141_0.png)

```java
输入: head = [3,2,0,-4], pos = 1
输出: true
解释: 链表中有一个环, 其尾部连接到第二个节点
```

**示例 2：**

![img](../assets/img/posts/leetcode/p141_1.png)

```java
输入: head = [1,2], pos = 0
输出: true
解释: 链表中有一个环, 其尾部连接到第一个节点
```

**示例 3：**

![img](../assets/img/posts/leetcode/p141_2.png)

```java
输入: head = [1], pos = -1
输出: false
解释: 链表中没有环
```

**进阶：** 你能用 $O(1)$（即，常量）内存解决此问题吗？

## 解题思路：

这是一道关于链表环检测的问题。需要判断链表中是否存在环，如果存在环则返回 true，否则返回 false。

### 方法一：快慢指针法（Floyd 判圈算法）（推荐）

核心思想是使用两个指针，一个慢指针每次移动一步，一个快指针每次移动两步。如果链表中存在环，快指针最终会追上慢指针。

**算法步骤：**

1. 初始化快慢指针都指向头节点
2. 慢指针每次移动一步，快指针每次移动两步
3. 如果快指针到达链表末尾（null），说明无环
4. 如果快指针和慢指针相遇，说明有环

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }

        // 初始化快慢指针
        ListNode slow = head;
        ListNode fast = head.next;

        // 当快指针未到达链表末尾时继续
        while (slow != fast) {
            // 如果快指针到达末尾，说明无环
            if (fast == null || fast.next == null) {
                return false;
            }
            // 慢指针移动一步，快指针移动两步
            slow = slow.next;
            fast = fast.next.next;
        }

        // 快慢指针相遇，存在环
        return true;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是链表的长度。在最坏情况下，需要遍历链表两遍。

**空间复杂度：** $O(1)$，只使用了两个指针的额外空间。

### 方法二：哈希表法

使用哈希表记录访问过的节点，如果访问到重复节点则说明存在环。

**算法步骤：**

1. 创建哈希集合存储访问过的节点
2. 遍历链表，检查当前节点是否已在集合中
3. 如果存在则返回 true，否则将节点加入集合
4. 如果遍历到链表末尾则返回 false

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> visited = new HashSet<>();

        while (head != null) {
            // 如果当前节点已访问过，说明存在环
            if (visited.contains(head)) {
                return true;
            }
            // 将当前节点加入已访问集合
            visited.add(head);
            head = head.next;
        }

        // 遍历结束，无环
        return false;
    }
}
```

**时间复杂度：** $O(n)$，需要遍历链表一遍。

**空间复杂度：** $O(n)$，最坏情况下需要存储所有节点。

### 方法三：标记法（修改节点值）

通过修改访问过的节点值来标记，但这种方法会改变原链表结构，一般不推荐。

**算法步骤：**

1. 遍历链表，将访问过的节点值设为特殊值
2. 如果遇到已标记的节点，说明存在环
3. 如果遍历到链表末尾则无环

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        while (head != null) {
            // 如果节点值为特殊标记，说明之前访问过
            if (head.val == Integer.MAX_VALUE) {
                return true;
            }
            // 标记当前节点
            head.val = Integer.MAX_VALUE;
            head = head.next;
        }

        return false;
    }
}
```

**时间复杂度：** $O(n)$

**空间复杂度：** $O(1)$

**注意：** 这种方法会修改原链表，在实际应用中需要谨慎使用。

### 方法四：快慢指针优化版

将快慢指针的初始位置都设为头节点，逻辑稍有不同。

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null) {
            return false;
        }

        ListNode slow = head;
        ListNode fast = head;

        // 使用do-while或者在while中先移动指针
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            // 检查是否相遇
            if (slow == fast) {
                return true;
            }
        }

        return false;
    }
}
```

**时间复杂度：** $O(n)$

**空间复杂度：** $O(1)$

**推荐使用方法一（快慢指针法）**，因为它空间效率高，不需要额外的数据结构，也不会修改原链表。这是检测链表环的经典算法，被称为 Floyd 判圈算法或龟兔赛跑算法。
