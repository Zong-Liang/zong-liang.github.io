---
title: "21-合并两个有序链表"
date: 2025-03-10 21:23:02 +0800
categories: [LEETCODE, HOT100]
tags: [链表, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/merge-two-sorted-lists/) \| 难度: 简单

## 问题描述:

将两个升序链表合并为一个新的**升序**链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例 1：**

![img](../assets/img/posts/leetcode/p21_0.jpg)

```java
输入: l1 = [1,2,4], l2 = [1,3,4]
输出: [1,1,2,3,4,4]
```

**示例 2：**

```java
输入: l1 = [], l2 = []
输出: []
```

**示例 3：**

```java
输入: l1 = [], l2 = [0]
输出: [0]
```

## 解题思路：

这是一道经典的合并两个有序链表问题。需要将两个已经按升序排列的链表合并成一个新的升序链表。

### 方法一：迭代法（推荐）

**核心思想：** 使用双指针技术，比较两个链表当前节点的值，将较小的节点连接到结果链表中。

**算法步骤：**

1. 创建一个哑节点（dummy node）作为结果链表的头部
2. 使用两个指针分别指向两个输入链表
3. 比较当前节点值，将较小的节点连接到结果链表
4. 移动对应的指针到下一个节点
5. 重复步骤 3-4 直到其中一个链表遍历完毕
6. 将剩余的链表直接连接到结果链表末尾

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // 创建哑节点，简化边界处理
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;

        // 当两个链表都不为空时进行比较合并
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                current.next = l1;
                l1 = l1.next;
            } else {
                current.next = l2;
                l2 = l2.next;
            }
            current = current.next;
        }

        // 连接剩余的链表
        if (l1 != null) {
            current.next = l1;
        } else {
            current.next = l2;
        }

        // 返回真正的头节点
        return dummy.next;
    }
}
```

**时间复杂度：**$O(m + n)$，其中 $m$ 和 $n$ 分别是两个链表的长度。

**空间复杂度：**$O(1)$，只使用了常数级别的额外空间。

### 方法二：递归法

**核心思想：** 利用递归的特性，每次选择较小的节点，然后递归处理剩余部分。

**算法步骤：**

1. 处理边界情况：如果其中一个链表为空，返回另一个链表
2. 比较两个链表头节点的值
3. 选择较小的节点，递归合并该节点的 next 和另一个链表
4. 返回较小的节点

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // 边界情况处理
        if (l1 == null) {
            return l2;
        }
        if (l2 == null) {
            return l1;
        }

        // 递归合并
        if (l1.val <= l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```

**时间复杂度：**$O(m + n)$，每个节点都会被访问一次。

**空间复杂度：**$O(m + n)$，递归调用栈的深度最多为 $m + n$。

**推荐使用方法一（迭代法）**，因为它的空间复杂度更优，避免了递归可能导致的栈溢出问题，同时逻辑清晰易懂。
