---
title: "206-反转链表"
date: 2025-03-20 21:26:35 +0800
categories: [LEETCODE, HOT100]
tags: [链表, 简单]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/reverse-linked-list/) \| 难度: 简单

## 问题描述:

给你单链表的头节点 `head`，请你反转链表，并返回反转后的链表。

**示例 1：**

![img](../assets/img/posts/leetcode/p206_0.jpg)

```java
输入: head = [1,2,3,4,5]
输出: [5,4,3,2,1]
```

**示例 2：**

![img](../assets/img/posts/leetcode/p206_1.jpg)

```java
输入: head = [1,2]
输出: [2,1]
```

**示例 3：**

```java
输入: head = []
输出: []
```

## 解题思路：

这是一道关于链表反转的经典问题。需要将单向链表的指针方向完全反转。

### 方法一：迭代法（推荐）

核心思想是使用三个指针遍历链表，逐个反转每个节点的指向。

**算法步骤：**

1. 使用三个指针：`prev`（前一个节点）、`curr`（当前节点）、`next`（下一个节点）
2. 初始化 `prev = null`，`curr = head`
3. 遍历链表，每次将当前节点的 `next` 指向前一个节点
4. 移动三个指针继续处理下一个节点
5. 当 `curr` 为 `null` 时，`prev` 就是新的头节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        // 处理空链表或单节点情况
        if (head == null || head.next == null) {
            return head;
        }

        ListNode prev = null;    // 前一个节点
        ListNode curr = head;    // 当前节点

        while (curr != null) {
            ListNode next = curr.next;  // 保存下一个节点
            curr.next = prev;           // 反转当前节点指向
            prev = curr;                // 移动prev指针
            curr = next;                // 移动curr指针
        }

        return prev;  // prev现在是新的头节点
    }
}
```

**时间复杂度：** $O(n)$，需要遍历链表一次。

**空间复杂度：** $O(1)$，只使用了常数个额外指针。

### 方法二：递归法

使用递归的思想，先反转后面的部分，再处理当前节点。

**算法步骤：**

1. 递归到链表末尾
2. 从后往前逐个反转节点指向
3. 返回新的头节点

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        // 递归终止条件
        if (head == null || head.next == null) {
            return head;
        }

        // 递归反转后面的链表，获得新头节点
        ListNode newHead = reverseList(head.next);

        // 反转当前节点
        head.next.next = head;  // 让下一个节点指向当前节点
        head.next = null;       // 断开当前节点的原始指向

        return newHead;         // 返回新的头节点
    }
}
```

**时间复杂度：** $O(n)$，需要递归访问每个节点。

**空间复杂度：** $O(n)$，递归调用栈的深度为链表长度。

### 方法三：栈辅助法

使用栈的先进后出特性来实现反转。

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null) {
            return null;
        }

        // 将所有节点压入栈中
        Stack<ListNode> stack = new Stack<>();
        ListNode curr = head;
        while (curr != null) {
            stack.push(curr);
            curr = curr.next;
        }

        // 弹出栈顶元素作为新头节点
        ListNode newHead = stack.pop();
        curr = newHead;

        // 依次弹出剩余节点并重新连接
        while (!stack.isEmpty()) {
            curr.next = stack.pop();
            curr = curr.next;
        }

        curr.next = null;  // 最后一个节点指向null
        return newHead;
    }
}
```

**时间复杂度：** $O(n)$，需要遍历链表两次。

**空间复杂度：** $O(n)$，栈存储所有节点。

**推荐使用方法一（迭代法）**，因为它时间效率高，空间复杂度最优，代码简洁易懂，是面试中的最佳解法。
