---
title: "23-合并K个升序链表"
date: 2025-03-11 21:23:33 +0800
categories: [LEETCODE, HOT100]
tags: [链表, 困难]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/merge-k-sorted-lists/) \| 难度: 困难

## 问题描述:

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**

```java
输入: lists = [[1,4,5],[1,3,4],[2,6]]
输出: [1,1,2,3,4,4,5,6]
解释: 链表数组如下:
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到:
1->1->2->3->4->4->5->6
```

**示例 2：**

```java
输入: lists = []
输出: []
```

**示例 3：**

```java
输入: lists = [[]]
输出: []
```

## 解题思路：

这道题要求合并 K 个升序链表，给定一个链表数组，每个链表都已经按升序排列。我们需要将所有链表合并到一个升序链表中，并返回合并后的链表。

### 方法一：分治法（推荐）

核心思想是将 K 个链表两两合并，类似归并排序的思想。

**算法步骤：**

1. 如果链表数组为空，返回 null
2. 使用分治法，将 K 个链表分成两部分
3. 递归合并左半部分和右半部分
4. 最后合并两个已排序的链表

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) {
            return null;
        }
        return mergeLists(lists, 0, lists.length - 1);
    }

    // 分治合并
    private ListNode mergeLists(ListNode[] lists, int left, int right) {
        if (left == right) {
            return lists[left];
        }

        int mid = left + (right - left) / 2;
        ListNode l1 = mergeLists(lists, left, mid);
        ListNode l2 = mergeLists(lists, mid + 1, right);

        return mergeTwoLists(l1, l2);
    }

    // 合并两个升序链表
    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;

        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                current.next = l1;
                l1 = l1.next;
            } else {
                current.next = l2;
                l2 = l2.next;
            }
            current = current.next;
        }

        // 连接剩余节点
        current.next = (l1 != null) ? l1 : l2;

        return dummy.next;
    }
}
```

**时间复杂度：** $O(n \times \log k)$，其中 $n$ 是所有链表中节点的总数，$k$ 是链表的数量。

**空间复杂度：** $O(\log k)$，递归调用栈的深度。

### 方法二：优先队列（最小堆）

使用最小堆来维护所有链表的头节点，每次取出最小值。

**算法步骤：**

1. 将所有链表的头节点加入最小堆
2. 每次从堆中取出最小节点，加入结果链表
3. 如果取出节点的下一个节点不为空，将其加入堆中
4. 重复步骤 2-3 直到堆为空

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) {
            return null;
        }

        // 创建最小堆，按节点值排序
        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);

        // 将所有链表的头节点加入堆中
        for (ListNode head : lists) {
            if (head != null) {
                minHeap.offer(head);
            }
        }

        ListNode dummy = new ListNode(0);
        ListNode current = dummy;

        // 从堆中依次取出最小节点
        while (!minHeap.isEmpty()) {
            ListNode minNode = minHeap.poll();
            current.next = minNode;
            current = current.next;

            // 如果该节点还有下一个节点，加入堆中
            if (minNode.next != null) {
                minHeap.offer(minNode.next);
            }
        }

        return dummy.next;
    }
}
```

**时间复杂度：** $O(n \times \log k)$，其中 $n$ 是所有链表中节点的总数，$k$ 是链表的数量。

**空间复杂度：** $O(k)$，堆中最多存储 $k$ 个节点。

### 方法三：逐个合并（较简单但效率低）

依次将每个链表与结果链表合并。

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) {
            return null;
        }

        ListNode result = null;

        for (ListNode list : lists) {
            result = mergeTwoLists(result, list);
        }

        return result;
    }

    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;

        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                current.next = l1;
                l1 = l1.next;
            } else {
                current.next = l2;
                l2 = l2.next;
            }
            current = current.next;
        }

        current.next = (l1 != null) ? l1 : l2;

        return dummy.next;
    }
}
```

**时间复杂度：** $O(n \times k)$，效率较低。

**空间复杂度：** $O(1)$。

**推荐使用方法一（分治法）**，因为它时间复杂度最优，思路清晰；如果想要更直观的理解，可以使用方法二（优先队列）。
