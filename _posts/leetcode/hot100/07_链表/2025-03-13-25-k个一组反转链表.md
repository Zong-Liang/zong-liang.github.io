---
title: "25-k个一组反转链表"
date: 2025-03-13 21:24:33 +0800
categories: [LEETCODE, HOT100]
tags: [链表, 困难]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/reverse-nodes-in-k-group/) \| 难度: 困难

## 问题描述:

给你链表的头节点 `head`，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**示例 1：**

![img](../assets/img/posts/leetcode/p25_0.jpg)

```java
输入: head = [1,2,3,4,5], k = 2
输出: [2,1,4,3,5]
```

**示例 2：**

![img](../assets/img/posts/leetcode/p25_1.jpg)

```java
输入: head = [1,2,3,4,5], k = 3
输出: [3,2,1,4,5]
```

## 解题思路：

这是一道关于链表 K 个一组翻转的问题。需要将链表中每 K 个节点作为一组进行翻转，如果最后不足 K 个节点则保持原顺序。

### 方法一：迭代法（推荐）

核心思想是先检查是否有 K 个节点，如果有则翻转这 K 个节点，然后继续处理下一组。

**算法步骤：**

1. 使用虚拟头节点简化边界处理
2. 用指针检查当前位置后是否还有 K 个节点
3. 如果有 K 个节点，则翻转这 K 个节点
4. 连接翻转后的节点组，继续处理下一组
5. 如果不足 K 个节点，则保持原顺序

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null || k == 1) {
            return head;
        }

        // 创建虚拟头节点
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prevGroupEnd = dummy;

        while (true) {
            // 检查是否还有k个节点
            ListNode kthNode = getKthNode(prevGroupEnd, k);
            if (kthNode == null) {
                break;
            }

            // 记录下一组的开始节点
            ListNode nextGroupStart = kthNode.next;

            // 翻转当前k个节点
            ListNode groupStart = prevGroupEnd.next;
            ListNode prev = nextGroupStart;
            ListNode curr = groupStart;

            // 翻转k个节点
            while (curr != nextGroupStart) {
                ListNode next = curr.next;
                curr.next = prev;
                prev = curr;
                curr = next;
            }

            // 连接翻转后的节点组
            prevGroupEnd.next = kthNode;
            prevGroupEnd = groupStart;
        }

        return dummy.next;
    }

    // 获取从start开始的第k个节点
    private ListNode getKthNode(ListNode start, int k) {
        ListNode curr = start;
        for (int i = 0; i < k && curr != null; i++) {
            curr = curr.next;
        }
        return curr;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是链表的长度，每个节点最多被访问两次。

**空间复杂度：** $O(1)$，只使用了常数个额外指针。

### 方法二：递归法

使用递归的思想，每次处理 K 个节点的翻转，然后递归处理剩余部分。

**算法步骤：**

1. 检查是否有 K 个节点，如果没有则返回原链表
2. 翻转前 K 个节点
3. 递归处理剩余部分
4. 连接翻转后的部分和递归结果

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        // 检查是否有k个节点
        ListNode curr = head;
        for (int i = 0; i < k; i++) {
            if (curr == null) {
                return head; // 不足k个节点，返回原链表
            }
            curr = curr.next;
        }

        // 翻转前k个节点
        ListNode prev = null;
        curr = head;
        for (int i = 0; i < k; i++) {
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }

        // 递归处理剩余部分，并连接到翻转后的尾部
        head.next = reverseKGroup(curr, k);

        // 返回翻转后的头节点
        return prev;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是链表的长度。

**空间复杂度：** $O(n/k)$，递归调用栈的深度。

### 方法三：双指针优化版

使用双指针来定位每组的开始和结束位置，然后翻转。

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null || k == 1) {
            return head;
        }

        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        ListNode end = dummy;

        while (end.next != null) {
            // 找到k个节点的末尾
            for (int i = 0; i < k && end != null; i++) {
                end = end.next;
            }

            if (end == null) {
                break; // 不足k个节点
            }

            ListNode start = pre.next;
            ListNode next = end.next;

            // 断开链接
            end.next = null;

            // 翻转k个节点
            pre.next = reverse(start);

            // 重新连接
            start.next = next;
            pre = start;
            end = pre;
        }

        return dummy.next;
    }

    // 翻转链表
    private ListNode reverse(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;

        while (curr != null) {
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }

        return prev;
    }
}
```

**时间复杂度：** $O(n)$

**空间复杂度：** $O(1)$

**推荐使用方法一（迭代法）**，因为它空间效率高，逻辑清晰，不需要额外的翻转函数，所有操作都在一个函数中完成，便于理解和调试。
