---
title: "2-两数相加"
date: 2025-03-08 21:22:05 +0800
categories: [LEETCODE, HOT100]
tags: [链表, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/add-two-numbers/) \| 难度: 中等

## 问题描述:

给你两个**非空**的链表，表示两个非负的整数。它们每位数字都是按照**逆序**的方式存储的，并且每个节点只能存储**一位**数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**

![img](../assets/img/posts/leetcode/p2_0.jpg)

```java
输入: l1 = [2,4,3], l2 = [5,6,4]
输出: [7,0,8]
解释: 342 + 465 = 807
```

**示例 2：**

```java
输入: l1 = [0], l2 = [0]
输出: [0]
```

**示例 3：**

```java
输入: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出: [8,9,9,9,0,0,0,1]
```

## 解题思路：

这是一道关于两数相加的链表问题。需要模拟加法运算过程，处理进位，并以链表形式返回结果。由于数字是逆序存储的，正好符合加法从低位到高位的计算顺序。

### 方法一：模拟加法过程（推荐）

核心思想是同时遍历两个链表，逐位相加并处理进位，构建结果链表。

**算法步骤：**

1. 创建虚拟头节点，便于处理结果链表
2. 同时遍历两个链表，逐位相加
3. 处理进位情况
4. 考虑两个链表长度不同的情况
5. 最后检查是否还有进位需要处理

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // 创建虚拟头节点
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        int carry = 0; // 进位

        // 同时遍历两个链表
        while (l1 != null || l2 != null || carry != 0) {
            // 获取当前位的值
            int val1 = (l1 != null) ? l1.val : 0;
            int val2 = (l2 != null) ? l2.val : 0;

            // 计算当前位的和
            int sum = val1 + val2 + carry;
            carry = sum / 10; // 新的进位
            int digit = sum % 10; // 当前位的数字

            // 创建新节点
            current.next = new ListNode(digit);
            current = current.next;

            // 移动指针
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }

        return dummy.next;
    }
}
```

**时间复杂度：** $O(\max(m, n))$，其中 $m$ 和 $n$ 分别是两个链表的长度。

**空间复杂度：** $O(\max(m, n))$，结果链表的长度最多为较长链表长度加 1。

### 方法二：递归解法

使用递归的方式处理加法运算。

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        return addTwoNumbersHelper(l1, l2, 0);
    }

    private ListNode addTwoNumbersHelper(ListNode l1, ListNode l2, int carry) {
        // 基本情况
        if (l1 == null && l2 == null && carry == 0) {
            return null;
        }

        // 获取当前位的值
        int val1 = (l1 != null) ? l1.val : 0;
        int val2 = (l2 != null) ? l2.val : 0;

        // 计算当前位的和
        int sum = val1 + val2 + carry;
        int digit = sum % 10;
        int newCarry = sum / 10;

        // 创建当前节点
        ListNode currentNode = new ListNode(digit);

        // 递归处理下一位
        ListNode next1 = (l1 != null) ? l1.next : null;
        ListNode next2 = (l2 != null) ? l2.next : null;
        currentNode.next = addTwoNumbersHelper(next1, next2, newCarry);

        return currentNode;
    }
}
```

**时间复杂度：** $O(\max(m, n))$

**空间复杂度：** $O(\max(m, n))$，递归调用栈的深度。

### 方法三：优化版迭代

稍微优化的迭代版本，减少一些判断。

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        int carry = 0;

        while (l1 != null || l2 != null) {
            int sum = carry;

            if (l1 != null) {
                sum += l1.val;
                l1 = l1.next;
            }

            if (l2 != null) {
                sum += l2.val;
                l2 = l2.next;
            }

            carry = sum / 10;
            current.next = new ListNode(sum % 10);
            current = current.next;
        }

        // 处理最后的进位
        if (carry > 0) {
            current.next = new ListNode(carry);
        }

        return dummy.next;
    }
}
```

### 关键点总结：

1. **进位处理**：每次计算都要考虑上一位的进位
2. **链表长度不同**：较短的链表结束后，继续处理较长链表的剩余部分
3. **最终进位**：所有位都处理完后，如果还有进位，需要创建新节点
4. **虚拟头节点**：简化链表操作，避免特殊情况处理

**推荐使用方法一（迭代解法）**，因为它逻辑清晰，易于理解，空间效率更高（不需要递归调用栈），是最常用的解决方案。
