---
title: "146-lru缓存"
date: 2025-03-17 21:25:46 +0800
categories: [LEETCODE, HOT100]
tags: [链表, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/lru-cache/) \| 难度: 中等

## 问题描述:

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类:

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存。
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 $O(1)$ 的平均时间复杂度运行。

**示例：**

```java
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

## 解题思路：

这是一道关于设计 LRU（Least Recently Used）缓存的问题。需要实现一个缓存数据结构，支持在 $O(1)$ 时间内完成 get 和 put 操作，当容量超出时移除最近最少使用的元素。

### 方法一：哈希表 + 双向链表（推荐）

核心思想是使用哈希表提供 $O(1)$ 的查找，使用双向链表维护访问顺序，链表头部是最近访问的，尾部是最久未访问的。

**算法步骤：**

1. 定义双向链表节点，包含 key、value、prev、next 指针
2. 使用 HashMap 存储 key 到节点的映射
3. 维护虚拟头尾节点简化边界处理
4. get 操作：查找节点并移动到头部
5. put 操作：更新或插入节点，超容量时删除尾部节点

```java
class LRUCache {
    // 双向链表节点
    class DListNode {
        int key;
        int value;
        DListNode prev;
        DListNode next;

        public DListNode() {}

        public DListNode(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    private Map<Integer, DListNode> cache = new HashMap<>();
    private int size;
    private int capacity;
    private DListNode head, tail;

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;

        // 创建虚拟头尾节点
        head = new DListNode();
        tail = new DListNode();

        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        DListNode node = cache.get(key);
        if (node == null) {
            return -1;
        }

        // 将访问的节点移动到头部
        moveToHead(node);

        return node.value;
    }

    public void put(int key, int value) {
        DListNode node = cache.get(key);

        if (node == null) {
            DListNode newNode = new DListNode(key, value);

            cache.put(key, newNode);
            addToHead(newNode);

            ++size;

            if (size > capacity) {
                // 删除尾部节点
                DListNode tail = removeTail();
                cache.remove(tail.key);
                --size;
            }
        } else {
            // 更新已存在的节点
            node.value = value;
            moveToHead(node);
        }
    }

    private void addToHead(DListNode node) {
        node.prev = head;
        node.next = head.next;

        head.next.prev = node;
        head.next = node;
    }

    private void removeNode(DListNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void moveToHead(DListNode node) {
        removeNode(node);
        addToHead(node);
    }

    private DListNode removeTail() {
        DListNode lastNode = tail.prev;
        removeNode(lastNode);
        return lastNode;
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

**时间复杂度：** get 和 put 操作都是$O(1)$。

**空间复杂度：** $O(capacity)$，存储最多 capacity 个键值对。

### 方法二：LinkedHashMap 实现（Java 内置）

利用 Java 内置的 LinkedHashMap 来简化实现，LinkedHashMap 本身就维护了插入顺序。

**算法步骤：**

1. 继承 LinkedHashMap，重写 removeEldestEntry 方法
2. 在构造函数中设置 accessOrder 为 true，使其按访问顺序排序
3. put 操作直接调用父类方法
4. get 操作调用父类方法，LinkedHashMap 会自动调整顺序

```java
class LRUCache extends LinkedHashMap<Integer, Integer> {
    private int capacity;

    public LRUCache(int capacity) {
        // accessOrder设置为true，按照访问顺序排序
        super(capacity, 0.75f, true);
        this.capacity = capacity;
    }

    public int get(int key) {
        return super.getOrDefault(key, -1);
    }

    public void put(int key, int value) {
        super.put(key, value);
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
        return size() > capacity;
    }
}
```

**时间复杂度：** get 和 put 操作都是$O(1)$。

**空间复杂度：** $O(capacity)$。

### 方法三：手动实现哈希表（不推荐，仅供理解）

完全手动实现哈希表和双向链表，用于深入理解底层原理。

```java
class LRUCache {
    class Node {
        int key, value;
        Node prev, next;
        Node(int k, int v) {
            key = k;
            value = v;
        }
    }

    private Node[] table;
    private Node head, tail;
    private int capacity, size;
    private final int HASH_SIZE = 10007;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.table = new Node[HASH_SIZE];
        this.head = new Node(-1, -1);
        this.tail = new Node(-1, -1);
        head.next = tail;
        tail.prev = head;
    }

    private int hash(int key) {
        return (key % HASH_SIZE + HASH_SIZE) % HASH_SIZE;
    }

    private Node findNode(int key) {
        int hash = hash(key);
        Node node = table[hash];
        while (node != null) {
            if (node.key == key) return node;
            node = node.next;
        }
        return null;
    }

    // ... 其他辅助方法

    public int get(int key) {
        Node node = findNode(key);
        if (node == null) return -1;
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        // 实现逻辑类似方法一
    }
}
```

**推荐使用方法一（哈希表 + 双向链表）**，这是标准的 LRU 缓存实现方式，既能达到 $O(1)$ 的时间复杂度，又能完全掌握底层实现原理。方法二虽然简洁，但在面试中可能不被认为是完整实现。
