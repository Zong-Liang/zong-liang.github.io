---
title: "160-相交链表"
date: 2025-03-19 21:26:25 +0800
categories: [LEETCODE, HOT100]
tags: [链表, 简单]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/intersection-of-two-linked-lists/) \| 难度：简单

## 问题描述：

给你两个单链表的头节点 `headA` 和 `headB`，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null`。

图示两个链表在节点 `c1` 开始相交**：**

![img](../assets/img/posts/leetcode/p160_0.png)

题目数据**保证**整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须**保持其原始结构** 。

**自定义评测：**

**评测系统**的输入如下（你设计的程序**不适用**此输入）：

- `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`
- `listA` - 第一个链表
- `listB` - 第二个链表
- `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数
- `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数

评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被**视作正确答案** 。

**示例 1：**

![img](../assets/img/posts/leetcode/p160_1.png)

```java
输入: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出: Intersected at '8'
解释: 相交节点的值为 8 (注意, 如果两个链表相交则不能为 0)
从各自的表头开始算起, 链表 A 为 [4,1,8,4,5], 链表 B 为 [5,6,1,8,4,5]
在 A 中, 相交节点前有 2 个节点; 在 B 中, 相交节点前有 3 个节点
请注意相交节点的值不为 1, 因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点; 换句话说, 它们在内存中指向两个不同的位置, 而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点, B 中第四个节点) 在内存中指向相同的位置
```

**示例 2：**

![img](../assets/img/posts/leetcode/p160_2.png)

```java
输入: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出: Intersected at '2'
解释: 相交节点的值为 2 (注意, 如果两个链表相交则不能为 0)
从各自的表头开始算起, 链表 A 为 [1,9,1,2,4], 链表 B 为 [3,2,4]
在 A 中, 相交节点前有 3 个节点; 在 B 中, 相交节点前有 1 个节点
```

**示例 3：**

![img](../assets/img/posts/leetcode/p160_3.png)

```java
输入: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出: No intersection
解释: 从各自的表头开始算起, 链表 A 为 [2,6,4], 链表 B 为 [1,5]
由于这两个链表不相交, 所以 intersectVal 必须为 0, 而 skipA 和 skipB 可以是任意值
这两个链表不相交, 因此返回 null
```

## 解题思路：

这是一道寻找两个单链表相交节点的经典问题。从图中可以看出，需要找到两个链表第一次相交的节点。

### 方法一：双指针法（推荐）

**核心思想：** 让两个指针分别遍历两个链表，当某个指针到达链表末尾时，让它从另一个链表的头部开始继续遍历。这样可以消除两个链表长度差的影响。

**算法原理：**

- 设链表 A 的长度为 a，链表 B 的长度为 b，相交部分长度为 c
- 链表 A 独有部分长度为(a-c)，链表 B 独有部分长度为(b-c)
- 指针 pA 走过的路径：A 链表 + B 链表 = a + b
- 指针 pB 走过的路径：B 链表 + A 链表 = b + a
- 两个指针走过的总距离相同，所以会在相交点相遇

**算法步骤：**

1. 初始化两个指针 pA 和 pB，分别指向链表 A 和 B 的头节点
2. 同时移动两个指针
3. 当 pA 到达链表 A 末尾时，让它指向链表 B 的头节点
4. 当 pB 到达链表 B 末尾时，让它指向链表 A 的头节点
5. 当两个指针相遇时，相遇点就是相交节点

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // 处理边界情况
        if (headA == null || headB == null) {
            return null;
        }

        ListNode pA = headA;
        ListNode pB = headB;

        // 双指针遍历，消除长度差
        while (pA != pB) {
            // pA到达末尾时，从headB开始
            pA = (pA == null) ? headB : pA.next;
            // pB到达末尾时，从headA开始
            pB = (pB == null) ? headA : pB.next;
        }

        // 返回相交节点（如果不相交，返回null）
        return pA;
    }
}
```

**时间复杂度：** $O(m + n)$，其中 $m$ 和 $n$ 分别是两个链表的长度  
**空间复杂度：** $O(1)$，只使用了常数级额外空间

### 方法二：HashSet 法

**算法步骤：**

1. 遍历链表 A，将所有节点存入 HashSet
2. 遍历链表 B，检查每个节点是否在 HashSet 中
3. 第一个在 HashSet 中找到的节点就是相交节点

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }

        Set<ListNode> visited = new HashSet<>();

        // 将链表A的所有节点加入HashSet
        ListNode curr = headA;
        while (curr != null) {
            visited.add(curr);
            curr = curr.next;
        }

        // 遍历链表B，查找相交节点
        curr = headB;
        while (curr != null) {
            if (visited.contains(curr)) {
                return curr;
            }
            curr = curr.next;
        }

        return null;
    }
}
```

**时间复杂度：** $O(m + n)$

**空间复杂度：** $O(m)$，需要额外的 HashSet 存储空间

### 方法三：计算长度差法

**算法步骤：**

1. 分别计算两个链表的长度
2. 让较长链表的指针先走|lenA - lenB|步
3. 然后两个指针同时移动，直到相遇

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }

        // 计算两个链表的长度
        int lenA = getLength(headA);
        int lenB = getLength(headB);

        // 让较长的链表先走差值步数
        ListNode pA = headA;
        ListNode pB = headB;

        if (lenA > lenB) {
            for (int i = 0; i < lenA - lenB; i++) {
                pA = pA.next;
            }
        } else {
            for (int i = 0; i < lenB - lenA; i++) {
                pB = pB.next;
            }
        }

        // 同时移动直到相遇
        while (pA != null && pB != null) {
            if (pA == pB) {
                return pA;
            }
            pA = pA.next;
            pB = pB.next;
        }

        return null;
    }

    private int getLength(ListNode head) {
        int length = 0;
        while (head != null) {
            length++;
            head = head.next;
        }
        return length;
    }
}
```

**时间复杂度：** $O(m + n)$

**空间复杂度：** $O(1)$

**推荐使用方法一（双指针法）**，因为它代码简洁优雅，时间空间复杂度都是最优的，且不需要额外计算链表长度。
