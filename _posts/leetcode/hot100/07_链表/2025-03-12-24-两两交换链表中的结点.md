---
title: "24-两两交换链表中的结点"
date: 2025-03-12 21:23:54 +0800
categories: [LEETCODE, HOT100]
tags: [链表, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/swap-nodes-in-pairs/) \| 难度: 中等

## 问题描述:

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例 1：**

![img](../assets/img/posts/leetcode/p24_0.jpg)

```java
输入: head = [1,2,3,4]
输出: [2,1,4,3]
```

**示例 2：**

```java
输入: head = []
输出: []
```

**示例 3：**

```java
输入: head = [1]
输出: [1]
```

## 解题思路：

这是一道关于链表中两两交换相邻节点的问题。需要将链表中每相邻的两个节点进行位置交换。

### 方法一：迭代法（推荐）

核心思想是使用三个指针来跟踪当前需要交换的两个节点以及它们的前一个节点。

**算法步骤：**

1. 创建虚拟头节点 dummy，简化边界处理
2. 使用 prev 指针指向当前需要交换的两个节点的前一个节点
3. 获取需要交换的两个节点 first 和 second
4. 执行交换操作：prev -> second -> first -> second.next
5. 更新 prev 指针，继续处理下一对节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        // 创建虚拟头节点，简化边界处理
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy;

        // 当存在至少两个节点时继续交换
        while (prev.next != null && prev.next.next != null) {
            // 获取需要交换的两个节点
            ListNode first = prev.next;
            ListNode second = prev.next.next;

            // 执行交换操作
            // 原来: prev -> first -> second -> second.next
            // 交换后: prev -> second -> first -> second.next
            prev.next = second;
            first.next = second.next;
            second.next = first;

            // 更新prev指针到已交换的第二个节点（原来的first）
            prev = first;
        }

        return dummy.next;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是链表的长度，需要遍历整个链表一次。

**空间复杂度：** $O(1)$，只使用了常数个额外指针。

### 方法二：递归法

使用递归的思想，每次处理两个节点的交换，然后递归处理剩余部分。

**算法步骤：**

1. 基础情况：如果链表为空或只有一个节点，直接返回
2. 获取前两个节点 first 和 second
3. 递归处理剩余部分，将结果连接到 first
4. 交换 first 和 second 的位置
5. 返回交换后的头节点 second

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        // 基础情况：空链表或只有一个节点
        if (head == null || head.next == null) {
            return head;
        }

        // 获取前两个节点
        ListNode first = head;
        ListNode second = head.next;

        // 递归处理剩余部分，并连接到first
        first.next = swapPairs(second.next);

        // 交换两个节点
        second.next = first;

        // 返回新的头节点
        return second;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是链表的长度，每个节点访问一次。

**空间复杂度：** $O(n)$，递归调用栈的深度为 $n/2$。

### 方法三：值交换法（简化版本）

如果只需要交换节点的值而不是节点本身，可以直接交换值。

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode current = head;

        // 遍历链表，每次处理两个节点
        while (current != null && current.next != null) {
            // 交换两个节点的值
            int temp = current.val;
            current.val = current.next.val;
            current.next.val = temp;

            // 移动到下一对节点
            current = current.next.next;
        }

        return head;
    }
}
```

**时间复杂度：** $O(n)$

**空间复杂度：** $O(1)$

**推荐使用方法一（迭代法）**，因为它空间效率高，逻辑清晰，易于理解和调试。如果题目要求不能修改节点值，则不能使用方法三。
