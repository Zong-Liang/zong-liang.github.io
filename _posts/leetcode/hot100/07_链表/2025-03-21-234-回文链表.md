---
title: "234-回文链表"
date: 2025-03-21 21:27:00 +0800
categories: [LEETCODE, HOT100]
tags: [链表, 简单]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/palindrome-linked-list/) \| 难度: 简单

## 问题描述:

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

**示例 1:**

![img](../assets/img/posts/leetcode/p234_0.jpg)

```
输入: head = [1,2,2,1]
输出: true
```

**示例 2:**

![img](../assets/img/posts/leetcode/p234_1.jpg)

```java
输入: head = [1,2]
输出: false
```

## 解题思路：

这是一道关于判断链表是否为回文链表的问题。回文链表是指正向遍历和反向遍历得到的值序列相同。

### 方法一：快慢指针 + 反转后半部分（推荐）

核心思想是找到链表中点，反转后半部分，然后与前半部分逐一比较。

**算法步骤：**

1. 使用快慢指针找到链表中点
2. 反转链表的后半部分
3. 同时遍历前半部分和反转后的后半部分进行比较
4. 可选：恢复链表的原始结构

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) {
            return true;
        }

        // 第一步：使用快慢指针找到中点
        ListNode slow = head;
        ListNode fast = head;

        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        // 第二步：反转后半部分链表
        ListNode secondHalf = reverseList(slow.next);

        // 第三步：比较前半部分和反转后的后半部分
        ListNode firstHalf = head;
        ListNode reversedSecondHalf = secondHalf;

        boolean isPalindrome = true;
        while (reversedSecondHalf != null) {
            if (firstHalf.val != reversedSecondHalf.val) {
                isPalindrome = false;
                break;
            }
            firstHalf = firstHalf.next;
            reversedSecondHalf = reversedSecondHalf.next;
        }

        // 第四步（可选）：恢复链表原始结构
        slow.next = reverseList(secondHalf);

        return isPalindrome;
    }

    // 辅助方法：反转链表
    private ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;

        while (curr != null) {
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }

        return prev;
    }
}
```

**时间复杂度：** $O(n)$，需要遍历链表常数次。

**空间复杂度：** $O(1)$，只使用了常数个额外变量。

### 方法二：数组转换法

将链表转换为数组，然后使用双指针判断是否为回文。

**算法步骤：**

1. 遍历链表，将所有值存储到数组中
2. 使用双指针从数组两端向中间比较

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        List<Integer> vals = new ArrayList<>();

        // 将链表值转换为数组
        ListNode curr = head;
        while (curr != null) {
            vals.add(curr.val);
            curr = curr.next;
        }

        // 双指针判断回文
        int left = 0;
        int right = vals.size() - 1;

        while (left < right) {
            if (!vals.get(left).equals(vals.get(right))) {
                return false;
            }
            left++;
            right--;
        }

        return true;
    }
}
```

**时间复杂度：** $O(n)$，需要遍历链表一次。

**空间复杂度：** $O(n)$，需要额外的数组存储所有值。

### 方法三：递归法

利用递归的特性，从链表尾部开始比较。

```java
class Solution {
    private ListNode frontPointer;

    public boolean isPalindrome(ListNode head) {
        frontPointer = head;
        return recursivelyCheck(head);
    }

    private boolean recursivelyCheck(ListNode currentNode) {
        if (currentNode != null) {
            if (!recursivelyCheck(currentNode.next)) {
                return false;
            }
            if (currentNode.val != frontPointer.val) {
                return false;
            }
            frontPointer = frontPointer.next;
        }
        return true;
    }
}
```

**时间复杂度：** $O(n)$，每个节点访问一次。

**空间复杂度：** $O(n)$，递归调用栈深度为链表长度。

### 方法四：栈辅助法

使用栈存储前半部分节点值，然后与后半部分比较。

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) {
            return true;
        }

        // 快慢指针找中点
        ListNode slow = head;
        ListNode fast = head;
        Stack<Integer> stack = new Stack<>();

        // 将前半部分压入栈中
        while (fast != null && fast.next != null) {
            stack.push(slow.val);
            slow = slow.next;
            fast = fast.next.next;
        }

        // 如果链表长度为奇数，跳过中间节点
        if (fast != null) {
            slow = slow.next;
        }

        // 比较栈中元素与后半部分
        while (slow != null) {
            if (stack.pop() != slow.val) {
                return false;
            }
            slow = slow.next;
        }

        return true;
    }
}
```

**时间复杂度：** $O(n)$，遍历链表一次。

**空间复杂度：** $O(n/2) = O(n)$，栈存储前半部分节点值。

**推荐使用方法一（快慢指针 + 反转后半部分）**，因为它空间复杂度最优，是 $O(1)$ 的解法，同时时间复杂度也是最优的 $O(n)$。如果不允许修改原链表结构，可以选择方法二（数组转换法），代码更简洁易懂。
