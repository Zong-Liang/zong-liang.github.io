---
title: "138-随机链表的复制"
date: 2025-03-14 21:24:50 +0800
categories: [LEETCODE, HOT100]
tags: [链表, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/copy-list-with-random-pointer/) \| 难度: 中等

## 问题描述:

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random`，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个**全新**节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y`。那么在复制链表中对应的两个节点 `x` 和 `y`，同样有 `x.random --> y`。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

- `val`: 一个表示 `Node.val` 的整数。
- `random_index`: 随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。

你的代码**只**接受原链表的头节点 `head` 作为传入参数。

**示例 1：**

![img](../assets/img/posts/leetcode/p138_0.png)

```java
输入: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出: [[7,null],[13,0],[11,4],[10,2],[1,0]]
```

**示例 2：**

![img](../assets/img/posts/leetcode/p138_1.png)

```java
输入: head = [[1,1],[2,1]]
输出: [[1,1],[2,1]]
```

**示例 3：**

![img](../assets/img/posts/leetcode/p138_2.png)

```java
输入: head = [[3,null],[3,0],[3,null]]
输出: [[3,null],[3,0],[3,null]]
```

## 解题思路：

这是一道关于链表深度复制的问题。链表中每个节点除了有指向下一个节点的 next 指针，还有一个 random 指针可以指向链表中的任意节点或者 null。需要创建这个链表的深度拷贝。

### 方法一：哈希表映射法（推荐）

核心思想是使用哈希表建立原节点和新节点之间的映射关系，然后通过两次遍历完成复制。

**算法步骤：**

1. 第一次遍历：创建所有新节点，建立原节点到新节点的映射关系
2. 第二次遍历：根据映射关系设置新节点的 next 和 random 指针
3. 返回新链表的头节点

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }

        // 创建原节点到新节点的映射
        Map<Node, Node> map = new HashMap<>();

        // 第一次遍历：创建所有新节点
        Node curr = head;
        while (curr != null) {
            map.put(curr, new Node(curr.val));
            curr = curr.next;
        }

        // 第二次遍历：设置新节点的next和random指针
        curr = head;
        while (curr != null) {
            Node newNode = map.get(curr);
            newNode.next = map.get(curr.next);
            newNode.random = map.get(curr.random);
            curr = curr.next;
        }

        return map.get(head);
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是链表的长度，需要遍历链表两次。

**空间复杂度：** $O(n)$，需要额外的哈希表存储映射关系。

### 方法二：递归 + 哈希表

使用递归的方式创建新节点，同样利用哈希表避免重复创建。

**算法步骤：**

1. 使用哈希表记录已创建的节点
2. 递归创建当前节点，如果已存在则直接返回
3. 递归创建 next 和 random 指向的节点

```java
class Solution {
    private Map<Node, Node> visited = new HashMap<>();

    public Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }

        // 如果已经创建过该节点，直接返回
        if (visited.containsKey(head)) {
            return visited.get(head);
        }

        // 创建新节点
        Node newNode = new Node(head.val);
        visited.put(head, newNode);

        // 递归创建next和random节点
        newNode.next = copyRandomList(head.next);
        newNode.random = copyRandomList(head.random);

        return newNode;
    }
}
```

**时间复杂度：** $O(n)$，每个节点最多访问一次。

**空间复杂度：** $O(n)$，递归调用栈和哈希表的空间。

### 方法三：节点拆分法（空间优化）

通过在原链表中插入新节点，然后拆分的方式实现复制，不需要额外的哈希表。

**算法步骤：**

1. 第一次遍历：在每个原节点后插入对应的新节点
2. 第二次遍历：设置新节点的 random 指针
3. 第三次遍历：拆分链表，恢复原链表并得到新链表

```java
class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }

        // 第一步：在每个节点后面插入复制的节点
        Node curr = head;
        while (curr != null) {
            Node newNode = new Node(curr.val);
            newNode.next = curr.next;
            curr.next = newNode;
            curr = newNode.next;
        }

        // 第二步：设置复制节点的random指针
        curr = head;
        while (curr != null) {
            if (curr.random != null) {
                curr.next.random = curr.random.next;
            }
            curr = curr.next.next;
        }

        // 第三步：拆分链表
        Node newHead = head.next;
        Node original = head;
        Node copy = newHead;

        while (original != null) {
            original.next = copy.next;
            if (copy.next != null) {
                copy.next = copy.next.next;
            }
            original = original.next;
            copy = copy.next;
        }

        return newHead;
    }
}
```

**时间复杂度：** $O(n)$，需要遍历链表三次。

**空间复杂度：** $O(1)$，不需要额外的哈希表空间。

### 方法四：一次遍历优化版

结合哈希表，在一次遍历中完成所有操作。

```java
class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }

        Map<Node, Node> map = new HashMap<>();

        // 辅助函数：获取或创建节点
        map.put(null, null); // 处理random为null的情况

        Node curr = head;
        Node newHead = null;
        Node newPrev = null;

        while (curr != null) {
            // 创建或获取当前节点的拷贝
            Node newCurr = map.computeIfAbsent(curr, k -> new Node(k.val));

            // 设置新链表的头节点
            if (newHead == null) {
                newHead = newCurr;
            }

            // 连接前一个节点
            if (newPrev != null) {
                newPrev.next = newCurr;
            }

            // 处理random指针
            if (curr.random != null) {
                newCurr.random = map.computeIfAbsent(curr.random, k -> new Node(k.val));
            }

            newPrev = newCurr;
            curr = curr.next;
        }

        return newHead;
    }
}
```

**时间复杂度：** $O(n)$

**空间复杂度：** $O(n)$

**推荐使用方法一（哈希表映射法）**，因为它思路清晰，易于理解和实现，代码简洁。如果对空间复杂度有严格要求，可以使用方法三（节点拆分法）。
