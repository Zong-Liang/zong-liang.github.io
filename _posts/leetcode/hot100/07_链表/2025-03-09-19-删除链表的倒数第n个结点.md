---
title: "19-删除链表的倒数第N个结点"
date: 2025-03-09 21:22:38 +0800
categories: [LEETCODE, HOT100]
tags: [链表, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/) \| 难度: 中等

## 问题描述:

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例 1：**

![img](../assets/img/posts/leetcode/p19_0.jpg)

```java
输入: head = [1,2,3,4,5], n = 2
输出: [1,2,3,5]
```

**示例 2：**

```java
输入: head = [1], n = 1
输出: []
```

**示例 3：**

```java
输入: head = [1,2], n = 1
输出: [1]
```

**进阶:** 你能尝试使用一趟扫描实现吗？

## 解题思路：

这是一道关于删除链表倒数第 N 个节点的问题。需要在一次遍历中找到并删除倒数第 N 个节点。

### 方法一：双指针法（推荐）

核心思想是使用快慢指针，让快指针先走 N 步，然后快慢指针同时移动，当快指针到达末尾时，慢指针正好指向倒数第 N 个节点的前一个节点。

**算法步骤：**

1. 创建虚拟头节点，处理边界情况（如删除第一个节点）
2. 设置快慢双指针，都指向虚拟头节点
3. 快指针先移动 N+1 步（为了让慢指针停在要删除节点的前一个位置）
4. 快慢指针同时移动，直到快指针到达末尾
5. 删除慢指针的下一个节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 创建虚拟头节点，便于处理删除第一个节点的情况
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        // 初始化快慢指针
        ListNode fast = dummy;
        ListNode slow = dummy;

        // 快指针先移动 n+1 步
        for (int i = 0; i <= n; i++) {
            fast = fast.next;
        }

        // 快慢指针同时移动，直到快指针到达末尾
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }

        // 此时 slow 指向要删除节点的前一个节点
        // 删除倒数第 n 个节点
        slow.next = slow.next.next;

        return dummy.next;
    }
}
```

**时间复杂度：** $O(L)$，其中 $L$ 是链表长度，只需要一次遍历。

**空间复杂度：** $O(1)$，只使用了常数级别的额外空间。

### 方法二：两次遍历法

先遍历一次计算链表长度，再遍历一次找到要删除的节点。

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 创建虚拟头节点
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        // 第一次遍历：计算链表长度
        int length = 0;
        ListNode current = head;
        while (current != null) {
            length++;
            current = current.next;
        }

        // 第二次遍历：找到要删除节点的前一个节点
        current = dummy;
        for (int i = 0; i < length - n; i++) {
            current = current.next;
        }

        // 删除目标节点
        current.next = current.next.next;

        return dummy.next;
    }
}
```

**时间复杂度：** $O(L)$，需要两次遍历，但仍是线性时间。

**空间复杂度：** $O(1)$

### 方法三：使用栈

将所有节点压入栈中，然后弹出 N 个节点，栈顶就是要删除节点的前一个节点。

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        // 将所有节点压入栈
        Stack<ListNode> stack = new Stack<>();
        ListNode current = dummy;
        while (current != null) {
            stack.push(current);
            current = current.next;
        }

        // 弹出 n 个节点
        for (int i = 0; i < n; i++) {
            stack.pop();
        }

        // 栈顶元素就是要删除节点的前一个节点
        ListNode prev = stack.peek();
        prev.next = prev.next.next;

        return dummy.next;
    }
}
```

**时间复杂度：** $O(L)$

**空间复杂度：** $O(L)$，需要额外的栈空间。

### 方法四：递归解法

使用递归的方式，在回溯过程中计数并删除目标节点。

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        removeHelper(dummy, n);
        return dummy.next;
    }

    private int removeHelper(ListNode node, int n) {
        if (node.next == null) {
            return 0;
        }

        int count = removeHelper(node.next, n);
        if (count == n) {
            // 删除下一个节点
            node.next = node.next.next;
        }

        return count + 1;
    }
}
```

**时间复杂度：** $O(L)$

**空间复杂度：** $O(L)$，递归调用栈的深度。

### 关键点总结：

1. **虚拟头节点**：处理删除第一个节点的边界情况
2. **双指针间距**：快指针先走 N+1 步，确保慢指针停在目标节点的前一个位置
3. **边界处理**：考虑链表长度等于 N 的情况
4. **一次遍历**：双指针法只需要一次遍历，效率最高

**推荐使用方法一（双指针法）**，因为它只需要一次遍历，空间复杂度最优，是解决此类问题的经典方法。题目进阶要求能否用一趟扫描实现，双指针法完美满足这个要求。
