---
title: "48-旋转图像"
date: 2025-03-04 21:20:19 +0800
categories: [LEETCODE, HOT100]
tags: [矩阵, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/rotate-image/) \| 难度: 中等

## 问题描述:

给定一个 _n_ × _n_ 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 [原地](https://baike.baidu.com/item/原地算法) 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要**使用另一个矩阵来旋转图像。

**示例 1：**

![img](../assets/img/posts/leetcode/p48_0.jpg)

```java
输入: matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出: [[7,4,1],[8,5,2],[9,6,3]]
```

**示例 2：**

![img](../assets/img/posts/leetcode/p48_1.jpg)

```java
输入: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

## 解题思路:

这道题是"旋转图像"问题。要求将 n×n 的二维矩阵顺时针旋转 90 度，并且要求原地旋转，不能使用另一个矩阵。

### 方法一：先转置再翻转（推荐）

将矩阵顺时针旋转 90 度可以分解为两个步骤：

1. 先将矩阵转置（沿主对角线翻转）
2. 再将每一行进行水平翻转

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;

        // 第一步：转置矩阵（沿主对角线翻转）
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }

        // 第二步：水平翻转每一行
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n / 2; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][n - 1 - j];
                matrix[i][n - 1 - j] = temp;
            }
        }
    }
}
```

**时间复杂度**：$O(n^2)$，需要遍历矩阵中的每个元素。

**空间复杂度**：$O(1)$，只使用常数额外空间。

### 方法二：四点循环交换

通过找到旋转规律，直接进行四个位置的循环交换。对于位置 (i,j)，旋转后会到达 (j, n-1-i)。

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;

        // 只需要处理左上角的 1/4 区域
        for (int i = 0; i < (n + 1) / 2; i++) {
            for (int j = 0; j < n / 2; j++) {
                // 四个位置的循环交换
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - 1 - j][i];
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];
                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];
                matrix[j][n - 1 - i] = temp;
            }
        }
    }
}
```

**时间复杂度**：$O(n^2)$，需要遍历矩阵中的每个元素。

**空间复杂度**：$O(1)$，只使用常数额外空间。

### 方法三：环形旋转

按照环形结构进行旋转，从外圈到内圈逐层处理。

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;

        // 从外圈到内圈，逐层旋转
        for (int layer = 0; layer < n / 2; layer++) {
            int first = layer;
            int last = n - 1 - layer;

            for (int i = first; i < last; i++) {
                int offset = i - first;

                // 保存上边
                int top = matrix[first][i];

                // 左边 -> 上边
                matrix[first][i] = matrix[last - offset][first];

                // 下边 -> 左边
                matrix[last - offset][first] = matrix[last][last - offset];

                // 右边 -> 下边
                matrix[last][last - offset] = matrix[i][last];

                // 上边 -> 右边
                matrix[i][last] = top;
            }
        }
    }
}
```

**时间复杂度**：$O(n^2)$，需要遍历矩阵中的每个元素。

**空间复杂度**：$O(1)$，只使用常数额外空间。

**推荐使用方法一（先转置再翻转）**，它思路最直观，代码最简洁，容易理解和记忆。

**核心思想**：

1. **方法一**：转置 + 水平翻转 = 顺时针旋转 90°
2. **方法二**：直接找到四个相关位置进行循环交换
3. **方法三**：按环形结构逐层旋转

**变换过程示例（3×3 矩阵）**：

```
原矩阵:     转置后:      水平翻转后:
1 2 3      1 4 7       7 4 1
4 5 6  ->  2 5 8   ->  8 5 2
7 8 9      3 6 9       9 6 3
```
