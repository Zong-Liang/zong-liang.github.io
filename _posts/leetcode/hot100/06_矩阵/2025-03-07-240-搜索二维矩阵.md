---
title: "240-搜索二维矩阵"
date: 2025-03-07 21:21:29 +0800
categories: [LEETCODE, HOT100]
tags: [矩阵, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/search-a-2d-matrix-ii/) \| 难度: 中等

## 问题描述:

编写一个高效的算法来搜索 `m x n` 矩阵 `matrix` 中的一个目标值 `target`。该矩阵具有以下特性:

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

**示例 1：**

![img](../assets/img/posts/leetcode/p240_0.jpg)

```java
输入: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出: true
```

**示例 2：**

![img](../assets/img/posts/leetcode/p240_1.jpg)

```java
输入: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出: false
```

## 解题思路：

这是一道关于搜索二维矩阵的问题。矩阵具有特殊性质：每行的元素从左到右升序排列，每列的元素从上到下升序排列。需要在这样的矩阵中高效地搜索目标值。

### 方法一：从右上角开始搜索（推荐）

核心思想是利用矩阵的有序性质，从右上角（或左下角）开始搜索，根据当前元素与目标值的比较结果决定搜索方向。

**算法步骤：**

1. 从矩阵的右上角开始搜索（row = 0, col = n-1）
2. 如果当前元素等于目标值，返回 true
3. 如果当前元素大于目标值，向左移动（col--）
4. 如果当前元素小于目标值，向下移动（row++）
5. 重复步骤 2-4，直到找到目标值或越界

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }

        int m = matrix.length;
        int n = matrix[0].length;

        // 从右上角开始搜索
        int row = 0;
        int col = n - 1;

        while (row < m && col >= 0) {
            int current = matrix[row][col];

            if (current == target) {
                return true;
            } else if (current > target) {
                // 当前值大于目标值，向左移动
                col--;
            } else {
                // 当前值小于目标值，向下移动
                row++;
            }
        }

        return false;
    }
}
```

**时间复杂度：** $O(m + n)$，其中 $m$ 是矩阵行数，$n$ 是矩阵列数。最坏情况下需要遍历一行加一列。

**空间复杂度：** $O(1)$，只使用了常数级别的额外空间。

### 方法二：从左下角开始搜索

同样利用矩阵的有序性质，从左下角开始搜索。

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }

        int m = matrix.length;
        int n = matrix[0].length;

        // 从左下角开始搜索
        int row = m - 1;
        int col = 0;

        while (row >= 0 && col < n) {
            int current = matrix[row][col];

            if (current == target) {
                return true;
            } else if (current > target) {
                // 当前值大于目标值，向上移动
                row--;
            } else {
                // 当前值小于目标值，向右移动
                col++;
            }
        }

        return false;
    }
}
```

**时间复杂度：** $O(m + n)$

**空间复杂度：** $O(1)$

### 方法三：二分搜索每一行

对每一行进行二分搜索，虽然可行但效率不如前两种方法。

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }

        int m = matrix.length;
        int n = matrix[0].length;

        for (int i = 0; i < m; i++) {
            // 如果目标值在当前行的范围内，进行二分搜索
            if (matrix[i][0] <= target && target <= matrix[i][n - 1]) {
                if (binarySearch(matrix[i], target)) {
                    return true;
                }
            }
        }

        return false;
    }

    private boolean binarySearch(int[] row, int target) {
        int left = 0;
        int right = row.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (row[mid] == target) {
                return true;
            } else if (row[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return false;
    }
}
```

**时间复杂度：** $O(m \log n)$，对每一行进行二分搜索。

**空间复杂度：** $O(1)$

### 方法四：暴力搜索

遍历整个矩阵，时间复杂度较高，不推荐。

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }

        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (matrix[i][j] == target) {
                    return true;
                }
            }
        }

        return false;
    }
}
```

**时间复杂度：** $O(m \times n)$

**空间复杂度：** $O(1)$

**推荐使用方法一（从右上角开始搜索）**，因为它充分利用了矩阵的有序性质，时间复杂度最优，代码简洁易懂。从左下角开始搜索的方法二也同样优秀，两者选择其一即可。
