---
title: "416-分割等和子集"
date: 2025-05-15 21:48:27 +0800
categories: [LEETCODE, HOT100]
tags: [动态规划, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/partition-equal-subset-sum/) \| 难度: 中等

## 问题描述:

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**示例 1：**

```java
输入: nums = [1,5,11,5]
输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11]
```

**示例 2：**

```java
输入: nums = [1,2,3,5]
输出: false
解释: 数组不能分割成两个元素和相等的子集
```

## 解题思路：

这是一道关于分割等和子集的动态规划问题。本质上是判断能否从数组中选出一个子集，使其元素之和等于数组总和的一半。

### 方法一：动态规划法（推荐）

核心思想是将问题转化为背包问题：能否用数组中的数字凑出 sum/2 的和。

**算法步骤：**

1. 计算数组总和，如果为奇数则无法分割，直接返回 false
2. 目标是找到和为 sum/2 的子集
3. 使用动态规划，dp[i] 表示能否凑出和为 i 的子集
4. 对于每个数字，更新所有可能的和

```java
class Solution {
    public boolean canPartition(int[] nums) {
        if (nums == null || nums.length < 2) {
            return false;
        }

        int sum = 0;
        int maxNum = 0;

        // 计算总和和最大值
        for (int num : nums) {
            sum += num;
            maxNum = Math.max(maxNum, num);
        }

        // 如果总和为奇数，无法分割成两个相等的子集
        if (sum % 2 == 1) {
            return false;
        }

        int target = sum / 2;

        // 如果最大值大于目标值，无法分割
        if (maxNum > target) {
            return false;
        }

        // dp[i] 表示能否凑出和为 i 的子集
        boolean[] dp = new boolean[target + 1];
        dp[0] = true; // 和为0的子集总是存在（空集）

        for (int num : nums) {
            // 从后往前遍历，避免重复使用同一个数字
            for (int j = target; j >= num; j--) {
                dp[j] = dp[j] || dp[j - num];
            }
        }

        return dp[target];
    }
}
```

**时间复杂度：** $O(n \times sum)$，其中 $n$ 是数组长度，$sum$ 是数组元素之和。

**空间复杂度：** $O(sum)$，需要额外的 dp 数组。

### 方法二：二维动态规划法

使用二维数组更清晰地表示状态转移过程。

**算法步骤：**

1. dp[i][j] 表示使用前 i 个数字能否凑出和为 j 的子集
2. 状态转移：dp[i][j] = dp[i-1][j] || dp[i-1]j-nums[i-1]]
3. 第一种情况是不选当前数字，第二种情况是选当前数字

```java
class Solution {
    public boolean canPartition(int[] nums) {
        if (nums == null || nums.length < 2) {
            return false;
        }

        int sum = 0;
        for (int num : nums) {
            sum += num;
        }

        if (sum % 2 == 1) {
            return false;
        }

        int target = sum / 2;
        int n = nums.length;

        // dp[i][j] 表示使用前i个数字能否凑出和为j的子集
        boolean[][] dp = new boolean[n + 1][target + 1];

        // 初始化：和为0的子集总是存在
        for (int i = 0; i <= n; i++) {
            dp[i][0] = true;
        }

        for (int i = 1; i <= n; i++) {
            int num = nums[i - 1];
            for (int j = 1; j <= target; j++) {
                // 不选当前数字
                dp[i][j] = dp[i - 1][j];

                // 选当前数字（如果可能的话）
                if (j >= num) {
                    dp[i][j] = dp[i][j] || dp[i - 1][j - num];
                }
            }
        }

        return dp[n][target];
    }
}
```

**时间复杂度：** $O(n \times sum)$，其中 $n$ 是数组长度，$sum$ 是数组元素之和。

**空间复杂度：** $O(n \times sum)$，需要二维 dp 数组。

### 方法三：位运算优化

使用 BitSet 来优化空间和时间复杂度。

**算法步骤：**

1. 使用 BitSet 表示所有可能的和
2. 对于每个数字，更新 BitSet
3. 最后检查目标位是否被设置

```java
import java.util.BitSet;

class Solution {
    public boolean canPartition(int[] nums) {
        if (nums == null || nums.length < 2) {
            return false;
        }

        int sum = 0;
        for (int num : nums) {
            sum += num;
        }

        if (sum % 2 == 1) {
            return false;
        }

        int target = sum / 2;

        // 使用 BitSet 表示所有可能的和
        BitSet bits = new BitSet(target + 1);
        bits.set(0); // 和为0总是可能的

        for (int num : nums) {
            // 创建新的 BitSet 来避免重复使用同一个数字
            BitSet newBits = (BitSet) bits.clone();
            newBits.or(bits.get(0, target + 1 - num) << num);
            bits = newBits;

            // 提前结束
            if (bits.get(target)) {
                return true;
            }
        }

        return bits.get(target);
    }
}
```

### 方法四：递归 + 记忆化搜索

使用递归的思路，加上记忆化避免重复计算。

```java
class Solution {
    private Boolean[][] memo;

    public boolean canPartition(int[] nums) {
        if (nums == null || nums.length < 2) {
            return false;
        }

        int sum = 0;
        for (int num : nums) {
            sum += num;
        }

        if (sum % 2 == 1) {
            return false;
        }

        int target = sum / 2;
        memo = new Boolean[nums.length][target + 1];

        return canPartitionHelper(nums, 0, target);
    }

    private boolean canPartitionHelper(int[] nums, int index, int target) {
        if (target == 0) {
            return true;
        }

        if (index >= nums.length || target < 0) {
            return false;
        }

        if (memo[index][target] != null) {
            return memo[index][target];
        }

        // 选择当前数字或不选择当前数字
        boolean result = canPartitionHelper(nums, index + 1, target - nums[index]) ||
                        canPartitionHelper(nums, index + 1, target);

        memo[index][target] = result;
        return result;
    }
}
```

**时间复杂度：** $O(n \times sum)$，每个状态最多计算一次。

**空间复杂度：** $O(n \times sum)$，递归栈和记忆化数组的空间。

**推荐使用方法一（一维动态规划法）**，因为它空间效率高，代码简洁，是经典的背包问题解法。核心思想是将问题转化为：能否从数组中选择一些数字使其和等于总和的一半。通过动态规划逐步构建所有可能的和。
