---
title: "300-最长递增子序列"
date: 2025-05-13 21:47:34 +0800
categories: [LEETCODE, HOT100]
tags: [动态规划, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/longest-increasing-subsequence/) \| 难度: 中等

## 问题描述:

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```java
输入: nums = [10,9,2,5,3,7,101,18]
输出: 4
解释: 最长递增子序列是 [2,3,7,101], 因此长度为 4
```

**示例 2：**

```java
输入: nums = [0,1,0,3,2,3]
输出: 4
```

**示例 3：**

```java
输入: nums = [7,7,7,7,7,7,7]
输出: 1
```

**进阶：**你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

## 解题思路：

这是一道关于寻找最长递增子序列（LIS）长度的经典动态规划问题。需要找到数组中严格递增的子序列的最大长度。

### 方法一：动态规划法

核心思想是定义 dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度。

**算法步骤：**

1. 创建 dp 数组，dp[i] 表示以第 i 个元素结尾的最长递增子序列长度
2. 初始化所有 dp[i] = 1（每个元素自身构成长度为 1 的序列）
3. 对于每个位置 i，检查所有前面的位置 j，如果 nums[j] < nums[i]，则可以将 nums[i] 接在以 nums[j] 结尾的序列后面
4. 返回 dp 数组中的最大值

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        int[] dp = new int[n];
        Arrays.fill(dp, 1); // 每个元素自身构成长度为1的序列

        int maxLength = 1;

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxLength = Math.max(maxLength, dp[i]);
        }

        return maxLength;
    }
}
```

**时间复杂度：** $O(n^2)$，双重循环遍历数组。

**空间复杂度：** $O(n)$，需要额外的 dp 数组。

### 方法二：二分查找 + 贪心法（推荐）

核心思想是维护一个数组 tails，其中 tails[i] 表示长度为 i+1 的递增子序列的最小尾元素。

**算法步骤：**

1. 维护 tails 数组，tails[i] 表示长度为 i+1 的递增子序列的最小尾元素
2. 对于每个元素 num，在 tails 中二分查找第一个大于等于 num 的位置
3. 如果找到，则更新该位置；如果没找到，则在末尾添加
4. tails 数组的长度即为最长递增子序列的长度

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        List<Integer> tails = new ArrayList<>();

        for (int num : nums) {
            // 二分查找第一个大于等于 num 的位置
            int left = 0, right = tails.size();

            while (left < right) {
                int mid = left + (right - left) / 2;
                if (tails.get(mid) < num) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }

            // 如果 left == tails.size()，说明 num 比所有元素都大，添加到末尾
            if (left == tails.size()) {
                tails.add(num);
            } else {
                // 否则更新 left 位置的元素
                tails.set(left, num);
            }
        }

        return tails.size();
    }
}
```

**时间复杂度：** $O(n \log n)$，其中 $n$ 是数组长度，每个元素需要进行二分查找。

**空间复杂度：** $O(n)$，需要额外的 tails 数组。

### 方法三：使用 Arrays.binarySearch 优化

利用 Java 内置的二分查找方法简化代码。

**算法步骤：**

1. 使用动态数组存储 tails
2. 利用 Collections.binarySearch 进行二分查找
3. 根据返回值判断是更新还是添加元素

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        List<Integer> tails = new ArrayList<>();

        for (int num : nums) {
            int pos = Collections.binarySearch(tails, num);

            if (pos < 0) {
                pos = -(pos + 1); // 转换为插入位置
            }

            if (pos == tails.size()) {
                tails.add(num);
            } else {
                tails.set(pos, num);
            }
        }

        return tails.size();
    }
}
```

**时间复杂度：** $O(n \log n)$，其中 $n$ 是数组长度。

**空间复杂度：** $O(n)$，需要额外的 tails 数组。

### 方法四：记录实际序列的动态规划

如果需要返回实际的最长递增子序列，而不仅仅是长度。

**算法步骤：**

1. 在动态规划的基础上，额外维护前驱数组
2. 记录每个位置的最优前驱位置
3. 通过回溯构造实际的最长递增子序列

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        int[] dp = new int[n];
        int[] prev = new int[n]; // 记录前驱位置
        Arrays.fill(dp, 1);
        Arrays.fill(prev, -1);

        int maxLength = 1;
        int maxIndex = 0;

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i] && dp[j] + 1 > dp[i]) {
                    dp[i] = dp[j] + 1;
                    prev[i] = j;
                }
            }

            if (dp[i] > maxLength) {
                maxLength = dp[i];
                maxIndex = i;
            }
        }

        // 如果需要构造实际序列，可以通过 prev 数组回溯
        // List<Integer> lis = new ArrayList<>();
        // int current = maxIndex;
        // while (current != -1) {
        //     lis.add(0, nums[current]);
        //     current = prev[current];
        // }

        return maxLength;
    }
}
```

**时间复杂度：** $O(n^2)$，双重循环遍历数组。

**空间复杂度：** $O(n)$，需要额外的 dp 和 prev 数组。

**推荐使用方法二（二分查找 + 贪心法）**，因为它达到了 $O(n \log n)$ 的最优时间复杂度，满足进阶要求。核心思想是贪心地维护每个长度的递增子序列的最小尾元素，这样可以为后续元素提供更多的选择空间。
