---
title: "152-乘积最大子数组"
date: 2025-05-10 21:46:55 +0800
categories: [LEETCODE, HOT100]
tags: [动态规划, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/maximum-product-subarray/) \| 难度: 中等

## 问题描述:

给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 **32-位** 整数。

**示例 1：**

```java
输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6
```

**示例 2：**

```java
输入: nums = [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组
```

**提示：**`nums` 的任何子数组的乘积都 **保证** 是一个 **32-位** 整数。

## 解题思路：

这是一道关于寻找乘积最大子数组的问题。需要找到数组中连续子数组的最大乘积。

### 方法一：动态规划法（推荐）

核心思想是维护当前位置的最大和最小乘积，因为负数乘以负数会变成正数，所以需要同时跟踪最大值和最小值。

**算法步骤：**

1. 维护两个变量：当前最大乘积和当前最小乘积
2. 遍历数组，对每个元素计算三个候选值：当前元素、当前元素 × 最大乘积、当前元素 × 最小乘积
3. 更新最大乘积和最小乘积
4. 记录全局最大值

```java
class Solution {
    public int maxProduct(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int maxProduct = nums[0];  // 全局最大乘积
        int currentMax = nums[0];  // 当前最大乘积
        int currentMin = nums[0];  // 当前最小乘积

        for (int i = 1; i < nums.length; i++) {
            int num = nums[i];

            // 计算三个候选值
            int candidate1 = num;
            int candidate2 = currentMax * num;
            int candidate3 = currentMin * num;

            // 更新当前最大和最小乘积
            currentMax = Math.max(candidate1, Math.max(candidate2, candidate3));
            currentMin = Math.min(candidate1, Math.min(candidate2, candidate3));

            // 更新全局最大值
            maxProduct = Math.max(maxProduct, currentMax);
        }

        return maxProduct;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是数组长度。

**空间复杂度：** $O(1)$，只使用常数额外空间。

### 方法二：动态规划数组法

使用两个数组分别存储以每个位置结尾的最大和最小乘积。

**算法步骤：**

1. 创建 dpMax 和 dpMin 数组
2. dpMax[i] 表示以 nums[i] 结尾的最大乘积
3. dpMin[i] 表示以 nums[i] 结尾的最小乘积
4. 状态转移方程考虑三种情况

```java
class Solution {
    public int maxProduct(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        int[] dpMax = new int[n];  // 以 i 结尾的最大乘积
        int[] dpMin = new int[n];  // 以 i 结尾的最小乘积

        dpMax[0] = nums[0];
        dpMin[0] = nums[0];
        int result = nums[0];

        for (int i = 1; i < n; i++) {
            int num = nums[i];

            // 计算三个候选值
            int candidate1 = num;
            int candidate2 = dpMax[i - 1] * num;
            int candidate3 = dpMin[i - 1] * num;

            dpMax[i] = Math.max(candidate1, Math.max(candidate2, candidate3));
            dpMin[i] = Math.min(candidate1, Math.min(candidate2, candidate3));

            result = Math.max(result, dpMax[i]);
        }

        return result;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是数组长度。

**空间复杂度：** $O(n)$，需要额外的数组空间。

### 方法三：分治法

遇到 0 时分割数组，分别计算每段的最大乘积。

**算法步骤：**

1. 遇到 0 时将数组分割
2. 对每个不含 0 的子数组，计算最大乘积
3. 处理负数个数为奇数的情况

```java
class Solution {
    public int maxProduct(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int result = Integer.MIN_VALUE;
        int start = 0;

        for (int i = 0; i <= nums.length; i++) {
            // 遇到0或数组结尾时处理当前段
            if (i == nums.length || nums[i] == 0) {
                if (i > start) {
                    result = Math.max(result, getMaxProductInRange(nums, start, i - 1));
                }
                if (i < nums.length) {
                    result = Math.max(result, 0);  // 包含0的情况
                }
                start = i + 1;
            }
        }

        return result;
    }

    private int getMaxProductInRange(int[] nums, int start, int end) {
        int product = 1;
        int maxProduct = Integer.MIN_VALUE;

        // 从左到右
        for (int i = start; i <= end; i++) {
            product *= nums[i];
            maxProduct = Math.max(maxProduct, product);
        }

        product = 1;
        // 从右到左
        for (int i = end; i >= start; i--) {
            product *= nums[i];
            maxProduct = Math.max(maxProduct, product);
        }

        return maxProduct;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是数组长度。

**空间复杂度：** $O(1)$，只使用常数额外空间。

### 方法四：双向遍历法

分别从左到右和从右到左遍历，处理负数个数为奇数的情况。

```java
class Solution {
    public int maxProduct(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        int maxProduct = Integer.MIN_VALUE;

        // 从左到右
        int product = 1;
        for (int i = 0; i < n; i++) {
            product *= nums[i];
            maxProduct = Math.max(maxProduct, product);
            if (product == 0) {
                product = 1;
            }
        }

        // 从右到左
        product = 1;
        for (int i = n - 1; i >= 0; i--) {
            product *= nums[i];
            maxProduct = Math.max(maxProduct, product);
            if (product == 0) {
                product = 1;
            }
        }

        return maxProduct;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是数组长度。

**空间复杂度：** $O(1)$，只使用常数额外空间。

**推荐使用方法一（动态规划法）**，因为它思路清晰，空间效率高，易于理解和实现。核心在于同时维护最大值和最小值，处理负数相乘的情况。
