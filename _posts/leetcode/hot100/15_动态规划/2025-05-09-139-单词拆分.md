---
title: "139-单词拆分"
date: 2025-05-09 21:46:38 +0800
categories: [LEETCODE, HOT100]
tags: [动态规划, 中等]
pin: false
toc: true
math: true
# image: /assets/img/default_post_banner.png # 可选: 如果您有默认的顶部图片，取消注释并修改路径
---

[官网链接](https://leetcode.cn/problems/word-break/) \| 难度: 中等

## 问题描述:

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1：**

```java
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成
```

**示例 2：**

```java
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成, 注意, 你可以重复使用字典中的单词
```

**示例 3：**

```java
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

## 解题思路：

这是一道关于**单词拆分**的动态规划问题。需要判断字符串 s 是否可以被拆分为字典中的单词组合。

### 核心思想：

使用动态规划，`dp[i]` 表示字符串前 i 个字符是否可以被字典中的单词拆分。

对于每个位置 i，检查所有可能的拆分点 j，如果：

- `dp[j] == true`（前 j 个字符可以拆分）
- `s.substring(j, i)` 在字典中存在

则 `dp[i] = true`

### 方法一：动态规划（推荐）

**算法步骤：**

1. 创建 dp 数组，`dp[i]` 表示前 i 个字符是否可以拆分
2. 初始化 `dp[0] = true`（空字符串可以拆分）
3. 将字典转换为 HashSet，提高查找效率
4. 对于每个位置 i，尝试所有可能的拆分点 j
5. 如果找到合适的拆分点，则 `dp[i] = true`

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        // 将字典转换为HashSet，提高查找效率
        Set<String> wordSet = new HashSet<>(wordDict);

        int n = s.length();
        // dp[i] 表示前i个字符是否可以被字典拆分
        boolean[] dp = new boolean[n + 1];

        // 初始化：空字符串可以拆分
        dp[0] = true;

        // 遍历字符串的每个位置
        for (int i = 1; i <= n; i++) {
            // 尝试所有可能的拆分点j
            for (int j = 0; j < i; j++) {
                // 如果前j个字符可以拆分，且j到i的子串在字典中
                if (dp[j] && wordSet.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break; // 找到一种拆分方式即可
                }
            }
        }

        return dp[n];
    }
}
```

**时间复杂度：** $O(n^3)$，其中 n 是字符串长度。外层循环 O(n)，内层循环 O(n)，substring 操作 O(n)。

**空间复杂度：** $O(n + m)$，其中 n 是字符串长度，m 是字典大小。

### 方法二：优化版动态规划

通过预先计算字典中单词的最大长度来减少内层循环次数：

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> wordSet = new HashSet<>(wordDict);

        // 计算字典中单词的最大长度，优化搜索范围
        int maxLen = 0;
        for (String word : wordDict) {
            maxLen = Math.max(maxLen, word.length());
        }

        int n = s.length();
        boolean[] dp = new boolean[n + 1];
        dp[0] = true;

        for (int i = 1; i <= n; i++) {
            // 只需要检查最大单词长度范围内的拆分点
            for (int j = Math.max(0, i - maxLen); j < i; j++) {
                if (dp[j] && wordSet.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[n];
    }
}
```

### 方法三：记忆化搜索（递归+记忆化）

```java
class Solution {
    private Set<String> wordSet;
    private Boolean[] memo;

    public boolean wordBreak(String s, List<String> wordDict) {
        wordSet = new HashSet<>(wordDict);
        memo = new Boolean[s.length()];
        return dfs(s, 0);
    }

    private boolean dfs(String s, int start) {
        // 递归终止条件
        if (start == s.length()) {
            return true;
        }

        // 记忆化：避免重复计算
        if (memo[start] != null) {
            return memo[start];
        }

        // 尝试从当前位置开始的所有可能单词
        for (int end = start + 1; end <= s.length(); end++) {
            String word = s.substring(start, end);
            if (wordSet.contains(word) && dfs(s, end)) {
                memo[start] = true;
                return true;
            }
        }

        memo[start] = false;
        return false;
    }
}
```

**时间复杂度：** $O(n^3)$

**空间复杂度：** $O(n + m)$

### 方法四：BFS 解法

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> wordSet = new HashSet<>(wordDict);
        Queue<Integer> queue = new LinkedList<>();
        boolean[] visited = new boolean[s.length()];

        queue.offer(0);

        while (!queue.isEmpty()) {
            int start = queue.poll();

            if (visited[start]) {
                continue;
            }
            visited[start] = true;

            for (int end = start + 1; end <= s.length(); end++) {
                if (wordSet.contains(s.substring(start, end))) {
                    if (end == s.length()) {
                        return true;
                    }
                    queue.offer(end);
                }
            }
        }

        return false;
    }
}
```

### 解题关键点：

1. **状态定义：** `dp[i]` 表示前 i 个字符是否可以拆分
2. **状态转移：** `dp[i] = dp[j] && wordSet.contains(s.substring(j, i))`
3. **边界条件：** `dp[0] = true`
4. **优化技巧：** 使用 HashSet 提高查找效率，预计算最大单词长度

**推荐使用方法一（基础动态规划）**或**方法二（优化版动态规划）**，因为逻辑清晰，易于理解和实现。
