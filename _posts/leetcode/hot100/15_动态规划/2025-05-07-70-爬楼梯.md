---
title: "70-爬楼梯"
date: 2025-05-07 21:46:13 +0800
categories: [LEETCODE, HOT100]
tags: [动态规划, 简单]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/climbing-stairs/) \| 难度: 简单

## 问题描述:

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**

```java
输入: n = 2
输出: 2
解释: 有两种方法可以爬到楼顶
(1) 1 阶 + 1 阶
(2) 2 阶
```

**示例 2：**

```java
输入: n = 3
输出: 3
解释: 有三种方法可以爬到楼顶
(1) 1 阶 + 1 阶 + 1 阶
(2) 1 阶 + 2 阶
(3) 2 阶 + 1 阶
```

## 解题思路：

这是一道经典的**动态规划**问题，类似于"爬楼梯"问题的变种。需要计算爬到第 n 阶楼梯有多少种不同的方法。

### 核心思想：

对于第 n 阶楼梯，我们可以：

- 从第(n-1)阶爬 1 阶到达
- 从第(n-2)阶爬 2 阶到达

因此：`f(n) = f(n-1) + f(n-2)`

这是一个斐波那契数列的应用。

### 方法一：动态规划（推荐）

**算法步骤：**

1. 处理边界情况：n=1 时返回 1，n=2 时返回 2
2. 使用两个变量记录前两个状态，节省空间
3. 从第 3 阶开始，逐步计算到第 n 阶
4. 每次更新：当前方法数 = 前一阶方法数 + 前两阶方法数

```java
class Solution {
    public int climbStairs(int n) {
        // 边界情况
        if (n <= 2) {
            return n;
        }

        // 初始化前两个状态
        int prev2 = 1; // f(1) = 1
        int prev1 = 2; // f(2) = 2
        int current = 0;

        // 从第3阶开始计算
        for (int i = 3; i <= n; i++) {
            current = prev1 + prev2; // f(i) = f(i-1) + f(i-2)
            prev2 = prev1; // 更新f(i-2)
            prev1 = current; // 更新f(i-1)
        }

        return current;
    }
}
```

**时间复杂度：** $O(n)$，需要计算从第 3 阶到第 n 阶的所有值。

**空间复杂度：** $O(1)$，只使用了常数个变量。

### 方法二：递归+记忆化搜索

```java
class Solution {
    private Map<Integer, Integer> memo = new HashMap<>();

    public int climbStairs(int n) {
        if (n <= 2) {
            return n;
        }

        // 检查是否已经计算过
        if (memo.containsKey(n)) {
            return memo.get(n);
        }

        // 递归计算并存储结果
        int result = climbStairs(n - 1) + climbStairs(n - 2);
        memo.put(n, result);

        return result;
    }
}
```

**时间复杂度：** $O(n)$，每个子问题只计算一次。

**空间复杂度：** $O(n)$，递归调用栈和记忆化存储。

### 方法三：数组形式的动态规划

```java
class Solution {
    public int climbStairs(int n) {
        if (n <= 2) {
            return n;
        }

        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;

        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
    }
}
```

**时间复杂度：** $O(n)$

**空间复杂度：** $O(n)$

### 解题关键点：

1. **状态转移方程：** `f(n) = f(n-1) + f(n-2)`
2. **边界条件：** f(1) = 1, f(2) = 2
3. **优化思路：** 由于只需要前两个状态，可以用变量代替数组，节省空间

**推荐使用方法一（空间优化的动态规划）**，因为它时间和空间复杂度都是最优的，代码简洁易懂。
