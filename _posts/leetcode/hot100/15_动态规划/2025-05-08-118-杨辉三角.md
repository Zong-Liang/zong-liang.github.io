---
title: "118-杨辉三角"
date: 2025-05-08 21:46:31 +0800
categories: [LEETCODE, HOT100]
tags: [动态规划, 简单]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/pascals-triangle/) \| 难度: 简单

## 问题描述:

给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 _`numRows`_ 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](../assets/img/posts/leetcode/p118_0.gif)

**示例 1：**

```java
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

**示例 2：**

```java
输入: numRows = 1
输出: [[1]]
```

## 解题思路：

这是一道关于**杨辉三角**（帕斯卡三角）生成的问题。杨辉三角的每个数是它上方两个数的和，边界都是 1。

### 核心规律：

1. **第一行和最后一行的元素都是 1**
2. **中间的元素：** `triangle[i][j] = triangle[i-1][j-1] + triangle[i-1][j]`
3. **每行的第一个和最后一个元素都是 1**

### 方法一：逐行构建法（推荐）

**算法步骤：**

1. 创建结果列表，用于存储每一行
2. 对于每一行 i（从 0 到 numRows-1）：
   - 创建当前行的列表，长度为 i+1
   - 设置第一个和最后一个元素为 1
   - 计算中间元素：当前元素 = 上一行对应的两个元素之和
3. 将当前行添加到结果中

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> result = new ArrayList<>();

        for (int i = 0; i < numRows; i++) {
            List<Integer> row = new ArrayList<>();

            // 每行的第一个元素都是1
            row.add(1);

            // 计算中间的元素
            for (int j = 1; j < i; j++) {
                // 当前元素 = 上一行的 triangle[i-1][j-1] + triangle[i-1][j]
                int val = result.get(i - 1).get(j - 1) + result.get(i - 1).get(j);
                row.add(val);
            }

            // 每行的最后一个元素都是1（除了第一行）
            if (i > 0) {
                row.add(1);
            }

            result.add(row);
        }

        return result;
    }
}
```

### 方法二：更简洁的写法

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> result = new ArrayList<>();

        for (int i = 0; i < numRows; i++) {
            List<Integer> row = new ArrayList<>();

            for (int j = 0; j <= i; j++) {
                // 边界条件：第一个和最后一个元素都是1
                if (j == 0 || j == i) {
                    row.add(1);
                } else {
                    // 中间元素：上一行对应位置的两个数之和
                    int val = result.get(i - 1).get(j - 1) + result.get(i - 1).get(j);
                    row.add(val);
                }
            }

            result.add(row);
        }

        return result;
    }
}
```

### 方法三：数学公式法（组合数）

利用杨辉三角的数学性质：第 i 行第 j 列的值等于组合数 C(i,j)。

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> result = new ArrayList<>();

        for (int i = 0; i < numRows; i++) {
            List<Integer> row = new ArrayList<>();

            for (int j = 0; j <= i; j++) {
                row.add(combination(i, j));
            }

            result.add(row);
        }

        return result;
    }

    // 计算组合数C(n, k) = n! / (k! * (n-k)!)
    private int combination(int n, int k) {
        if (k == 0 || k == n) {
            return 1;
        }

        long result = 1;
        // 优化：C(n,k) = C(n,n-k)，选择较小的k
        k = Math.min(k, n - k);

        for (int i = 0; i < k; i++) {
            result = result * (n - i) / (i + 1);
        }

        return (int) result;
    }
}
```

**时间复杂度：** $O(numRows^2)$，需要生成 numRows 行，每行平均有 numRows/2 个元素。

**空间复杂度：** $O(1)$，不考虑结果存储空间的话，只使用了常数级别的额外空间。

### 解题关键点：

1. **边界处理：** 每行的第一个和最后一个元素都是 1
2. **状态转移：** 中间元素等于上一行对应的两个元素之和
3. **索引关系：** 第 i 行第 j 列的值 = 第(i-1)行第(j-1)列 + 第(i-1)行第 j 列

**推荐使用方法二（简洁写法）**，因为逻辑清晰，边界条件处理简单，代码可读性强。
