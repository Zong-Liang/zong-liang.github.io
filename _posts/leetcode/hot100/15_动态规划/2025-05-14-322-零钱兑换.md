---
title: "322-零钱兑换"
date: 2025-05-14 21:48:15 +0800
categories: [LEETCODE, HOT100]
tags: [动态规划, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/coin-change/) \| 难度: 中等

## 问题描述:

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

**示例 1：**

```java
输入: coins = [1, 2, 5], amount = 11
输出: 3
解释: 11 = 5 + 5 + 1
```

**示例 2：**

```java
输入: coins = [2], amount = 3
输出: -1
```

**示例 3：**

```java
输入: coins = [1], amount = 0
输出: 0
```

## 解题思路：

这是一道关于零钱兑换的经典动态规划问题。需要计算凑成总金额所需的最少硬币个数。

### 方法一：动态规划法（推荐）

核心思想是定义 dp[i] 表示凑成金额 i 所需的最少硬币数量，通过遍历所有硬币面额来更新状态。

**算法步骤：**

1. 创建 dp 数组，dp[i] 表示凑成金额 i 所需的最少硬币数
2. 初始化 dp[0] = 0（凑成 0 元需要 0 个硬币），其他位置初始化为无穷大
3. 对于每个金额 i，尝试使用每种硬币，选择最优方案
4. 状态转移方程：dp[i] = min(dp[i], dp[i - coin] + 1)

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        if (amount < 0) {
            return -1;
        }
        if (amount == 0) {
            return 0;
        }

        // dp[i] 表示凑成金额 i 所需的最少硬币数
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1); // 初始化为一个不可能达到的大值
        dp[0] = 0; // 凑成 0 元需要 0 个硬币

        for (int i = 1; i <= amount; i++) {
            for (int coin : coins) {
                if (coin <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }

        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

**时间复杂度：** $O(amount \times coins.length)$，需要计算每个金额的最优解。

**空间复杂度：** $O(amount)$，需要额外的 dp 数组。

### 方法二：记忆化递归法

使用递归的思路，但加上记忆化避免重复计算。

**算法步骤：**

1. 定义递归函数，计算凑成指定金额的最少硬币数
2. 使用记忆化数组缓存已计算的结果
3. 递归终止条件：金额为 0 返回 0，金额小于 0 返回-1
4. 对于每个金额，尝试所有硬币，选择最优方案

```java
class Solution {
    private int[] memo;

    public int coinChange(int[] coins, int amount) {
        if (amount < 0) {
            return -1;
        }

        memo = new int[amount + 1];
        Arrays.fill(memo, -2); // -2 表示未计算，-1 表示无解
        return dp(coins, amount);
    }

    private int dp(int[] coins, int amount) {
        if (amount == 0) {
            return 0;
        }
        if (amount < 0) {
            return -1;
        }

        if (memo[amount] != -2) {
            return memo[amount];
        }

        int result = Integer.MAX_VALUE;
        for (int coin : coins) {
            int subResult = dp(coins, amount - coin);
            if (subResult != -1) {
                result = Math.min(result, subResult + 1);
            }
        }

        memo[amount] = (result == Integer.MAX_VALUE) ? -1 : result;
        return memo[amount];
    }
}
```

**时间复杂度：** $O(amount \times coins.length)$，每个金额最多计算一次。

**空间复杂度：** $O(amount)$，递归栈和记忆化数组的空间。

### 方法三：BFS 广度优先搜索法

将问题转化为图的最短路径问题，使用 BFS 寻找最少步数。

**算法步骤：**

1. 从金额 0 开始，使用 BFS 逐层探索
2. 对于当前金额，尝试加上每种硬币面额
3. 使用 visited 数组避免重复访问相同金额
4. 当第一次到达目标金额时，返回步数

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        if (amount == 0) {
            return 0;
        }

        Queue<Integer> queue = new LinkedList<>();
        boolean[] visited = new boolean[amount + 1];

        queue.offer(0);
        visited[0] = true;
        int level = 0;

        while (!queue.isEmpty()) {
            int size = queue.size();
            level++;

            for (int i = 0; i < size; i++) {
                int current = queue.poll();

                for (int coin : coins) {
                    int next = current + coin;

                    if (next == amount) {
                        return level;
                    }

                    if (next < amount && !visited[next]) {
                        visited[next] = true;
                        queue.offer(next);
                    }
                }
            }
        }

        return -1;
    }
}
```

**时间复杂度：** $O(amount \times coins.length)$，最坏情况下需要遍历所有可能的金额。

**空间复杂度：** $O(amount)$，队列和 visited 数组的空间。

### 方法四：优化的动态规划（按硬币遍历）

改变遍历顺序，先遍历硬币，再遍历金额，在某些情况下可能更高效。

**算法步骤：**

1. 外层循环遍历硬币
2. 内层循环遍历金额
3. 对于每个硬币，更新所有可能受影响的金额

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        if (amount < 0) {
            return -1;
        }
        if (amount == 0) {
            return 0;
        }

        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;

        for (int coin : coins) {
            for (int i = coin; i <= amount; i++) {
                if (dp[i - coin] != amount + 1) {
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }

        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

**时间复杂度：** $O(amount \times coins.length)$，与方法一相同。

**空间复杂度：** $O(amount)$，需要额外的 dp 数组。

**推荐使用方法一（动态规划法）**，因为它思路清晰，代码简洁，效率高。核心思想是将大问题分解为子问题，通过状态转移方程逐步求解。对于无法凑成的金额返回 -1，这是通过初始化和最终判断来实现的。
