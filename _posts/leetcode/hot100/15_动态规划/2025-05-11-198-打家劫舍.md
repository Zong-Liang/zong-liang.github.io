---
title: "198-打家劫舍"
date: 2025-05-11 21:47:06 +0800
categories: [LEETCODE, HOT100]
tags: [动态规划, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/house-robber/) \| 难度: 中等

## 问题描述:

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```java
输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1), 然后偷窃 3 号房屋 (金额 = 3), 偷窃到的最高金额 = 1 + 3 = 4
```

**示例 2：**

```java
输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9), 接着偷窃 5 号房屋 (金额 = 1), 偷窃到的最高金额 = 2 + 9 + 1 = 12
```

## 解题思路：

这是一道关于打家劫舍的动态规划问题。小偷不能偷取相邻的房屋，需要找到能偷取的最大金额。

### 方法一：动态规划法（推荐）

核心思想是对于每个房屋，都有两种选择：偷或不偷。如果偷当前房屋，就不能偷前一个房屋；如果不偷当前房屋，最大金额就是前一个房屋的最大金额。

**算法步骤：**

1. 定义 dp[i] 表示偷取前 i+1 个房屋能获得的最大金额
2. 状态转移方程：dp[i] = max(dp[i-1], dp[i-2] + nums[i])
3. 边界条件：dp[0] = nums[0]，dp[1] = max(nums[0], nums[1])

```java
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        if (n == 1) {
            return nums[0];
        }

        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);

        for (int i = 2; i < n; i++) {
            // 要么偷当前房屋（加上前前个房屋的最大金额）
            // 要么不偷当前房屋（保持前一个房屋的最大金额）
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }

        return dp[n - 1];
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是房屋数量。

**空间复杂度：** $O(n)$，需要额外的 dp 数组。

### 方法二：空间优化的动态规划法

由于只需要前两个状态，可以用两个变量代替数组。

**算法步骤：**

1. 使用两个变量 prev1 和 prev2 分别表示前一个和前两个房屋的最大金额
2. 逐步更新这两个变量
3. 最终返回 prev1

```java
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        if (n == 1) {
            return nums[0];
        }

        int prev2 = nums[0];                    // dp[i-2]
        int prev1 = Math.max(nums[0], nums[1]); // dp[i-1]

        for (int i = 2; i < n; i++) {
            int current = Math.max(prev1, prev2 + nums[i]);
            prev2 = prev1;
            prev1 = current;
        }

        return prev1;
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是房屋数量。

**空间复杂度：** $O(1)$，只使用常数额外空间。

### 方法三：更简洁的空间优化版本

进一步简化代码，使用更直观的变量命名。

**算法步骤：**

1. rob 表示偷取当前房屋的最大金额
2. notRob 表示不偷取当前房屋的最大金额
3. 对每个房屋更新这两个值

```java
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int rob = 0;    // 偷取当前房屋的最大金额
        int notRob = 0; // 不偷取当前房屋的最大金额

        for (int num : nums) {
            int currentRob = notRob + num;  // 偷取当前房屋
            notRob = Math.max(rob, notRob); // 不偷取当前房屋
            rob = currentRob;
        }

        return Math.max(rob, notRob);
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是房屋数量。

**空间复杂度：** $O(1)$，只使用常数额外空间。

### 方法四：递归 + 记忆化搜索

使用递归的思路，但加上记忆化避免重复计算。

**算法步骤：**

1. 定义递归函数 robFrom(i)，表示从第 i 个房屋开始能偷取的最大金额
2. 对于每个房屋，选择偷或不偷的最大值
3. 使用记忆化数组避免重复计算

```java
class Solution {
    private int[] memo;

    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        memo = new int[nums.length];
        Arrays.fill(memo, -1);
        return robFrom(nums, 0);
    }

    private int robFrom(int[] nums, int index) {
        if (index >= nums.length) {
            return 0;
        }

        if (memo[index] != -1) {
            return memo[index];
        }

        // 偷取当前房屋：当前金额 + 从下下个房屋开始偷取的最大金额
        int rob = nums[index] + robFrom(nums, index + 2);
        // 不偷取当前房屋：从下个房屋开始偷取的最大金额
        int notRob = robFrom(nums, index + 1);

        memo[index] = Math.max(rob, notRob);
        return memo[index];
    }
}
```

**时间复杂度：** $O(n)$，其中 $n$ 是房屋数量。

**空间复杂度：** $O(n)$，递归栈和记忆化数组的空间。

**推荐使用方法二（空间优化的动态规划法）**，因为它既保持了良好的时间复杂度，又优化了空间复杂度，代码简洁易懂。核心思想是对于每个房屋都有偷与不偷两种选择，选择能获得更大收益的方案。
