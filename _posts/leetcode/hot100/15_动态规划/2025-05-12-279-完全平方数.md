---
title: "279-完全平方数"
date: 2025-05-12 21:47:19 +0800
categories: [LEETCODE, HOT100]
tags: [动态规划, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/perfect-squares/) \| 难度: 中等

## 问题描述:

给你一个整数 `n` ，返回 _和为 `n` 的完全平方数的最少数量_ 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

**示例 1：**

```java
输入: n = 12
输出: 3
解释: 12 = 4 + 4 + 4
```

**示例 2：**

```java
输入: n = 13
输出: 2
解释: 13 = 4 + 9
```

## 解题思路：

这是一道关于判断完全平方数的问题。需要判断给定的正整数是否可以表示为某个整数的平方。

### 方法一：二分查找法（推荐）

核心思想是在 1 到 n 的范围内使用二分查找，寻找是否存在某个数的平方等于 n。

**算法步骤：**

1. 设定搜索范围：left = 1, right = n
2. 使用二分查找，计算 mid 的平方
3. 如果 mid² = n，返回 true
4. 如果 mid² < n，搜索右半部分
5. 如果 mid² > n，搜索左半部分

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        if (num < 1) {
            return false;
        }

        long left = 1;
        long right = num;

        while (left <= right) {
            long mid = left + (right - left) / 2;
            long square = mid * mid;

            if (square == num) {
                return true;
            } else if (square < num) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return false;
    }
}
```

**时间复杂度：** $O(\log n)$，二分查找的时间复杂度。

**空间复杂度：** $O(1)$，只使用常数额外空间。

### 方法二：牛顿迭代法

使用牛顿迭代法快速逼近平方根，然后验证结果。

**算法步骤：**

1. 使用牛顿迭代公式：x\_{n+1} = (x_n + num/x_n) / 2
2. 迭代直到收敛
3. 检查最终结果的平方是否等于原数

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        if (num < 1) {
            return false;
        }

        long x = num;

        // 牛顿迭代法求平方根
        while (x * x > num) {
            x = (x + num / x) / 2;
        }

        return x * x == num;
    }
}
```

**时间复杂度：** $O(\log n)$，牛顿迭代法的收敛速度。

**空间复杂度：** $O(1)$，只使用常数额外空间。

### 方法三：数学性质法

利用完全平方数的性质：1+3+5+...+(2n-1) = n²。

**算法步骤：**

1. 从 1 开始，依次减去奇数 1, 3, 5, 7, ...
2. 如果最终结果为 0，说明是完全平方数
3. 如果结果小于 0，说明不是完全平方数

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        int i = 1;

        while (num > 0) {
            num -= i;
            i += 2; // 下一个奇数
        }

        return num == 0;
    }
}
```

**时间复杂度：** $O(\sqrt{n})$，需要减去 $\sqrt{n}$ 个奇数。

**空间复杂度：** $O(1)$，只使用常数额外空间。

### 方法四：直接开方法

使用数学库函数计算平方根，然后验证。

**算法步骤：**

1. 计算 num 的平方根
2. 将结果转换为整数
3. 检查该整数的平方是否等于原数

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        if (num < 1) {
            return false;
        }

        int sqrt = (int) Math.sqrt(num);
        return sqrt * sqrt == num;
    }
}
```

**时间复杂度：** $O(1)$，Math.sqrt() 通常是常数时间。

**空间复杂度：** $O(1)$，只使用常数额外空间。

### 方法五：位运算优化的二分查找

针对大数进行优化，避免溢出问题。

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        if (num < 1) {
            return false;
        }

        if (num == 1) {
            return true;
        }

        long left = 1;
        long right = num / 2; // 优化：完全平方数的平方根不会超过 num/2

        while (left <= right) {
            long mid = left + (right - left) / 2;
            long square = mid * mid;

            if (square == num) {
                return true;
            } else if (square < num) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return false;
    }
}
```

**时间复杂度：** $O(\log n)$，优化后的二分查找。

**空间复杂度：** $O(1)$，只使用常数额外空间。

**推荐使用方法一（二分查找法）**，因为它效率高、思路清晰，适用范围广。对于追求极致性能的场景，可以考虑方法二（牛顿迭代法）。需要注意的是，在实现时要使用 long 类型避免整数溢出问题。
