---
title: "560-和为K的子数组"
date: 2025-02-26 21:14:26 +0800
categories: [LEETCODE, HOT100]
tags: [子串, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/subarray-sum-equals-k/) \| 难度: 中等

## 问题描述:

给你一个整数数组 `nums` 和一个整数 `k`，请你统计并返回*该数组中和为 `k` 的子数组的个数*。

子数组是数组中元素的连续非空序列。

**示例 1：**

```java
输入: nums = [1,1,1], k = 2
输出: 2
```

**示例 2：**

```java
输入: nums = [1,2,3], k = 3
输出: 2
```

## 解题思路:

这道题要求找到数组中和为目标值 K 的子数组的个数。这是一个经典的前缀和问题，可以通过多种方法来解决。

### 方法一：暴力解法

最直接的方法是枚举所有可能的子数组，计算它们的和，统计和为 K 的子数组个数。

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0;
        int n = nums.length;

        // 枚举所有可能的子数组起始位置
        for (int i = 0; i < n; i++) {
            int sum = 0;
            // 从当前起始位置向后扩展子数组
            for (int j = i; j < n; j++) {
                sum += nums[j];
                // 如果当前子数组和等于k，计数加1
                if (sum == k) {
                    count++;
                }
            }
        }

        return count;
    }
}
```

**时间复杂度**：$O(n^2)$，其中 $n$ 是数组长度。需要两重循环遍历所有可能的子数组。

**空间复杂度**：$O(1)$，只使用了常数额外空间。

### 方法二：前缀和 + 哈希表（最优解法）

这是最优的解法，核心思想是利用前缀和的性质：

- 如果从索引 $i$ 到索引 $j$ 的子数组和为 $k$，那么 $prefixSum[j] - prefixSum[i-1] = k$
- 即 $prefixSum[i-1] = prefixSum[j] - k$

算法步骤：

1. 使用哈希表记录每个前缀和出现的次数
2. 遍历数组，计算当前位置的前缀和
3. 检查 `当前前缀和 - k` 是否在哈希表中存在
4. 如果存在，说明找到了若干个和为 k 的子数组，将对应的次数加到结果中
5. 将当前前缀和加入哈希表

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        // 哈希表用于记录前缀和出现的次数
        Map<Integer, Integer> prefixSumCount = new HashMap<>();

        // 初始化：前缀和为0出现1次（表示空数组的前缀和）
        prefixSumCount.put(0, 1);

        int count = 0;          // 结果计数
        int prefixSum = 0;      // 当前前缀和

        for (int num : nums) {
            // 更新前缀和
            prefixSum += num;

            // 检查是否存在前缀和为 (prefixSum - k) 的情况
            // 如果存在，说明从那个位置到当前位置的子数组和为k
            if (prefixSumCount.containsKey(prefixSum - k)) {
                count += prefixSumCount.get(prefixSum - k);
            }

            // 将当前前缀和加入哈希表，或更新其出现次数
            prefixSumCount.put(prefixSum, prefixSumCount.getOrDefault(prefixSum, 0) + 1);
        }

        return count;
    }
}
```

**时间复杂度**：$O(n)$，其中 $n$ 是数组长度。只需要遍历一次数组，哈希表的操作时间复杂度为 $O(1)$。

**空间复杂度**：$O(n)$，主要是哈希表的开销，最坏情况下所有前缀和都不相同。

### 算法原理详解

以示例 1 为例：`nums = [1,1,1], k = 2`

- 初始：`prefixSumCount = {0: 1}`, `count = 0`
- 遍历 `nums[0] = 1`：
  - `prefixSum = 1`
  - 查找 `prefixSum - k = 1 - 2 = -1`，不存在
  - 更新：`prefixSumCount = {0: 1, 1: 1}`
- 遍历 `nums[1] = 1`：
  - `prefixSum = 2`
  - 查找 `prefixSum - k = 2 - 2 = 0`，存在且次数为 1
  - `count += 1`，`count = 1`
  - 更新：`prefixSumCount = {0: 1, 1: 1, 2: 1}`
- 遍历 `nums[2] = 1`：
  - `prefixSum = 3`
  - 查找 `prefixSum - k = 3 - 2 = 1`，存在且次数为 1
  - `count += 1`，`count = 2`
  - 更新：`prefixSumCount = {0: 1, 1: 1, 2: 1, 3: 1}`

最终返回 `count = 2`，对应子数组 `[1,1]`（索引 0-1）和 `[1,1]`（索引 1-2）。
