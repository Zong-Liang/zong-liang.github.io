---
title: "76-最小覆盖子串"
date: 2025-02-24 21:09:44 +0800
categories: [LEETCODE, HOT100]
tags: [子串, 困难]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/minimum-window-substring/) \| 难度: 困难

## 问题描述:

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意:**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**

```java
输入: s = "ADOBECODEBANC", t = "ABC"
输出: "BANC"
解释: 最小覆盖子串 "BANC" 包含来自字符串 t 的 'A' 'B' 'C'
```

**示例 2：**

```java
输入: s = "a", t = "a"
输出: "a"
解释: 整个字符串 s 是最小覆盖子串
```

**示例 3：**

```java
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中, 因此没有符合条件的子字符串, 返回空字符串
```

## 解题思路:

这道题是"最小覆盖子串"问题。给定两个字符串 `s` 和 `t`，要求找出字符串 `s` 中包含 `t` 所有字符的最小子串。这是一个经典的滑动窗口问题。

### 方法一：滑动窗口（推荐）

使用滑动窗口技术，通过双指针维护一个可变长度的窗口，当窗口包含所有目标字符时收缩左边界寻找最小解。

```java
class Solution {
    public String minWindow(String s, String t) {
        if (s.length() < t.length()) return "";

        // 统计t中每个字符的频次
        Map<Character, Integer> targetMap = new HashMap<>();
        for (char c : t.toCharArray()) {
            targetMap.put(c, targetMap.getOrDefault(c, 0) + 1);
        }

        int left = 0, right = 0;
        int minLen = Integer.MAX_VALUE;
        int minStart = 0;
        int required = targetMap.size(); // 需要匹配的不同字符数
        int formed = 0; // 当前已经匹配的字符数

        Map<Character, Integer> windowMap = new HashMap<>();

        while (right < s.length()) {
            // 扩展右边界
            char rightChar = s.charAt(right);
            windowMap.put(rightChar, windowMap.getOrDefault(rightChar, 0) + 1);

            // 检查当前字符是否满足要求
            if (targetMap.containsKey(rightChar) &&
                windowMap.get(rightChar).equals(targetMap.get(rightChar))) {
                formed++;
            }

            // 当窗口包含所有字符时，尝试收缩左边界
            while (left <= right && formed == required) {
                // 更新最小窗口
                if (right - left + 1 < minLen) {
                    minLen = right - left + 1;
                    minStart = left;
                }

                // 收缩左边界
                char leftChar = s.charAt(left);
                windowMap.put(leftChar, windowMap.get(leftChar) - 1);

                if (targetMap.containsKey(leftChar) &&
                    windowMap.get(leftChar) < targetMap.get(leftChar)) {
                    formed--;
                }

                left++;
            }

            right++;
        }

        return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
    }
}
```

**时间复杂度**：$O(|s| + |t|)$，其中 $|s|$ 和 $|t|$ 分别是字符串 `s` 和 `t` 的长度。

**空间复杂度**：$O(|s| + |t|)$，HashMap 的空间开销。

### 方法二：滑动窗口 + 数组优化

如果字符串只包含 ASCII 字符，可以使用数组代替 HashMap 提高性能。

```java
class Solution {
    public String minWindow(String s, String t) {
        if (s.length() < t.length()) return "";

        // 使用数组统计字符频次
        int[] targetCount = new int[128];
        int[] windowCount = new int[128];
        int required = 0;

        // 统计t中字符频次
        for (char c : t.toCharArray()) {
            if (targetCount[c] == 0) required++;
            targetCount[c]++;
        }

        int left = 0, right = 0;
        int minLen = Integer.MAX_VALUE;
        int minStart = 0;
        int formed = 0;

        while (right < s.length()) {
            char rightChar = s.charAt(right);
            windowCount[rightChar]++;

            if (targetCount[rightChar] > 0 &&
                windowCount[rightChar] == targetCount[rightChar]) {
                formed++;
            }

            while (left <= right && formed == required) {
                if (right - left + 1 < minLen) {
                    minLen = right - left + 1;
                    minStart = left;
                }

                char leftChar = s.charAt(left);
                windowCount[leftChar]--;

                if (targetCount[leftChar] > 0 &&
                    windowCount[leftChar] < targetCount[leftChar]) {
                    formed--;
                }

                left++;
            }

            right++;
        }

        return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
    }
}
```

**时间复杂度**：$O(|s| + |t|)$，其中 $|s|$ 和 $|t|$ 分别是字符串长度。

**空间复杂度**：$O(1)$，使用固定大小的数组。

### 方法三：暴力解法

枚举所有可能的子串，检查是否包含目标字符串的所有字符。

```java
class Solution {
    public String minWindow(String s, String t) {
        if (s.length() < t.length()) return "";

        String result = "";
        int minLen = Integer.MAX_VALUE;

        // 枚举所有子串
        for (int i = 0; i < s.length(); i++) {
            for (int j = i + t.length(); j <= s.length(); j++) {
                String substring = s.substring(i, j);
                if (isValidWindow(substring, t)) {
                    if (substring.length() < minLen) {
                        minLen = substring.length();
                        result = substring;
                    }
                }
            }
        }

        return result;
    }

    private boolean isValidWindow(String window, String target) {
        Map<Character, Integer> targetMap = new HashMap<>();
        Map<Character, Integer> windowMap = new HashMap<>();

        for (char c : target.toCharArray()) {
            targetMap.put(c, targetMap.getOrDefault(c, 0) + 1);
        }

        for (char c : window.toCharArray()) {
            windowMap.put(c, windowMap.getOrDefault(c, 0) + 1);
        }

        for (Map.Entry<Character, Integer> entry : targetMap.entrySet()) {
            if (windowMap.getOrDefault(entry.getKey(), 0) < entry.getValue()) {
                return false;
            }
        }

        return true;
    }
}
```

**时间复杂度**：$O(|s|^2 \times |t|)$，需要枚举所有子串并检查每个子串。

**空间复杂度**：$O(|s| + |t|)$，HashMap 的空间开销。

### 方法四：滑动窗口 + 预处理优化

预先找出包含目标字符的位置，减少不必要的遍历。

```java
class Solution {
    public String minWindow(String s, String t) {
        if (s.length() < t.length()) return "";

        Map<Character, Integer> targetMap = new HashMap<>();
        for (char c : t.toCharArray()) {
            targetMap.put(c, targetMap.getOrDefault(c, 0) + 1);
        }

        // 预处理：只保留s中在t中出现的字符
        List<Pair> filteredS = new ArrayList<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (targetMap.containsKey(c)) {
                filteredS.add(new Pair(i, c));
            }
        }

        int left = 0, right = 0;
        int minLen = Integer.MAX_VALUE;
        int minStart = 0;
        int required = targetMap.size();
        int formed = 0;

        Map<Character, Integer> windowMap = new HashMap<>();

        while (right < filteredS.size()) {
            char rightChar = filteredS.get(right).c;
            windowMap.put(rightChar, windowMap.getOrDefault(rightChar, 0) + 1);

            if (windowMap.get(rightChar).equals(targetMap.get(rightChar))) {
                formed++;
            }

            while (left <= right && formed == required) {
                int start = filteredS.get(left).index;
                int end = filteredS.get(right).index;

                if (end - start + 1 < minLen) {
                    minLen = end - start + 1;
                    minStart = start;
                }

                char leftChar = filteredS.get(left).c;
                windowMap.put(leftChar, windowMap.get(leftChar) - 1);

                if (windowMap.get(leftChar) < targetMap.get(leftChar)) {
                    formed--;
                }

                left++;
            }

            right++;
        }

        return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
    }

    class Pair {
        int index;
        char c;

        Pair(int index, char c) {
            this.index = index;
            this.c = c;
        }
    }
}
```

**时间复杂度**：$O(|s| + |t|)$，其中 $|s|$ 和 $|t|$ 分别是字符串长度。

**空间复杂度**：$O(|s| + |t|)$，需要额外空间存储过滤后的字符。

### 方法五：双指针 + 字符匹配计数

使用更精细的匹配计数来优化判断逻辑。

```java
class Solution {
    public String minWindow(String s, String t) {
        if (s.length() < t.length()) return "";

        int[] targetCount = new int[128];
        int targetChars = 0;

        // 统计目标字符
        for (char c : t.toCharArray()) {
            if (targetCount[c] == 0) targetChars++;
            targetCount[c]++;
        }

        int left = 0;
        int minLen = Integer.MAX_VALUE;
        int minStart = 0;
        int matchedChars = 0;
        int[] windowCount = new int[128];

        for (int right = 0; right < s.length(); right++) {
            char rightChar = s.charAt(right);
            windowCount[rightChar]++;

            if (windowCount[rightChar] == targetCount[rightChar]) {
                matchedChars++;
            }

            while (matchedChars == targetChars) {
                if (right - left + 1 < minLen) {
                    minLen = right - left + 1;
                    minStart = left;
                }

                char leftChar = s.charAt(left);
                windowCount[leftChar]--;

                if (windowCount[leftChar] < targetCount[leftChar]) {
                    matchedChars--;
                }

                left++;
            }
        }

        return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
    }
}
```

**时间复杂度**：$O(|s| + |t|)$，其中 $|s|$ 和 $|t|$ 分别是字符串长度。

**空间复杂度**：$O(1)$，使用固定大小的数组。

**推荐使用方法一或方法二**，它们是最优解法，时间复杂度为 $O(|s| + |t|)$。如果确定字符集为 ASCII，方法二的性能会更好。

**核心思想**：

1. 使用滑动窗口维护一个包含所有目标字符的子串
2. 右指针扩展窗口直到包含所有目标字符
3. 左指针收缩窗口寻找最小解
4. 重复上述过程直到遍历完整个字符串
