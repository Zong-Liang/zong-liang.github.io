---
title: "215-数组中的第K个最大元素值"
date: 2025-04-29 21:42:32 +0800
categories: [LEETCODE, HOT100]
tags: [堆, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/kth-largest-element-in-an-array/) \| 难度: 中等

## 问题描述:

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 $O(n)$ 的算法解决此问题。

**示例 1：**

```java
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

**示例 2：**

```java
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

## 解题思路：

这是一道关于查找数组中第 K 个最大元素的问题。我们需要在给定的整数数组中找到排序后第 K 个最大的元素（注意是排序后的第 K 个，不是第 K 个不同的元素）。

### 方法一：快速选择算法（推荐）

基于快速排序的分治思想，平均时间复杂度为 O(n)。

**算法步骤：**

1. 使用快速排序的 partition 过程
2. 每次 partition 后，比较 pivot 位置与目标位置
3. 如果 pivot 位置等于目标位置，直接返回
4. 如果 pivot 位置大于目标位置，在左半部分继续查找
5. 如果 pivot 位置小于目标位置，在右半部分继续查找

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        // 第k个最大元素的索引位置（从大到小排序）
        return quickSelect(nums, 0, nums.length - 1, k - 1);
    }

    private int quickSelect(int[] nums, int left, int right, int k) {
        // 随机选择pivot，避免最坏情况
        int randomIndex = left + new Random().nextInt(right - left + 1);
        swap(nums, randomIndex, right);

        int pivot = partition(nums, left, right);

        if (pivot == k) {
            return nums[pivot];
        } else if (pivot > k) {
            return quickSelect(nums, left, pivot - 1, k);
        } else {
            return quickSelect(nums, pivot + 1, right, k);
        }
    }

    private int partition(int[] nums, int left, int right) {
        int pivot = nums[right];
        int i = left;

        for (int j = left; j < right; j++) {
            // 降序排列，大的元素放在前面
            if (nums[j] >= pivot) {
                swap(nums, i, j);
                i++;
            }
        }

        swap(nums, i, right);
        return i;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

**时间复杂度：** 平均 $O(n)$，最坏 $O(n^2)$

**空间复杂度：** $O(\log n)$，递归栈空间

### 方法二：最小堆

使用优先队列（最小堆）维护 K 个最大元素。

**算法步骤：**

1. 创建一个大小为 K 的最小堆
2. 遍历数组，将元素加入堆中
3. 如果堆大小超过 K，移除堆顶（最小元素）
4. 最后堆顶就是第 K 个最大元素

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        // 使用最小堆，保持堆大小为k
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        for (int num : nums) {
            minHeap.offer(num);

            // 如果堆大小超过k，移除最小元素
            if (minHeap.size() > k) {
                minHeap.poll();
            }
        }

        // 堆顶就是第k个最大元素
        return minHeap.peek();
    }
}
```

**时间复杂度：** $O(n \log k)$

**空间复杂度：** $O(k)$

### 方法三：排序法（最简单）

直接对数组排序，然后返回第 K 个最大元素。

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        Arrays.sort(nums);
        // 第k个最大元素在排序后数组的倒数第k个位置
        return nums[nums.length - k];
    }
}
```

**时间复杂度：** $O(n \log n)$

**空间复杂度：** $O(1)$ 或 $O(n)$（取决于排序算法的实现）

**推荐使用方法一（快速选择算法）**，因为它的平均时间复杂度最优；如果对代码简洁性要求较高，可以使用方法二（最小堆）；方法三最简单但效率相对较低。
