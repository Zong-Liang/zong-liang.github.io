---
title: "347-前k个高频元素"
date: 2025-05-01 21:43:02 +0800
categories: [LEETCODE, HOT100]
tags: [堆, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/top-k-frequent-elements/) \| 难度: 中等

## 问题描述:

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1：**

```java
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2：**

```java
输入: nums = [1], k = 1
输出: [1]
```

**提示：**

- `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
- 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

## 解题思路：

这是一道关于查找前 K 个高频元素的问题。需要在给定的整数数组中找到出现频率最高的前 K 个元素。

### 方法一：哈希表 + 最小堆（推荐）

核心思想是先统计每个元素的频率，然后使用最小堆维护前 K 个高频元素。

**算法步骤：**

1. 使用哈希表统计每个元素的出现频率
2. 使用最小堆（优先队列）维护前 K 个高频元素
3. 遍历哈希表，将元素加入堆中，保持堆大小为 K
4. 当堆大小超过 K 时，移除堆顶（频率最小的元素）
5. 最后堆中的所有元素就是前 K 个高频元素

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // 统计每个元素的频率
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        for (int num : nums) {
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }

        // 使用最小堆，按频率排序
        PriorityQueue<Integer> minHeap = new PriorityQueue<>(
            (a, b) -> frequencyMap.get(a) - frequencyMap.get(b)
        );

        // 遍历频率表，维护大小为k的最小堆
        for (int num : frequencyMap.keySet()) {
            minHeap.offer(num);
            if (minHeap.size() > k) {
                minHeap.poll(); // 移除频率最小的元素
            }
        }

        // 提取结果
        int[] result = new int[k];
        for (int i = k - 1; i >= 0; i--) {
            result[i] = minHeap.poll();
        }

        return result;
    }
}
```

**时间复杂度：** $O(n \log k)$，其中 n 是数组长度。统计频率需要 O(n)，堆操作需要 O(n log k)。

**空间复杂度：** $O(n)$，哈希表存储频率，堆最多存储 k 个元素。

### 方法二：哈希表 + 排序

统计频率后，根据频率对元素进行排序，取前 K 个。

**算法步骤：**

1. 使用哈希表统计每个元素的出现频率
2. 将哈希表的键值对转换为列表
3. 根据频率对列表进行降序排序
4. 取前 K 个元素作为结果

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // 统计每个元素的频率
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        for (int num : nums) {
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }

        // 将键值对转换为列表并按频率降序排序
        List<Map.Entry<Integer, Integer>> entryList = new ArrayList<>(frequencyMap.entrySet());
        entryList.sort((a, b) -> b.getValue() - a.getValue());

        // 提取前k个元素
        int[] result = new int[k];
        for (int i = 0; i < k; i++) {
            result[i] = entryList.get(i).getKey();
        }

        return result;
    }
}
```

**时间复杂度：** $O(n \log n)$，主要是排序操作。

**空间复杂度：** $O(n)$，哈希表和列表的存储空间。

### 方法三：桶排序（最优解）

利用频率的范围有限（最多为数组长度），使用桶排序达到线性时间复杂度。

**算法步骤：**

1. 使用哈希表统计每个元素的出现频率
2. 创建频率桶，索引表示频率，值为该频率的元素列表
3. 从高频率到低频率遍历桶，取前 K 个元素

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // 统计每个元素的频率
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        for (int num : nums) {
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }

        // 创建频率桶，索引为频率，值为该频率的元素列表
        List<Integer>[] buckets = new List[nums.length + 1];
        for (int num : frequencyMap.keySet()) {
            int frequency = frequencyMap.get(num);
            if (buckets[frequency] == null) {
                buckets[frequency] = new ArrayList<>();
            }
            buckets[frequency].add(num);
        }

        // 从高频率到低频率收集元素
        List<Integer> result = new ArrayList<>();
        for (int i = buckets.length - 1; i >= 0 && result.size() < k; i--) {
            if (buckets[i] != null) {
                result.addAll(buckets[i]);
            }
        }

        // 转换为数组并截取前k个
        return result.subList(0, k).stream().mapToInt(i -> i).toArray();
    }
}
```

**时间复杂度：** $O(n)$，线性时间复杂度。

**空间复杂度：** $O(n)$，哈希表和桶的存储空间。

### 方法四：快速选择算法

基于快速排序的分治思想，平均时间复杂度为 O(n)。

```java
class Solution {
    private Map<Integer, Integer> frequencyMap;

    public int[] topKFrequent(int[] nums, int k) {
        // 统计频率
        frequencyMap = new HashMap<>();
        for (int num : nums) {
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }

        // 获取所有不同的元素
        Integer[] unique = frequencyMap.keySet().toArray(new Integer[0]);

        // 使用快速选择找到第k个最高频元素的位置
        int targetIndex = unique.length - k;
        quickSelect(unique, 0, unique.length - 1, targetIndex);

        // 返回频率最高的k个元素
        return Arrays.copyOfRange(unique, targetIndex, unique.length)
                     .stream().mapToInt(i -> i).toArray();
    }

    private void quickSelect(Integer[] nums, int left, int right, int k) {
        if (left >= right) return;

        int pivot = partition(nums, left, right);
        if (pivot == k) {
            return;
        } else if (pivot < k) {
            quickSelect(nums, pivot + 1, right, k);
        } else {
            quickSelect(nums, left, pivot - 1, k);
        }
    }

    private int partition(Integer[] nums, int left, int right) {
        int pivot = frequencyMap.get(nums[right]);
        int i = left;

        for (int j = left; j < right; j++) {
            if (frequencyMap.get(nums[j]) < pivot) {
                swap(nums, i, j);
                i++;
            }
        }

        swap(nums, i, right);
        return i;
    }

    private void swap(Integer[] nums, int i, int j) {
        Integer temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

**时间复杂度：** 平均 $O(n)$，最坏 $O(n^2)$

**空间复杂度：** $O(n)$

**推荐使用方法一（哈希表 + 最小堆）**，因为它稳定高效，代码简洁易懂；如果对时间复杂度要求极高，可以考虑方法三（桶排序）。
