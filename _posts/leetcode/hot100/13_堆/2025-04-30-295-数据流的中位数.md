---
title: "295-数据流的中位数"
date: 2025-04-30 21:42:47 +0800
categories: [LEETCODE, HOT100]
tags: [堆, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/find-median-from-data-stream/) \| 难度: 中等

## 问题描述:

**中位数**是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

- 例如 `arr = [2,3,4]` 的中位数是 `3` 。
- 例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5` 。

实现 MedianFinder 类:

- `MedianFinder() `初始化 `MedianFinder` 对象。
- `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。
- `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10-5` 以内的答案将被接受。

**示例 1：**

```java
输入
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
输出
[null, null, null, 1.5, null, 2.0]

解释
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
```

## 解题思路：

这是一道关于设计数据流中位数查找器的问题。需要支持动态添加整数和实时查找中位数。

### 方法一：双堆法（推荐）

核心思想是使用两个堆来维护数据流：最大堆存储较小的一半数据，最小堆存储较大的一半数据。

**算法步骤：**

1. 使用最大堆（`maxHeap`）存储较小的一半元素
2. 使用最小堆（`minHeap`）存储较大的一半元素
3. 保持两个堆的大小平衡：`maxHeap.size()` 和 `minHeap.size()` 的差值不超过 1
4. 添加元素时，根据堆顶元素大小决定加入哪个堆，然后重新平衡
5. 查找中位数时，根据两个堆的大小关系返回对应值

```java
class MedianFinder {
    private PriorityQueue<Integer> maxHeap; // 存储较小的一半，大顶堆
    private PriorityQueue<Integer> minHeap; // 存储较大的一半，小顶堆

    public MedianFinder() {
        // 最大堆，存储较小的一半数据
        maxHeap = new PriorityQueue<>((a, b) -> b - a);
        // 最小堆，存储较大的一半数据
        minHeap = new PriorityQueue<>();
    }

    public void addNum(int num) {
        // 如果最大堆为空或者num小于等于最大堆的堆顶，加入最大堆
        if (maxHeap.isEmpty() || num <= maxHeap.peek()) {
            maxHeap.offer(num);
        } else {
            minHeap.offer(num);
        }

        // 重新平衡两个堆的大小
        rebalance();
    }

    public double findMedian() {
        if (maxHeap.size() == minHeap.size()) {
            // 偶数个元素，返回两个堆顶的平均值
            return (maxHeap.peek() + minHeap.peek()) / 2.0;
        } else {
            // 奇数个元素，返回较大堆的堆顶
            return maxHeap.size() > minHeap.size() ? maxHeap.peek() : minHeap.peek();
        }
    }

    private void rebalance() {
        // 保证两个堆的大小差不超过1
        if (maxHeap.size() > minHeap.size() + 1) {
            minHeap.offer(maxHeap.poll());
        } else if (minHeap.size() > maxHeap.size() + 1) {
            maxHeap.offer(minHeap.poll());
        }
    }
}
```

**时间复杂度：**

- `addNum()`: $O(\log n)$
- `findMedian()`: $O(1)$

**空间复杂度：** $O(n)$，存储所有元素

### 方法二：有序列表法

使用有序数据结构（如 ArrayList）维护所有元素的有序状态。

**算法步骤：**

1. 使用 ArrayList 存储所有元素，保持有序
2. 添加元素时使用二分查找找到插入位置
3. 查找中位数时直接根据索引获取

```java
class MedianFinder {
    private List<Integer> nums;

    public MedianFinder() {
        nums = new ArrayList<>();
    }

    public void addNum(int num) {
        // 使用二分查找找到插入位置
        int left = 0, right = nums.size();
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums.get(mid) < num) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        nums.add(left, num);
    }

    public double findMedian() {
        int n = nums.size();
        if (n % 2 == 1) {
            // 奇数个元素
            return nums.get(n / 2);
        } else {
            // 偶数个元素
            return (nums.get(n / 2 - 1) + nums.get(n / 2)) / 2.0;
        }
    }
}
```

**时间复杂度：**

- `addNum()`: $O(n)$（插入操作需要移动元素）
- `findMedian()`: $O(1)$

**空间复杂度：** $O(n)$

### 方法三：多重集合法（TreeMap 实现）

使用 TreeMap 统计每个数字的出现次数，维护有序性。

```java
class MedianFinder {
    private TreeMap<Integer, Integer> map;
    private int count;

    public MedianFinder() {
        map = new TreeMap<>();
        count = 0;
    }

    public void addNum(int num) {
        map.put(num, map.getOrDefault(num, 0) + 1);
        count++;
    }

    public double findMedian() {
        if (count % 2 == 1) {
            return findKthElement((count + 1) / 2);
        } else {
            return (findKthElement(count / 2) + findKthElement(count / 2 + 1)) / 2.0;
        }
    }

    private int findKthElement(int k) {
        int currentCount = 0;
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            currentCount += entry.getValue();
            if (currentCount >= k) {
                return entry.getKey();
            }
        }
        return -1; // 不应该到达这里
    }
}
```

**时间复杂度：**

- `addNum()`: $O(\log n)$
- `findMedian()`: $O(n)$（最坏情况下需要遍历所有不同的数字）

**空间复杂度：** $O(n)$

**推荐使用方法一（双堆法）**，因为它在时间和空间复杂度上都有最优的表现，特别适合需要频繁查找中位数的场景。
