---
title: "64-最小路径和"
date: 2025-05-18 21:49:21 +0800
categories: [LEETCODE, HOT100]
tags: [多维动态规划, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/minimum-path-sum/) \| 难度: 中等

## 问题描述:

给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：** 每次只能向下或者向右移动一步。

**示例 1：**

![img](../assets/img/posts/leetcode/p64_0.jpg)

```java
输入: grid = [[1,3,1],[1,5,1],[4,2,1]]
输出: 7
解释: 因为路径 1->3->1->1->1 的总和最小
```

**示例 2：**

```java
输入: grid = [[1,2,3],[4,5,6]]
输出: 12
```

## 解题思路：

这是一道经典的动态规划问题——最小路径和。需要找到从网格左上角到右下角的路径，使得路径上数字的总和最小。

### 方法：动态规划

核心思想是利用动态规划，从左上角开始逐步计算到达每个位置的最小路径和。

**算法步骤：**

1. 创建一个与原网格相同大小的 dp 数组，`dp[i][j]`表示从起点到位置`(i,j)`的最小路径和
2. 初始化第一行和第一列：只能从左边或上边到达
3. 对于其他位置，状态转移方程为：`dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])`
4. 最终答案为`dp[m-1][n-1]`

**优化：** 可以直接在原数组上修改，节省空间复杂度。

```java
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }

        int m = grid.length;
        int n = grid[0].length;

        // 初始化第一行：只能从左边到达
        for (int j = 1; j < n; j++) {
            grid[0][j] += grid[0][j - 1];
        }

        // 初始化第一列：只能从上边到达
        for (int i = 1; i < m; i++) {
            grid[i][0] += grid[i - 1][0];
        }

        // 填充其余位置
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                // 选择从上方或左方到达的最小值
                grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
            }
        }

        return grid[m - 1][n - 1];
    }
}
```

**如果不想修改原数组，可以创建新的 dp 数组：**

```java
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }

        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];

        // 起点
        dp[0][0] = grid[0][0];

        // 初始化第一行
        for (int j = 1; j < n; j++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }

        // 初始化第一列
        for (int i = 1; i < m; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }

        // 填充其余位置
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);
            }
        }

        return dp[m - 1][n - 1];
    }
}
```

**进一步优化：使用一维数组**

```java
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }

        int m = grid.length;
        int n = grid[0].length;
        int[] dp = new int[n];

        // 初始化第一行
        dp[0] = grid[0][0];
        for (int j = 1; j < n; j++) {
            dp[j] = dp[j - 1] + grid[0][j];
        }

        // 逐行处理
        for (int i = 1; i < m; i++) {
            dp[0] += grid[i][0]; // 第一列只能从上方来
            for (int j = 1; j < n; j++) {
                dp[j] = grid[i][j] + Math.min(dp[j], dp[j - 1]);
            }
        }

        return dp[n - 1];
    }
}
```

**时间复杂度：** $O(m \times n)$，需要遍历网格中的每个元素。

**空间复杂度：**

- 原地修改：$O(1)$
- 使用 dp 数组：$O(m \times n)$
- 使用一维数组：$O(n)$

**推荐使用原地修改的方法**，因为它空间效率最高且代码简洁易懂。
