---
title: "64-最小路径和"
date: 2025-05-18 21:49:21 +0800
categories: [LEETCODE, HOT100]
tags: [多维动态规划, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/minimum-path-sum/) \| 难度: 中等

## 问题描述:

给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：** 每次只能向下或者向右移动一步。

**示例 1：**

![img](../assets/img/posts/leetcode/p64_0.jpg)

```java
输入: grid = [[1,3,1],[1,5,1],[4,2,1]]
输出: 7
解释: 因为路径 1->3->1->1->1 的总和最小
```

**示例 2：**

```java
输入: grid = [[1,2,3],[4,5,6]]
输出: 12
```

## 解题思路：

这是一道经典的最小路径和问题。需要从网格的左上角移动到右下角，每次只能向右或向下移动一步，目标是找到路径上数字和最小的路径。

### 方法一：动态规划法（推荐）

核心思想是使用动态规划，`dp[i][j]` 表示从起点到位置 `(i,j)` 的最小路径和。

**算法步骤：**

1. 创建二维数组 `dp`，其中 `dp[i][j]` 表示到达位置 `(i,j)` 的最小路径和
2. 初始化第一行和第一列，只能从一个方向到达
3. 对于其他位置，`dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])`
4. 返回 `dp[m-1][n-1]`

```java
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        
        // 初始化起点
        dp[0][0] = grid[0][0];
        
        // 初始化第一行
        for (int j = 1; j < n; j++) {
            dp[0][j] = dp[0][j-1] + grid[0][j];
        }
        
        // 初始化第一列
        for (int i = 1; i < m; i++) {
            dp[i][0] = dp[i-1][0] + grid[i][0];
        }
        
        // 填充其余位置
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);
            }
        }
        
        return dp[m-1][n-1];
    }
}
```

**时间复杂度：** $O(m \times n)$，需要遍历整个网格。

**空间复杂度：** $O(m \times n)$，需要额外的二维数组存储结果。

### 方法二：空间优化的动态规划

使用一维数组来优化空间复杂度，因为每个位置只依赖于上方和左方的值。

**算法步骤：**

1. 使用一维数组 `dp`，长度为列数 `n`
2. 初始化第一行
3. 逐行更新数组，`dp[j] = grid[i][j] + min(dp[j], dp[j-1])`

```java
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        
        int m = grid.length;
        int n = grid[0].length;
        int[] dp = new int[n];
        
        // 初始化第一行
        dp[0] = grid[0][0];
        for (int j = 1; j < n; j++) {
            dp[j] = dp[j-1] + grid[0][j];
        }
        
        // 逐行更新
        for (int i = 1; i < m; i++) {
            dp[0] += grid[i][0]; // 更新第一列
            for (int j = 1; j < n; j++) {
                dp[j] = grid[i][j] + Math.min(dp[j], dp[j-1]);
            }
        }
        
        return dp[n-1];
    }
}
```

**时间复杂度：** $O(m \times n)$，需要遍历整个网格。

**空间复杂度：** $O(n)$，只需要一维数组。

### 方法三：原地修改（最优空间）

直接在原网格上进行修改，不使用额外空间。

**算法步骤：**

1. 初始化第一行和第一列
2. 对于其他位置，直接修改 `grid[i][j] += min(grid[i-1][j], grid[i][j-1])`
3. 返回 `grid[m-1][n-1]`

```java
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        
        int m = grid.length;
        int n = grid[0].length;
        
        // 初始化第一行
        for (int j = 1; j < n; j++) {
            grid[0][j] += grid[0][j-1];
        }
        
        // 初始化第一列
        for (int i = 1; i < m; i++) {
            grid[i][0] += grid[i-1][0];
        }
        
        // 填充其余位置
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);
            }
        }
        
        return grid[m-1][n-1];
    }
}
```

**时间复杂度：** $O(m \times n)$，需要遍历整个网格。

**空间复杂度：** $O(1)$，只使用常量级额外空间，但会修改原数组。

**推荐使用方法二（空间优化的动态规划）**，因为它在保持较好时间复杂度的同时优化了空间复杂度，且不会修改原数组。如果允许修改原数组，方法三是最优选择。
