---
title: "1143-最长公共子序列"
date: 2025-05-20 21:49:41 +0800
categories: [LEETCODE, HOT100]
tags: [多维动态规划, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/longest-common-subsequence/) \| 难度: 中等

## 问题描述:

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长**公共子序列**的长度。如果不存在**公共子序列**，返回 `0` 。

一个字符串的**子序列**是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的**公共子序列**是这两个字符串所共同拥有的子序列。

**示例 1：**

```java
输入: text1 = "abcde", text2 = "ace"
输出: 3
解释: 最长公共子序列是 "ace", 它的长度为 3
```

**示例 2：**

```java
输入: text1 = "abc", text2 = "abc"
输出: 3
解释: 最长公共子序列是 "abc", 它的长度为 3
```

**示例 3：**

```java
输入: text1 = "abc", text2 = "def"
输出: 0
解释: 两个字符串没有公共子序列, 返回 0
```

## 解题思路：

这是一道关于最长公共子序列（LCS）的经典动态规划问题。需要找到两个字符串中最长的公共子序列长度。

### 方法一：二维动态规划法（推荐）

使用二维动态规划数组来解决这个问题。核心思想是比较两个字符串的每个字符，逐步构建最优解。

**算法步骤：**

1. 创建一个 (m+1)×(n+1) 的二维数组 dp，其中 m 和 n 分别是 text1 和 text2 的长度
2. 初始化边界条件：`dp[0][j] = 0`，`dp[i][0] = 0`（空字符串的 LCS 长度为 0）
3. 对于每个位置`(i,j)`：
   - 如果 `text1[i-1] == text2[j-1]`，则 `dp[i][j] = dp[i-1][j-1] + 1`
   - 否则，`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();

        // dp[i][j] 表示 text1 前 i 个字符和 text2 前 j 个字符的最长公共子序列长度
        int[][] dp = new int[m + 1][n + 1];

        // 边界条件已经初始化为0，无需额外处理

        // 填充 dp 数组
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    // 字符相同，LCS长度加1
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // 字符不同，取两种情况的最大值
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[m][n];
    }
}
```

**时间复杂度：** $O(m \times n)$，其中 $m$ 和 $n$ 分别是两个字符串的长度。

**空间复杂度：** $O(m \times n)$，用于存储 dp 数组。

### 方法二：空间优化的动态规划

由于每次计算只需要用到上一行的数据，可以优化空间复杂度到 O(n)。

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();

        // 只使用一维数组，滚动更新
        int[] dp = new int[n + 1];

        for (int i = 1; i <= m; i++) {
            int prev = 0; // 保存 dp[i-1][j-1] 的值

            for (int j = 1; j <= n; j++) {
                int temp = dp[j]; // 保存当前 dp[i-1][j] 的值

                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[j] = prev + 1; // dp[i-1][j-1] + 1
                } else {
                    dp[j] = Math.max(dp[j], dp[j - 1]); // max(dp[i-1][j], dp[i][j-1])
                }

                prev = temp; // 更新 prev 为下一轮的 dp[i-1][j-1]
            }
        }

        return dp[n];
    }
}
```

**时间复杂度：** $O(m \times n)$。

**空间复杂度：** $O(n)$，只使用一维数组。

### 方法三：递归 + 记忆化搜索

使用递归的方式思考问题，并使用记忆化避免重复计算。

```java
class Solution {
    private int[][] memo;

    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        memo = new int[m][n];

        // 初始化memo数组为-1
        for (int i = 0; i < m; i++) {
            Arrays.fill(memo[i], -1);
        }

        return dfs(text1, text2, 0, 0);
    }

    private int dfs(String text1, String text2, int i, int j) {
        // 边界条件：任一字符串到达末尾
        if (i == text1.length() || j == text2.length()) {
            return 0;
        }

        // 如果已经计算过，直接返回
        if (memo[i][j] != -1) {
            return memo[i][j];
        }

        int result;
        if (text1.charAt(i) == text2.charAt(j)) {
            // 字符相同，继续比较下一个字符
            result = 1 + dfs(text1, text2, i + 1, j + 1);
        } else {
            // 字符不同，分别跳过text1和text2的当前字符，取最大值
            result = Math.max(
                dfs(text1, text2, i + 1, j),
                dfs(text1, text2, i, j + 1)
            );
        }

        memo[i][j] = result;
        return result;
    }
}
```

**时间复杂度：** $O(m \times n)$。

**空间复杂度：** $O(m \times n)$，包括递归栈空间和 memo 数组。

### 方法四：获取具体的最长公共子序列

如果需要返回具体的最长公共子序列内容，可以在二维 DP 的基础上进行回溯：

```java
class Solution {
    public String longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m + 1][n + 1];

        // 填充 dp 数组
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        // 回溯构建LCS字符串
        StringBuilder lcs = new StringBuilder();
        int i = m, j = n;
        while (i > 0 && j > 0) {
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                lcs.append(text1.charAt(i - 1));
                i--;
                j--;
            } else if (dp[i - 1][j] > dp[i][j - 1]) {
                i--;
            } else {
                j--;
            }
        }

        return lcs.reverse().toString();
    }
}
```

**推荐使用方法一（二维动态规划法）**，因为它思路清晰，易于理解和实现；如果需要优化空间，可以使用方法二；方法三适合用来理解递归思想；方法四用于获取具体的 LCS 内容。
