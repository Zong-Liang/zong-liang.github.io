---
title: "62-不同路径"
date: 2025-05-17 21:49:10 +0800
categories: [LEETCODE, HOT100]
tags: [多维动态规划, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/unique-paths/) \| 难度: 中等

## 问题描述:

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

![img](../assets/img/posts/leetcode/p62_0.png)

```java
输入: m = 3, n = 7
输出: 28
```

**示例 2：**

```java
输入: m = 3, n = 2
输出: 3
解释: 从左上角开始, 总共有 3 条路径可以到达右下角
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

**示例 3：**

```java
输入: m = 7, n = 3
输出: 28
```

**示例 4：**

```java
输入: m = 3, n = 3
输出: 6
```

## 解题思路：

这是一道经典的动态规划问题，需要计算从起点到终点的所有可能路径数量。

### 方法一：动态规划（推荐）

**核心思想：** 到达任意位置的路径数等于到达其上方位置和左方位置的路径数之和。

**算法步骤：**

1. 创建一个 `m × n` 的二维数组 `dp`，`dp[i][j]` 表示到达位置 `(i,j)` 的路径数
2. 初始化第一行和第一列为 1（只有一条路径可以到达）
3. 状态转移方程：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`
4. 返回 `dp[m-1][n-1]`

```java
class Solution {
    public int uniquePaths(int m, int n) {
        // 创建dp数组
        int[][] dp = new int[m][n];

        // 初始化第一行
        for (int j = 0; j < n; j++) {
            dp[0][j] = 1;
        }

        // 初始化第一列
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }

        // 填充dp数组
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        return dp[m-1][n-1];
    }
}
```

**时间复杂度：** $O(m \times n)$

**空间复杂度：** $O(m \times n)$

### 方法二：空间优化的动态规划

由于每个位置只依赖于上方和左方的值，可以用一维数组优化空间。

```java
class Solution {
    public int uniquePaths(int m, int n) {
        // 只需要一行的空间
        int[] dp = new int[n];

        // 初始化第一行
        Arrays.fill(dp, 1);

        // 从第二行开始计算
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[j] = dp[j] + dp[j-1];
            }
        }

        return dp[n-1];
    }
}
```

**时间复杂度：** $O(m \times n)$

**空间复杂度：** $O(n)$

### 方法三：数学组合法

**核心思想：** 从左上角到右下角需要移动 `(m-1) + (n-1)` 步，其中 `(m-1)` 步向下，`(n-1)` 步向右。问题转化为在总共 `m+n-2` 步中选择 `m-1` 步向下的组合数。

```java
class Solution {
    public int uniquePaths(int m, int n) {
        // 计算 C(m+n-2, m-1)
        int totalSteps = m + n - 2;
        int downSteps = m - 1;

        long result = 1;

        // 计算组合数，避免溢出
        for (int i = 0; i < downSteps; i++) {
            result = result * (totalSteps - i) / (i + 1);
        }

        return (int) result;
    }
}
```

**时间复杂度：** $O(\min(m, n))$

**空间复杂度：** $O(1)$

**推荐使用方法二（空间优化的动态规划）**，它在时间复杂度合理的情况下最大化了空间效率，代码也相对简洁易懂。如果对性能要求极高，可以考虑方法三（数学组合法）。
