---
title: "5-最长回文子串"
date: 2025-05-16 21:49:00 +0800
categories: [LEETCODE, HOT100]
tags: [多维动态规划, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/longest-palindromic-substring/) \| 难度: 中等

## 问题描述:

给你一个字符串 `s`，找到 `s` 中最长的 回文 子串。

**示例 1：**

```java
输入: s = "babad"
输出: "bab"
解释: "aba" 同样是符合题意的答案
```

**示例 2：**

```java
输入: s = "cbbd"
输出: "bb"
```

## 解题思路：

这是一道经典的最长回文子串问题。给定一个字符串，要求找到其中最长的回文子串。

### 方法一：中心扩散法（推荐）

回文字符串的特点是以某个字符（或字符间隙）为中心，向两边扩散时字符相同。

**算法步骤：**

1. 遍历字符串的每个位置作为回文中心
2. 对于每个中心，分别考虑奇数长度和偶数长度的回文
3. 从中心向两边扩散，找到以该点为中心的最长回文
4. 记录全局最长的回文子串

```java
class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) {
            return "";
        }

        int start = 0, end = 0;

        for (int i = 0; i < s.length(); i++) {
            // 奇数长度回文，以i为中心
            int len1 = expandAroundCenter(s, i, i);
            // 偶数长度回文，以i和i+1之间为中心
            int len2 = expandAroundCenter(s, i, i + 1);

            int maxLen = Math.max(len1, len2);

            // 更新最长回文的起始和结束位置
            if (maxLen > end - start) {
                start = i - (maxLen - 1) / 2;
                end = i + maxLen / 2;
            }
        }

        return s.substring(start, end + 1);
    }

    private int expandAroundCenter(String s, int left, int right) {
        // 向两边扩散，找到以left和right为中心的最长回文长度
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1;
    }
}
```

**时间复杂度：** $O(n^2)$，其中 $n$ 是字符串长度。每个中心最多扩散 $n$ 次。

**空间复杂度：** $O(1)$，只使用常数额外空间。

### 方法二：动态规划法

使用二维数组记录子串是否为回文。

**算法步骤：**

1. 创建二维布尔数组 `dp[i][j]` 表示从索引 `i` 到 `j` 的子串是否为回文
2. 初始化：单个字符都是回文，相邻相同字符是回文
3. 从长度为 3 的子串开始，逐步填充 dp 表
4. 记录最长回文子串的位置

```java
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        if (n < 2) {
            return s;
        }

        boolean[][] dp = new boolean[n][n];
        int maxLen = 1;
        int start = 0;

        // 单个字符都是回文
        for (int i = 0; i < n; i++) {
            dp[i][i] = true;
        }

        // 检查长度为2的子串
        for (int i = 0; i < n - 1; i++) {
            if (s.charAt(i) == s.charAt(i + 1)) {
                dp[i][i + 1] = true;
                start = i;
                maxLen = 2;
            }
        }

        // 检查长度为3及以上的子串
        for (int len = 3; len <= n; len++) {
            for (int i = 0; i < n - len + 1; i++) {
                int j = i + len - 1;

                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {
                    dp[i][j] = true;
                    start = i;
                    maxLen = len;
                }
            }
        }

        return s.substring(start, start + maxLen);
    }
}
```

**时间复杂度：** $O(n^2)$

**空间复杂度：** $O(n^2)$，需要二维数组存储状态。

### 方法三：Manacher 算法（最优解）

这是专门解决回文问题的线性时间算法，但实现较复杂。

```java
class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() == 0) {
            return "";
        }

        // 预处理字符串，在每个字符间插入'#'
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            sb.append('#').append(s.charAt(i));
        }
        sb.append('#');

        String processed = sb.toString();
        int n = processed.length();
        int[] radius = new int[n]; // 回文半径数组
        int center = 0, right = 0; // 当前回文的中心和右边界
        int maxLen = 0, maxCenter = 0;

        for (int i = 0; i < n; i++) {
            // 利用回文的对称性
            int mirror = 2 * center - i;

            if (i < right) {
                radius[i] = Math.min(right - i, radius[mirror]);
            }

            // 尝试扩展回文
            try {
                while (i + radius[i] + 1 < n && i - radius[i] - 1 >= 0 &&
                       processed.charAt(i + radius[i] + 1) == processed.charAt(i - radius[i] - 1)) {
                    radius[i]++;
                }
            } catch (Exception e) {
                // 边界处理
            }

            // 更新中心和右边界
            if (i + radius[i] > right) {
                center = i;
                right = i + radius[i];
            }

            // 更新最长回文
            if (radius[i] > maxLen) {
                maxLen = radius[i];
                maxCenter = i;
            }
        }

        // 还原到原字符串的位置
        int start = (maxCenter - maxLen) / 2;
        return s.substring(start, start + maxLen);
    }
}
```

**时间复杂度：** $O(n)$

**空间复杂度：** $O(n)$

**推荐使用方法一（中心扩散法）**，因为它简洁易懂，时间复杂度 acceptable，空间复杂度最优。对于面试场景，这是最佳选择。
