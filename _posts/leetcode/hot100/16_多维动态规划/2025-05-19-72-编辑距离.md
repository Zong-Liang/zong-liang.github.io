---
title: "72-编辑距离"
date: 2025-05-19 21:49:29 +0800
categories: [LEETCODE, HOT100]
tags: [多维动态规划, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/edit-distance/) \| 难度: 中等

## 问题描述:

给你两个单词 `word1` 和 `word2`，请返回将 `word1` 转换成 `word2` 所使用的最少操作数。

你可以对一个单词进行如下三种操作:

- 插入一个字符。
- 删除一个字符。
- 替换一个字符。

**示例 1：**

```java
输入: word1 = "horse", word2 = "ros"
输出: 3
解释:
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例 2：**

```java
输入: word1 = "intention", word2 = "execution"
输出: 5
解释:
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

**提示：** `word1` 和 `word2` 由小写英文字母组成。

## 解题思路：

这是一道关于编辑距离的问题。给定两个单词，需要计算将 word1 转换为 word2 所需的最少操作数。可以进行插入、删除、替换三种操作。

### 方法一：动态规划法（推荐）

使用二维动态规划数组来解决这个问题。核心思想是将大问题拆解为子问题。

**算法步骤：**

1. 创建一个 (m+1)×(n+1) 的二维数组 dp，其中 m 和 n 分别是 word1 和 word2 的长度
2. 初始化边界条件：`dp[i][0] = i，dp[0][j] = j`
3. 对于每个位置(i,j)，考虑三种操作：
   - 如果 `word1[i-1] == word2[j-1]`，则 `dp[i][j] = dp[i-1][j-1]`
   - 否则，取三种操作的最小值加 1：
     - 插入：`dp[i][j-1] + 1`
     - 删除：`dp[i-1][j] + 1`
     - 替换：`dp[i-1][j-1] + 1`

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();

        // dp[i][j] 表示 word1 的前 i 个字符转换成 word2 的前 j 个字符所使用的最少操作数
        int[][] dp = new int[m + 1][n + 1];

        // 初始化边界条件
        // 当 word2 为空时，将 word1 转换为空字符串需要删除 i 个字符
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        // 当 word1 为空时，将空字符串转换为 word2 需要插入 j 个字符
        for (int j = 0; j <= n; j++) {
            dp[0][j] = j;
        }

        // 填充 dp 表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 获取当前比较的字符
                char c1 = word1.charAt(i - 1);
                char c2 = word2.charAt(j - 1);

                if (c1 == c2) {
                    // 如果两个字符相同，则不需要任何操作
                    // 操作数等于 dp[i-1][j-1]
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    // 如果两个字符不同，则需要进行一次操作（插入、删除或替换）
                    // 取三者中的最小值
                    // 1. 替换：dp[i-1][j-1] + 1 (将 word1[i-1] 替换为 word2[j-1])
                    // 2. 删除：dp[i-1][j] + 1 (删除 word1[i-1])
                    // 3. 插入：dp[i][j-1] + 1 (在 word1 后插入 word2[j-1])
                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
                }
            }
        }

        // 返回最终结果
        return dp[m][n];
    }
}
```

**时间复杂度：** $O(m \times n)$，其中 $m$ 和 $n$ 分别是两个字符串的长度。

**空间复杂度：** $O(m \times n)$，用于存储 dp 数组。

### 方法二：空间优化的动态规划

由于每次计算只需要用到上一行和当前行的数据，可以优化空间复杂度。

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();

        // 只使用一维数组，滚动更新
        int[] dp = new int[n + 1];

        // 初始化第一行
        for (int j = 0; j <= n; j++) {
            dp[j] = j;
        }

        for (int i = 1; i <= m; i++) {
            int prev = dp[0]; // 保存 dp[i-1][j-1] 的值
            dp[0] = i; // 更新第一列

            for (int j = 1; j <= n; j++) {
                int temp = dp[j]; // 保存当前 dp[i-1][j] 的值

                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[j] = prev; // dp[i-1][j-1]
                } else {
                    dp[j] = Math.min(
                        Math.min(dp[j] + 1, dp[j - 1] + 1), // 删除, 插入
                        prev + 1 // 替换
                    );
                }

                prev = temp; // 更新 prev 为下一轮的 dp[i-1][j-1]
            }
        }

        return dp[n];
    }
}
```

**时间复杂度：** $O(m \times n)$。

**空间复杂度：** $O(n)$，只使用一维数组。

### 方法三：递归 + 记忆化搜索

使用递归的方式思考问题，并使用记忆化避免重复计算。

```java
class Solution {
    private int[][] memo;

    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        memo = new int[m][n];

        // 初始化memo数组为-1
        for (int i = 0; i < m; i++) {
            Arrays.fill(memo[i], -1);
        }

        return dfs(word1, word2, 0, 0);
    }

    private int dfs(String word1, String word2, int i, int j) {
        // 边界条件
        if (i == word1.length()) return word2.length() - j;
        if (j == word2.length()) return word1.length() - i;

        // 如果已经计算过，直接返回
        if (memo[i][j] != -1) return memo[i][j];

        int result;
        if (word1.charAt(i) == word2.charAt(j)) {
            result = dfs(word1, word2, i + 1, j + 1);
        } else {
            result = Math.min(
                Math.min(
                    dfs(word1, word2, i + 1, j) + 1,     // 删除
                    dfs(word1, word2, i, j + 1) + 1      // 插入
                ),
                dfs(word1, word2, i + 1, j + 1) + 1      // 替换
            );
        }

        memo[i][j] = result;
        return result;
    }
}
```

**时间复杂度：** $O(m \times n)$。

**空间复杂度：** $O(m \times n)$，包括递归栈空间和 memo 数组。

**推荐使用方法一（动态规划法）**，因为它思路清晰，易于理解和实现；如果需要优化空间，可以使用方法二；方法三适合用来理解递归思想。
