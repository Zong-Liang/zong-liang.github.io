---
title: "131-分割回文串"
date: 2025-04-17 21:36:46 +0800
categories: [LEETCODE, HOT100]
tags: [回溯, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/palindrome-partitioning/) \| 难度: 中等

## 问题描述:

给你一个字符串 `s`，请你将 `s` 分割成一些 子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**示例 1：**

```java
输入: s = "aab"
输出: [["a","a","b"],["aa","b"]]
```

**示例 2：**

```java
输入: s = "a"
输出: [["a"]]
```

## 解题思路：

这是一道关于分割回文串的回溯算法问题。需要找到字符串的所有可能分割方案，使得每个子串都是回文串。

### 方法一：回溯 + 动态规划预处理（推荐）

核心思想是使用回溯算法枚举所有可能的分割方案，同时用动态规划预处理判断子串是否为回文，提高效率。

**算法步骤：**

1. 使用动态规划预处理，构建二维数组记录任意子串是否为回文
2. 使用回溯算法从字符串开始位置逐个尝试分割
3. 对于每个位置，尝试从当前位置到字符串末尾的所有可能切割点
4. 如果当前子串是回文，则递归处理剩余部分
5. 当到达字符串末尾时，将当前分割方案加入结果

```java
class Solution {
    public List<List<String>> partition(String s) {
        List<List<String>> result = new ArrayList<>();
        if (s == null || s.length() == 0) {
            return result;
        }

        int n = s.length();
        // 预处理：动态规划判断子串是否为回文
        boolean[][] isPalindrome = new boolean[n][n];

        // 构建回文判断表
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    // 单个字符或相邻字符相等，或者内部是回文
                    isPalindrome[i][j] = (j - i <= 2) || isPalindrome[i + 1][j - 1];
                }
            }
        }

        // 回溯搜索所有分割方案
        backtrack(s, 0, new ArrayList<>(), result, isPalindrome);
        return result;
    }

    private void backtrack(String s, int start, List<String> path,
                          List<List<String>> result, boolean[][] isPalindrome) {
        // 到达字符串末尾，找到一个有效分割
        if (start == s.length()) {
            result.add(new ArrayList<>(path));
            return;
        }

        // 尝试从start位置开始的所有可能子串
        for (int end = start; end < s.length(); end++) {
            // 如果当前子串是回文
            if (isPalindrome[start][end]) {
                // 选择当前子串
                path.add(s.substring(start, end + 1));
                // 递归处理剩余部分
                backtrack(s, end + 1, path, result, isPalindrome);
                // 回溯，撤销选择
                path.remove(path.size() - 1);
            }
        }
    }
}
```

**时间复杂度：** $O(n \times 2^n)$，其中 $n$ 是字符串长度。最坏情况下有 $2^{n-1}$ 种分割方法，每种方法需要 $O(n)$ 时间复制到结果中。

**空间复杂度：** $O(n^2)$，动态规划表的空间复杂度，递归栈深度最大为 $n$。

### 方法二：回溯 + 中心扩展法判断回文

不使用额外的动态规划表，而是在回溯过程中使用中心扩展法判断回文。

```java
class Solution {
    public List<List<String>> partition(String s) {
        List<List<String>> result = new ArrayList<>();
        if (s == null || s.length() == 0) {
            return result;
        }

        backtrack(s, 0, new ArrayList<>(), result);
        return result;
    }

    private void backtrack(String s, int start, List<String> path, List<List<String>> result) {
        // 到达字符串末尾
        if (start == s.length()) {
            result.add(new ArrayList<>(path));
            return;
        }

        // 尝试从start位置开始的所有可能子串
        for (int end = start; end < s.length(); end++) {
            // 如果当前子串是回文
            if (isPalindrome(s, start, end)) {
                // 选择当前子串
                path.add(s.substring(start, end + 1));
                // 递归处理剩余部分
                backtrack(s, end + 1, path, result);
                // 回溯，撤销选择
                path.remove(path.size() - 1);
            }
        }
    }

    // 判断子串s[left...right]是否为回文
    private boolean isPalindrome(String s, int left, int right) {
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```

**时间复杂度：** $O(n \times 2^n)$，每次判断回文需要 $O(n)$ 时间。

**空间复杂度：** $O(n)$，递归栈的空间复杂度。

### 方法三：记忆化递归优化

结合记忆化递归来避免重复计算回文判断。

```java
class Solution {
    private Boolean[][] memo;

    public List<List<String>> partition(String s) {
        List<List<String>> result = new ArrayList<>();
        if (s == null || s.length() == 0) {
            return result;
        }

        int n = s.length();
        memo = new Boolean[n][n]; // 记忆化数组

        backtrack(s, 0, new ArrayList<>(), result);
        return result;
    }

    private void backtrack(String s, int start, List<String> path, List<List<String>> result) {
        if (start == s.length()) {
            result.add(new ArrayList<>(path));
            return;
        }

        for (int end = start; end < s.length(); end++) {
            if (isPalindrome(s, start, end)) {
                path.add(s.substring(start, end + 1));
                backtrack(s, end + 1, path, result);
                path.remove(path.size() - 1);
            }
        }
    }

    // 记忆化判断回文
    private boolean isPalindrome(String s, int left, int right) {
        if (memo[left][right] != null) {
            return memo[left][right];
        }

        if (left >= right) {
            memo[left][right] = true;
        } else if (s.charAt(left) == s.charAt(right)) {
            memo[left][right] = isPalindrome(s, left + 1, right - 1);
        } else {
            memo[left][right] = false;
        }

        return memo[left][right];
    }
}
```

**推荐使用方法一（回溯 + 动态规划预处理）**，因为它预先计算了所有子串的回文性质，在回溯过程中查询时间为 $O(1)$，整体效率最高。
