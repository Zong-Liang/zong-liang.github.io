---
title: "78-子集"
date: 2025-04-15 21:36:23 +0800
categories: [LEETCODE, HOT100]
tags: [回溯, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/subsets/) \| 难度: 中等

## 问题描述:

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

**示例 1：**

```java
输入: nums = [1,2,3]
输出: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**示例 2：**

```java
输入: nums = [0]
输出: [[],[0]]
```

**提示：** `nums` 中的所有元素 **互不相同**

## 解题思路：

这是一道关于生成所有子集（幂集）的问题，需要返回给定数组所有可能的子集。本质上是一个**回溯算法**问题，需要枚举所有可能的元素组合。

### 核心思想：

- 对于每个元素，都有选择和不选择两种情况
- 使用回溯算法，逐个考虑每个元素是否加入当前子集
- 空集也是一个有效的子集
- 需要生成 2^n 个子集（n 为数组长度）

### 方法一：回溯算法（推荐）

**算法步骤：**

1. 从空子集开始，逐个考虑每个元素
2. 对于每个元素，有两种选择：加入当前子集或不加入
3. 递归处理剩余元素
4. 当处理完所有元素时，将当前子集加入结果

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        backtrack(result, new ArrayList<>(), nums, 0);
        return result;
    }

    private void backtrack(List<List<Integer>> result, List<Integer> current,
                          int[] nums, int start) {
        // 每次递归都添加当前子集到结果中
        result.add(new ArrayList<>(current));

        // 从start开始，尝试添加后续的每个元素
        for (int i = start; i < nums.length; i++) {
            // 选择当前元素
            current.add(nums[i]);

            // 递归处理剩余元素
            backtrack(result, current, nums, i + 1);

            // 撤销选择（回溯）
            current.remove(current.size() - 1);
        }
    }
}
```

**时间复杂度：** $O(2^n \times n)$，生成 $2^n$ 个子集，每个子集平均长度为 $n/2$。

**空间复杂度：** $O(n)$，递归深度最多为 $n$。

### 方法二：迭代法

通过迭代的方式逐步构建所有子集。

**算法步骤：**

1. 初始化结果为空集
2. 对于每个元素，将其添加到已有的所有子集中，形成新的子集
3. 重复此过程直到处理完所有元素

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        result.add(new ArrayList<>()); // 添加空集

        for (int num : nums) {
            int size = result.size();
            // 对于每个已存在的子集，创建包含当前元素的新子集
            for (int i = 0; i < size; i++) {
                List<Integer> newSubset = new ArrayList<>(result.get(i));
                newSubset.add(num);
                result.add(newSubset);
            }
        }

        return result;
    }
}
```

**时间复杂度：** $O(2^n \times n)$，同方法一。

**空间复杂度：** $O(1)$，不考虑结果存储的额外空间。

### 方法三：位运算法

利用二进制位来表示每个元素是否在子集中。

**算法步骤：**

1. 对于 n 个元素，有 2^n 种可能的组合
2. 用 0 到 2^n-1 的二进制表示来枚举所有可能
3. 二进制位为 1 表示对应元素在子集中，为 0 表示不在

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        int n = nums.length;

        // 遍历所有可能的二进制组合
        for (int i = 0; i < (1 << n); i++) {
            List<Integer> subset = new ArrayList<>();

            // 检查二进制的每一位
            for (int j = 0; j < n; j++) {
                // 如果第j位为1，则包含nums[j]
                if ((i & (1 << j)) != 0) {
                    subset.add(nums[j]);
                }
            }

            result.add(subset);
        }

        return result;
    }
}
```

**时间复杂度：** $O(2^n \times n)$，需要生成 $2^n$ 个子集。

**空间复杂度：** $O(1)$，不考虑结果存储的额外空间。

### 方法四：递归分治

基于"选择或不选择当前元素"的思想进行递归。

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        return generateSubsets(nums, 0);
    }

    private List<List<Integer>> generateSubsets(int[] nums, int index) {
        // 基本情况：没有更多元素可选择
        if (index == nums.length) {
            List<List<Integer>> result = new ArrayList<>();
            result.add(new ArrayList<>());
            return result;
        }

        // 递归生成不包含当前元素的所有子集
        List<List<Integer>> subsetsWithoutCurrent = generateSubsets(nums, index + 1);

        // 复制并添加当前元素，生成包含当前元素的所有子集
        List<List<Integer>> subsetsWithCurrent = new ArrayList<>();
        for (List<Integer> subset : subsetsWithoutCurrent) {
            List<Integer> newSubset = new ArrayList<>(subset);
            newSubset.add(nums[index]);
            subsetsWithCurrent.add(newSubset);
        }

        // 合并两种情况的结果
        List<List<Integer>> allSubsets = new ArrayList<>();
        allSubsets.addAll(subsetsWithoutCurrent);
        allSubsets.addAll(subsetsWithCurrent);

        return allSubsets;
    }
}
```

**时间复杂度：** $O(2^n \times n)$，同前面的方法。

**空间复杂度：** $O(2^n \times n)$，需要存储所有子集。

**推荐使用方法一（回溯算法）**，因为它思路清晰，是解决子集生成问题的经典方法。回溯算法不仅适用于生成子集，还能很容易地扩展到处理重复元素、限制子集大小等变种问题。
