---
title: "79-单词搜索"
date: 2025-04-16 21:36:35 +0800
categories: [LEETCODE, HOT100]
tags: [回溯, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/word-search/) \| 难度: 中等

## 问题描述:

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**示例 1：**

![img](../assets/img/posts/leetcode/p79_0.jpg)

```java
输入: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出: true
```

**示例 2：**

![img](../assets/img/posts/leetcode/p79_1.jpg)

```java
输入: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
输出: true
```

**示例 3：**

![img](../assets/img/posts/leetcode/p79_2.jpg)

```java
输入: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
输出: false
```

**提示:** `board` 和 `word` 仅由大小写英文字母组成

## 解题思路：

这是一道关于在二维字符网格中搜索单词的问题。需要在网格中找到是否存在给定的单词，单词可以由相邻格子的字母按顺序连接构成，但同一个格子不能重复使用。

### 方法一：深度优先搜索 + 回溯（推荐）

核心思想是使用深度优先搜索（DFS）遍历网格，对于每个可能的起始位置，尝试匹配单词的每个字符，同时使用回溯确保不重复使用格子。

**算法步骤：**

1. 遍历网格中的每个位置作为搜索起点
2. 对于每个起点，使用 DFS 搜索是否能找到完整单词
3. 在 DFS 过程中，标记当前格子为已访问，递归搜索四个方向
4. 如果找到单词或当前路径不可行，进行回溯恢复格子状态
5. 匹配成功返回 true，所有起点都失败则返回 false

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        if (board == null || board.length == 0 || board[0].length == 0 || word == null) {
            return false;
        }

        int m = board.length;
        int n = board[0].length;

        // 遍历网格中的每个位置作为起点
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (dfs(board, word, i, j, 0)) {
                    return true;
                }
            }
        }

        return false;
    }

    private boolean dfs(char[][] board, String word, int row, int col, int index) {
        // 边界检查
        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) {
            return false;
        }

        // 字符不匹配或格子已被访问
        if (board[row][col] != word.charAt(index)) {
            return false;
        }

        // 找到完整单词
        if (index == word.length() - 1) {
            return true;
        }

        // 标记当前格子为已访问
        char temp = board[row][col];
        board[row][col] = '#'; // 使用特殊字符标记

        // 搜索四个方向
        boolean found = dfs(board, word, row + 1, col, index + 1) ||
                       dfs(board, word, row - 1, col, index + 1) ||
                       dfs(board, word, row, col + 1, index + 1) ||
                       dfs(board, word, row, col - 1, index + 1);

        // 回溯：恢复格子原始值
        board[row][col] = temp;

        return found;
    }
}
```

**时间复杂度：** $O(m \times n \times 4^l)$，其中 $m$ 和 $n$ 是网格的行数和列数，$l$ 是单词长度。最坏情况下，每个格子都可能作为起点，每个位置有 4 个方向可以探索。

**空间复杂度：** $O(l)$，递归栈的深度最大为单词长度。

### 方法二：使用额外 visited 数组的 DFS

使用独立的 visited 数组来标记访问状态，不修改原始 board。

```java
class Solution {
    private int[][] directions = {% raw %}{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}{% endraw %};

    public boolean exist(char[][] board, String word) {
        if (board == null || board.length == 0 || board[0].length == 0 || word == null) {
            return false;
        }

        int m = board.length;
        int n = board[0].length;
        boolean[][] visited = new boolean[m][n];

        // 遍历每个位置作为起点
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (dfs(board, word, i, j, 0, visited)) {
                    return true;
                }
            }
        }

        return false;
    }

    private boolean dfs(char[][] board, String word, int row, int col,
                       int index, boolean[][] visited) {
        // 找到完整单词
        if (index == word.length()) {
            return true;
        }

        // 边界检查和访问检查
        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length ||
            visited[row][col] || board[row][col] != word.charAt(index)) {
            return false;
        }

        // 标记当前位置为已访问
        visited[row][col] = true;

        // 搜索四个方向
        for (int[] dir : directions) {
            int newRow = row + dir[0];
            int newCol = col + dir[1];
            if (dfs(board, word, newRow, newCol, index + 1, visited)) {
                visited[row][col] = false; // 提前回溯
                return true;
            }
        }

        // 回溯：恢复访问状态
        visited[row][col] = false;
        return false;
    }
}
```

**时间复杂度：** $O(m \times n \times 4^l)$

**空间复杂度：** $O(m \times n + l)$，包括 visited 数组和递归栈空间。

### 方法三：优化的 DFS（剪枝优化）

添加一些优化策略来提高搜索效率。

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        if (board == null || board.length == 0 || board[0].length == 0 || word == null) {
            return false;
        }

        // 优化：统计字符频次，如果board中某字符数量少于word中的，直接返回false
        int[] boardCount = new int[128];
        int[] wordCount = new int[128];

        // 统计board中字符频次
        for (char[] row : board) {
            for (char c : row) {
                boardCount[c]++;
            }
        }

        // 统计word中字符频次
        for (char c : word.toCharArray()) {
            wordCount[c]++;
            if (boardCount[c] < wordCount[c]) {
                return false;
            }
        }

        int m = board.length;
        int n = board[0].length;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == word.charAt(0) && dfs(board, word, i, j, 0)) {
                    return true;
                }
            }
        }

        return false;
    }

    private boolean dfs(char[][] board, String word, int row, int col, int index) {
        if (index == word.length()) {
            return true;
        }

        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length ||
            board[row][col] != word.charAt(index)) {
            return false;
        }

        char temp = board[row][col];
        board[row][col] = '#';

        boolean found = dfs(board, word, row + 1, col, index + 1) ||
                       dfs(board, word, row - 1, col, index + 1) ||
                       dfs(board, word, row, col + 1, index + 1) ||
                       dfs(board, word, row, col - 1, index + 1);

        board[row][col] = temp;
        return found;
    }
}
```

**推荐使用方法一（基本 DFS 回溯）**，因为它简洁高效，直接修改 board 来标记访问状态，空间复杂度最优。对于需要保持原始数据不变的场景，可以使用方法二。
