---
title: "51-n皇后"
date: 2025-04-14 21:36:13 +0800
categories: [LEETCODE, HOT100]
tags: [回溯, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/n-queens/) \| 难度: 困难

## 问题描述:

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

**示例 1：**

![img](../assets/img/posts/leetcode/p51_0.jpg)

```java
输入: n = 4
输出: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释: 如上图所示, 4 皇后问题存在两个不同的解法
```

**示例 2：**

```java
输入: n = 1
输出: [["Q"]]
```

## 解题思路：

这是一道经典的 N 皇后问题，需要在 N×N 的棋盘上放置 N 个皇后，使得她们彼此不能相互攻击。本质上是一个**回溯算法**问题，需要处理行、列、对角线的约束条件。

### 核心思想：

- 皇后可以攻击同一行、同一列、同一对角线上的棋子
- 逐行放置皇后，对于每行尝试所有列的位置
- 使用回溯算法，当发现冲突时回退并尝试其他位置
- 通过优化的数据结构快速检查冲突

### 方法一：回溯算法 + 集合优化（推荐）

**算法步骤：**

1. 使用三个集合分别记录已占用的列、主对角线、副对角线
2. 逐行尝试放置皇后，检查是否与已放置的皇后冲突
3. 如果无冲突则放置皇后，递归处理下一行
4. 如果有冲突或递归失败，则回溯尝试下一个位置

```java
class Solution {
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> result = new ArrayList<>();
        Set<Integer> cols = new HashSet<>();        // 记录已占用的列
        Set<Integer> diagonal1 = new HashSet<>();   // 记录已占用的主对角线 (row - col)
        Set<Integer> diagonal2 = new HashSet<>();   // 记录已占用的副对角线 (row + col)

        int[] queens = new int[n]; // queens[i] 表示第i行皇后所在的列
        backtrack(result, queens, n, 0, cols, diagonal1, diagonal2);
        return result;
    }

    private void backtrack(List<List<String>> result, int[] queens, int n, int row,
                          Set<Integer> cols, Set<Integer> diagonal1, Set<Integer> diagonal2) {
        // 终止条件：所有行都放置了皇后
        if (row == n) {
            result.add(generateBoard(queens, n));
            return;
        }

        // 尝试在当前行的每一列放置皇后
        for (int col = 0; col < n; col++) {
            // 检查是否与已放置的皇后冲突
            if (cols.contains(col) ||
                diagonal1.contains(row - col) ||
                diagonal2.contains(row + col)) {
                continue;
            }

            // 放置皇后
            queens[row] = col;
            cols.add(col);
            diagonal1.add(row - col);
            diagonal2.add(row + col);

            // 递归处理下一行
            backtrack(result, queens, n, row + 1, cols, diagonal1, diagonal2);

            // 回溯：移除皇后
            cols.remove(col);
            diagonal1.remove(row - col);
            diagonal2.remove(row + col);
        }
    }

    private List<String> generateBoard(int[] queens, int n) {
        List<String> board = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            char[] row = new char[n];
            Arrays.fill(row, '.');
            row[queens[i]] = 'Q';
            board.add(new String(row));
        }
        return board;
    }
}
```

**时间复杂度：** $O(N!)$，在最坏情况下需要尝试所有可能的排列。

**空间复杂度：** $O(N)$，递归深度和辅助数据结构的空间。

### 方法二：回溯算法 + 数组优化

使用布尔数组代替集合，可能在某些情况下性能更好。

**算法步骤：**

1. 使用三个布尔数组分别标记列和对角线的占用情况
2. 对角线的映射关系：主对角线 `row - col + n - 1`，副对角线 `row + col`
3. 其余逻辑与方法一相同

```java
class Solution {
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> result = new ArrayList<>();
        boolean[] cols = new boolean[n];              // 列
        boolean[] diagonal1 = new boolean[2 * n - 1]; // 主对角线
        boolean[] diagonal2 = new boolean[2 * n - 1]; // 副对角线

        int[] queens = new int[n];
        backtrack(result, queens, n, 0, cols, diagonal1, diagonal2);
        return result;
    }

    private void backtrack(List<List<String>> result, int[] queens, int n, int row,
                          boolean[] cols, boolean[] diagonal1, boolean[] diagonal2) {
        if (row == n) {
            result.add(generateBoard(queens, n));
            return;
        }

        for (int col = 0; col < n; col++) {
            int d1 = row - col + n - 1; // 主对角线索引
            int d2 = row + col;          // 副对角线索引

            if (cols[col] || diagonal1[d1] || diagonal2[d2]) {
                continue;
            }

            // 放置皇后
            queens[row] = col;
            cols[col] = diagonal1[d1] = diagonal2[d2] = true;

            backtrack(result, queens, n, row + 1, cols, diagonal1, diagonal2);

            // 回溯
            cols[col] = diagonal1[d1] = diagonal2[d2] = false;
        }
    }

    private List<String> generateBoard(int[] queens, int n) {
        List<String> board = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            char[] row = new char[n];
            Arrays.fill(row, '.');
            row[queens[i]] = 'Q';
            board.add(new String(row));
        }
        return board;
    }
}
```

**时间复杂度：** $O(N!)$，同方法一。

**空间复杂度：** $O(N)$，使用固定大小的数组。

### 方法三：位运算优化

使用位运算进一步优化空间和时间效率。

```java
class Solution {
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> result = new ArrayList<>();
        int[] queens = new int[n];
        backtrack(result, queens, n, 0, 0, 0, 0);
        return result;
    }

    private void backtrack(List<List<String>> result, int[] queens, int n, int row,
                          int cols, int diagonal1, int diagonal2) {
        if (row == n) {
            result.add(generateBoard(queens, n));
            return;
        }

        // 计算当前行可放置皇后的位置
        int available = ((1 << n) - 1) & (~(cols | diagonal1 | diagonal2));

        while (available != 0) {
            int position = available & (-available); // 取最低位的1
            int col = Integer.bitCount(position - 1); // 计算列号

            queens[row] = col;
            backtrack(result, queens, n, row + 1,
                     cols | position,
                     (diagonal1 | position) << 1,
                     (diagonal2 | position) >> 1);

            available &= available - 1; // 清除最低位的1
        }
    }

    private List<String> generateBoard(int[] queens, int n) {
        List<String> board = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            char[] row = new char[n];
            Arrays.fill(row, '.');
            row[queens[i]] = 'Q';
            board.add(new String(row));
        }
        return board;
    }
}
```

**时间复杂度：** $O(N!)$，但常数因子更小。

**空间复杂度：** $O(N)$，只使用常数个整数变量。

**推荐使用方法一（回溯算法 + 集合优化）**，因为它思路清晰，代码易懂，性能也很好。对于理解 N 皇后问题的核心思想和回溯算法的应用非常有帮助。
