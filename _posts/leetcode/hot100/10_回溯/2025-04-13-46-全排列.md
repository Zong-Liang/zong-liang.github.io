---
title: "46-全排列"
date: 2025-04-13 21:36:01 +0800
categories: [LEETCODE, HOT100]
tags: [回溯, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/permutations/) \| 难度: 中等

## 问题描述:

给定一个不含重复数字的数组 `nums` ，返回其 _所有可能的全排列_。你可以**按任意顺序**返回答案。

**示例 1：**

```java
输入: nums = [1,2,3]
输出: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```java
输入: nums = [0,1]
输出: [[0,1],[1,0]]
```

**示例 3：**

```java
输入: nums = [1]
输出: [[1]]
```

**提示：**`nums` 中的所有整数 **互不相同**

## 解题思路：

这是一道关于生成全排列的问题，需要返回给定数组的所有可能排列。本质上是一个**回溯算法**问题，需要穷举所有可能的排列组合。

### 核心思想：

- 对于每个位置，尝试放入所有未使用的数字
- 使用回溯算法，当选择一个数字后递归处理剩余位置
- 当排列长度等于原数组长度时，找到一个完整的排列
- 通过标记数组避免重复使用同一个数字

### 方法一：回溯算法 + 标记数组（推荐）

**算法步骤：**

1. 使用布尔数组标记哪些数字已被使用
2. 对于当前位置，尝试所有未使用的数字
3. 选择数字后递归处理下一个位置
4. 递归返回后撤销选择，尝试其他可能性

```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        boolean[] used = new boolean[nums.length];
        backtrack(result, new ArrayList<>(), nums, used);
        return result;
    }

    private void backtrack(List<List<Integer>> result, List<Integer> current,
                          int[] nums, boolean[] used) {
        // 终止条件：当前排列长度等于原数组长度
        if (current.size() == nums.length) {
            result.add(new ArrayList<>(current));
            return;
        }

        // 尝试所有可能的数字
        for (int i = 0; i < nums.length; i++) {
            // 跳过已使用的数字
            if (used[i]) {
                continue;
            }

            // 选择当前数字
            current.add(nums[i]);
            used[i] = true;

            // 递归处理剩余位置
            backtrack(result, current, nums, used);

            // 撤销选择（回溯）
            current.remove(current.size() - 1);
            used[i] = false;
        }
    }
}
```

**时间复杂度：** $O(n! \times n)$，生成 $n!$ 个排列，每个排列需要 $O(n)$ 时间复制到结果中。

**空间复杂度：** $O(n)$，递归深度为 $n$，加上标记数组的空间。

### 方法二：回溯算法 + 交换元素

通过交换数组元素来生成排列，避免使用额外的标记数组。

**算法步骤：**

1. 将当前位置与后续所有位置的元素进行交换
2. 递归处理下一个位置
3. 交换回来，尝试其他可能性

```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        backtrack(result, nums, 0);
        return result;
    }

    private void backtrack(List<List<Integer>> result, int[] nums, int start) {
        // 终止条件：已经确定了所有位置
        if (start == nums.length) {
            // 将当前数组状态转换为列表并添加到结果中
            List<Integer> permutation = new ArrayList<>();
            for (int num : nums) {
                permutation.add(num);
            }
            result.add(permutation);
            return;
        }

        // 对于当前位置，尝试与后续所有位置交换
        for (int i = start; i < nums.length; i++) {
            // 交换元素
            swap(nums, start, i);

            // 递归处理下一个位置
            backtrack(result, nums, start + 1);

            // 撤销交换（回溯）
            swap(nums, start, i);
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

**时间复杂度：** $O(n! \times n)$，同方法一。

**空间复杂度：** $O(n)$，只需要递归栈空间。

### 方法三：字典序法（迭代实现）

使用字典序的下一个排列算法，迭代生成所有排列。

**算法步骤：**

1. 对数组排序得到最小字典序排列
2. 重复寻找下一个字典序排列，直到没有下一个排列

```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();

        // 排序得到最小字典序排列
        Arrays.sort(nums);

        do {
            // 将当前排列添加到结果中
            List<Integer> permutation = new ArrayList<>();
            for (int num : nums) {
                permutation.add(num);
            }
            result.add(permutation);
        } while (nextPermutation(nums));

        return result;
    }

    // 生成下一个字典序排列
    private boolean nextPermutation(int[] nums) {
        int n = nums.length;

        // 从右往左找第一个降序位置
        int i = n - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }

        // 如果没有找到，说明已经是最大排列
        if (i < 0) {
            return false;
        }

        // 从右往左找第一个大于nums[i]的数
        int j = n - 1;
        while (nums[j] <= nums[i]) {
            j--;
        }

        // 交换nums[i]和nums[j]
        swap(nums, i, j);

        // 反转i+1到末尾的部分
        reverse(nums, i + 1);

        return true;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    private void reverse(int[] nums, int start) {
        int left = start, right = nums.length - 1;
        while (left < right) {
            swap(nums, left, right);
            left++;
            right--;
        }
    }
}
```

**时间复杂度：** $O(n! \times n)$，生成每个排列的均摊时间复杂度是 $O(1)$。

**空间复杂度：** $O(1)$，不考虑结果存储的额外空间。

**推荐使用方法一（回溯算法 + 标记数组）**，因为它思路清晰，易于理解和实现，是解决排列问题的经典方法。虽然需要额外的标记数组空间，但代码逻辑更加直观。
