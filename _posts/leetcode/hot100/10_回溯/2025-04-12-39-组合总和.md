---
title: "39-组合总和"
date: 2025-04-12 21:35:49 +0800
categories: [LEETCODE, HOT100]
tags: [回溯, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/combination-sum/) \| 难度: 中等

## 问题描述:

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合**，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取**。如果至少一个数字的被选数量不同，则两种组合是不同的。

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

**示例 1：**

```java
输入: candidates = [2,3,6,7], target = 7
输出: [[2,2,3],[7]]
解释:
2 和 3 可以形成一组候选, 2 + 2 + 3 = 7, 注意 2 可以使用多次
7 也是一个候选, 7 = 7
仅有这两种组合
```

**示例 2：**

```java
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
```

**示例 3：**

```java
输入: candidates = [2], target = 1
输出: []
```

**提示：**`candidates` 的所有元素 **互不相同**

## 解题思路：

这是一道关于组合总和的问题，需要在给定的候选数组中找出所有和为目标值的不同组合。本质上是一个**回溯算法**问题，同时需要处理数字可以重复使用的特点。

### 核心思想：

- 数组中的同一个数字可以被选择多次
- 解集不能包含重复的组合
- 使用回溯算法遍历所有可能的组合
- 通过排序和剪枝优化搜索效率

### 方法一：回溯算法（推荐）

**算法步骤：**

1. 对候选数组进行排序，便于剪枝
2. 使用回溯算法，维护当前组合、当前和、起始索引
3. 剪枝条件：当前和超过目标值时直接返回
4. 终止条件：当前和等于目标值时，将组合加入结果

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        // 排序便于剪枝
        Arrays.sort(candidates);
        backtrack(result, new ArrayList<>(), candidates, target, 0);
        return result;
    }

    private void backtrack(List<List<Integer>> result, List<Integer> current,
                          int[] candidates, int target, int start) {
        // 终止条件：找到目标和
        if (target == 0) {
            result.add(new ArrayList<>(current));
            return;
        }

        // 遍历候选数字
        for (int i = start; i < candidates.length; i++) {
            // 剪枝：如果当前数字大于剩余目标值，后续数字也会更大
            if (candidates[i] > target) {
                break;
            }

            // 选择当前数字
            current.add(candidates[i]);
            // 递归搜索，注意这里传入i而不是i+1，因为数字可以重复使用
            backtrack(result, current, candidates, target - candidates[i], i);
            // 撤销选择
            current.remove(current.size() - 1);
        }
    }
}
```

**时间复杂度：** $O(S)$，其中 $S$ 为所有可行解的长度之和。在最坏情况下，可能达到指数级。

**空间复杂度：** $O(target)$，递归深度最多为 $target$（当全部选择数字 1 时）。

### 方法二：动态规划

使用动态规划的思想，逐步构建所有可能的组合。

**算法步骤：**

1. 使用 dp[i] 表示和为 i 的所有组合
2. 对于每个候选数字，更新所有可能的和
3. 避免重复组合的产生

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        // dp[i] 存储和为 i 的所有组合
        List<List<List<Integer>>> dp = new ArrayList<>();

        // 初始化 dp 数组
        for (int i = 0; i <= target; i++) {
            dp.add(new ArrayList<>());
        }

        // 和为 0 的组合只有空组合
        dp.get(0).add(new ArrayList<>());

        // 排序候选数组
        Arrays.sort(candidates);

        // 对每个候选数字进行处理
        for (int candidate : candidates) {
            // 从 candidate 开始更新，避免重复使用之前的结果
            for (int i = candidate; i <= target; i++) {
                // 如果 dp[i - candidate] 有解，则可以构造 dp[i] 的解
                for (List<Integer> combination : dp.get(i - candidate)) {
                    List<Integer> newCombination = new ArrayList<>(combination);
                    newCombination.add(candidate);
                    dp.get(i).add(newCombination);
                }
            }
        }

        return dp.get(target);
    }
}
```

**时间复杂度：** $O(target \times S)$，其中 $S$ 是所有可行解的数量。

**空间复杂度：** $O(target \times S)$，用于存储动态规划表。

### 方法三：优化的回溯（减少重复计算）

通过记忆化搜索减少重复计算。

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        return backtrack(candidates, target, 0, new HashMap<>());
    }

    private List<List<Integer>> backtrack(int[] candidates, int target, int start,
                                         Map<String, List<List<Integer>>> memo) {
        // 构建记忆化的key
        String key = target + "," + start;
        if (memo.containsKey(key)) {
            return memo.get(key);
        }

        List<List<Integer>> result = new ArrayList<>();

        if (target == 0) {
            result.add(new ArrayList<>());
            memo.put(key, result);
            return result;
        }

        for (int i = start; i < candidates.length; i++) {
            if (candidates[i] > target) {
                break;
            }

            List<List<Integer>> subResult = backtrack(candidates, target - candidates[i], i, memo);
            for (List<Integer> combination : subResult) {
                List<Integer> newCombination = new ArrayList<>();
                newCombination.add(candidates[i]);
                newCombination.addAll(combination);
                result.add(newCombination);
            }
        }

        memo.put(key, result);
        return result;
    }
}
```

**时间复杂度：** $O(S)$，通过记忆化避免重复计算。

**空间复杂度：** $O(target \times n + S)$，用于记忆化存储和结果存储。

**推荐使用方法一（回溯算法）**，因为它思路清晰，代码简洁，是解决组合问题的经典方法。通过排序和剪枝可以有效提高搜索效率，在实际应用中表现良好。
