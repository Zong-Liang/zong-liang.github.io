---
title: "22-括号生成"
date: 2025-04-11 21:35:38 +0800
categories: [LEETCODE, HOT100]
tags: [回溯, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/generate-parentheses/) \| 难度: 中等

## 问题描述:

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例 1：**

```java
输入: n = 3
输出: ["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```java
输入: n = 1
输出: ["()"]
```

## 解题思路：

这是一道关于生成所有有效括号组合的问题。需要生成 n 对括号的所有有效组合，本质上是一个**回溯算法**问题。

### 核心思想：

- 有效的括号组合需要满足：左括号数量等于右括号数量，且任何时候右括号数量不能超过左括号数量
- 使用回溯算法，在每个位置选择添加左括号或右括号
- 通过剪枝条件确保生成的括号组合有效

### 方法一：回溯算法（推荐）

**算法步骤：**

1. 使用递归回溯，维护当前字符串、左括号数量、右括号数量
2. 剪枝条件：
   - 左括号数量不能超过 n
   - 右括号数量不能超过左括号数量
3. 终止条件：当字符串长度达到 2\*n 时，添加到结果中

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<>();
        backtrack(result, new StringBuilder(), 0, 0, n);
        return result;
    }

    private void backtrack(List<String> result, StringBuilder current,
                          int left, int right, int n) {
        // 终止条件：生成了完整的括号组合
        if (current.length() == 2 * n) {
            result.add(current.toString());
            return;
        }

        // 可以添加左括号的条件：左括号数量小于n
        if (left < n) {
            current.append('(');
            backtrack(result, current, left + 1, right, n);
            current.deleteCharAt(current.length() - 1); // 回溯
        }

        // 可以添加右括号的条件：右括号数量小于左括号数量
        if (right < left) {
            current.append(')');
            backtrack(result, current, left, right + 1, n);
            current.deleteCharAt(current.length() - 1); // 回溯
        }
    }
}
```

**时间复杂度：** $O(\frac{4^n}{\sqrt{n}})$，这是第 n 个卡特兰数的渐近复杂度。

**空间复杂度：** $O(\frac{4^n}{\sqrt{n}})$，用于存储所有有效的括号组合。

### 方法二：动态规划

利用卡特兰数的递推性质，通过组合已知结果生成新结果。

**算法步骤：**

1. 对于 n 对括号，可以表示为：(a)b 的形式
2. 其中 a 是 i 对括号的组合，b 是 n-1-i 对括号的组合
3. 遍历所有可能的 i 值，组合所有可能的结果

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<List<String>> dp = new ArrayList<>();

        // 初始化 dp[0] = [""]
        dp.add(Arrays.asList(""));

        // 逐步计算 dp[1] 到 dp[n]
        for (int i = 1; i <= n; i++) {
            List<String> current = new ArrayList<>();

            // 对于每个 i，枚举所有可能的分割方式
            for (int j = 0; j < i; j++) {
                List<String> left = dp.get(j);      // j 对括号
                List<String> right = dp.get(i - 1 - j); // i-1-j 对括号

                // 组合所有可能的结果：(left)right
                for (String l : left) {
                    for (String r : right) {
                        current.add("(" + l + ")" + r);
                    }
                }
            }

            dp.add(current);
        }

        return dp.get(n);
    }
}
```

**时间复杂度：** $O(\frac{4^n}{\sqrt{n}})$，同样是卡特兰数的复杂度。

**空间复杂度：** $O(\frac{4^n}{\sqrt{n}})$，用于存储动态规划表。

### 方法三：暴力法 + 验证

生成所有可能的 2^(2n) 种括号序列，然后验证哪些是有效的。

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<>();
        generateAll(new char[2 * n], 0, result);
        return result;
    }

    private void generateAll(char[] current, int pos, List<String> result) {
        if (pos == current.length) {
            if (isValid(current)) {
                result.add(new String(current));
            }
        } else {
            current[pos] = '(';
            generateAll(current, pos + 1, result);
            current[pos] = ')';
            generateAll(current, pos + 1, result);
        }
    }

    private boolean isValid(char[] current) {
        int balance = 0;
        for (char c : current) {
            if (c == '(') {
                balance++;
            } else {
                balance--;
            }
            if (balance < 0) {
                return false;
            }
        }
        return balance == 0;
    }
}
```

**时间复杂度：** $O(2^{2n} \times n)$，生成所有可能序列并验证。

**空间复杂度：** $O(2^{2n} \times n)$，存储所有可能的序列。

**推荐使用方法一（回溯算法）**，因为它通过剪枝避免了无效的搜索路径，效率最高且思路清晰。回溯算法是解决这类组合生成问题的最佳选择。
