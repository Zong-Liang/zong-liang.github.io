---
title: "438-找到字符串中所有字母异位词"
date: 2025-02-23 21:07:07 +0800
categories: [LEETCODE, HOT100]
tags: [滑动窗口, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/find-all-anagrams-in-a-string/) \| 难度：中等

## 问题描述：

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的**异位词**的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**示例 1：**

```java
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词
```

**示例 2：**

```java
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词
```

## 解题思路:

这道题是"找到字符串中所有字母异位词"问题。给定两个字符串 `s` 和 `p`，要求找到字符串 `s` 中所有是字符串 `p` 的异位词的子串的起始索引。异位词指字母相同但排列不同的词。

### 方法一：滑动窗口 + 字符计数（推荐）

使用滑动窗口技术，维护一个长度为 `p.length()` 的窗口，通过比较字符计数来判断是否为异位词。

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> result = new ArrayList<>();
        if (s.length() < p.length()) return result;

        // 统计p中每个字符的频次
        int[] pCount = new int[26];
        int[] windowCount = new int[26];

        for (char c : p.toCharArray()) {
            pCount[c - 'a']++;
        }

        int windowSize = p.length();

        // 初始化第一个窗口
        for (int i = 0; i < windowSize; i++) {
            windowCount[s.charAt(i) - 'a']++;
        }

        // 检查第一个窗口
        if (Arrays.equals(pCount, windowCount)) {
            result.add(0);
        }

        // 滑动窗口
        for (int i = windowSize; i < s.length(); i++) {
            // 添加新字符
            windowCount[s.charAt(i) - 'a']++;
            // 移除旧字符
            windowCount[s.charAt(i - windowSize) - 'a']--;

            // 检查当前窗口是否为异位词
            if (Arrays.equals(pCount, windowCount)) {
                result.add(i - windowSize + 1);
            }
        }

        return result;
    }
}
```

**时间复杂度**：$O(s + p)$，其中 $s$ 和 $p$ 分别是两个字符串的长度。

**空间复杂度**：$O(1)$，只使用了固定大小的数组。

### 方法二：滑动窗口 + 匹配计数优化

通过维护匹配字符的数量来避免每次都比较整个数组。

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> result = new ArrayList<>();
        if (s.length() < p.length()) return result;

        int[] pCount = new int[26];
        int[] windowCount = new int[26];

        // 统计p中字符频次
        for (char c : p.toCharArray()) {
            pCount[c - 'a']++;
        }

        int windowSize = p.length();
        int matches = 0; // 记录匹配的字符种类数

        // 初始化窗口
        for (int i = 0; i < windowSize; i++) {
            int index = s.charAt(i) - 'a';
            windowCount[index]++;
            if (windowCount[index] == pCount[index]) {
                matches++;
            } else if (windowCount[index] == pCount[index] + 1) {
                matches--;
            }
        }

        if (matches == 26) result.add(0);

        // 滑动窗口
        for (int i = windowSize; i < s.length(); i++) {
            // 添加右边字符
            int rightIndex = s.charAt(i) - 'a';
            windowCount[rightIndex]++;
            if (windowCount[rightIndex] == pCount[rightIndex]) {
                matches++;
            } else if (windowCount[rightIndex] == pCount[rightIndex] + 1) {
                matches--;
            }

            // 移除左边字符
            int leftIndex = s.charAt(i - windowSize) - 'a';
            windowCount[leftIndex]--;
            if (windowCount[leftIndex] == pCount[leftIndex]) {
                matches++;
            } else if (windowCount[leftIndex] == pCount[leftIndex] - 1) {
                matches--;
            }

            if (matches == 26) {
                result.add(i - windowSize + 1);
            }
        }

        return result;
    }
}
```

**时间复杂度**：$O(s + p)$，其中 $s$ 和 $p$ 分别是两个字符串的长度。

**空间复杂度**：$O(1)$，只使用了固定大小的数组。

### 方法三：暴力解法

对每个可能的起始位置，检查对应长度的子串是否为异位词。

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> result = new ArrayList<>();
        if (s.length() < p.length()) return result;

        // 对每个可能的起始位置进行检查
        for (int i = 0; i <= s.length() - p.length(); i++) {
            if (isAnagram(s.substring(i, i + p.length()), p)) {
                result.add(i);
            }
        }

        return result;
    }

    private boolean isAnagram(String s1, String s2) {
        if (s1.length() != s2.length()) return false;

        int[] count = new int[26];
        for (int i = 0; i < s1.length(); i++) {
            count[s1.charAt(i) - 'a']++;
            count[s2.charAt(i) - 'a']--;
        }

        for (int c : count) {
            if (c != 0) return false;
        }

        return true;
    }
}
```

**时间复杂度**：$O((s-p+1) \times p)$，对于每个位置都要检查长度为 $p$ 的子串。

**空间复杂度**：$O(1)$，只使用了固定大小的数组。

### 方法四：使用 HashMap

使用 HashMap 代替数组来统计字符频次，适用于字符集较大的情况。

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> result = new ArrayList<>();
        if (s.length() < p.length()) return result;

        Map<Character, Integer> pMap = new HashMap<>();
        Map<Character, Integer> windowMap = new HashMap<>();

        // 统计p中字符频次
        for (char c : p.toCharArray()) {
            pMap.put(c, pMap.getOrDefault(c, 0) + 1);
        }

        int windowSize = p.length();

        // 初始化窗口
        for (int i = 0; i < windowSize; i++) {
            char c = s.charAt(i);
            windowMap.put(c, windowMap.getOrDefault(c, 0) + 1);
        }

        if (windowMap.equals(pMap)) {
            result.add(0);
        }

        // 滑动窗口
        for (int i = windowSize; i < s.length(); i++) {
            // 添加右边字符
            char rightChar = s.charAt(i);
            windowMap.put(rightChar, windowMap.getOrDefault(rightChar, 0) + 1);

            // 移除左边字符
            char leftChar = s.charAt(i - windowSize);
            windowMap.put(leftChar, windowMap.get(leftChar) - 1);
            if (windowMap.get(leftChar) == 0) {
                windowMap.remove(leftChar);
            }

            if (windowMap.equals(pMap)) {
                result.add(i - windowSize + 1);
            }
        }

        return result;
    }
}
```

**时间复杂度**：$O(s + p)$，其中 $s$ 和 $p$ 分别是两个字符串的长度。

**空间复杂度**：$O(p)$，HashMap 最多存储 $p$ 个不同字符。

### 方法五：排序比较法

对每个子串进行排序后与排序后的 `p` 比较。

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> result = new ArrayList<>();
        if (s.length() < p.length()) return result;

        // 对p进行排序
        char[] pSorted = p.toCharArray();
        Arrays.sort(pSorted);
        String pSortedStr = new String(pSorted);

        // 检查每个可能的子串
        for (int i = 0; i <= s.length() - p.length(); i++) {
            String substring = s.substring(i, i + p.length());
            char[] substringArr = substring.toCharArray();
            Arrays.sort(substringArr);

            if (Arrays.equals(substringArr, pSorted)) {
                result.add(i);
            }
        }

        return result;
    }
}
```

**时间复杂度**：$O((s-p+1) \times p \log p)$，对每个子串都要排序。

**空间复杂度**：$O(p)$，排序需要的空间。

**推荐使用方法一或方法二**，它们都是最优解法，时间复杂度为 $O(s + p)$，空间复杂度为 $O(1)$。方法二通过维护匹配计数避免了每次比较整个数组，在某些情况下性能会更好。

**核心思想**：

1. 使用滑动窗口维护一个长度固定的子串
2. 通过字符频次统计判断当前窗口是否为异位词
3. 窗口滑动时只需要更新新增和移除字符的计数
