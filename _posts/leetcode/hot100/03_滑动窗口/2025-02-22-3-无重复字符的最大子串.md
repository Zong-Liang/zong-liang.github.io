---
title: "3-无重复字符的最大子串"
date: 2025-02-22 21:02:52 +0800
categories: [LEETCODE, HOT100]
tags: [滑动窗口, 中等]
pin: false
toc: true
math: true
---

[官网链接](https://leetcode.cn/problems/longest-substring-without-repeating-characters/) \| 难度：中等

## 问题描述：

给定一个字符串 `s`，请你找出其中不含有重复字符的**最长子串**的长度。

**示例 1：**

```java
输入: s = "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc", 所以其长度为 3
```

**示例 2：**

```java
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b", 所以其长度为 1
```

**示例 3：**

```java
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke", 所以其长度为 3
请注意, 你的答案必须是 子串 的长度, "pwke" 是一个子序列, 不是子串
```

## 解题思路:

这道题是"无重复字符的最长子串"问题。要求找出给定字符串中不包含重复字符的最长子串的长度。这是一个经典的滑动窗口问题。

### 方法一：滑动窗口 + HashSet（推荐）

使用滑动窗口技术，配合 HashSet 来记录当前窗口中的字符，当遇到重复字符时收缩左边界。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s == null || s.length() == 0) return 0;

        Set<Character> window = new HashSet<>();
        int left = 0, right = 0;
        int maxLength = 0;

        while (right < s.length()) {
            char rightChar = s.charAt(right);

            // 如果右边界字符已存在，收缩左边界
            while (window.contains(rightChar)) {
                window.remove(s.charAt(left));
                left++;
            }

            // 将右边界字符加入窗口
            window.add(rightChar);
            maxLength = Math.max(maxLength, right - left + 1);
            right++;
        }

        return maxLength;
    }
}
```

**时间复杂度**：$O(n)$，其中 $n$ 是字符串长度。每个字符最多被访问两次。

**空间复杂度**：$O(min(m,n))$，其中 $m$ 是字符集大小。HashSet 最多存储 $min(m,n)$ 个字符。

### 方法二：滑动窗口 + HashMap（优化版）

使用 HashMap 记录字符最后出现的位置，可以直接跳转到重复字符的下一个位置，避免逐个移动左指针。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s == null || s.length() == 0) return 0;

        Map<Character, Integer> charIndex = new HashMap<>();
        int left = 0;
        int maxLength = 0;

        for (int right = 0; right < s.length(); right++) {
            char rightChar = s.charAt(right);

            // 如果字符已存在且在当前窗口内，更新左边界
            if (charIndex.containsKey(rightChar) && charIndex.get(rightChar) >= left) {
                left = charIndex.get(rightChar) + 1;
            }

            // 更新字符位置
            charIndex.put(rightChar, right);
            maxLength = Math.max(maxLength, right - left + 1);
        }

        return maxLength;
    }
}
```

**时间复杂度**：$O(n)$，其中 $n$ 是字符串长度。只需要一次遍历。

**空间复杂度**：$O(min(m,n))$，其中 $m$ 是字符集大小。

### 方法三：数组优化版（ASCII 字符）

如果字符串只包含 ASCII 字符，可以使用数组代替 HashMap 来提高性能。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s == null || s.length() == 0) return 0;

        int[] charIndex = new int[128]; // ASCII字符集
        // 初始化为-1，表示未出现过
        Arrays.fill(charIndex, -1);

        int left = 0;
        int maxLength = 0;

        for (int right = 0; right < s.length(); right++) {
            char rightChar = s.charAt(right);

            // 如果字符已存在且在当前窗口内，更新左边界
            if (charIndex[rightChar] >= left) {
                left = charIndex[rightChar] + 1;
            }

            // 更新字符位置
            charIndex[rightChar] = right;
            maxLength = Math.max(maxLength, right - left + 1);
        }

        return maxLength;
    }
}
```

**时间复杂度**：$O(n)$，其中 $n$ 是字符串长度。

**空间复杂度**：$O(1)$，使用固定大小的数组。

### 方法四：暴力解法

枚举所有可能的子串，检查是否包含重复字符。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s == null || s.length() == 0) return 0;

        int maxLength = 0;
        int n = s.length();

        // 枚举所有子串的起始位置
        for (int i = 0; i < n; i++) {
            Set<Character> seen = new HashSet<>();

            // 从起始位置开始扩展
            for (int j = i; j < n; j++) {
                char c = s.charAt(j);

                // 如果遇到重复字符，停止扩展
                if (seen.contains(c)) {
                    break;
                }

                seen.add(c);
                maxLength = Math.max(maxLength, j - i + 1);
            }
        }

        return maxLength;
    }
}
```

**时间复杂度**：$O(n^2)$，需要枚举所有子串。

**空间复杂度**：$O(min(m,n))$，HashSet 的空间开销。

### 方法五：递归 + 记忆化

使用递归方法，配合记忆化来避免重复计算。

```java
class Solution {
    private Map<String, Integer> memo = new HashMap<>();

    public int lengthOfLongestSubstring(String s) {
        return helper(s, 0, new HashSet<>());
    }

    private int helper(String s, int index, Set<Character> used) {
        if (index >= s.length()) return 0;

        String key = index + ":" + used.toString();
        if (memo.containsKey(key)) {
            return memo.get(key);
        }

        char c = s.charAt(index);
        int result;

        if (used.contains(c)) {
            // 遇到重复字符，重新开始
            result = lengthOfLongestSubstring(s.substring(index));
        } else {
            // 继续扩展
            used.add(c);
            result = 1 + helper(s, index + 1, used);
            used.remove(c); // 回溯
        }

        memo.put(key, result);
        return result;
    }
}
```

**时间复杂度**：$O(n \cdot 2^n)$，最坏情况下的时间复杂度。

**空间复杂度**：$O(n \cdot 2^n)$，记忆化的空间开销。

**推荐使用方法二（滑动窗口 + HashMap）**，它是最优解法，时间复杂度为 $O(n)$，空间复杂度为 $O(min(m,n))$，代码简洁高效。如果确定字符集为 ASCII，方法三性能会更好。

**核心思想**：

1. 使用滑动窗口维护一个无重复字符的子串
2. 右指针不断扩展窗口，左指针在遇到重复字符时收缩窗口
3. 记录过程中出现的最大窗口长度
