---
title: Git
date: 2024-03-28 06:00:00 +0800
categories: [Java Backend, Git]
tags: [Git]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/java_backend/20251118103211367.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 核心概念与环境搭建

### 1. 什么是版本控制？

在没有 Git 之前，你写毕业论文或做项目可能是这样的：

- `论文_初稿.doc`
- `论文_修改版.doc`
- `论文_最终版.doc`
- `论文_打死不改版.doc`
- `论文_绝对不改版_v2.doc`

这就是**手动版本控制**。它的缺点很明显：乱、占空间、无法知道 `v2` 和 `最终版` 到底改了哪一行字。

**Git 的作用就是：**

它是一个**时光机**。它能记录你对文件内容的每一次改动（增加、删除、修改）。

- **回溯**：你可以随时把项目还原到两天前的状态。
- **对比**：你可以清楚地看到你今天写的代码和昨天的代码差了哪几行。
- **协作**：它能帮你把五个人写的代码合并成一份，并自动处理冲突（虽然有时需要人工干预）。

#### 分布式 vs 集中式

- **SVN（老一代，集中式）：** 必须联网才能工作，历史记录都在中央服务器。服务器炸了，所有人都完蛋。
- **Git（新一代，分布式）：** **你电脑上的仓库是完整的。** 即使没网，你也能在本地提交代码、查看历史。联网后，再把变动推送到远程服务器。

### 2. Git 的三个核心区域

想象一下你是一个仓库管理员：

1.  **工作区 (Working Directory)**

    - **是什么**：就是你电脑文件资源管理器里看到的**项目文件夹**。
    - **状态**：你在这里编写 `.java` 代码，修改 Bug。这时的修改是“红色的”（未追踪）。

2.  **暂存区 (Staging Area / Index)**

    - **是什么**：它是一个隐形的“**购物车**”或者“**发货清单**”。
    - **作用**：你修改了 10 个文件，但只想提交其中 3 个文件作为一次更新。你就把这 3 个文件先“放入暂存区”。
    - **状态**：文件放进这里，表示“我准备把这些修改存入历史了”。这时的修改是“绿色的”。

3.  **版本库 (Repository / Local Repo)**

    - **是什么**：就是项目根目录下那个隐藏的 `.git` 文件夹。
    - **作用**：这是**安全存档区**。一旦提交到这里，Git 就永久记录下了这个快照。
    - **状态**：生成了一个唯一的 ID（哈希值），你可以随时回滚到这个状态。

**流转过程（请在脑海中模拟）：**

> 我写代码（在**工作区**） -> `git add` -> 放入**暂存区** -> `git commit` -> 永久存入**版本库**。

### 3. 环境安装与配置

作为 Java 程序员，我们主要在三种环境下工作，请根据你的电脑系统操作：

#### 步骤 A：下载安装

- **Windows 用户**：

  1.  访问 [git-scm.com](https://git-scm.com/download/win) 下载安装包。
  2.  **安装注意**：一路“下一步”即可。但有一步选择默认编辑器时，如果你已经装了 VS Code 或 Notepad++ 可以选它们，否则默认 Vim 对新手不太友好（但这不影响核心功能）。
  3.  **关键点**：安装完成后，在桌面右键，你会看到 **"Git Bash Here"**。以后我们主要用这个黑窗口（Git Bash）敲命令，它模拟了 Linux 的环境，比 Windows 自带的 CMD 好用得多。

- **macOS 用户**：

  1.  打开终端（Terminal），输入 `git --version`。
  2.  如果没有安装，系统会自动弹窗提示你安装 `Xcode Command Line Tools`，确认即可。
  3.  或者使用 Homebrew 安装：`brew install git`。

- **Linux 用户**：

  - Debian/Ubuntu: `sudo apt-get install git`
  - CentOS/Fedora: `sudo yum install git`

#### 步骤 B：验证安装

打开终端（Windows 用户打开 **Git Bash**），输入：

```bash
git --version
```

如果出现了类似 `git version 2.x.x` 的字样，说明安装成功。

#### 步骤 C：全局配置（自报家门）

Git 需要知道是谁提交了代码。这个配置只需要做一次（除非你换电脑）。

请在终端依次输入以下两行命令（注意替换成你的名字和邮箱）：

```bash
# 配置用户名（可以用英文名或拼音，不建议中文）
git config --global user.name "YourName"

# 配置邮箱（建议用常用邮箱，如果你以后用 GitHub，最好和 GitHub 邮箱一致）
git config --global user.email "your_email@example.com"
```

**解释：**

- `config`: 配置指令。
- `--global`: 全局的意思。表示这台电脑上所有的 Git 项目都默认使用这个身份。

#### 步骤 D：检查配置

输入以下命令查看你的配置清单：

```bash
git config --list
```

看看列表里有没有你刚才输进去的 `user.name` 和 `user.email`。如果有，恭喜你，配置完成！

## 基础操作

### 1. 初始化仓库：让项目“被 Git 接管”

假设你在电脑上新建了一个文件夹叫 `JavaLearning`，此时它只是个普通的文件夹。

**操作步骤：**

1.  进入该文件夹。
2.  打开 Git Bash（或终端）。
3.  输入命令：

    ```bash
    git init
    ```

**发生了什么？**

Git 会在这个文件夹里创建一个隐藏的目录 `.git`。

- **注意**：千万不要手动去修改或删除 `.git` 里的东西，否则你的版本历史就全丢了！
- 现在，这个 `JavaLearning` 文件夹就变成了一个 **Git 仓库 (Repository)**。

### 2. 核心命令：Status, Add, Commit（最最常用）

#### 查看状态 `git status`

**这是 Git 中最重要的命令，没有之一。**

- **作用**：它是你的“眼睛”，告诉你哪些文件被修改了，哪些文件还在“购物车”里。
- **现象**：

  - **红色**：文件改了，但 Git 还没准备存（还在工作区）。
  - **绿色**：文件已经放到“购物车”了，准备提交（在暂存区）。
  - **Nothing to commit**：工作区很干净，所有修改都已保存。

#### 添加到暂存区 `git add`

你写了一个 `HelloWorld.java` 文件。现在它在 Git 眼里是“未追踪（Untracked）”的。你需要告诉 Git：“我要把这个文件纳入管理”。

- **命令**：

  ```bash
  git add HelloWorld.java
  ```

- **技巧**：如果你改了 10 个文件，不想一个个敲文件名，可以用：

  ```bash
  git add .
  ```

  （注意有个点 `.`，代表当前目录下的所有变动）。

#### 提交到版本库 `git commit`

这是“**正式存档**”。

- **命令**：

  ```bash
  git commit -m "这是我的第一次提交：创建了HelloWorld程序"
  ```

- **详解**：

  - `-m`：后面跟的是本次提交的说明信息 (Message)。
  - **规范**：**严禁**写 "update", "fix", "111" 这种无意义的说明。要写清楚**改了什么**。比如："修复登录页面的空指针异常" 或 "新增用户注册功能"。

### 3. 查看历史：时光机 `git log`

当你提交了很多次后，你想看看以前干了什么。

- **命令**：

  ```bash
  git log
  ```

- **输出**：你会看到一串黄色的字符（Commit ID），作者是谁，时间和提交说明。
- **退出**：如果记录太长，屏幕显示 `END`，按键盘上的 `q` 键退出查看。

### 4. Java 开发必备：忽略文件 `.gitignore`

在 Java 开发中，有些文件是**不需要**也是**不应该**提交到 Git 里的：

1.  **编译后的文件**：`.class` 文件（因为那是源码编译生成的，我们要存的是源码）。
2.  **IDE 配置文件**：`.idea/`, `.vscode/`（每个人的编辑器配置不一样，不要同步给别人）。
3.  **构建目录**：`target/`, `build/`。

**怎么做？**

在你的项目根目录下，手动创建一个名为 `.gitignore` 的文件（注意文件名前面有个点，没有后缀名）。

**在文件里写上你要忽略的内容：**

```text
# 忽略所有的 .class 文件
*.class

# 忽略编译输出目录
target/
build/

# 忽略 IDE 配置
.idea/
*.iml
```

一旦配置好，`git status` 就会自动无视这些垃圾文件，保持仓库整洁。

### 5. 撤销修改

如果你在 `HelloWorld.java` 里乱写了一行代码，还没 `add`，想恢复原状：

- **命令**：

  ```bash
  git restore HelloWorld.java
  ```

  _(注：旧版本 Git 使用 `git checkout -- HelloWorld.java`，两个都可以，推荐用 `restore`，语义更清晰)_。

- **效果**：文件会瞬间变回上一次 Commit 时的样子。

## 分支与合并

### 1. 为什么要用分支？

想象你在写一个 Java 游戏：

- **主线（main 分支）**：这是稳定发布的版本，玩家正在玩。
- **你的任务**：你要开发一个“飞行功能”。你不能直接在稳定版上改，万一改崩了，游戏就挂了。

**Git 的做法**：
你基于主线，复制出一个“平行宇宙”（分支）。你在平行宇宙里怎么折腾、怎么改代码，都不会影响主线。等你测试完美了，再把这个平行宇宙合并回主线。

### 2. 分支的基本操作

#### A. 查看与创建

- **查看分支**：

  ```bash
  git branch
  ```

  你会看到类似 `* master`。前面的星号 `*` 表示你**当前所在的分支**。

- **创建分支**：

  ```bash
  git branch dev
  ```

  这创建了一个名为 `dev` 的新分支，但**注意：你现在还在 master 分支上，并没有过去。**

#### B. 切换分支 (Switch)

这是新手最容易弄混的。

- **旧命令**：`git checkout dev`（这个命令身兼数职，既能撤销文件又能切分支，容易晕）。
- **新命令（推荐）**：

  ```bash
  git switch dev
  ```

  现在，你就在 `dev` 分支上了。你在工作区做的任何修改、提交，都只属于 `dev`，跟 `master` 没关系了。

- **创建并切换**：

  ```bash
  git checkout -b feature-login
  # 或者新版写法
  git switch -c feature-login
  ```

  这句话的意思是：创建一个叫 `feature-login` 的分支，并马上跳过去。

#### C. 删除分支

如果功能开发完了，或者废弃了：

```bash
git branch -d feature-login
```

### 3. 合并分支 (Merge)

假设你在 `dev` 分支上写好了代码，现在要把它合并回 `master`。

**口诀：想把 B 合并进 A，必须先站在 A 上，然后“吸入” B。**

1.  **第一步：切换回目标分支**（比如 master）

    ```bash
    git switch master
    ```

2.  **第二步：执行合并命令**

    ```bash
    git merge dev
    ```

    意思是：把 `dev` 的成果合并到当前分支（master）来。

### 4. 解决冲突 (Merge Conflicts)

**什么时候会发生冲突？**

当你和同事（或者你自己的两个分支）**修改了同一个文件的同一行代码**，并且内容不一样。Git 懵了，它不知道该听谁的，于是它会停下来，让你手动决定。

**冲突发生时的现象：**

当你执行 `git merge` 时，终端会报错：

`CONFLICT (content): Merge conflict in Main.java`

`Automatic merge failed; fix conflicts and then commit the result.`

**如何解决？（标准步骤）**

1.  **不要慌**。
2.  **打开冲突的文件**。你会看到 Git 把文件改成了这样：

    ```java
    public class Main {
        public static void main(String[] args) {
    <<<<<<< HEAD
            System.out.println("这是主线的内容");
    =======
            System.out.println("这是dev分支修改的内容");
    >>>>>>> dev
        }
    }
    ```

    - `<<<<<<< HEAD` 到 `=======`：是你当前分支（master）的代码。
    - `=======` 到 `>>>>>>> dev`：是你要合并进来的分支（dev）的代码。

3.  **手动修改**。删掉那些乱七八糟的符号（`<<<`, `===`, `>>>`），留下你想要的代码。比如你决定保留两行：

    ```java
    public class Main {
        public static void main(String[] args) {
            System.out.println("这是主线的内容");
            System.out.println("这是dev分支修改的内容");
        }
    }
    ```

4.  **保存文件**。
5.  **提交结果**。

    ```bash
    git add .
    git commit -m "解决冲突：合并dev分支"
    ```

**注意**：解决冲突后的提交通常不需要写具体改了啥，Git 会知道这是一个 Merge Commit。

### 5. HEAD 指针

你经常会听到 HEAD 这个词。你可以把它理解为 **“当前光标”**。

- 当你切换到 `master`，HEAD 就指向 `master` 的最新一次提交。
- 当你切换到 `dev`，HEAD 就指向 `dev` 的最新一次提交。
- 当你 `git commit` 时，HEAD 就会带着当前分支向前走一步。

## 远程协作

### 1. 什么是远程仓库 (Remote Repository)？

之前的操作（add, commit, branch）全都是在你本机完成的。

- **本地仓库**：你电脑上的 `.git` 文件夹。
- **远程仓库**：托管在互联网上的服务器（比如 GitHub, GitLab, Gitee）。

**它的作用：**

1.  **云备份**：你电脑硬盘坏了，代码还在。
2.  **多人协作**：你和同事都把代码推送到同一个远程仓库，实现代码共享。

**常见平台：**

- **GitHub**：全球最大的代码托管平台（必须有账号，它是程序员的简历）。
- **Gitee (码云)**：国内平台，速度快（如果 GitHub 访问慢，可以用这个练习）。
- **GitLab**：很多公司内部会自己搭建这个。

### 2. 关联远程仓库：`git remote`

假设你在 GitHub 上新建了一个空仓库（Repository），地址是 `https://github.com/YourName/JavaLearning.git`。

现在，你需要把你本地现有的项目和这个远程地址**绑定**起来。

- **命令**：

  ```bash
  git remote add origin https://github.com/YourName/JavaLearning.git
  ```

- **详解**：

  - `git remote add`：添加远程连接。
  - `origin`：这是给远程仓库起的**别名**。你可以叫它 `my-server`，但约定俗成大家都叫 `origin`。
  - 后面的 URL：远程仓库的地址。

- **查看关联**：

  ```bash
  git remote -v
  ```

  如果看到 `fetch` 和 `push` 的地址，说明关联成功。

### 3. 推送代码：`git push`

这是把本地的“存档”上传到云端。

- **第一次推送（关键）**：

  ```bash
  git push -u origin master
  ```

  - **注意**：现在的 GitHub 新建仓库默认主分支叫 `main`，如果你本地是 `master`，你可能需要先改名或者推送到 `main`。
  - `-u` (upstream)：意思是“**绑定上游**”。以后你再推送到这个分支，只需要敲 `git push` 两个词，Git 就知道是要推给 `origin` 的 `master`，不用每次都输长命令。

- **日常推送**：

  写完代码 -> `git add .` -> `git commit -m "commit message"` -> `git push`

### 4. 拉取代码：`git pull` & `git clone`

这就涉及到两个场景：

#### 场景 A：你换了台电脑，想把项目下载下来

- **命令**：

  ```bash
  git clone https://github.com/YourName/JavaLearning.git
  ```

- **效果**：这会把整个远程仓库连同所有的历史记录，完整地下载到你的新电脑上。

#### 场景 B：同事更新了代码，你想同步到你的电脑上

比如同事修了个 Bug 推送到了远程，你现在的代码不仅是旧的，而且如果你直接 push 可能会报错。你需要先“拉”下来。

- **命令**：
  、
  ```bash
  git pull
  ```
- **原理**：`git pull` 其实等于两步操作：

  1.  `git fetch`（把代码下载到本地的版本库，但不修改工作区）。
  2.  `git merge`（把下载的代码合并到你的当前分支）。

### 5. 身份认证

当你执行 `git push` 时，Git 会问你是谁。

**以前**：输入 GitHub 的账号密码。
**现在（2021 年以后）**：GitHub **不再支持**直接用账号密码推送（因为不安全）。

你需要掌握以下两种认证方式之一（推荐第二种）：

#### 方式 A：Personal Access Token (HTTPS)

如果你用 HTTPS 链接，你需要去 GitHub 设置里生成一个 Token，把这个 Token 当作密码输进去。

#### 方式 B：SSH Key (推荐，一劳永逸)

这是专业程序员的做法。它的原理是：你电脑生成一对钥匙（公钥和私钥），把公钥给 GitHub。以后你再推送，GitHub 认识你的钥匙，就不需要输密码了。

**配置 SSH 简易步骤（了解即可，实操需查文档）：**

1.  本地生成：`ssh-keygen -t ed25519 -C "your_email@example.com"`
2.  复制公钥内容：`cat ~/.ssh/id_ed25519.pub`
3.  去 GitHub -> Settings -> SSH and GPG keys -> New SSH key -> 粘贴。
4.  关联远程时使用 SSH 地址（以 `git@github.com` 开头的地址）而不是 HTTPS。

### 6. 多人协作的基本流程

假设你进入了一家 Java 公司，流程通常是这样的：

1.  **早上上班**：

    - `git pull`：先拉取同事昨晚写的代码，保持同步。

2.  **写代码**：

    - `git switch -b feature-xxx`：开个新分支写功能。
    - 写代码 -> `git add` -> `git commit`。

3.  **提交代码**：

    - `git push origin feature-xxx`：把你的分支推送到服务器。

4.  **合并代码**：

    - 在网页上（GitHub/GitLab）发起 **Pull Request (PR)**，请求组长把你的代码合并进主分支。

## 高级操作

当你把代码写崩了、提交错分支了、或者觉得提交历史太乱太丑了，就需要用到这些工具。这通常是高级开发者的“特权”。

### 1. 版本回退： `git reset`

你在本地提交了一堆烂代码，或者发现刚才的 Commit 包含了一个敏感密码，想彻底撤销这次提交。

`git reset` 有三种模式，必须分清（假设你想回退到上一个版本 `HEAD^`）：

#### A. 软重置 (`--soft`) —— “我只是想重新提交”

```bash
git reset --soft HEAD^
```

- **效果**：撤销了 Commit 记录。
- **文件状态**：你的代码**全都在**，而且是**绿色**的（在暂存区）。
- **场景**：你提交完了发现漏了一个文件没 add，想撤销提交，加上那个文件再一起重新提交。

#### B. 混合重置 (`--mixed`) —— “默认模式”

```bash
git reset HEAD^
# 或者
git reset --mixed HEAD^
```

- **效果**：撤销了 Commit 记录。
- **文件状态**：你的代码**全都在**，但是是**红色**的（在工作区，未 add）。
- **场景**：你想保留代码，但想重新整理，或者单纯只是想把它们从暂存区拿出来。

#### C. 硬重置 (`--hard`)

```bash
git reset --hard HEAD^
```

- **效果**：撤销 Commit，**并且删除工作区所有修改**。
- **文件状态**：彻底回到上一个版本的状态，你刚写的代码**全部消失**。
- **场景**：你彻底写乱了，想完全放弃这一小时的工作，重头再来。

### 2. 现场保留： `git stash`

**场景**：你正在 `dev` 分支狂写代码，写到一半，老板突然冲过来说：“线上有个紧急 Bug（在 `master` 分支），马上修复！”
这时候你很尴尬：

- 如果你提交（Commit）：代码还没写完，编译都通不过，不能提交。
- 如果不提交：你无法切换分支，Git 会阻止你。

**解决方案**：把当前工作现场“藏”起来。

1.  **封存现场**：

    ```bash
    git stash
    ```

    这时候你的工作区瞬间变得干干净净，回到了上一次提交的状态。你就可以安全地切换到 `master` 去修 Bug 了。

2.  **修完 Bug 回来**：

    切换回 `dev` 分支。

3.  **恢复现场**：

    ```bash
    git stash pop
    ```

    你的代码又回来了！就像什么都没发生过一样。

### 3. 变基：`git rebase` (vs Merge)

我们在前面学了 `git merge`，它是把两条线绑在一起，会生成一个新的“Merge Commit”。

而 `git rebase`（变基）的作用是：**修剪树枝，让历史变成一条直线**。

**场景**：

你在 `feature` 分支开发，同事在 `master` 更新了代码。

- **Merge 做法**：`git merge master`。历史记录会出现分叉再汇合的菱形，多了很多 "Merge branch 'master'..." 的废话记录。
- **Rebase 做法**：

  ```bash
  git rebase master
  ```

  **原理**：Git 会把你当前分支的修改暂时拿下来，把 `master` 的新代码接过来，然后再把你的修改**追加**到最后面。
  **好处**：提交历史是一条完美的直线，非常整洁（强迫症福音）。

**黄金法则**：**永远不要在公共分支（如 master）上使用 rebase，只在你自己私有的功能分支上用。**

### 4. 精准拾取：`git cherry-pick`

这是一个非常实用的“物理外挂”。

**场景**：

你在 `dev` 分支上修了 3 个 Bug，提交了 3 次（Commit A, B, C）。

但是，老板说：“其中 Bug B 的修复非常紧急，需要立刻上线到 `master`，但 A 和 C 还有问题，不能上。”

你不能合并整个 `dev` 分支。你需要**只挑** Commit B。

**操作**：

1.  在 `dev` 分支用 `git log` 找到 Commit B 的 ID（比如 `a1b2c3d`）。
2.  切换到 `master` 分支。
3.  执行：`git cherry-pick a1b2c3d`

**结果**：Git 会把那一次提交的内容，复制一份应用到当前分支。

### 5. 打标签：`git tag`

Git 的 Commit ID 是一串记不住的乱码（如 `f4a32c...`）。

当你的 Java 项目开发到一定阶段，发布了“1.0 版本”，你需要给这个特定的 Commit 贴个条。

- **打标签**：

  ```bash
  git tag v1.0
  ```

- **推送到远程**（标签默认不会被 push，需要专门推）：

  ```bash
  git push origin v1.0
  ```

### 终极救命绝招：`git reflog`

这是老手必须要知道的命令。

如果你不小心执行了 `git reset --hard`，把代码删没了。你以为丢了吗？

**Git 几乎从不真正删除数据。**

- **命令**：

  ```bash
  git reflog
  ```

- **作用**：它记录了**你所有的操作历史**（包括你 Reset 之前的状态）。
- **复活**：找到你误删之前的那个 HEAD@{n} 的 ID，然后 `git reset --hard <那个ID>`，你的代码就回来了！

## 工作流与 IDE 集成

在公司里，我们追求的是**效率**和**规范**。因此，我们通常会使用图形化工具（IDE）来操作 Git，并遵循特定的团队合作流程。

### 1. 主流工作流 (Branching Models)

Git 很灵活，灵活到每个人都可以乱搞。为了防止混乱，团队会约定一套“交通规则”，这就是工作流。

#### A. GitHub Flow（最流行、最适合敏捷开发）

这是目前最主流的轻量级流程，核心逻辑只有一条：**保护主分支 (master/main)**。

1.  **主分支 (main)**：永远是可以部署的稳定代码。**严禁直接在主分支上 Push 代码**。
2.  **新任务**：每次要开发新功能或修 Bug，必须从 main 切出一个新分支（如 `feature-user-login`）。
3.  **提交**：在你的新分支上开发、提交。
4.  **Pull Request (PR)**：开发完成后，在网页端发起“合并请求”，请同事 Review 代码。
5.  **合并**：审核通过后，在网页上点“Merge”按钮，把代码合入 main。

#### B. Git Flow（传统、严谨）

稍微复杂一点，适合有固定发布周期的软件（比如 App 版本更新）。

- **Develop 分支**：日常开发用的。
- **Release 分支**：准备发布版本用的。
- **Hotfix 分支**：紧急修复线上 Bug 用的。

> **新手建议**：目前你一个人学习，或者参与开源项目，**掌握 GitHub Flow 就足够了**。

### 2. 代码审查：Pull Request (PR) / Merge Request (MR)

**这是团队协作的核心仪式。**

在公司里，你写的代码通常不会直接合并，而是需要经过“审查”。

1.  **发起 PR**：你把代码 push 到 GitHub 后，页面会出现一个绿色的 "Compare & pull request" 按钮。
2.  **Code Review**：你的组长或同事会看你的代码。他们可以在网页上对某一行代码发表评论：“这里可能会空指针异常”、“这里的变量名不规范”。
3.  **修改**：你在本地修改代码 -> 再次 commit -> 再次 push。PR 会自动更新你的最新修改。
4.  **批准 (Approve)**：同事觉得没问题了，点击批准，代码合并。

### 3. IntelliJ IDEA 中的 Git

作为 Java 程序员，你 90% 的时间是在 **IntelliJ IDEA** 里写代码的。IDEA 内置了极度强大的 Git 工具。

_你之前学的命令行知识，能让你看懂 IDEA 在干什么，出问题时知道怎么修。但在日常开发中，用 IDEA 效率高十倍。_

#### A. 配置 Git

打开 IDEA -> `Settings` -> `Version Control` -> `Git` -> 确保 Path to Git executable 找到了你安装的 git.exe。

#### B. 常用操作映射

- **Commit (⌘K / Ctrl+K)**：

  IDEA 会弹出一个侧边栏，自动列出所有变动文件。你可以勾选文件，直观地看到改了哪里（Diff），填写日志，然后点 Commit。

- **Push (⌘⇧K / Ctrl+Shift+K)**：

  一键推送到远程。

- **分支管理 (右下角)**：

  IDEA 窗口右下角显示着 `master` 或 `main`。点击它，可以新建分支、切换分支、重命名分支。

- **解决冲突 (最强功能)**：

  当发生 Merge 冲突时，IDEA 会弹出一个**三栏窗口**：

  - 左边：你的代码。
  - 右边：传入的代码。
  - 中间：合并后的结果。
  - **操作**：你只需要点击 `<<` 或 `>>` 箭头，选择要保留哪边的代码，非常直观，不再需要对着 `<<<< HEAD` 发呆。

#### C. `Local History`

这不属于 Git，但比 Git 还快。IDEA 会自动记录你每一次键盘输入。

即使你**没 Add 也没 Commit**，甚至把文件删了，Git 救不了你，但在文件上右键 -> `Local History` -> `Show History`，IDEA 能帮你找回 5 分钟前的代码。

### 4. Git 提交规范

不要写 `update` 或 `fix` 这种烂提交信息。业界通用的 **Conventional Commits** 规范如下：

- `feat: 新增用户登录功能` (新功能)
- `fix: 修复订单金额计算错误的 Bug` (修补)
- `docs: 更新 README 文档` (文档)
- `style: 修改代码格式（不影响逻辑）` (格式)
- `refactor: 重构支付模块代码` (既不修 bug 也不加功能)
