---
title: Java虚拟机
date: 2024-03-08 06:00:00 +0800
categories: [Java Backend, JVM]
tags: [JVM]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/java_backend/20251118105226390.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 什么是 Java 虚拟机？

Java 虚拟机（JVM）可以理解为一个抽象的计算机，它通过在实际的计算机上仿真模拟各种计算机功能来实现。 JVM 是 Java 程序运行的基础，它提供了一个独立于硬件和操作系统的运行环境，从而实现了 Java 语言“一次编写，到处运行”的跨平台特性。 JVM 的核心任务是执行 Java 程序，它在程序开始执行时运行，在程序结束时停止。 实际上，当我们在执行一个 Java 程序时，真正运行的是一个 Java 虚拟机进程。

JVM 并不关心在其内部运行的程序是用何种语言编写的，它只关心“字节码”文件。 也就是说，任何能够编译成符合 JVM 规范的字节码文件的语言，都可以在 JVM 上运行。

## JVM 的各个组成部分？

JVM 主要由以下几个部分组成：

- **类加载器（Class Loader）**: 负责加载类文件到内存。
- **运行时数据区（Runtime Data Area）**: JVM 的内存区域，用于存储程序运行期间的各种数据。
- **执行引擎（Execution Engine）**: 负责解释或编译字节码指令，并交由操作系统执行。
- **本地库接口（Native Interface）**: 用于与本地方法库（Native Libraries）交互，使得 Java 代码可以调用其他语言（如 C/C++）编写的本地代码。

### 一、 类加载器子系统（Class Loader Subsystem）

类加载器的主要职责就是根据类的全限定名（Fully Qualified Class Name）来加载对应的`.class`文件的二进制数据，并将其转换为`java.lang.Class`的一个实例，最终存放在方法区中。

Java 中的类加载器主要有以下几种，并且它们之间形成了**双亲委派模型（Parents Delegation Model）**：

1.  **启动类加载器（Bootstrap Class Loader）**:

    - 这是 JVM 自身的一部分，由 C++实现。
    - 它负责加载 Java 最核心的类库，比如`rt.jar`，也就是位于`<JAVA_HOME>/jre/lib`目录下的类。
    - 它是所有类加载器的“顶层”，没有父加载器。

2.  **扩展类加载器（Extension Class Loader）**:

    - 由 Java 实现，是`ClassLoader`的子类。
    - 它负责加载`<JAVA_HOME>/jre/lib/ext`目录下的，或者被`java.ext.dirs`系统变量所指定的路径中的所有类库。
    - 它的父加载器是启动类加载器。

3.  **应用程序类加载器（Application / System Class Loader）**:

    - 也由 Java 实现，是`ClassLoader`的子类。
    - 它负责加载用户类路径（Classpath）上所指定的类库。我们自己编写的 Java 类，默认就是由它来加载的。
    - 它的父加载器是扩展类加载器。

4.  **自定义类加载器（Custom Class Loader）**:
    - 在有特殊需求时，例如从网络加载类、对字节码进行解密等，开发者可以继承`java.lang.ClassLoader`类，实现自己的类加载器。

**双亲委派模型的工作流程是**：当一个类加载器收到类加载请求时，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。每一层的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

**这样做的好处**是保证了 Java 核心库的类型安全。例如，无论哪个类加载器要加载`java.lang.String`类，最终都会委派给启动类加载器加载，从而保证了系统中只存在一份由 JVM 官方加载的`String`类，防止了核心 API 库被随意篡改。

### 二、 运行时数据区（Runtime Data Area）

这是 JVM 的内存模型，程序运行过程中所有的数据都存储在这里。它分为**线程共享**和**线程私有**两部分。

#### 线程共享区域

1.  **堆（Heap）**:

    - 堆是 JVM 管理的内存中最大的一块区域，在 JVM 启动时创建。
    - 它的唯一目的就是存放对象实例，几乎所有的对象实例和数组都在这里分配内存。
    - 堆是垃圾回收器（Garbage Collector）进行垃圾回收的主要区域。
    - 从内存回收的角度，堆还可以细分为：新生代（Young Generation）和老年代（Old Generation）。新生代又可以分为 Eden 区、From Survivor 区（S0）和 To Survivor 区（S1）。

2.  **方法区（Method Area）**:
    - 方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器（JIT）编译后的代码等数据。
    - 它是一个逻辑上的区域，具体的实现会随 JVM 版本而变化。在 JDK 7 及以前，它通常被称为“永久代（Permanent Generation）”。在 JDK 8 及以后，永久代被移除，取而代之的是**元空间（Metaspace）**，元空间使用的是本地内存（Native Memory），而不是 JVM 的堆内存。

#### 线程私有区域

1.  **Java 虚拟机栈（Java Virtual Machine Stack）**:

    - 每个线程在创建时都会创建一个虚拟机栈，其生命周期与线程相同。
    - 每个方法在执行时，都会在虚拟机栈中创建一个**栈帧（Stack Frame）**。
    - 栈帧用于存储**局部变量表**、**操作数栈**、**动态链接信息**、**方法出口**等。一个方法的调用到执行完成，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
    - 这个区域可能抛出两种异常：`StackOverflowError`（线程请求的栈深度大于虚拟机所允许的深度）和`OutOfMemoryError`（如果虚拟机栈可以动态扩展，但在扩展时无法申请到足够的内存）。

2.  **本地方法栈（Native Method Stack）**:

    - 与虚拟机栈的作用非常相似，区别在于虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

3.  **程序计数器（Program Counter Register）**:
    - 是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。
    - 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
    - 它是唯一一个在 Java 虚拟机规范中没有规定任何`OutOfMemoryError`情况的区域。

### 三、 执行引擎（Execution Engine）

执行引擎是 JVM 的核心，它负责执行包含在被加载类的方法中的字节码指令。

1.  **解释器（Interpreter）**: 负责读取字节码，逐条解释并执行指令。它的优点是启动快，但执行效率相对较低。

2.  **即时编译器（Just-In-Time Compiler, JIT）**: 为了解决解释器执行效率低的问题，JVM 引入了 JIT 编译器。它会在运行时将“热点代码”（被频繁执行的方法或代码块）编译成与本地平台相关的机器码，并进行缓存。后续执行这些代码时，直接运行编译后的机器码，从而极大地提高了执行效率。HotSpot 虚拟机就内置了多个 JIT 编译器，如 C1（Client Compiler）和 C2（Server Compiler）。

3.  **垃圾回收器（Garbage Collector, GC）**: GC 可以看作是执行引擎的一部分，它是一个后台线程，负责自动回收堆内存中不再被引用的对象，实现内存的自动管理。

### 四、 本地方法接口（Native Method Interface, JNI）

JNI 是一个接口，它允许 Java 代码与用其他语言（如 C、C++）编写的代码进行交互。当 Java 程序需要调用一些底层操作系统功能或者使用已有的非 Java 类库时，就可以通过 JNI 来调用这些本地方法。本地方法栈就是为这些 JNI 调用服务的。

## 一个 Java 程序的执行过程？

一个 Java 程序的完整执行过程，从我们编写的`.java`源代码文件开始，到最终在 Java 虚拟机（JVM）中运行并得出结果，大致可以分为以下几个关键阶段：

### **第一阶段：编译（Compilation）**

这个阶段发生在开发环境中，由 Java 编译器（`javac`）完成。

1.  **编写源代码**: 首先，开发者会编写符合 Java 语法规范的源代码文件，这些文件以`.java`为扩展名。
2.  **编译成字节码**: 接着，我们使用 Java 开发工具包（JDK）中的 Java 编译器（`javac`命令）对`.java`源文件进行编译。编译器会进行词法分析、语法分析、语义分析和代码生成等步骤，最终将人类可读的源代码转换成 JVM 可以理解和执行的字节码（Bytecode）。编译后的产物是扩展名为`.class`的文件。

这个`.class`文件包含了程序的指令集，但它不是针对任何特定硬件或操作系统的本地机器码，而是一种平台无关的中间代码。这正是 Java“一次编译，到处运行”口号的基石。

### **第二阶段：加载（Loading）**

当我们需要运行一个 Java 程序时，JVM 会启动，并通过其**类加载器（Class Loader）** 子系统将编译好的`.class`文件加载到内存中。

类加载过程又包含三个主要步骤：

1.  **加载（Loading）**: 这是“类加载”过程的第一个阶段。在这个阶段，JVM 会根据类的全限定名（例如 `com.example.MyClass`）找到对应的`.class`文件，读取这个文件的二进制数据流，并将其转换成方法区中的一个内部数据结构（`Class`对象）。这个`Class`对象将作为程序访问方法区中该类所有数据的入口。
2.  **链接（Linking）**: 这个阶段是将类的二进制数据合并到 JVM 运行时状态中的过程。
    - **验证（Verification）**: 确保被加载的类（`.class`文件）符合 JVM 规范，并且不会危害虚拟机自身的安全。这包括文件格式验证、元数据验证、字节码验证和符号引用验证等。
    - **准备（Preparation）**: 为类的静态变量（static variables）分配内存，并设置其初始默认值（例如，`int`为 0，`boolean`为`false`，引用类型为`null`等）。注意，这里是设置默认值，而不是我们在代码中显式赋予的初始值。
    - **解析（Resolution）**: 将符号引用（Symbolic References）替换为直接引用（Direct References）。符号引用是以一组符号来描述所引用的目标，而直接引用是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。
3.  **初始化（Initialization）**: 这是类加载过程的最后一步。在这个阶段，JVM 会执行类的初始化代码，即`<clinit>`方法。这个方法是由编译器自动收集类中所有静态变量的赋值动作和静态代码块（`static {}`块）中的语句合并产生的。只有在这个阶段，静态变量才会被赋予我们在代码中指定的初始值。

### **第三阶段：执行（Execution）**

当类被成功加载、链接并初始化后，程序就进入了执行阶段。这个阶段由 JVM 的**执行引擎（Execution Engine）** 负责。

1.  **找到主方法**: JVM 会首先寻找程序的入口点，也就是`main`方法。
2.  **执行字节码**: 执行引擎开始逐条执行`main`方法内的字节码指令。执行字节码主要有两种方式：

    - **解释执行（Interpretation）**: 执行引擎中的解释器会逐条读取字节码指令，将其翻译成对应的本地机器指令，然后立即执行。这种方式启动速度快，但整体执行效率较低。
    - **即时编译（Just-In-Time Compilation, JIT）**: 为了提升性能，现代 JVM 都引入了 JIT 编译器。当 JVM 发现某个方法或代码块被频繁地执行（即成为“热点代码”）时，JIT 编译器会介入，将这部分字节码一次性地编译成高效的、与平台相关的本地机器码，并进行缓存。后续再次执行这部分代码时，将直接运行编译后的本地机器码，从而大大提高执行效率。

3.  **与运行时数据区交互**: 在执行过程中，执行引擎会频繁地与 JVM 的**运行时数据区（Runtime Data Area）** 进行交互：
    - 每当调用一个新方法时，会在当前线程的**Java 虚拟机栈**中创建一个新的**栈帧（Stack Frame）**，用于存放该方法的局部变量、操作数栈等信息。
    - 当方法执行完毕后，对应的栈帧会从虚拟机栈中弹出。
    - 程序中创建的对象实例和数组会被分配在**堆（Heap）** 内存中。
    - **程序计数器（Program Counter Register）** 会记录当前线程正在执行的字节码指令的地址。

### **第四阶段：垃圾回收（Garbage Collection）**

在程序长时间运行的过程中，堆内存中会创建大量的对象。JVM 的垃圾回收器（Garbage Collector, GC）会作为一个后台线程持续监控堆内存的使用情况。当 GC 确定某些对象不再被任何活动线程引用时，它会自动回收这些对象所占用的内存空间，以供新的对象使用。这个过程是自动进行的，开发者无需手动管理内存。

### **总结**

所以，一个 Java 程序的完整生命周期是：

**`.java`文件 → `javac`编译器 → `.class`文件 → 类加载器 → 字节码校验器 → 解释器/JIT 编译器 → 操作系统 → 硬件**

这个流程通过 JVM 这一抽象层，巧妙地屏蔽了底层硬件和操作系统的差异，实现了 Java 的跨平台特性，并通过 JIT 编译等技术保证了良好的执行性能。

## Java 中对象创建的过程？

Java 中对象的创建过程虽然在代码层面仅仅是一行`new`语句，但在 JVM 内部却经历了一系列严谨而复杂的步骤。

### 第一步：类加载检查 (Class Loading Check)

当 JVM 遇到一条`new`指令时，它首先会去**运行时常量池**中检查，看是否能定位到这个指令所引用的类的符号引用。

1.  **检查符号引用是否存在**: 它会检查这个类是否已经被加载、解析和初始化过。
2.  **执行类加载**: 如果没有，JVM 必须首先执行相应的**类加载过程**。这包括了加载（Loading）、链接（Linking，包含验证、准备、解析三个子阶段）和初始化（Initialization）这几个步骤。这个过程确保了类的`.class`文件被正确地加载到内存（特别是方法区/元空间）中，并且类的静态部分已经准备就绪。

只有当类加载过程全部完成后，对象的创建过程才能继续。

### 第二步：为对象分配内存 (Memory Allocation)

类加载完成后，JVM 就已经完全确定了要创建的对象需要占用多大的内存空间。接下来，JVM 会从**Java 堆（Heap）** 中划分出一块确定大小的内存分配给这个新对象。

内存分配的方式主要有两种，具体采用哪种取决于 Java 堆是否规整，而堆是否规整又由所采用的垃圾收集器是否带有**压缩整理（Compact）** 功能决定。

1.  **指针碰撞 (Bump the Pointer)**:

    - **适用场景**: 如果 Java 堆内存是绝对规整的，即所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器。
    - **工作方式**: 分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。
    - **使用的垃圾收集器**: 比如 Serial、ParNew 等带 Compact 过程的收集器。

2.  **空闲列表 (Free List)**:
    - **适用场景**: 如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错。
    - **工作方式**: JVM 就必须维护一个列表，记录上哪些内存块是可用的。在分配的时候，就从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。
    - **使用的垃圾收集器**: 比如 CMS 这种基于标记-清除（Mark-Sweep）算法的收集器。

#### 并发安全问题

在多线程环境下，对象的创建是非常频繁的行为。仅仅是修改一个指针的位置，在并发情况下也可能不是线程安全的（比如 A、B 两个线程同时在堆上申请内存）。JVM 采用以下两种方式来保证线程安全：

- **CAS + 失败重试**: JVM 采用 CAS（Compare-And-Swap）配上失败重试的方式保证更新操作的原子性。
- **本地线程分配缓冲 (Thread Local Allocation Buffer, TLAB)**: 这是更常用的方法。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。TLAB 是每个线程在 Java 堆中预先分配的一小块私有内存。只有当线程的 TLAB 用完并需要分配新的 TLAB 时，才需要同步锁定。通过`-XX:+/-UseTLAB`参数可以设定是否使用 TLAB。

### 第三步：内存空间初始化 (Zeroing)

内存分配完成后，虚拟机需要将分配到的内存空间（但不包括对象头）都初始化为**零值**（Zero Value）。例如，`int`类型的字段会被初始化为`0`，`boolean`为`false`，引用类型为`null`等。

这一步操作保证了对象的实例字段在 Java 代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

### 第四步：设置对象头 (Object Header Setup)

初始化零值之后，虚拟机要对对象进行必要的设置，将一些关于这个对象自身的运行时数据存放在对象的**对象头（Object Header）** 中。

对象头中通常包含两部分信息：

1.  **Mark Word**: 用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID 等。这部分数据的长度在 32 位和 64 位的虚拟机中分别为 32 位和 64 位，它是一个动态定义的数据结构，以便在极小的空间内存储尽量多的信息。
2.  **类型指针 (Class Pointer)**: 即对象指向它的类元数据（Class Metadata）的指针。虚拟机通过这个指针来确定这个对象是哪个类的实例。

如果是数组对象，对象头中还必须有一块用于记录数组长度的数据。

### 第五步：执行 `<init>` 方法 (Constructor Execution)

在前面的工作都完成之后，从 JVM 的视角来看，一个新的对象已经产生了。但从 Java 程序的视角来看，对象的创建才刚刚开始——构造函数还没有执行。

此时，JVM 会接着执行`<init>`方法（即构造函数）。`<init>`方法是按照程序员的意图来对对象进行初始化的。这个过程包括：

1.  **执行父类的构造函数**: 在子类的构造函数中，会首先隐式或显式地调用父类的构造函数 (`super()`)，这个调用链会一直上溯到`java.lang.Object`的构造函数。
2.  **为成员变量赋初始值**: 执行成员变量定义时的赋值语句（例如 `private int value = 10;`）。
3.  **执行构造方法体中的代码**: 最后执行构造函数内部的代码块。

当`<init>`方法执行完毕后，一个真正可用的、被完整初始化的对象才算完全创建出来。此时，栈中的引用变量会指向堆中这个新创建的对象的内存地址。

### 总结

所以，一个 Java 对象的创建过程可以概括为：

1.  **检查类是否加载**
2.  **在堆中分配内存**（通过指针碰撞或空闲列表，并解决并发安全问题）
3.  **将分配的内存初始化为零值**
4.  **设置对象头信息**
5.  **执行`<init>`构造方法**（进行程序员定义的初始化）

整个过程环环相扣，确保了 Java 对象在被程序使用之前，其内存布局和初始状态都是正确和确定的。

## Java 中堆内存是如何进行分配的？

Java 堆内存的分配策略是 JVM 内存管理中最为核心和复杂的部分之一，其设计目标是为了高效地分配内存并有效地进行垃圾回收。这套机制的核心思想是**分代收集（Generational Collection）** 理论。

这个理论基于一个重要的假设：**绝大多数对象都是“朝生夕死”的，生命周期很短；而活过第一轮垃圾回收的少数对象，则倾向于活很长的时间。**

基于这个假设，HotSpot 虚拟机将 Java 堆划分为了两个主要的物理区域：**新生代（Young Generation）** 和 **老年代（Old Generation）**。

### 一、 堆的内部结构

首先，我们来看一下堆内存的具体划分：

1.  **新生代 (Young Generation)**

    - 新生代是绝大多数新对象被创建和分配内存的地方。
    - 它的特点是对象创建频繁，垃圾回收（称为 **Minor GC** 或 **Young GC**）也因此非常频繁，但回收速度很快。
    - 新生代内部又被细分为三个区域：
      - **一个伊甸园区 (Eden Space)**: 新创建的对象**绝大多数**会被分配在这里。
      - **两个幸存者区 (Survivor Spaces)**: 分别称为 From Survivor (S0) 和 To Survivor (S1)。这两个区域的大小完全相同，并且在任何时刻，其中一个必定是空的（这个空的就是 "To" 区）。

    默认情况下，新生代中 Eden、S0、S1 的空间比例通常是 **8:1:1**。

2.  **老年代 (Old Generation / Tenured Generation)**
    - 老年代用于存放生命周期较长的对象，即那些在新生代中经历了多次 Minor GC 后仍然存活的对象。
    - 老年代的空间通常比新生代大，其垃圾回收（称为 **Major GC** 或 **Full GC**）发生的频率要低得多，但一旦发生，耗时会更长。

### 二、 对象的分配过程详解

一个 Java 对象的“一生”通常会经历以下旅程：

#### 步骤 1：出生在伊甸园 (Eden Allocation)

- 当程序通过 `new` 关键字创建一个新对象时，JVM 会首先尝试在当前线程的 **TLAB (Thread Local Allocation Buffer)** 中为这个对象分配内存。TLAB 是每个线程在 Eden 区预留的一小块私有内存，这样做可以极大地避免多线程同时在 Eden 区分配内存时所需要的同步开销（如加锁）。
- 如果对象的尺寸太大，TLAB 放不下，或者 TLAB 已经用完，JVM 会尝试在 Eden 区的共享区域进行分配，这时通常需要通过 CAS 等机制来保证分配的原子性。
- 绝大多数情况下，新对象就这样在 Eden 区安家了。

#### 步骤 2：伊甸园的第一次筛选 (Minor GC)

- 随着程序运行，Eden 区会很快被填满。当 Eden 区没有足够空间分配新对象时，JVM 就会触发一次 **Minor GC**。
- Minor GC 的过程如下：
  1.  JVM 会扫描 Eden 区和 "From" Survivor 区（S0），找出所有仍然存活的对象。
  2.  将这些存活的对象复制到 "To" Survivor 区（S1）。在复制的过程中，每个对象的**年龄计数器（Age）会加 1**。对象的年龄存储在它的对象头（Header）中。
  3.  复制完成后，Eden 区和 "From" Survivor 区（S0）中的所有（无论死活）对象所占用的内存都会被一次性清空。
  4.  最后，"From" Survivor 区（S0）和 "To" Survivor 区（S1）的**角色互换**。原来的 S1 现在变成了下一次 GC 时的 S0，而原来的 S0 则变成了下一次 GC 时的 S1（也就是空的"To"区）。

#### 步骤 3：在幸存者区挣扎与成长

- 经过一次 Minor GC 后，存活下来的对象在 Survivor 区有了新的开始。
- 在此之后，每次 Eden 区满并触发 Minor GC 时，都会重复上述的第 2 步。存活的对象会在 S0 和 S1 之间来回复制，每次复制，其年龄都会加 1。

#### 步骤 4：晋升到老年代 (Promotion to Old Generation)

一个对象不会永远停留在新生代。当满足以下任一条件时，它就会被“晋升”到老年代：

1.  **年龄达到阈值 (Max Tenuring Threshold)**:

    - 当对象的年龄增长到一定阈值时（默认为 15，可以通过 `-XX:MaxTenuringThreshold` 参数设置），它就会在下一次 Minor GC 时被移动到老年代。
    - 为什么是 15？因为对象头中用于存储年龄的标记位只有 4 位，最大能表示的数字就是 15。

2.  **动态年龄判断 (Dynamic Age Calculation)**:
    - 这是一种 JVM 的优化策略。如果在 Survivor 区中，**相同年龄**的所有对象大小的总和大于 Survivor 空间的一半，那么**年龄大于或等于该年龄**的对象就会被直接移动到老年代，而无需等到达到`MaxTenuringThreshold`。

### 三、 特殊情况：大对象的直接分配

- 有一种特殊情况，就是当程序需要创建一个非常大的对象时（比如一个巨大的数组），这个对象可能会被**直接分配到老年代**。
- 这是因为如果把这样的大对象放在新生代，它可能会直接占满 Eden 区，导致频繁的 Minor GC。更糟糕的是，在 Survivor 区之间复制这种大对象的开销会非常高。
- JVM 提供了一个 `-XX:PretenureSizeThreshold` 参数。当一个对象的大小超过这个值时，它将不会在新生代分配，而是直接进入老年代。

### 总结

所以，Java 堆内存的分配策略可以概括为以下流程：

1.  **常规对象**：优先在当前线程的 **TLAB** 中分配，然后是 **Eden** 区。
2.  **大对象**：直接在 **老年代** 分配。
3.  **生命周期**：对象在 Eden 区出生，经过 Minor GC 后进入 Survivor 区，在两个 Survivor 区之间多次移动，年龄不断增加，最终达到阈值或满足动态年龄判断后，晋升到老年代。

这个精巧的设计，使得 JVM 的垃圾回收器可以针对不同区域的对象采用不同的回收策略（比如新生代用复制算法，老年代用标记-整理或标记-清除算法），从而在分配效率和回收效率之间取得了很好的平衡。

## Java 中创建新对象时堆内存中会发生抢占么？

理论上会发生抢占，但 JVM 通过一系列精巧的设计，在绝大多数情况下都避免了这种抢占的发生。

### 一、 抢占问题的根源：共享资源与并发访问

首先，我们要明确抢占（或者说“竞争”、“冲突”）的根源在哪里。

1.  **Java 堆是线程共享的**: 整个 Java 堆被应用程序的所有线程共享。
2.  **对象创建是高频操作**: 在一个典型的 Java 应用中，创建新对象的操作非常频繁。
3.  **并发创建**: 在多线程环境下，必然会有多个线程**在同一时刻**向 JVM 申请内存来创建新对象。

如果 JVM 处理内存分配的方式非常朴素，比如只用一个全局的指针来标记“堆顶”（即空闲内存的起始位置），那么当多个线程同时来分配内存时，必然会发生冲突。比如线程 A 刚读取了指针位置，还没来得及修改，线程 B 也读取了同一个位置，这就导致了数据不一致，一块内存可能会被错误地分配给两个不同的对象。

为了解决这个根本性的并发问题，JVM 必须引入同步机制。但如果简单地使用重量级锁（比如`synchronized`）来对整个内存分配过程加锁，虽然能保证线程安全，但性能会急剧下降，因为所有线程都必须排队等待分配内存，这在高并发场景下是无法接受的。

因此，JVM 采用了两种核心技术来高效、安全地处理并发内存分配：**线程本地分配缓冲（TLAB）** 和 **CAS（比较并交换）**。

### 二、 主要解决方案：线程本地分配缓冲 (Thread Local Allocation Buffer, TLAB)

**TLAB 是 JVM 避免内存分配抢占的主要武器，也是默认的优化策略。**

1.  **核心思想**: TLAB 的核心思想是“**化共享为私有**”。与其让所有线程都在一个大的、共享的 Eden 区里争抢内存，不如在 JVM 启动时，为**每个线程**在 Eden 区里预先分配一小块专属的、私有的内存区域。这个区域就叫做这个线程的 TLAB。

2.  **工作流程**:

    - 当一个线程需要创建一个新对象时，它会**首先尝试在自己的 TLAB 中进行分配**。
    - 因为 TLAB 是线程私有的，所以在这个区域内进行内存分配时，**完全不需要任何同步或加锁**。线程只需要简单地移动自己 TLAB 内部的一个“顶针”（指针）即可，这个过程非常快。
    - **绝大多数**（特别是小的）对象都可以在 TLAB 中成功分配。

3.  **TLAB 的耗尽与再分配**:
    - TLAB 的大小是有限的。当一个线程的 TLAB 用完，或者一个新对象太大，当前 TLAB 剩余空间不足以容纳时，线程就需要申请一块新的 TLAB。
    - **此时，抢占才会发生**。线程需要向共享的 Eden 区申请一块新的、确定大小的内存作为其新的 TLAB。这个分配过程是需要同步的，因为 Eden 区是共享的。
    - 但是，JVM 在这里并不会使用重量级锁，而是采用了更轻量的 **CAS（Compare-And-Swap）** 机制。

### 三、 后备解决方案：CAS (Compare-And-Swap)

当无法在 TLAB 中分配时（比如 TLAB 用尽需要重新分配，或者对象太大 TLAB 放不下，需要直接在 Eden 区分配），JVM 就会动用它的后备方案。

1.  **核心思想**: CAS 是一种**乐观锁**技术。它是一种原子的 CPU 指令，其操作包含三个操作数——内存位置（V）、预期原值（A）和新值（B）。如果内存位置 V 的值与预期原值 A 相匹配，那么处理器会自动将该位置的值更新为新值 B。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。

2.  **在内存分配中的应用**:
    - JVM 会维护一个指向 Eden 区空闲内存起点的指针。
    - 当一个线程需要在 Eden 区分配内存时，它会：
      a. 读取当前指针的位置（作为“预期原值 A”）。
      b. 计算分配完内存后，指针的新位置（作为“新值 B”）。
      c. 使用 CAS 指令，尝试将指针从位置 A 原子地更新到位置 B。
    - 如果 CAS 成功，说明在它操作期间没有其他线程修改过这个指针，内存分配成功。
    - 如果 CAS 失败，说明在他之前，已经有另一个线程成功地修改了指针，发生了竞争。此时，当前线程**不会被挂起**，而是会进行**自旋（Spinning）**，即立即重新尝试上述过程（读取新的指针位置，计算，再 CAS），直到成功为止。

通过 CAS+自旋的方式，JVM 保证了在共享区域分配内存的原子性和线程安全性，并且其性能开销远小于传统的重量级锁。

### 总结

所以，对于“创建新对象时堆内存是否会发生抢占”这个问题，一个完整的回答是：

1.  **会，但 JVM 有高效的应对策略**。由于 Java 堆是所有线程共享的，并发创建对象时必然存在资源竞争的可能。
2.  **主要通过 TLAB 避免抢占**。JVM 为每个线程在 Eden 区分配了私有的 TLAB。对于绝大多数对象的创建，都是在各自的 TLAB 中完成的，这是一个无锁、无竞争的快速过程，从根本上避免了抢占。
3.  **通过 CAS 处理剩余的抢占**。当 TLAB 用尽或对象过大，必须在共享的 Eden 区分配时，JVM 会使用 CAS+自旋的乐观锁机制来保证分配的原子性。这种方式虽然存在竞争，但相比重量级锁，性能要高得多。
4.  **最终屏障是 GC**。如果 CAS 尝试多次后，发现 Eden 区空间确实不足了，那么 JVM 会暂停所有用户线程（Stop-The-World），触发一次 Minor GC 来回收空间。这是最大的一种“抢占”，因为它抢占了所有线程的执行时间。

## Java 中对象的内存布局？

在 HotSpot 虚拟机中，一个 Java 对象在堆内存中的存储布局可以清晰地划分为三个部分：**对象头（Header）**、**实例数据（Instance Data）**和**对齐填充（Padding）**。

### 一、 对象头 (Object Header)

对象头是内存布局的起始部分，它是一个至关重要的区域，因为它包含了对象的“元数据”信息，即描述对象自身状态的数据。对象头本身又包含两部分（如果是数组对象，则为三部分）：

#### 1. Mark Word (标记字段)

这是对象头中**最复杂**的部分。它是一个非固定的、动态的数据结构，会根据对象所处的状态复用自己的存储空间，来存储不同的信息。在 64 位的 JVM 中，Mark Word 占用 **8 个字节 (64 bits)**。

它主要存储以下几类信息：

- **哈希码 (HashCode)**: 对象的哈希码，只有在第一次调用 `Object.hashCode()` 方法时才会被计算并写入。
- **GC 分代年龄 (GC Generation Age)**: 对象在新生代的 Survivor 区中每经历一次 Minor GC 后，年龄就会加 1。这个年龄就记录在这里，它是对象能否晋升到老年代的重要依据（默认最大 15）。
- **锁状态标志 (Lock Status Bits)**: 这是 Mark Word 中最核心的部分，用于标识对象当前的锁状态。它有以下几种状态，随着锁竞争的升级而变化：
  - **无锁状态 (Unlocked)**
  - **偏向锁 (Biased Lock)**: 存储持有该锁的线程 ID。
  - **轻量级锁 (Lightweight Lock)**: 存储指向线程栈中锁记录（Lock Record）的指针。
  - **重量级锁 (Heavyweight Lock)**: 存储指向互斥量（Mutex）的指针。
- **GC 标记**: 在垃圾回收期间，用于标记对象是否为可达对象。

**Mark Word 的状态变化示例 (64 位 JVM):**

| 锁状态       | 存储内容                                |
| :----------- | :-------------------------------------- |
| **无锁**     | 对象哈希码, GC 分代年龄, 未使用         |
| **偏向锁**   | 持有偏向锁的线程 ID, Epoch, GC 分代年龄 |
| **轻量级锁** | 指向线程栈中锁记录的指针                |
| **重量级锁** | 指向监视器对象(Monitor)的指针           |
| **GC 标记**  | (无，专门用于 GC)                       |

#### 2. Klass Pointer (类型指针)

类型指针，也叫“类元信息指针”，它指向方法区/元空间（Metaspace）中存储的该对象的类元信息（`Class`对象）。虚拟机通过这个指针来确定当前这个对象是哪个类的实例。

- 在 64 位 JVM 中，这个指针理论上需要 8 个字节。但是，为了节省内存空间，JVM 默认开启了**指针压缩（Compressed Class Pointers）**。
- 开启指针压缩后，Klass Pointer 只占用 **4 个字节 (32 bits)**。

#### 3. Array Length (数组长度)

这部分**只在数组对象中存在**。如果当前对象是一个数组，那么对象头中还必须有一块区域来记录数组的长度。这部分数据占用 **4 个字节 (32 bits)**。

所以，一个非数组对象在 64 位 JVM（开启指针压缩）中的对象头大小为：`Mark Word (8字节) + Klass Pointer (4字节) = 12字节`。
而一个数组对象则是：`Mark Word (8字节) + Klass Pointer (4字节) + Array Length (4字节) = 16字节`。

### 二、 实例数据 (Instance Data)

实例数据是对象内存布局中的核心部分，它真正存储了**对象有效信息**，也就是我们在类中定义的各种类型的成员变量（字段），包括从父类继承下来的字段。

这部分数据的存储顺序会受到虚拟机分配策略参数（`-XX:FieldsAllocationStyle`）和字段在源码中定义顺序的影响，但通常会遵循以下一些优化原则：

1.  **分配策略**: 相同宽度的字段总是被分配到一起，例如 `long` 和 `double` 会被优先分配。
2.  **父类优先**: 父类中定义的变量会出现在子类变量之前。
3.  **对齐优化**: 如果 CompactFields 参数为 true（默认），那么子类的窄变量（如`byte`, `boolean`）可能会插入到父类变量的间隙中，以节省空间。

### 三、 对齐填充 (Padding)

对齐填充并不是一个必然存在的部分，它的作用是**占位符**，目的是为了**保证整个对象的总大小是 8 字节的整数倍**。

- **原因**: 现代 CPU 在访问内存时，通常不是一个字节一个字节地读取，而是以“字”（Word）为单位进行块读取（例如 64 位 CPU 一次可以读取 8 个字节）。如果对象的起始地址是 8 的倍数，那么 CPU 的访问效率会更高。
- **工作方式**: 当对象头和实例数据的大小加起来不是 8 字节的整数倍时，JVM 会自动在对象的末尾添加若干个字节的填充，直到总大小凑成 8 的倍数。

### 举例说明

让我们以一个简单的类为例，在 64 位 JVM（开启指针压缩）环境下分析其内存布局：

```java
public class Person {
    private int id;         // 4字节
    private boolean isMale; // 1字节
    private String name;    // 4字节 (引用，开启指针压缩)
}
```

创建一个`new Person()`对象，其内存占用分析如下：

1.  **对象头 (Header)**:

    - Mark Word: 8 字节
    - Klass Pointer: 4 字节
    - **头部总计: 12 字节**

2.  **实例数据 (Instance Data)**:

    - `int id`: 4 字节
    - `boolean isMale`: 1 字节
    - `String name`: 4 字节
    - **实例数据总计: 4 + 1 + 4 = 9 字节**
    - _注意: JVM 为了对齐可能会对实例数据内部进行重排序，比如把 `isMale` 和其他字段凑在一起，但这里我们先简单相加。_

3.  **计算总大小并填充**:
    - 当前总大小 = 头部 (12 字节) + 实例数据 (9 字节) = **21 字节**
    - 21 字节不是 8 的整数倍。离它最近的 8 的倍数是 **24**。
    - 因此，需要填充的字节数 = 24 - 21 = **3 字节**。

**最终，这个`Person`对象在堆上会占用 24 个字节的内存空间。**

这就是 Java 中对象内存布局的详细情况，它是一个综合了性能、空间和 JVM 内部管理需求的设计。

## Java 中是怎么进行对象访问的？

当我们在 Java 代码中写下类似 `Person p = new Person(); p.getName();` 这样的代码时，我们实际上是在通过栈上的`p`这个**引用（reference）** 来定位并操作堆上的`Person`对象实例。

JVM 规范并没有严格规定这个“引用”到底应该如何实现，以及如何通过它来定位到具体的对象。因此，主流的虚拟机都提供了两种常见的实现方式：**使用句柄（Handle）**和**使用直接指针（Direct Pointers）**。

### 一、 使用句柄访问 (Accessing Objects by Handle)

这种方式下，JVM 的实现引入了一个中间层——**句柄池（Handle Pool）**。

#### 1. 内存布局

- **Java 堆**中会划分出一块专门的内存区域作为**句柄池**。
- 栈上的**引用变量**（reference）存储的不再是对象的直接内存地址，而是一个指向句柄池中某个**句柄**的稳定指针。
- **句柄**本身包含了两个关键信息：
  1.  一个指针，指向堆中**对象的实例数据**（Object Instance Data）。
  2.  另一个指针，指向方法区/元空间中**对象的类型数据**（Class Object）。

#### 2. 访问过程

当通过引用访问对象时（例如 `p.getName()`），过程如下：

1.  JVM 根据栈上的`reference`找到句柄池中的**句柄**。
2.  通过句柄中的**实例数据指针**，定位到堆中实际的`Person`对象。
3.  通过句柄中的**类型数据指针**，定位到方法区中的`Person.class`类型信息，以确认`getName()`这个方法是否存在、是否合法等。
4.  执行方法。

#### 3. 优缺点分析

- **优点**:

  - **引用非常稳定**：这是句柄访问最大的好处。当垃圾收集器（GC）移动对象时（例如在进行内存整理时），对象在堆中的地址会改变。但对于句柄访问方式，**只需要修改句柄中指向对象实例的那个指针即可**，而栈上的`reference`本身完全不需要改动。这使得 GC 与用户线程可以更好地并发工作。

- **缺点**:
  - **访问效率较低**：访问一个对象需要经过**两次指针解引用**（dereference）。第一次是从`reference`到句柄，第二次是从句柄到对象实例。这比直接访问多了一层间接转换，带来了额外的时间开销。

### 二、 使用直接指针访问 (Accessing Objects by Direct Pointer)

这是目前主流虚拟机（如 **HotSpot**）采用的实现方式。

#### 1. 内存布局

- 栈上的**引用变量**（reference）存储的就是对象在**堆中的直接内存地址**。
- 对象的**内存布局**中必须包含足够的信息来定位到它的类型数据。正如我们之前在“对象内存布局”问题中讨论的，对象的**对象头（Object Header）**中就包含了一个**类型指针（Klass Pointer）**，该指针直接指向方法区/元空间中的对象类型数据。

#### 2. 访问过程

当通过引用访问对象时（例如 `p.getName()`），过程如下：

1.  JVM 根据栈上的`reference`，直接定位到堆中实际的`Person`对象。
2.  通过对象头中的**类型指针**，定位到方法区中的`Person.class`类型信息，以进行方法表的查找和验证。
3.  执行方法。

#### 3. 优缺点分析

- **优点**:

  - **访问速度快**：这是直接指针最大的优势。它只需要**一次指针解引用**就可以定位到对象，比句柄方式少了一次间接访问的开销。由于对象的访问在程序中是非常高频的操作，因此这种优化带来的性能提升是非常可观的。

- **缺点**:
  - **GC 时引用更新复杂**：当垃圾收集器移动对象时，对象的内存地址发生了变化。此时，虚拟机**必须遍历所有执行栈、方法区等区域，找到所有指向该对象的引用，并逐一更新它们的值**。这个过程相对复杂，需要在 GC 期间正确地暂停和处理。

### 总结与对比：HotSpot 的选择

| 特性           | 使用句柄 (Handle)                | 使用直接指针 (Direct Pointers)  |
| :------------- | :------------------------------- | :------------------------------ |
| **访问效率**   | 低 (需要两次指针解引用)          | **高 (只需一次指针解引用)**     |
| **引用稳定性** | **高 (对象移动时只需改变句柄)**  | 低 (对象移动时需要更新所有引用) |
| **实现复杂度** | 相对简单                         | GC 部分的实现相对复杂           |
| **代表虚拟机** | （一些早期的或特定的虚拟机实现） | **HotSpot**                     |

**HotSpot 虚拟机选择的是使用直接指针的方式来访问对象。**

它的设计哲学是：**对象的访问是程序中一项极其频繁的操作，而对象的移动（垃圾回收）相对于访问来说，频率要低得多。** 因此，为了最大化程序的运行性能，牺牲一些 GC 时的复杂度来换取访问速度的提升，是一个非常明智和划算的权衡。

## Java 中对象的引用类型？

在 JDK 1.2 之前，Java 中的引用定义非常传统：如果一个`reference`类型的数据存储的数值代表的是另一块内存的起始地址，就称该`reference`数据是代表这块内存的引用。这种定义下，对象只有“被引用”和“未被引用”两种状态。

这种简单的划分在很多场景下显得过于绝对。例如，我们希望构建一个对象缓存：当内存空间足够时，我们希望缓存中的对象不被回收；而当内存空间紧张时，我们又希望能够自动回收这些缓存对象。为了让开发者能够更灵活地控制对象的生命周期，从 JDK 1.2 开始，Java 将引用分为了四个强度级别，由强到弱依次是：**强引用（Strong Reference）**、**软引用（Soft Reference）**、**弱引用（Weak Reference）**和**虚引用（Phantom Reference）**。

### 一、 强引用 (Strong Reference)

这是我们日常编程中使用得最广泛的引用类型。

- **定义**: 通过 `new` 关键字创建对象，并将其赋值给一个引用变量时，这个引用变量就是一个强引用。
  ```java
  Object strongRef = new Object();
  ```
- **垃圾回收行为**: **只要一个对象仍然被强引用关联着，垃圾回收器就永远不会回收它**。即使系统内存空间严重不足，JVM 宁愿抛出 `OutOfMemoryError` 错误，使程序异常终止，也不会回收具有强引用的对象。
- **生命周期**: 它的生命周期由程序的逻辑决定。当强引用超出其作用域（例如方法执行结束）或者被显式地设置为 `null` 时，它与对象之间的关联才会断开。
  ```java
  strongRef = null; // 断开强引用，对象此时可能被回收
  ```
- **一句话总结**: 强引用在，对象就永远在。

### 二、 软引用 (Soft Reference)

软引用用来描述一些还有用，但非必须的对象。

- **定义**: 通过 `java.lang.ref.SoftReference` 类来实现。
  ```java
  Object obj = new Object();
  SoftReference<Object> softRef = new SoftReference<>(obj);
  ```
- **垃圾回收行为**: **当系统内存充足时，软引用关联的对象不会被垃圾回收器回收。只有在系统内存即将发生溢出（OutOfMemoryError）之前，垃圾回收器才会把这些仅被软引用关联的对象列入回收范围之中进行第二次回收。** 如果这次回收还没有足够的内存，才会抛出内存溢出异常。
- **使用场景**: 非常适合用来实现**内存敏感的高速缓存**。例如，网页缓存、图片缓存等。当内存足够时，可以从缓存中快速获取对象，提升性能；当内存不足时，GC 会自动清理这些缓存，保证程序的稳定运行。
- **获取对象**: 通过 `softRef.get()` 方法可以获取到被引用的对象。如果对象已经被回收，`get()` 方法会返回 `null`。

### 三、 弱引用 (Weak Reference)

弱引用的强度比软引用更弱一些。

- **定义**: 通过 `java.lang.ref.WeakReference` 类来实现。
  ```java
  Object obj = new Object();
  WeakReference<Object> weakRef = new WeakReference<>(obj);
  ```
- **垃圾回收行为**: **只要垃圾回收器开始工作，无论当前内存是否充足，都将回收掉那些仅被弱引用关联的对象**。换句话说，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。
- **使用场景**:
  1.  **防止内存泄漏**: 在一些监听器、回调等场景中，如果一个对象被长期持有（例如在一个静态集合中），但它在业务上已经不再需要，弱引用可以确保它能被正常回收。
  2.  **`WeakHashMap`**: 这是弱引用的经典应用。`WeakHashMap` 的 `Key` 是一个弱引用。当一个 `Key` 对象不再有其他强引用指向它时，GC 会回收这个 `Key` 对象，并且`WeakHashMap`会自动移除这个 `Key` 对应的键值对，从而避免了内存泄漏。

### 四、 虚引用 (Phantom Reference)

虚引用也称为“幽灵引用”或者“幻影引用”，它是所有引用类型中最弱的一种。

- **定义**: 通过 `java.lang.ref.PhantomReference` 类来实现。它必须和**引用队列（ReferenceQueue）** 联合使用。

  ```java
  Object obj = new Object();
  ReferenceQueue<Object> refQueue = new ReferenceQueue<>();
  PhantomReference<Object> phantomRef = new PhantomReference<>(obj, refQueue);
  ```

- **垃圾回收行为**: 一个对象是否有虚引用的存在，**完全不会对其生存时间构成影响**，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的，就是能在这个对象被垃圾回收器回收时，收到一个系统通知。
- **关键特点**: 它的 `get()` 方法**永远返回 `null`**。它存在的意义不在于获取对象，而在于**跟踪对象的回收状态**。
- **使用场景**: 主要用于管理**堆外内存（Direct Memory）**，如 `NIO` 中的 `DirectByteBuffer`。当一个 `DirectByteBuffer` 对象被垃圾回收时，其对应的虚引用会被加入到关联的 `ReferenceQueue` 中。一个专门的线程会监视这个队列，一旦发现有虚引用进入，就意味着其关联的 Java 对象已被回收，此时就可以安全地调用本地方法来释放对应的堆外内存，从而避免了内存泄漏。

### 总结对比

| 引用类型   | 回收时机                      | 是否关联引用队列 | 主要用途                             |
| :--------- | :---------------------------- | :--------------- | :----------------------------------- |
| **强引用** | 从不回收（除非引用断开）      | 否               | 普通的对象引用                       |
| **软引用** | 内存不足时回收                | 可选             | 内存敏感的缓存                       |
| **弱引用** | 下一次 GC 时回收              | 可选             | 防止内存泄漏，如 `WeakHashMap`       |
| **虚引用** | (不影响回收) 回收时会收到通知 | **必须**         | 跟踪对象回收状态，管理堆外内存等资源 |

## Java 中的 STW？

**STW**，全称 **Stop-The-World**，是 Java 垃圾回收（Garbage Collection, GC）机制中一个非常关键且需要重点关注的现象。

### 一、 什么是 Stop-The-World (STW)？

Stop-The-World，从字面上理解就是“世界暂停”。在 Java 虚拟机（JVM）中，它指的是当垃圾回收器（Garbage Collector）需要执行某些特定阶段的操作时，**必须暂停所有正在执行的应用程序线程（Application Threads）**。

在 STW 期间，Java 应用程序的**一切外部响应都会停止**：

- Web 服务器无法处理新的 HTTP 请求。
- 桌面应用的 UI 会卡住，无法响应用户点击。
- 定时任务无法按时触发。
- 所有业务逻辑的执行都会被冻结。

### 二、 为什么 STW 是必要的？

STW 的存在，根本原因是为了**保证垃圾回收过程的准确性和一致性**。

垃圾回收器工作的核心是**可达性分析（Reachability Analysis）**。它需要从一组称为“GC Roots”的根节点（如虚拟机栈中的引用、静态变量等）开始，遍历整个对象引用图（Object Graph），从而确定哪些对象是“活”的（可达的），哪些是“死”的（不可达的，即垃圾）。

试想一下，如果垃圾回收器正在标记对象，而应用程序线程同时还在修改对象的引用关系（比如，一个原本要被判定为垃圾的对象，突然被一个 GC Root 重新引用了），那么 GC 得到的结果就会是错误的。这可能会导致两种严重后果：

1.  **错标 (Floating Garbage)**: 把本应是垃圾的对象标记为存活。这种情况问题不大，这些“浮动垃圾”可以在下一次 GC 时被回收。
2.  **漏标 (Object Corruption)**: 把本应是存活的对象标记为垃圾并回收掉。**这是致命的错误**，会导致程序在后续访问这个已被回收的对象时崩溃。

为了彻底避免“漏标”这种灾难性问题，GC 需要在某个时刻获得一个**一致性的快照（Consistent Snapshot）**，确保在分析期间，整个对象引用图是静止不变的。实现这个一致性快照最简单、最直接的方式，就是 Stop-The-World。

### 三、 STW 在何时发生？

STW 最主要的触发者就是**垃圾回收**。但是，并非所有 GC 的所有阶段都会导致 STW，也并非所有 GC 的 STW 时间都一样长。

1.  **Minor GC (新生代 GC)**:

    - 通常会触发 STW。
    - 但由于新生代的对象大多是“朝生夕死”的，存活对象少，所以回收速度非常快。
    - 因此，Minor GC 导致的 STW 通常非常短暂，可能只有几毫秒或几十毫秒，对应用的影响较小。

2.  **Full GC (老年代 GC / 整堆 GC)**:

    - **这是导致长时间 STW 的罪魁祸首**。
    - Full GC 需要扫描和处理整个 Java 堆（包括新生代和老年代），甚至方法区。
    - 老年代中对象数量多、生命周期长、引用关系复杂，导致分析和清理过程非常耗时。
    - 一次 Full GC 的 STW 时间可能长达数百毫秒甚至数秒，这对于延迟敏感的应用（如在线交易、实时通信）是不可接受的。

3.  **其他触发点**:
    - 除了 GC，某些 JVM 的其他操作也可能触发短暂的 STW，例如执行线程转储（Thread Dump）、类加载或卸载等。

### 四、 如何减少 STW 的影响？—— GC 的演进

JVM 的设计者们深知 STW 的危害，因此垃圾回收器的发展史，在很大程度上就是一部与 STW 作斗争的历史。目标是不断**缩短 STW 的时间**，甚至**消除 STW**。

1.  **串行收集器 (Serial GC)**: 单线程工作，GC 期间全程 STW，适用于单核 CPU 和小型应用。

2.  **并行收集器 (Parallel GC)**:

    - 也叫“吞吐量优先”收集器。
    - GC 时使用多线程并行工作，**大大缩短了 STW 的时间**。
    - 但它仍然是“独占式”的，GC 期间依然需要暂停所有用户线程。

3.  **并发标记清除收集器 (CMS - Concurrent Mark Sweep)**:

    - 这是第一款真正意义上的**并发**收集器，以获取**最短回收停顿时间**为目标。
    - 它将 GC 过程分为几个阶段，其中最耗时的“并发标记”和“并发清除”阶段，**可以让 GC 线程与应用程序线程并发执行**。
    - 它仍然有两个短暂的 STW 阶段：“初始标记”和“重新标记”。
    - CMS 显著降低了 STW 时间，但有内存碎片的缺点。

4.  **G1 收集器 (Garbage-First)**:

    - G1 是当今服务端应用的主流选择，它致力于实现**可预测的停顿时间模型**。
    - 它将堆划分为多个独立的区域（Region），并跟踪每个 Region 的回收价值。
    - G1 会优先回收价值最大的 Region（即垃圾最多的区域），从而避免了对整个堆进行扫描。
    - 通过参数 `-XX:MaxGCPauseMillis`，用户可以设定一个期望的最大 STW 时间，G1 会尽力去满足这个目标。

5.  **ZGC 和 Shenandoah**:
    - 这是目前最前沿的**低延迟/无停顿**收集器。
    - 它们的目标是将 STW 时间控制在**亚毫秒级别（1ms 以下）**，几乎可以认为是“无停顿”的。
    - 它们通过更复杂的技术（如着色指针、读屏障等），实现了在 GC 的几乎所有阶段都与应用程序线程并发执行，包括对象的移动和整理。

### 总结

- **STW 是 JVM 为保证 GC 数据一致性而采取的必要措施，即暂停所有应用线程。**
- **长时间的 STW 是 Java 应用性能的“天敌”，尤其是在 Full GC 时。**
- **JVM 垃圾回收器的发展方向，就是不断通过并发技术来缩短甚至消除 STW。**
- 作为开发者，我们可以通过**合理配置堆大小**、**选择合适的垃圾回收器**（如 G1、ZGC）、**优化代码以减少垃圾产生**等方式，来有效避免频繁或长时间的 STW，从而提升应用的响应能力和用户体验。

## Java 中的内存溢出和内存泄漏？

### 一、 内存泄漏 (Memory Leak)

#### 1. 什么是内存泄漏？

**内存泄漏指的是，程序中某些已经不再被使用的对象，由于仍然被一系列强引用链关联着，导致垃圾回收器（GC）无法识别并回收它们，从而永久地滞留在内存中，占用了宝贵的内存空间。**

通俗地讲，就是“该死”的对象“死不掉”。

#### 2. 内存泄漏的本质

内存泄漏的本质是**长生命周期的对象持有了短生命周期对象的引用**。

想象一下，一个静态的集合（它的生命周期和整个应用程序一样长）持有一个在某个方法中创建的临时对象的引用。当这个方法执行完毕后，这个临时对象在业务逻辑上已经不再需要了，但由于静态集合仍然引用着它，GC 就无法回收它，这就造成了内存泄漏。

随着时间的推移，泄漏的对象越积越多，最终会耗尽所有可用内存。

#### 3. 常见的内存泄漏场景

1.  **静态集合类引起的内存泄漏**:
    这是最典型的场景。如果一个静态的`Map`、`List`等集合持续地向其中添加元素，但没有相应的移除机制，那么这些元素及其所引用的对象都将无法被回收。

    ```java
    public class StaticLeak {
        // 静态List的生命周期与JVM相同
        private static List<Object> list = new ArrayList<>();

        public void add(Object o) {
            list.add(o);
        }
    }
    // 如果只调用add而不清理list，list中的对象会越来越多，造成泄漏。
    ```

2.  **资源连接未关闭**:
    比如数据库连接（`Connection`）、网络连接（`Socket`）、文件 IO 流等资源。这些资源底层往往关联着物理连接或操作系统句柄。如果在`try`块中打开了这些资源，但在`finally`块中没有确保其`close()`方法被调用，那么这些资源将无法被释放，导致泄漏（这通常是系统资源和内存的双重泄漏）。

    - **最佳实践**: 使用 Java 7 引入的 `try-with-resources` 语句可以完美解决这个问题。

3.  **监听器未移除**:
    在 GUI 编程或事件驱动模型中，我们经常会注册监听器（Listener）。如果一个对象注册了监听器，但在其生命周期结束时没有显式地将监听器移除，那么发布者（Publisher）就会一直持有对这个监听器对象的引用。如果监听器对象又持有着其他重量级对象的引用，就会导致内存泄漏。

4.  **ThreadLocal 使用不当**:
    `ThreadLocal`本身的设计（Key 是弱引用）能一定程度上避免内存泄漏。但是，如果线程池中的线程被复用，而我们又没有在使用完`ThreadLocal`后调用其`remove()`方法，那么与这个线程关联的`ThreadLocalMap`中存储的`Value`（这是一个强引用）就会一直存在，导致内存泄漏。

### 二、 内存溢出 (OutOfMemoryError)

#### 1. 什么是内存溢出？

**内存溢出指的是，程序在向 JVM 申请内存时，JVM 无法提供足够的内存空间来满足请求，从而抛出的一个严重错误（Error），而不是异常（Exception）。**

通俗地讲，就是“想装的东西太多，桶装不下了”。

#### 2. 内存溢出的原因

- **内存泄漏的最终结果**: 这是最常见的原因。持续的内存泄漏会不断消耗内存，最终导致无内存可用。
- **创建了巨型对象**: 程序试图创建一个巨大的对象或数组（比如 `new byte[1024 * 1024 * 500]`），其大小超过了堆的最大可用空间。
- **JVM 配置不当**: 分配给 JVM 的内存（特别是堆内存，通过`-Xmx`设置）过小，无法满足应用程序正常运行的需求。

#### 3. 常见的`OutOfMemoryError`类型

`OutOfMemoryError`并不是一个单一的错误，它通常会附带一些信息，说明是哪一块内存区域发生了溢出：

1.  **`java.lang.OutOfMemoryError: Java heap space`**:

    - **最常见的内存溢出**。
    - **原因**: 堆内存耗尽。要么是内存泄漏导致对象无法回收，要么是确实需要这么大的堆内存而配置又不足。

2.  **`java.lang.OutOfMemoryError: GC overhead limit exceeded`**:

    - **原因**: 这是一种特殊的堆溢出。当 JVM 花费了超过 98%的时间在执行垃圾回收，但回收到的内存却少于 2%时，就会抛出这个错误。这实际上是 JVM 的一种保护机制，防止应用程序因为 GC 而长时间无响应。本质上还是因为堆中几乎全是存活对象，GC 无法回收空间。

3.  **`java.lang.OutOfMemoryError: Metaspace`**:

    - **原因**: 元空间（Metaspace，JDK 8 之前是永久代 PermGen）溢出。元空间主要存储类的元数据信息。如果程序在运行时动态加载了大量的类（比如通过 CGLIB 等字节码技术），或者加载的类过多，而元空间大小又有限，就会导致此溢出。

4.  **`java.lang.StackOverflowError`**:
    - 虽然名字不叫 OOM，但它本质上也是一种内存耗尽的错误。
    - **原因**: 虚拟机栈（VM Stack）溢出。每个线程都有一个独立的虚拟机栈。如果一个线程的计算过程中，方法调用链过深（最常见的是没有终止条件的递归调用），导致栈帧（Stack Frame）数量超出了栈的深度限制，就会抛出此错误。

### 三、 两者的关系与区别

**核心区别**:

- **性质不同**:
  - **内存泄漏**是一种**原因**，是代码中存在的逻辑缺陷，是一个**过程**。
  - **内存溢出**是一个**结果**，是系统资源耗尽时的一个**事件点**。
- **关系**: **内存泄漏是导致内存溢出的主要原因之一，但内存溢出不一定都是由内存泄漏引起的。**

作为一名合格的 Java 开发者，我们需要通过编写健壮的代码来**预防内存泄漏**，并通过 JVM 监控和性能分析工具（如 JVisualVM, MAT, JProfiler）来**诊断和定位**已经发生的内存泄漏问题，从而从根本上避免内存溢出的发生。

## Java 的垃圾回收机制？

### 一、 GC 要回收谁？—— 判断对象存活的算法

为了进行垃圾回收，GC 首先必须准确地判断出哪些对象是“垃圾”（即不再被任何存活的对象所引用的对象）。主要有两种算法来实现这个判断：

#### 1. 引用计数算法 (Reference Counting)

- **原理**: 为每个对象添加一个引用计数器。每当有一个地方引用它时，计数器就加 1；当引用失效时，计数器就减 1。任何时刻当计数器为 0 的对象，就是不可能再被使用的，即为垃圾。
- **优点**: 实现简单，判定效率高。
- **缺点**: **它无法解决对象之间循环引用的问题**。例如，对象 A 引用了对象 B，同时对象 B 也引用了对象 A，但再无其他任何引用指向 A 或 B。此时，A 和 B 的引用计数都不为 0，导致它们永远无法被回收，从而造成内存泄漏。
- **结论**: **主流的 Java 虚拟机（如 HotSpot）并没有采用引用计数算法来管理内存。**

#### 2. 可达性分析算法 (Reachability Analysis)

这是 Java 虚拟机真正采用的算法。

- **原理**: 此算法的核心思想是，通过一系列称为 **“GC Roots”** 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索所走过的路径称为“引用链”（Reference Chain）。**如果一个对象到任何 GC Roots 之间都没有引用链相连，则证明此对象是不可达的，即为垃圾。**
- **什么是 GC Roots？** 在 Java 体系中，固定可作为 GC Roots 的对象包括以下几种：
  1.  **在虚拟机栈（栈帧中的本地变量表）中引用的对象**：比如方法内部的局部变量。
  2.  **在本地方法栈中 JNI（即通常所说的 Native 方法）引用的对象**。
  3.  **在方法区中类静态属性引用的对象**：比如`public static final`定义的常量。
  4.  **在方法区中常量引用的对象**：比如字符串常量池（String Table）里的引用。
  5.  **所有被同步锁（`synchronized`关键字）持有的对象**。
  6.  **Java 虚拟机内部的引用**，如基本数据类型对应的 Class 对象，一些常驻的异常对象等。
  7.  **反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等**。

### 二、 GC 怎么回收？—— 核心垃圾回收算法

在确定了哪些是垃圾之后，GC 就需要执行回收动作。主流的回收算法有以下几种：

#### 1. 标记-清除算法 (Mark-Sweep)

这是最基础的收集算法。

- **过程**:
  1.  **标记 (Mark)**: 首先通过可达性分析，标记出所有需要回收的对象。
  2.  **清除 (Sweep)**: 在标记完成后，统一回收所有被标记的对象所占用的空间。
- **缺点**:
  1.  **执行效率不稳定**: 如果堆中包含大量对象，且其中大部分是需要回收的，这时必须进行大量标记和清除的动作，导致效率随对象数量增长而降低。
  2.  **内存碎片化**: 清除之后会产生大量不连续的内存碎片。碎片过多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

#### 2. 标记-复制算法 (Mark-Copy)

为了解决标记-清除算法的内存碎片问题，复制算法应运而生。

- **过程**: 它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的那块内存空间一次性清理掉。
- **优点**:
  1.  **无内存碎片**: 每次都是对整个半区进行内存回收，实现简单，运行高效。
  2.  **分配时无需考虑碎片等复杂情况**，只需移动堆顶指针，按顺序分配即可。
- **缺点**:
  1.  **空间浪费**: 将可用的内存缩小为了原来的一半，代价高昂。
  2.  **对象存活率高时效率低**: 如果大部分对象都是存活的，那么复制的开销就会很大。

#### 3. 标记-整理算法 (Mark-Compact)

复制算法在对象存活率较高时并不适用，而标记-清除算法又会产生碎片，于是标记-整理算法被提了出来。

- **过程**:
  1.  **标记 (Mark)**: 其标记过程与“标记-清除”算法一样。
  2.  **整理 (Compact)**: 但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。
- **优点**:
  1.  **无内存碎片**。
  2.  **没有空间浪费**。
- **缺点**: 移动对象的过程比较耗时，效率相对较低。

### 三、 GC 在何时回收？—— 分代收集理论

现代的商用虚拟机（如 HotSpot）的垃圾收集器，大多都遵循了“**分代收集 (Generational Collection)**”的理论。这个理论建立在两个分代假说之上：

1.  **弱分代假说**: 绝大多数对象都是朝生夕死的。
2.  **强分代假说**: 熬过越多次垃圾收集过程的对象就越难以消亡。

基于此，Java 堆被划分为不同的区域：

- **新生代 (Young Generation)**:

  - **特点**: 存放生命周期短的对象。每次垃圾收集时都有大批对象死去，只有少量存活。
  - **回收算法**: 因此选用**标记-复制算法**。只需付出少量存活对象的复制成本就可以完成收集。
  - **内部结构**: 新生代内部又分为一个**伊甸园区 (Eden)** 和两个**幸存者区 (Survivor)**（From 和 To）。绝大部分新创建的对象都分配在 Eden 区。当 Eden 区满时，触发**Minor GC**，将存活的对象复制到一个 Survivor 区，并清空 Eden 区。

- **老年代 (Old Generation)**:
  - **特点**: 存放生命周期长的对象。对象存活率高，没有额外空间对它进行分配担保。
  - **回收算法**: 因此必须使用**标记-清除**或者**标记-整理**算法来进行回收。
  - **触发时机**: 当老年代空间不足时，会触发**Major GC**或**Full GC**。

### 四、 具体的 GC 实现 —— 垃圾回收器

算法是方法论，垃圾回收器就是具体的落地实现。它们是 JVM 内置的、用于执行 GC 的模块。

1.  **Serial 收集器**: 单线程、”Stop-The-World“。最古老，简单高效（对于单核 CPU），是 Client 模式下的默认新生代收集器。
2.  **Parallel Scavenge 收集器**: Serial 的多线程版本，关注**吞吐量**（CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值）。是 Server 模式下的默认新生代收集器。
3.  **CMS (Concurrent Mark Sweep) 收集器**: 第一款真正意义上的**并发**收集器，以获取**最短回收停顿时间**为目标。它在“并发标记”和“并发清除”阶段可以让 GC 线程与用户线程并发执行，显著降低了 STW。但有内存碎片的缺点。
4.  **G1 (Garbage-First) 收集器**: JDK 9 以后的默认收集器。它将堆划分为多个独立的 Region，开创了**可预测的停顿时间模型**。它在整体上是基于“标记-整理”算法，局部（两个 Region 之间）是基于“标记-复制”算法，所以不会产生碎片。
5.  **ZGC / Shenandoah**: JDK 11/12 中引入的最新款、超低延迟的垃圾收集器。它们的目标是将 STW 时间控制在 10ms 甚至 1ms 以内，几乎实现了 GC 与用户线程的完全并发。

总而言之，Java 的垃圾回收机制是一个自动化的、基于可达性分析的、采用分代收集模型的、由具体回收器实现的复杂系统，其最终目标是在吞吐量和延迟之间取得最佳平衡，保障 Java 程序的稳定高效运行。

## CMS 垃圾回收器的回收过程？

CMS（Concurrent Mark Sweep）垃圾回收器是 JVM 中第一款真正意义上的**并发**收集器，它的诞生标志着 GC 技术进入了一个新的时代。它的核心设计目标是**获取最短的回收停顿时间（STW）**，这对于那些对响应时间有高要求的互联网应用或 B/S 系统来说至关重要。

CMS 是一款专门用于**老年代**的垃圾回收器。

### 一、 CMS 的核心思想：并发

在 CMS 出现之前，像 Parallel Scavenge 这样的回收器，在执行 GC 时（无论是 Minor GC 还是 Full GC），都必须完全暂停用户线程（STW）。如果老年代很大，一次 Full GC 的 STW 时间可能会达到秒级，这是无法接受的。

CMS 的核心思想是将最耗时的两个步骤——**标记（Mark）**和**清除（Sweep）**——设计为可以与用户线程**并发执行**，从而将原本一整段很长的 STW 时间，分解成几个非常短暂的 STW 停顿加上一段并发执行的时间。

### 二、 CMS 的四个主要回收步骤

CMS 的整个垃圾回收周期可以分为四个主要阶段，其中包含两个短暂的 STW 和两个主要的并发阶段。

#### 第 1 步：初始标记 (Initial Mark)

- **任务**: 这个阶段的任务非常简单，就是标记出从 **GC Roots** 能**直接关联**到的对象。可以把它想象成可达性分析的第一层。
- **性质**: **这是一个 Stop-The-World (STW)阶段。**
- **耗时**: **非常快**。因为 GC Roots 的数量是有限的，而且只遍历直接关联的对象，所以这个阶段的暂停时间极短，通常在毫秒级别。

#### 第 2 步：并发标记 (Concurrent Mark)

- **任务**: 这是 CMS 最核心、最耗时的阶段。GC 线程从“初始标记”阶段找到的那些对象开始，**递归地遍历整个老年代的对象引用图**，找出所有存活的对象。
- **性质**: **这是一个并发阶段**。GC 线程在进行标记工作的同时，**应用程序的线程也在继续运行**。
- **挑战**: 这个阶段最大的挑战在于，当 GC 线程在标记时，用户线程可能正在改变对象的引用关系。比如，一个原本未被标记的对象，可能被用户线程赋予了一个新的引用，导致它不应该被回收。或者一个已经被标记的对象，它的引用被用户线程切断了。这个问题的专业术语叫“多标”或“漏标”。CMS 通过 **写屏障（Write Barrier）** 和 **增量更新（Incremental Update）** 的机制来解决这个问题，记录下在并发标记期间发生变动的引用关系。

#### 第 3. 重新标记 (Final Mark / Remark)

- **任务**: 这个阶段的任务是为了**修正**在“并发标记”期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。它需要重新扫描在并发标记阶段被弄“脏”（Dirty）的内存区域（通过“Card Table”等数据结构记录）。
- **性质**: **这也是一个 Stop-The-World (STW)阶段。**
- **耗时**: 这个阶段的停顿时间通常会比“初始标记”阶段**稍长一些**，但远比整个老年代的完整标记要短得多。为了缩短这个阶段的时间，这个过程通常是**并行执行**的。

#### 第 4 步：并发清除 (Concurrent Sweep)

- **任务**: 在完成了所有标记工作后，GC 线程开始**清除**那些未被标记的、确定为垃圾的对象，回收它们所占用的内存空间。
- **性质**: **这也是一个并发阶段**。GC 线程在清除垃圾的同时，应用程序线程仍然可以继续运行，并创建新的对象。
- **挑战**: 由于是在并发地清除，用户线程此时可能会产生新的垃圾，这些新产生的垃圾在本轮 GC 中是无法被清理的，它们被称为“**浮动垃圾 (Floating Garbage)**”。这些浮动垃圾只能等到下一次 GC 时再被清理。

### 三、 CMS 的“三宗罪”—— 主要缺点

尽管 CMS 在降低停顿时间上取得了巨大成功，但它的设计也带来了几个不可避免的硬伤：

1.  **对 CPU 资源非常敏感**:
    虽然是并发执行，但 GC 线程终究还是要占用 CPU 资源的。在 GC 线程工作时，会“抢占”一部分 CPU，导致应用程序的整体吞吐量下降。在 CPU 核心数较少的情况下，这种影响会更加明显。

2.  **无法处理“浮动垃圾” (Floating Garbage)**:
    如上所述，在并发清除阶段新产生的垃圾，本次 GC 无法处理，必须等到下一次 GC。这就要求 CMS 不能等到老年代几乎被填满了再进行收集，必须预留一部分空间来容纳在并发收集期间用户程序新创建的对象。因此，CMS 需要通过 `-XX:CMSInitiatingOccupancyFraction` 参数来设置一个触发 GC 的阈值（例如当老年代使用率达到 70%时就开始 GC），这导致了空间的浪费。

3.  **产生大量的内存碎片 (Memory Fragmentation)**:
    **这是 CMS 最致命的缺点**。CMS 是基于“**标记-清除 (Mark-Sweep)**”算法实现的。这意味着它在回收完垃圾后，并不会对内存空间进行压缩整理。长时间运行后，老年代会产生大量不连续的内存碎片。当后续需要分配一个大对象时，尽管老年代总的剩余空间还很充足，但可能找不到一块足够大的连续空间来存放，从而不得不提前触发一次**Full GC**。

### 四、 "Concurrent Mode Failure" 与后备方案

当 CMS 预留的内存空间不足以容纳程序新创建的对象时，就会出现“**并发模式失败 (Concurrent Mode Failure)**”。

一旦发生这种情况，JVM 会启动一个**后备预案 (Fallback)**：**临时停止所有用户线程（STW），并启用 Serial Old 收集器（一个单线程、标记-整理算法的收集器）来重新对整个老年代进行一次 Full GC**。

这个后备的 Full GC 是非常恐怖的，它的 STW 时间会非常长，完全违背了使用 CMS 的初衷。因此，避免"Concurrent Mode Failure"是 CMS 调优的核心目标之一。

### 总结

总而言之，CMS 通过将耗时的标记和清除操作并发化，用两次短暂的 STW 换来了整体的低延迟，是 GC 技术发展的一个重要里程碑。但它对 CPU 敏感、会产生浮动垃圾，尤其是其**内存碎片**问题，最终使其在 JDK 9 中被标记为废弃，并被设计更先进、无内存碎片的**G1 收集器**所取代。

## G1 垃圾回收器的回收过程？

G1（Garbage-First）垃圾回收器是当今服务端 Java 应用的主流选择，也是 JDK 9 及以后版本的默认垃圾回收器。它的设计目标是取代 CMS，致力于在提供高吞吐量的同时，满足**可预测的、短暂的停顿时间**。

要理解 G1 的回收过程，首先必须理解它与之前所有回收器都截然不同的内存布局和核心理念。

### 一、 G1 的核心理念与内存布局

#### 1. 化整为零：Region（区域）

G1 不再将 Java 堆划分为连续的新生代和老年代。取而代之的是，它将整个堆划分为**约 2048 个大小相等、不连续的独立区域（Region）**。每个 Region 的大小可以在 1MB 到 32MB 之间，由 JVM 在启动时根据堆大小自动设定。

每个 Region 在运行时都可以扮演不同的角色：

- **Eden**: 新生代的 Eden 区。
- **Survivor**: 新生代的 Survivor 区。
- **Old**: 老年代区。
- **Humongous**: 巨型对象区。专门用于存放大小超过 Region 容量一半的对象。一个 Humongous 对象可能会跨越多个连续的 Region。

这种设计使得 G1 的回收不再是针对整个新生代或整个老年代，而是**以 Region 为最小单位进行回收**，极大地增强了灵活性。

#### 2. “Garbage-First”：优先回收价值最高的区域

G1 的名字“Garbage-First”就揭示了它的核心策略。G1 会**跟踪每个 Region 中的垃圾堆积情况（即回收该 Region 能释放多少空间）**，并维护一个**优先列表**。

在进行垃圾回收时，G1 会根据用户设定的**期望最大停顿时间**（通过 `-XX:MaxGCPauseMillis` 参数设置，默认为 200ms），优先选择那些**回收价值最高**（即垃圾最多、回收耗时最短）的 Region 进行回收。这就是“Garbage-First”的由来。

#### 3. 解决跨代引用：Remembered Set (RSet)

当只回收部分 Region（比如只回收新生代 Region）时，一个关键问题是如何处理从其他 Region（比如老年代 Region）指向这些 Region 的引用。如果为此扫描整个堆，那和 Full GC 无异。

G1 的解决方案是为**每个 Region**都维护一个**记忆集（Remembered Set, RSet）**。RSet 记录了 **“谁引用了我”**，即其他 Region 中的哪些 Card（内存页）包含了指向当前 Region 的引用。

当 GC 需要回收一个 Region 时，它只需要扫描该 Region 的 RSet，就能快速找到所有跨区域的引用，而无需扫描整个堆。RSet 的维护是通过**写屏障（Write Barrier）**技术在程序运行时自动完成的。

### 二、 G1 的回收过程

G1 的回收过程可以分为两大类：**年轻代 GC（Young GC）** 和 **混合 GC（Mixed GC）**。G1 基本上没有传统意义上的 Full GC，除非并发模式失败，才会触发一次后备的、STW 的 Full GC。

#### 阶段一：年轻代 GC (Young GC)

- **触发时机**: 当 Eden 区的 Region 被占满，无法为新对象分配空间时。
- **过程**:
  1.  **Stop-The-World (STW)**: G1 的 Young GC 也是一个完全的 STW 事件。
  2.  **确定 CSet**: G1 确定本次要回收的**回收集合（Collection Set, CSet）**。在 Young GC 中，CSet 就是所有的新生代 Region（Eden + Survivor）。
  3.  **扫描 GC Roots**: 从 GC Roots 开始，找出直接引用的对象。
  4.  **处理 RSet**: 扫描 CSet 中每个 Region 的 RSet，找出从老年代指向新生代的引用。
  5.  **复制存活对象**: 将 CSet 中存活的对象通过**复制算法**，复制到新的 Survivor Region 中。如果对象的年龄达到阈值，或者新的 Survivor 区放不下，就将其晋升到 Old Region。
  6.  **清空 CSet**: 回收 CSet 中所有 Region 的内存空间。
- **特点**: 这是一个**并行**的、**STW**的、采用**复制算法**的回收过程。它与传统的 Minor GC 非常相似，但规模是基于 Region 的。

#### 阶段二：混合 GC (Mixed GC)

当整个堆的内存占用率达到某个阈值时（由 `-XX:InitiatingHeapOccupancyPercent` 参数控制，默认 45%），G1 就不能只进行 Young GC 了，它必须开始着手回收老年代的内存。这个过程就是混合 GC，它由一系列复杂的子阶段组成。

##### 1. 并发标记周期 (Concurrent Marking Cycle)

这个周期的目标是**为老年代的所有 Region 建立一个完整的存活对象快照**，以便后续的 Mixed GC 可以准确地知道哪些 Old Region 里有最多的垃圾。这个周期与应用程序**并发执行**。

1.  **初始标记 (Initial Mark)**:

    - **STW 阶段**。
    - 这个阶段通常 **“借用”一次 Young GC 的 STW** 来完成。它仅仅标记出从 GC Roots 能直接到达的对象。
    - 由于是 piggyback 在 Young GC 上，所以几乎没有额外的停顿。

2.  **根区域扫描 (Root Region Scanning)**:

    - **并发阶段**。
    - 扫描在初始标记中标记出的 Survivor Region，找出由它们引用的老年代对象。这个阶段必须在下一次 Young GC 发生前完成。

3.  **并发标记 (Concurrent Marking)**:

    - **并发阶段**，这是最耗时的阶段。
    - GC 线程从 GC Roots 和根区域扫描的结果出发，遍历整个堆中的对象图，查找所有存活的对象。
    - 这个过程使用了一种叫做**原始快照（Snapshot-At-The-Beginning, SATB）** 的技术来保证并发标记的正确性。

4.  **重新标记 (Remark)**:

    - **STW 阶段**。
    - 这是最后一个 STW 阶段，用于**修正**在并发标记期间因用户程序继续运行而导致标记产生变动的那一部分记录。G1 会处理 SATB 的日志，并进行最终的存活对象标记。这个阶段的 STW 通常比 CMS 的重新标记要短。

5.  **清理 (Cleanup)**:
    - **部分 STW，部分并发**。
    - **STW 部分**: 对各个 Region 的存活对象进行最终计数，并对所有 Region 进行回收价值的排序。还会识别出所有 Region 中一个存活对象都没有的**完全空闲 Region**，并立即回收它们。
    - **并发部分**: 重置 RSet 等数据结构。

##### 2. 混合回收阶段 (Mixed GC Evacuation)

当并发标记周期成功结束后，G1 就已经知道了哪些 Old Region 的回收价值最高。接下来，G1 会进入混合回收阶段。

- **过程**: G1 会执行**多次**（而不是一次）**混合 GC**。
- **CSet 的构成**: 每次 Mixed GC 的 CSet 不仅包含**所有的新生代 Region**，还会根据预设的停顿时间目标，额外选择**一部分回收价值最高的老年代 Region**。
- **回收方式**: 每次 Mixed GC 都是一次**STW 的、并行的、基于复制算法**的回收过程，将 CSet 中的存活对象复制到新的 Region 中。
- **结束**: G1 会持续执行 Mixed GC，直到老年代中那些高价值的、“垃圾多”的 Region 被清理干净为止。然后，GC 过程会重新回到只有 Young GC 的阶段，等待下一次堆内存占用率达到阈值。

### 三、 G1 的优势总结

1.  **可预测的停顿**: G1 最核心的优势，允许用户设定期望的最大停顿时间。
2.  **无内存碎片**: 整体上是基于“标记-整理”思想，局部（Region 之间）是基于“标记-复制”算法，从根本上避免了内存碎片的产生。
3.  **空间整合**: 将堆划分为 Region，使得新生代和老年代的大小可以动态调整，内存使用更灵活。
4.  **兼顾吞吐量与低延迟**: 在满足停顿时间目标的同时，也具备了不错的吞吐量。

总而言之，G1 通过引入 Region、RSet、CSet 等概念，将一个庞大的、不可控的整堆回收问题，巧妙地转化为了一个可预测的、选择性的、分批次的 Region 回收问题，从而在低延迟和高吞吐量之间取得了出色的平衡。

## 现代 HotSpot 虚拟机一次完整的垃圾回收过程？

我将以**现代 HotSpot 虚拟机默认的 G1（Garbage-First）垃圾回收器**为蓝本，详细描绘一次**完整的、典型的垃圾回收生命周期**。这个过程不是一个单一的事件，而是一个由多个阶段组成的、持续进行的循环。

### 序幕：对象的诞生与舞台布局

首先，我们的舞台是**G1 管理的 Java 堆**，它被划分为成百上千个**Region**。这些 Region 在任何时候都可能扮演 Eden、Survivor 或 Old 的角色。一个新对象的生命旅程通常从这里开始：

- **对象诞生**: 当代码执行 `new Object()` 时，这个对象优先被分配在**Eden Region**中。

### 第一幕：常规清扫 - 年轻代 GC (Young GC)

这是最频繁发生的垃圾回收事件，就像每天对垃圾箱进行的常规清扫。

- **触发时机**: 应用程序不断创建新对象，Eden Region 很快被填满。当没有足够空间分配新对象时，一次**Young GC**就被触发了。

- **回收过程 (STW)**:

  1.  **世界暂停 (Stop-The-World)**: JVM 暂停所有应用程序线程。
  2.  **确定回收范围 (CSet)**: 本次回收的集合（Collection Set）被确定为**所有的新生代 Region**（即所有的 Eden 和 Survivor Region）。
  3.  **可达性分析**: 从 GC Roots 出发，结合每个 Region 的**记忆集（Remembered Set, RSet）**，快速找出在 CSet 中所有存活的对象。RSet 在这里至关重要，它帮助 G1 在不扫描整个老年代的情况下，就知道了从老年代指向新生代的引用。
  4.  **复制与晋升**: G1 将所有存活的对象通过**复制算法**，移动到**新的、干净的 Survivor Region**中。在这个过程中：
      - 对象的**年龄（Age）** 会加 1。
      - 如果一个对象的年龄达到了**晋升阈值**（`-XX:MaxTenuringThreshold`，默认 15），它将被直接移动到一个**Old Region**中，完成“晋升”。
      - 如果 Survivor Region 空间不足，一些对象也可能被提前晋升。
  5.  **清空与恢复**: 完成复制后，原来所有的 Eden 和旧的 Survivor Region 被整体清空，变成完全空闲的 Region，可以用于未来的分配。STW 结束，应用程序线程恢复运行。

- **结果**: 绝大多数“朝生夕死”的对象在这一阶段就被高效地回收了。存活下来的对象进入了 Survivor 区，开始了它们的“升级之路”。

### 第二幕：风暴预警 - 并发标记周期的启动

随着程序的长时间运行，越来越多的对象从新生代晋升到了老年代。老年代 Region 逐渐被填满。

- **触发时机**: 当整个 Java 堆的内存占用率达到一个阈值时——由`InitiatingHeapOccupancyPercent`（IHOP，默认 45%）参数控制——G1 认为不能再仅仅依赖 Young GC 了，必须开始着手准备对老年代进行一次清理，以避免未来发生更严重的内存问题。**并发标记周期（Concurrent Marking Cycle）** 就此启动。

- **核心目标**: 在不长时间暂停应用的前提下，精确地计算出老年代中每个 Region 里到底有多少存活对象，也就是评估出每个 Old Region 的“回收价值”。

### 第三幕：深度扫描 - 并发标记周期的执行

这个周期是 G1 的精华所在，它与应用程序线程并发执行，包含以下关键步骤：

1.  **初始标记 (Initial Mark)**:

    - **一个短暂的 STW 阶段**。
    - 它通常 **piggybacks（搭载）在一次常规的 Young GC 上**，因此几乎不会增加额外的停顿。
    - 任务是标记出从 GC Roots 能**直接**到达的对象。

2.  **根区域扫描 (Root Region Scanning)**:

    - **并发阶段**。
    - 扫描由初始标记标记出的 Survivor 区，找出由它们引用的老年代对象，并标记它们。

3.  **并发标记 (Concurrent Marking)**:

    - **最长的、完全并发的阶段**。
    - GC 线程从上一步找到的对象出发，在**整个堆**中进行可达性分析，递归地查找所有存活的对象。这个过程使用了**SATB（Snapshot-At-The-Beginning）** 算法来确保即使应用线程在修改引用，最终的结果也是正确的。

4.  **重新标记 (Remark)**:

    - **又一个短暂的 STW 阶段**。
    - 这是为了修正并发标记期间，因用户线程修改引用而导致标记结果需要更新的部分。它会处理 SATB 的日志，是确保标记准确性的最后一步。

5.  **清理 (Cleanup)**:
    - **一个短暂的 STW 阶段，伴随后续并发操作**。
    - 在 STW 期间，G1 会统计每个 Region 中的存活对象数量，并根据此信息对所有 Old Region 的**回收价值进行排序**。同时，它会**立即回收那些完全没有任何存活对象的 Region**。然后，STW 结束。

- **结果**: 经过这个周期，G1 手里就有了一张详细的“藏宝图”，清楚地知道哪些 Old Region 里全是“垃圾”，回收它们事半功倍。

### 第四幕：精准打击 - 混合 GC (Mixed GC)

并发标记完成后，G1 不会立刻回收所有的老年代垃圾。它会启动一轮或多轮的**混合 GC**。

- **触发时机**: 在并发标记成功结束后，下一次的 GC 就不再是单纯的 Young GC，而是 Mixed GC。

- **回收过程 (STW)**:

  1.  **世界暂停 (STW)**。
  2.  **确定回收范围 (CSet)**: 本次回收的 CSet**既包含了所有的新生代 Region（像 Young GC 一样），也包含了根据“藏宝图”选出的若干个回收价值最高的 Old Region**。G1 会根据用户设定的期望停顿时间（`MaxGCPauseMillis`）来智能地决定这次要回收多少个 Old Region。
  3.  **回收执行**: 整个回收过程与 Young GC 完全一样，采用**复制算法**，将 CSet 中的存活对象（无论是来自新生代还是老年代）都复制到新的、干净的 Region 中。
  4.  **世界恢复**。

- **特点**:
  - “混合”意味着它同时回收新生代和部分老年代。
  - 它是**分批次、有选择地**回收老年代，而不是一次性回收全部。G1 可能会执行好几次 Mixed GC，直到大部分高价值的 Old Region 都被清理完毕。
  - 这种方式将一次可能很长的老年代回收停顿，**分解成了多次可控的、短暂的停顿**，从而实现了 G1 可预测停顿时间的核心目标。

### 最终章：紧急预案 - Full GC (后备方案)

G1 的设计目标是**极力避免 Full GC**的发生。但在极端情况下，如果系统出现问题，还是可能触发一次 Full GC。

- **触发时机**:

  - **晋升失败 (Evacuation Failure)**: 在 Young GC 或 Mixed GC 期间，需要将对象复制到新的 Region 时，发现没有足够的空闲 Region 来容纳它们。这通常是因为应用程序产生内存的速度远快于 GC 回收的速度。
  - **并发模式失败**: 在并发标记期间，应用程序创建对象的速度太快，导致堆内存被耗尽。

- **回收过程**: 一旦触发，G1 会放弃其所有并发和增量的特性，退化为一次**单线程的、长时间 STW 的、使用标记-整理算法的 Full GC**，对整个堆进行彻底的整理和回收。这是性能的“核冬天”，是我们需要在调优中极力避免的。

**总结起来，现代 HotSpot 虚拟机（以 G1 为例）的完整 GC 过程是一个优雅的、自适应的循环：**

**日常 (Young GC) → 堆占用率升高 → 启动并发标记 → 并发标记完成 → 执行若干次精准的混合 GC → 堆占用率下降 → 回到日常 (Young GC)**

而 Full GC，则是这个优雅循环被打破时的紧急制动。

## JVM 的参数配置？

JVM 参数配置是 Java 性能调优中至关重要的一环，它直接决定了 JVM 的资源使用方式、行为模式和运行效率。一个好的配置能让应用程序稳定、高效地运行，而错误的配置则可能导致性能瓶颈甚至崩溃。

### 一、 JVM 参数的分类与语法

JVM 参数种类繁多，我们可以按照其功能和稳定性将其分为三类：

1.  **标准参数 (-)**:

    - **特点**: 功能稳定，在未来的所有 JVM 版本中都保证兼容。
    - **语法**: 以单个 `-` 开头，如 `-version`, `-help`, `-server`, `-cp`。
    - **示例**: `java -server -version`

2.  **非标准参数 (-X)**:

    - **特点**: 是特定于 HotSpot 虚拟机的扩展参数，功能基本稳定，但官方不保证所有版本都兼容。
    - **语法**: 以 `-X` 开头，如 `-Xms`, `-Xmx`, `-Xss`。
    - **示例**: `java -Xmx2g -Xms2g MyApp`

3.  **高级/不稳定参数 (-XX)**:
    - **特点**: 这是最庞大、最复杂的一类参数，用于对 JVM 进行更深层次的、精细化的控制。它们可能在不同版本间发生变化，使用时需要谨慎。
    - **语法**: 以 `-XX:` 开头，又分为两种：
      - **布尔型参数 (Boolean Flags)**: `-XX:+<option>` 表示开启，`-XX:-<option>` 表示关闭。
        - **示例**: `-XX:+UseG1GC` (开启 G1 垃圾回收器)
      - **键值型参数 (Key-Value Flags)**: `-XX:<option>=<value>` 表示设值。
        - **示例**: `-XX:MaxGCPauseMillis=200` (设置 G1 的最大停顿时间目标为 200 毫秒)

### 二、 核心参数详解

下面我将分门别类地介绍在生产环境中最为常用和重要的几类参数。

#### A. 堆内存配置 (Heap Memory)

这是最基础也是最重要的配置。

- **`-Xms<size>`**: 设置 JVM**初始堆大小**。

  - 例如 `-Xms2g` 表示初始堆为 2GB。
  - **调优建议**: 在生产环境中，通常将初始堆大小与最大堆大小设置为**相同的值**，以避免程序在运行时频繁地向操作系统申请内存和进行堆的动态伸缩，这个过程会带来不必要的性能开销。

- **`-Xmx<size>`**: 设置 JVM**最大堆大小**。

  - 例如 `-Xmx2g` 表示最大堆为 2GB。
  - **调优建议**: 这是防止 `java.lang.OutOfMemoryError: Java heap space` 的生命线。大小的设定需要根据应用的内存足迹（Memory Footprint）来决定，需要进行压力测试和容量规划。

- **`-Xmn<size>`** 或 **`-XX:NewSize=<size>` / `-XX:MaxNewSize=<size>`**: 设置**新生代的大小**。

  - `-Xmn` 将初始和最大新生代大小设为同一个值。
  - **调优建议**: 新生代大小决定了 Minor GC 的频率和时长。一个较大的新生代会减少 Minor GC 的次数，但单次 GC 的停顿时间可能会变长。通常建议设置为整个堆大小的 **1/4 到 1/2** 之间。

- **`-XX:SurvivorRatio=<ratio>`**: 设置**新生代中 Eden 区与单个 Survivor 区的空间比例**。

  - 默认是 `8`，表示 `Eden : S0 : S1 = 8 : 1 : 1`。
  - **调优建议**: 如果应用的 Minor GC 后存活对象很多，导致 Survivor 区不够用而直接晋升到老年代，可以适当调小此值（如 `6` 或 `4`），以增大 Survivor 区的空间。

- **`-XX:MetaspaceSize=<size>`** 和 **`-XX:MaxMetaspaceSize=<size>`**: 设置**元空间 (Metaspace)** 的初始大小和最大大小。
  - 元空间在 JDK 8 后取代了永久代，用于存储类的元数据，它使用的是**本地内存（Native Memory）**。
  - **调优建议**: 如果应用需要加载大量的类（例如使用了 CGLIB 等动态代理技术），可能需要适当调大 `MaxMetaspaceSize` 以避免 `OutOfMemoryError: Metaspace`。

#### B. 垃圾回收器配置 (Garbage Collector)

选择合适的 GC 是性能调优的核心。

- **`-XX:+UseG1GC`**: **明确指定使用 G1 垃圾回收器**。这是 JDK 9 及以后版本的默认回收器，也是目前绝大多数服务端应用的最佳选择。

- **`-XX:MaxGCPauseMillis=<ms>`**: **设置 G1 GC 的期望最大停顿时间**（单位毫秒）。

  - 默认是 `200`。
  - **调优建议**: 这是一个**目标**而非硬性承诺。G1 会尽力调整新生代大小、GC 频率等来满足这个目标。如果设置得过小（如 `50ms`），G1 为了达成目标可能会频繁触发 GC，反而导致吞吐量下降。

- **`-XX:InitiatingHeapOccupancyPercent=<percent>`**: 设置触发 G1 并发标记周期的**堆占用率阈值**。

  - 默认是 `45` (%)。
  - **调优建议**: 如果应用的内存分配速率很快，导致频繁发生晋升失败（Evacuation Failure）进而引发 Full GC，可以适当调低此值（如 `35` 或 `40`），让 G1 更早地启动老年代的回收。

- **`-XX:+ParallelRefProcEnabled`**: 开启并行引用处理。在 GC 时可以并行处理`SoftReference`、`WeakReference`等引用，可以缩短 GC 的重新标记（Remark）阶段的停顿时间。**强烈建议开启**。

#### C. 分析与排错参数 (Analysis & Troubleshooting)

这些参数是生产环境排查问题的“救命稻草”。

- **`-XX:+HeapDumpOnOutOfMemoryError`**: **当发生 OOM 时，自动生成一个堆转储（Heap Dump）文件**。这是诊断内存泄漏问题的最关键文件。**强烈建议在所有生产环境中开启**。

- **`-XX:HeapDumpPath=<path>`**: 指定堆转储文件的生成路径。例如 `-XX:HeapDumpPath=/data/dumps/`。

- **`-Xlog:gc*:file=<path>:<options>`**: 这是 JDK 9 及以后版本统一的 GC 日志配置方式。

  - **示例**: `-Xlog:gc*:file=/data/logs/gc.log:time,level,tags:filecount=10,filesize=100m`
  - 这表示将所有级别的 GC 日志（`gc*`）输出到 `/data/logs/gc.log` 文件，日志格式包含时间、级别和标签，并配置了日志滚动（保留 10 个文件，每个最大 100MB）。
  - （对于 JDK 8 及之前版本，使用 `-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:<path>`）

- **`-XX:ErrorFile=<path>`**: 当 JVM 发生致命错误（Crash）时，错误日志（`hs_err_pid<pid>.log`）的存放路径。

### 三、 生产环境配置示例

假设我们有一个部署在 8 核 16G 服务器上的核心 Spring Boot 微服务，我们可以给出一个如下的参考配置：

```bash
# JVM启动命令
java \
  -server \
  # ----- 1. 堆内存配置 -----
  -Xmx8g \
  -Xms8g \
  # ----- 2. G1垃圾回收器配置 -----
  -XX:+UseG1GC \
  -XX:MaxGCPauseMillis=200 \
  -XX:InitiatingHeapOccupancyPercent=45 \
  -XX:+ParallelRefProcEnabled \
  # ----- 3. 分析与排错配置 -----
  -XX:+HeapDumpOnOutOfMemoryError \
  -XX:HeapDumpPath=/opt/logs/heapdump/ \
  -Xlog:gc*:file=/opt/logs/gc.log:time,level,tags:filecount=10,filesize=100m \
  -XX:ErrorFile=/opt/logs/hs_err_pid%p.log \
  # ----- 4. 其他优化 -----
  -Djava.net.preferIPv4Stack=true \
  -Dfile.encoding=UTF-8 \
  # ----- 应用启动入口 -----
  -jar my-application.jar
```

- **解释**:
  - `-server`: 明确使用 Server 模式的 JIT 编译器，进行更深度的优化。
  - `-Xmx8g -Xms8g`: 将堆内存固定为 8GB，避免伸缩开销。
  - 使用 G1 回收器，并设定了常规的性能目标。
  - 配置了完整的 OOM Dump、GC 日志和错误日志，便于问题排查。

### 四、 调优的最佳实践

1.  **先监控，再调优**: 不要凭感觉调优。首先使用 JVisualVM、JConsole、Grafana+Prometheus 或商业 APM 工具充分监控应用的 GC 次数、停顿时间、堆内存使用情况等，找到瓶颈再动手。
2.  **明确调优目标**: 你的目标是**降低延迟（停顿时间）**还是**提高吞吐量**？这两个目标在某些场景下是互斥的。例如，G1 和 ZGC 追求低延迟，而 Parallel GC 追求高吞吐量。
3.  **从基础开始**: 绝大多数性能问题首先应该从**堆内存大小（-Xmx）** 和**选择合适的垃圾回收器（-XX:+UseG1GC）** 开始。
4.  **遵循迭代原则**: 每次只修改**一个**参数，然后进行测试和观察，对比修改前后的性能数据。切忌一次性修改大量参数。
5.  **参考官方文档**: 始终以你正在使用的 JDK 版本的官方文档为准，因为参数的默认值和行为可能会有变化。

## 一个生产中 JVM 调优的例子？

### 一、 项目背景与问题现象 (The Problem)

- **项目描述**: 我当时负责的是一个大型电商平台的**订单和促销微服务**。这是一个典型的**高并发、低延迟**的 Spring Boot 应用，每天处理数百万的订单创建和价格计算请求。
- **技术栈**: JDK 8, Spring Boot, G1 垃圾回收器（默认配置）。
- **问题现象**: 在一次“双十一”大促前的全链路压力测试中，我们发现当并发用户数达到一个高峰值时，该服务的**TP99 响应时间**（Top Percentile 99%，即 99%的请求响应时间）会出现**周期性的、剧烈的抖动**。平峰期 TP99 在 50ms 左右，但在压测高峰期会突然飙升到**800ms 甚至 1 秒以上**，然后又恢复正常，几分钟后再次出现。
- **业务影响**: 这种延迟抖动对于核心交易链路是致命的。在促销活动中，它会导致用户下单失败、页面加载超时，直接影响用户体验和交易成功率。监控系统（Grafana + Prometheus）也发出了大量的延迟告警。

### 二、 分析与排查过程 (The Investigation)

我们的首要怀疑对象就是**JVM 的垃圾回收（GC）**，因为这种周期性的、服务完全停顿的现象，与 GC 的**Stop-The-World (STW)** 特征高度吻合。

#### 步骤 1：收集诊断数据

我们在压测环境中，为该服务实例添加了详细的 JVM 参数来收集诊断信息：

```bash
# ...其他参数...
# 开启详细GC日志，并配置滚动输出
-Xlog:gc*:file=/opt/logs/gc-%t.log:time,level,tags:filecount=10,filesize=100m \
# OOM时自动dump堆内存
-XX:+HeapDumpOnOutOfMemoryError \
-XX:HeapDumpPath=/opt/logs/heapdump/
```

然后，我们复现了这次压测，并成功收集到了问题发生时的 GC 日志和应用监控数据。

#### 步骤 2：分析 GC 日志

我们使用 GC 分析工具（如 GCeasy.io）对 GC 日志进行了可视化分析，并结合`grep`和`awk`命令进行手动探查。很快发现了“罪魁祸首”：

1.  **发现了长时间的 STW 停顿**:
    日志中频繁出现`Pause Young`（年轻代 GC）和`Pause Mixed`（混合 GC），它们的停顿时间大多在`50ms - 150ms`之间，这在我们的可接受范围内。
    但是，每隔几分钟，就会出现一次这样的日志：

    ```
    [2024-10-26T10:30:15.123+0800][12345.678s] [info][gc] Pause Full (G1 Evacuation Failure) 8192M->6144M(8192M) 950.4ms
    ```

    这个 **`Pause Full (G1 Evacuation Failure)`** 就是元凶！它的 STW 时间达到了**950.4 毫秒**，几乎就是 1 秒，这与我们在监控上看到的延迟尖刺完全吻合。

2.  **定位问题根源 - “Evacuation Failure”**:
    “Evacuation Failure”翻译过来是“晋升失败”。在 G1 中，这意味着在进行 Young GC 或 Mixed GC 时，需要将存活对象复制到新的 Survivor 区或老年代区，但**目标区域没有足够的连续空间来容纳这些对象**。
    当这种情况发生时，G1 会放弃原有的、并行的复制计划，**退化（Fallback）** 为一次**单线程的、STW 的、使用标记-整理算法的 Full GC**。这种 Full GC 会整理整个堆，非常耗时，是 G1 调优中必须极力避免的情况。

#### 步骤 3：关联应用行为与 GC 日志

为什么会发生晋升失败？我们进一步分析了压测期间的堆内存使用情况：

- **内存分配速率极高**: 促销引擎在计算价格时，会创建大量复杂的临时对象（如促销规则、优惠券、价格快照等）。在压测高峰期，内存的分配速率（Allocation Rate）非常惊人。
- **并发标记跟不上对象晋升速度**: G1 依赖其**并发标记周期（Concurrent Marking Cycle）**来确定老年代中有哪些垃圾 Region，以便在 Mixed GC 中回收它们。但由于我们的内存分配速率太快，导致老年代被新晋升的对象迅速填满。G1 的并发标记周期**还没来得及完成**，或者说**启动得太晚了**，老年代就已经没有足够空间来接纳新一轮晋升的对象了。

**最终结论**: **内存分配速率过高，导致老年代被迅速填满，而 G1 的并发标记周期启动得太晚，未能及时触发 Mixed GC 来回收老年代空间，最终导致 Young GC 时对象晋升失败，触发了灾难性的 Full GC。**

### 三、 调优解决方案与验证 (The Solution)

针对上述结论，我们的调优目标非常明确：**让 G1 的并发标记周期更早地启动，以便它能“跑赢”对象的晋升速度，从而避免 Full GC。**

#### 调优措施 1：降低并发标记的触发阈值

- **参数**: `-XX:InitiatingHeapOccupancyPercent` (IHOP)
- **说明**: 这个参数决定了当整个堆的内存占用率达到多少时，启动 G1 的并发标记周期。它的默认值是 **45%**。
- **调整**: 我们的老年代增长得非常快，45%的阈值显然太晚了。我们决定将它调低。经过几次尝试，最终确定了一个合适的值：
  ```
  -XX:InitiatingHeapOccupancyPercent=35
  ```
  我们将阈值从 45%降低到了 35%。这意味着当堆内存使用到 35%时，G1 就会开始着手准备回收老年代，而不是等到 45%。这给了 G1 更充足的时间来完成并发标记，并及时安排 Mixed GC。

#### 调优措施 2：增加并发 GC 线程数（辅助）

- **参数**: `-XX:ConcGCThreads`
- **说明**: G1 用于并发标记的线程数。默认值大约是并行 GC 线程数（`ParallelGCThreads`）的 1/4。
- **调整**: 我们的服务器是多核 CPU（32 核），CPU 资源充足。为了让并发标记跑得更快一些，我们适当增加了这个值：
  ```
  # 假设ParallelGCThreads为24，默认ConcGCThreads约为6
  # 我们将其手动增加到8
  -XX:ConcGCThreads=8
  ```

#### 验证结果

我们将调整后的 JVM 参数部署到压测环境，并以相同的压力模型重新进行了测试。结果非常理想：

1.  **Full GC 消失**: 检查新的 GC 日志，`Pause Full (G1 Evacuation Failure)` 的记录完全消失了。
2.  **Mixed GC 正常执行**: 取而代之的是，我们观察到在堆内存占用率达到 35%左右后，系统会平滑地、周期性地执行`Pause Mixed`，每次停顿时间都在 150ms 以内。
3.  **TP99 响应时间稳定**: 在应用监控图上，之前剧烈的延迟尖刺彻底消失了。整个压测过程中，服务的 TP99 响应时间稳定地维持在**180ms 以下**，完全达到了我们的性能预期。

### 四、 总结

这次调优是一个典型的“**数据驱动、定位瓶颈、精准优化**”的过程。我们没有盲目地去调整堆大小或新生代比例，而是：

1.  通过**监控和日志**发现了**长时间 STW**的现象。
2.  深入分析 GC 日志，精准定位到问题是**G1 的晋升失败（Evacuation Failure）**。
3.  结合业务场景，推断出根源是**并发标记启动过晚**。
4.  最终通过调整核心参数 **`-XX:InitiatingHeapOccupancyPercent`**，提前触发并发标记，从而根本上解决了问题。

这个案例也深刻地说明了，对于 G1 这样的现代垃圾回收器，理解其工作原理和各个阶段的触发时机，是进行高效性能调优的关键。
