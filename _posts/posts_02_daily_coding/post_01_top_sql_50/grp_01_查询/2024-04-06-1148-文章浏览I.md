---
title: 1148. 文章浏览 I
date: 2024-04-06 06:00:00 +0800
categories: [Daily Coding, Top SQL 50, 查询]
tags: [查询]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121154022031.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：1148. 文章浏览 I

**表:** `Views`

| Column Name | Type |
| ----------- | ---- |
| article_id  | int  |
| author_id   | int  |
| viewer_id   | int  |
| view_date   | date |

- 此表可能会存在重复行。(换句话说，在 SQL 中这个表没有主键)
- 此表的每一行都表示某人在某天浏览了某位作者的某篇文章。
- 请注意，同一人的 `author_id` 和 `viewer_id` 是相同的。

**问题描述:**

请查询出所有浏览过自己文章的作者。

结果按照作者的 `id` **升序排列**。


**示例 1:**

**输入:**
`Views` 表:

| article_id | author_id | viewer_id | view_date  |
| ---------- | --------- | --------- | ---------- |
| 1          | 3         | 5         | 2019-08-01 |
| 1          | 3         | 6         | 2019-08-02 |
| 2          | 7         | 7         | 2019-08-01 |
| 2          | 7         | 6         | 2019-08-02 |
| 4          | 7         | 1         | 2019-07-22 |
| 3          | 4         | 4         | 2019-07-21 |
| 3          | 4         | 4         | 2019-07-21 |

**输出:**

| id  |
| --- |
| 4   |
| 7   |


## 正确答案 (MySQL)

你只需要在 `Views` 表中筛选出 `author_id` 与 `viewer_id` 相同的记录即可。

```sql
SELECT DISTINCT author_id AS id
FROM Views
WHERE author_id = viewer_id
ORDER BY id ASC;
```

**查询逻辑分解:**

1. **`SELECT DISTINCT author_id AS id`**:

   - `author_id`: 我们选择 `author_id` 作为结果，因为它代表了作者的 ID。
   - `DISTINCT`: 使用 `DISTINCT` 关键字来确保每个作者的 ID 只在结果中出现一次，即使他们多次浏览了自己的文章。
   - `AS id`: 将结果列的名称重命名为 `id` 以匹配输出格式。

2. **`FROM Views`**:

   - 指定从 `Views` 表中查询数据。

3. **`WHERE author_id = viewer_id`**:

   - 这是筛选的核心条件。它只选择那些作者 ID 和浏览者 ID 相同的行，这些行就代表了作者浏览了他们自己的文章。

4. **`ORDER BY id ASC`**:
   - 根据题目要求，按 `id`（即作者 ID）对最终结果进行升序排序。
