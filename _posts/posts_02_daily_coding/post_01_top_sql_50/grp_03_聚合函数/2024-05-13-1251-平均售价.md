---
title: 1251. 平均售价
date: 2024-05-13 06:00:00 +0800
categories: [Daily Coding, Top SQL 50, 聚合函数]
tags: [聚合函数]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121164157212.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：1251. 平均售价

**表:** `Prices`

| Column Name | Type |
| ----------- | ---- |
| product_id  | int  |
| start_date  | date |
| end_date    | date |
| price       | int  |

- `(product_id, start_date, end_date)` 是 `prices` 表的主键。
- `prices` 表的每一行表示的是某个产品在一段时期内的价格。
- 每个产品的对应时间段是不会重叠的，这也意味着同一个产品的价格时段不会出现交叉。

**表:** `UnitsSold`

| Column Name   | Type |
| ------------- | ---- |
| product_id    | int  |
| purchase_date | date |
| units         | int  |

- 该表可能包含重复数据。
- 该表的每一行表示的是每种产品的出售日期，单位和产品 id。

**问题描述:**

编写解决方案以查找每种产品的平均售价。`average_price` 应该 **四舍五入到小数点后两位**。如果产品没有任何售出，则假设其平均售价为
0。

返回结果表 **无顺序要求**。

**示例 1:**

**输入:**
`Prices` table:

| product_id | start_date | end_date   | price |
| ---------- | ---------- | ---------- | ----- |
| 1          | 2019-02-17 | 2019-02-28 | 5     |
| 1          | 2019-03-01 | 2019-03-22 | 20    |
| 2          | 2019-02-01 | 2019-02-20 | 15    |
| 2          | 2019-02-21 | 2019-03-31 | 30    |

`UnitsSold` table:

| product_id | purchase_date | units |
| ---------- | ------------- | ----- |
| 1          | 2019-02-25    | 100   |
| 1          | 2019-03-01    | 15    |
| 2          | 2019-02-10    | 200   |
| 2          | 2019-03-22    | 30    |

**输出:**

| product_id | average_price |
| ---------- | ------------- |
| 1          | 6.96          |
| 2          | 16.96         |

**解释:**
平均售价 = 产品总价 / 销售的产品数量。

- 产品 1 的平均售价 = `((100 * 5) + (15 * 20)) / (100 + 15)` = 6.96
- 产品 2 的平均售价 = `((200 * 15) + (30 * 30)) / (200 + 30)` = 16.96

## 题解

这个问题的关键是，对于每一笔销售，需要根据其 `purchase_date` 找到对应的价格。这可以通过连接两个表并使用 `BETWEEN`
条件来实现。同时，需要使用 `LEFT JOIN` 来包含那些没有销售记录的产品。

```sql
SELECT p.product_id,
       IFNULL(ROUND(SUM(p.price * u.units) / SUM(u.units), 2), 0) AS average_price
FROM Prices p
         LEFT JOIN
     UnitsSold u ON p.product_id = u.product_id AND u.purchase_date BETWEEN p.start_date AND p.end_date
GROUP BY p.product_id;

```

**查询逻辑分解:**

1. **`FROM Prices p LEFT JOIN UnitsSold u ON ...`**:

   - 我们使用 `LEFT JOIN` 从 `Prices` 表连接到 `UnitsSold` 表。这确保了即使一个产品从未被售出（在 `UnitsSold`
     中没有记录），它也会出现在结果中。
   - 连接条件 `p.product_id = u.product_id` 匹配相同的产品。
   - 连接条件 `AND u.purchase_date BETWEEN p.start_date AND p.end_date` 是核心，它确保每一笔销售记录都与其发生时有效的价格记录相匹配。

2. **`GROUP BY p.product_id`**:

   - 按 `product_id` 对结果进行分组，以便为每个产品计算总销售额和总销售单位。

3. **`SELECT p.product_id, IFNULL(ROUND(SUM(p.price * u.units) / SUM(u.units), 2), 0) AS average_price`**:
   - `SUM(p.price * u.units)`: 对于每个产品组，计算总销售额（每笔销售的单位数乘以其单价，然后求和）。
   - `SUM(u.units)`: 计算每个产品组的总销售单位数。
   - `... / ...`: 将总销售额除以总销售单位数，得到平均售价。
   - `ROUND(..., 2)`: 将平均售价四舍五入到小数点后两位。
   - `IFNULL(..., 0)`: 如果一个产品从未售出，`SUM(u.units)` 会是 `NULL`，导致除法结果为 `NULL`。`IFNULL` 函数在这种情况下会返回
     0，满足题目要求。
   - `AS average_price`: 将结果列重命名。
