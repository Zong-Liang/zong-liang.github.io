---
title: 1211. 查询结果的质量和占比
date: 2024-05-10 06:00:00 +0800
categories: [Daily Coding, Top SQL 50, 聚合函数]
tags: [聚合函数]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121163916771.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：1211. 查询结果的质量和占比

**表:** `Queries`

| Column Name | Type    |
| ----------- | ------- |
| query_name  | varchar |
| result      | varchar |
| position    | int     |
| rating      | int     |

- 此表可能存在重复的行。
- 此表包含了一些从数据库中收集的查询信息。
- “位置”（position）列的值为 1 到 500 。
- “评分”（rating）列的值为 1 到 5 。评分小于 3 的查询被定义为质量很差的查询。

**问题定义:**

- 将查询结果的 **质量** `quality` 定义为：各查询结果的评分与其位置之间比率的平均值。
- 将 **劣质查询百分比** `poor_query_percentage` 定义为：评分小于 3 的查询结果占全部查询结果的百分比。

编写解决方案，找出每次的 `query_name`、`quality` 和 `poor_query_percentage`。

`quality` 和 `poor_query_percentage` 都应 **四舍五入到小数点后两位**。

以 **任意顺序** 返回结果表。

**示例 1:**

**输入:**
`Queries` table:

| query_name | result           | position | rating |
| ---------- | ---------------- | -------- | ------ |
| Dog        | Golden Retriever | 1        | 5      |
| Dog        | German Shepherd  | 2        | 5      |
| Dog        | Mule             | 200      | 1      |
| Cat        | Shirazi          | 5        | 2      |
| Cat        | Siamese          | 3        | 3      |
| Cat        | Sphynx           | 7        | 4      |

**输出:**

| query_name | quality | poor_query_percentage |
| ---------- | ------- | --------------------- |
| Dog        | 2.50    | 33.33                 |
| Cat        | 0.66    | 33.33                 |

**解释:**

- **Dog** 查询结果的质量为 ((5 / 1) + (5 / 2) + (1 / 200)) / 3 = 2.50
- **Dog** 查询结果的劣质查询百分比为 (1 / 3) \* 100 = 33.33
- **Cat** 查询结果的质量为 ((2 / 5) + (3 / 3) + (4 / 7)) / 3 = 0.66
- **Cat** 查询结果的劣质查询百分比为 (1 / 3) \* 100 = 33.33

## 正确答案 (MySQL)

您可以使用 `GROUP BY` 按 `query_name` 对数据进行分组，并使用聚合函数 `AVG()` 和条件聚合 `SUM(CASE ...)` 来计算所需的指标。

```sql
SELECT query_name,
       ROUND(AVG(rating / position), 2)                                       AS quality,
       ROUND(SUM(CASE WHEN rating < 3 THEN 1 ELSE 0 END) * 100 / COUNT(*), 2) AS poor_query_percentage
FROM Queries
GROUP BY query_name;
```

**查询逻辑分解:**

1. **`GROUP BY query_name`**:

   - 将 `Queries` 表中具有相同 `query_name` 的所有行组合成一个单独的组，以便对每个查询名称进行独立的计算。

2. **`SELECT ...` (计算列)**:
   - `query_name`: 选择查询的名称。
   - **`ROUND(AVG(rating / position), 2) AS quality`**:
     - `rating / position`: 对于每一行，计算评分与其位置的比率。
     - `AVG(...)`: 计算每个 `query_name` 组中所有这些比率的平均值，这就是 `quality`。
     - `ROUND(..., 2)`: 将结果四舍五入到小数点后两位。
   - **`ROUND(SUM(CASE WHEN rating < 3 THEN 1 ELSE 0 END) * 100 / COUNT(*), 2) AS poor_query_percentage`**:
     - `SUM(CASE WHEN rating < 3 THEN 1 ELSE 0 END)`: 这是一个条件计数。`CASE` 语句检查 `rating` 是否小于 3。如果是，则计为
       1（劣质查询），否则计为 0。`SUM` 将这些 1 和 0 相加，得到每个组中劣质查询的总数。
     - `COUNT(*)`: 计算每个组中的总查询数。
     - `... * 100 / ...`: 将劣质查询数除以总查询数，再乘以 100，得到百分比。
     - `ROUND(..., 2)`: 将最终的百分比四舍五入到小数点后两位。
