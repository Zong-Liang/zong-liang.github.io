---
title: 1174. 即时食物配送 II
date: 2024-05-05 06:00:00 +0800
categories: [Daily Coding, Top SQL 50, 聚合函数]
tags: [聚合函数]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121163706114.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：1174. 即时食物配送 II

**配送表:** `Delivery`

| Column Name                 | Type |
| --------------------------- | ---- |
| delivery_id                 | int  |
| customer_id                 | int  |
| order_date                  | date |
| customer_pref_delivery_date | date |

- `delivery_id` 是该表中具有唯一值的列。
- 该表保存着顾客的食物配送信息，顾客在某个日期下了订单，并指定了一个期望的配送日期（和下单日期相同或者在那之后）。

**问题描述:**

- 如果顾客期望的配送日期和下单日期相同，则该订单称为 **「即时订单」**，否则称为 **「计划订单」**。
- **「首次订单」** 是顾客最早创建的订单。我们保证一个顾客只会有一个「首次订单」。

编写解决方案以获取即时订单在所有用户的首次订单中的比例。**保留两位小数**。

**示例 1:**

**输入:**
`Delivery` 表:

| delivery_id | customer_id | order_date | customer_pref_delivery_date |
| ----------- | ----------- | ---------- | --------------------------- |
| 1           | 1           | 2019-08-01 | 2019-08-02                  |
| 2           | 2           | 2019-08-02 | 2019-08-02                  |
| 3           | 1           | 2019-08-11 | 2019-08-12                  |
| 4           | 3           | 2019-08-24 | 2019-08-24                  |
| 5           | 3           | 2019-08-21 | 2019-08-22                  |
| 6           | 2           | 2019-08-11 | 2019-08-13                  |
| 7           | 4           | 2019-08-09 | 2019-08-09                  |

**输出:**

| immediate_percentage |
| -------------------- |
| 50.00                |

**解释:**

- 1 号顾客的 1 号订单是首次订单, 并且是计划订单。
- 2 号顾客的 2 号订单是首次订单, 并且是即时订单。
- 3 号顾客的 5 号订单是首次订单, 并且是计划订单。
- 4 号顾客的 7 号订单是首次订单, 并且是即时订单。
- 因此, 一半顾客的首次订单是即时的。

## 正确答案 (MySQL)

这个问题的核心是先找出每个用户的首次订单，然后计算这些首次订单中即时订单所占的百分比。使用窗口函数 `RANK()` 或
`ROW_NUMBER()` 是解决此类问题的有效方法。

```sql
WITH FirstOrders AS (
    -- 步骤1: 使用窗口函数为每个客户的订单按日期排序，找到首次订单
    SELECT order_date,
           customer_pref_delivery_date,
           RANK() OVER (PARTITION BY customer_id ORDER BY order_date ASC) as order_rank
    FROM Delivery)
-- 步骤2: 从所有首次订单中计算即时订单的比例
SELECT ROUND(
               AVG(CASE WHEN order_date = customer_pref_delivery_date THEN 1 ELSE 0 END) * 100,
               2
       ) AS immediate_percentage
FROM FirstOrders
WHERE order_rank = 1;
```

**查询逻辑分解:**

1. **`WITH FirstOrders AS (...)` (步骤 1):**

   - 我们使用一个公共表表达式 (CTE) 来处理订单排名。
   - `RANK() OVER (PARTITION BY customer_id ORDER BY order_date ASC) as order_rank`: 这是窗口函数。
     - `PARTITION BY customer_id`: 将数据按 `customer_id` 分成多个窗口（组）。
     - `ORDER BY order_date ASC`: 在每个窗口内，按订单日期升序排列。
     - `RANK()`: 为排序后的每一行分配一个排名。每个客户最早的订单（即首次订单）将被赋予排名 `1`。

2. **最终 `SELECT` (步骤 2):**
   - `FROM FirstOrders WHERE order_rank = 1`: 我们从 CTE 中只选择那些排名为 1 的记录，这些就是所有客户的首次订单。
   - `AVG(CASE WHEN order_date = customer_pref_delivery_date THEN 1 ELSE 0 END)`: 这是一个计算比例的技巧。
     - `CASE` 语句：如果订单是即时的 (`order_date = customer_pref_delivery_date`)，则返回 1，否则返回 0。
     - `AVG()`: 对这一系列的 1 和 0 求平均值。结果恰好是 1 的占比，即即时订单的比例。
   - `* 100`: 将比例转换为百分比。
   - `ROUND(..., 2)`: 将结果四舍五入到两位小数，以满足输出格式要求。
