---
title: 1581. 进店却未进行过交易的顾客
date: 2024-04-23 06:00:00 +0800
categories: [Daily Coding, Top SQL 50, 连接]
tags: [连接]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121162247720.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：1581. 进店却未进行过交易的顾客

**表:** `Visits`

| Column Name | Type |
| ----------- | ---- |
| visit_id    | int  |
| customer_id | int  |

- `visit_id` 是该表中具有唯一值的列。
- 该表包含有关光临过购物中心的顾客的信息。

**表:** `Transactions`

| Column Name    | Type |
| -------------- | ---- |
| transaction_id | int  |
| visit_id       | int  |
| amount         | int  |

- `transaction_id` 是该表中具有唯一值的列。
- 此表包含 `visit_id` 期间进行的交易的信息。

**问题描述:**

有一些顾客可能光顾了购物中心但没有进行交易。请你编写一个解决方案，来查找这些顾客的 ID，以及他们只光顾不交易的次数。

返回以 **任意顺序** 排序的结果表。

**示例 1:**

**输入:**

`Visits` 表:

| visit_id | customer_id |
| -------- | ----------- |
| 1        | 23          |
| 2        | 9           |
| 4        | 30          |
| 5        | 54          |
| 6        | 96          |
| 7        | 54          |
| 8        | 54          |

`Transactions` 表:

| transaction_id | visit_id | amount |
| -------------- | -------- | ------ |
| 2              | 5        | 310    |
| 3              | 5        | 300    |
| 9              | 5        | 200    |
| 12             | 1        | 910    |
| 13             | 2        | 970    |

**输出:**

| customer_id | count_no_trans |
| ----------- | -------------- |
| 54          | 2              |
| 30          | 1              |
| 96          | 1              |

**解释:**

- ID = 23 的顾客曾经逛过一次购物中心，并在 ID = 12 的访问期间进行了一笔交易。
- ID = 30 的顾客曾经去过购物中心，并且没有进行任何交易。
- ID = 54 的顾客三度造访了购物中心。在 2 次访问中，他们没有进行任何交易，在 1 次访问中，他们进行了 3 次交易。
- ID = 96 的顾客曾经去过购物中心，并且没有进行任何交易。
- 如我们所见，ID 为 30 和 96 的顾客一次没有进行任何交易就去了购物中心。顾客 54 也两次访问了购物中心并且没有进行任何交易。

## 正确答案 (MySQL)

你可以使用 `LEFT JOIN` 从 `Visits` 表连接到 `Transactions` 表，并筛选出那些没有匹配交易的访问。然后，按 `customer_id`
分组并计数。

```sql
SELECT v.customer_id,
       COUNT(v.visit_id) AS count_no_trans
FROM Visits v
         LEFT JOIN
     Transactions t ON v.visit_id = t.visit_id
WHERE t.transaction_id IS NULL
GROUP BY v.customer_id;
```

**查询逻辑分解:**

1. **`FROM Visits v LEFT JOIN Transactions t ON v.visit_id = t.visit_id`**:

   - 我们从 `Visits` 表 (别名 `v`) 开始，并对其 `LEFT JOIN` `Transactions` 表 (别名 `t`)。
   - `LEFT JOIN` 会返回所有 `Visits` 表中的记录。如果一次访问（由 `v.visit_id` 标识）在 `Transactions` 表中没有对应的交易记录，那么来自
     `t` 表的所有列（如 `t.transaction_id`）在该连接结果行中将为 `NULL`。

2. **`WHERE t.transaction_id IS NULL`**:

   - 这个条件筛选出所有在 `LEFT JOIN` 后 `t.transaction_id` 为 `NULL` 的行。这精确地标识了那些**没有发生任何交易的访问**。

3. **`GROUP BY v.customer_id`**:

   - 我们将筛选出的“无交易访问”记录按 `customer_id` 进行分组。

4. **`SELECT v.customer_id, COUNT(v.visit_id) AS count_no_trans`**:

   - `v.customer_id`: 选择顾客的 ID。
   - `COUNT(v.visit_id)`: 计算每个顾客分组中的访问次数。因为我们已经筛选出了无交易的访问，所以这个计数就是每个顾客“只光顾不交易”的次数。
   - `AS count_no_trans`: 将计数结果的列重命名。
