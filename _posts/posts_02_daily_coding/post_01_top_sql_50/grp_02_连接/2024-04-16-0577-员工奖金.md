---
title: 0577. 员工奖金
date: 2024-04-16 06:00:00 +0800
categories: [Daily Coding, Top SQL 50, 连接]
tags: [连接]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121161707410.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：0577. 员工奖金

**表:** `Employee`

| Column Name | Type    |
| ----------- | ------- |
| empId       | int     |
| name        | varchar |
| supervisor  | int     |
| salary      | int     |

- `empId` 是该表中具有唯一值的列。
- 该表的每一行都表示员工的 id 和姓名，以及他们经理的 id 和他们的工资。

**表:** `Bonus`

| Column Name | Type |
| ----------- | ---- |
| empId       | int  |
| bonus       | int  |

- `empId` 是该表具有唯一值的列。
- `empId` 是 `Employee` 表中 `empId` 的外键(reference 列)。
- 该表的每一行都包含一个员工的 id 和他们各自的奖金。

**问题描述:**

编写解决方案，报告每个奖金 **少于** 1000 的员工的姓名和奖金数额。

以 **任意顺序** 返回结果表。


**示例 1:**

**输入:**
`Employee` table:

| empId | name   | supervisor | salary |
| ----- | ------ | ---------- | ------ |
| 3     | Brad   | null       | 4000   |
| 1     | John   | 3          | 1000   |
| 2     | Dan    | 3          | 2000   |
| 4     | Thomas | 3          | 4000   |

`Bonus` table:

| empId | bonus |
| ----- | ----- |
| 2     | 500   |
| 4     | 2000  |

**输出:**

| name | bonus |
| ---- | ----- |
| Brad | null  |
| John | null  |
| Dan  | 500   |


## 题解

你需要使用 `LEFT JOIN` 将 `Employee` 表与 `Bonus` 表连接起来，以确保所有员工都被考虑在内，即使他们没有奖金记录。然后，你可以筛选出奖金小于 1000 或没有奖金的员工。

```sql
SELECT e.name,
       b.bonus
FROM Employee e
         LEFT JOIN
     Bonus b ON e.empId = b.empId
WHERE b.bonus < 1000
   OR b.bonus IS NULL;
```

**查询逻辑分解:**

1. **`FROM Employee e LEFT JOIN Bonus b ON e.empId = b.empId`**:

   - 我们使用 `LEFT JOIN` 从 `Employee` 表 (别名 `e`) 连接到 `Bonus` 表 (别名 `b`)。
   - `LEFT JOIN` 是此题的关键，因为它会返回所有左表（`Employee`）的记录，即使在右表（`Bonus`）中没有匹配的记录。
   - 对于那些在 `Bonus` 表中没有记录的员工（如 Brad 和 John），连接后的 `b.bonus` 列的值将为 `NULL`。

2. **`WHERE b.bonus < 1000 OR b.bonus IS NULL`**:

   - 这是一个包含两个条件的 `WHERE` 子句，用 `OR` 连接。
   - `b.bonus < 1000`: 这个条件会筛选出那些有奖金记录且奖金数额小于 1000 的员工（如 Dan）。
   - `b.bonus IS NULL`: 这个条件会筛选出那些在 `Bonus` 表中没有记录，因此奖金为 `NULL` 的员工（如 Brad 和 John）。
   - 结合起来，这个 `WHERE` 子句就能找出所有符合题目要求的员工。

3. **`SELECT e.name, b.bonus`**:
   - 选择员工的姓名 `e.name` 和他们对应的奖金 `b.bonus`（可能是具体数值或 `NULL`）。
