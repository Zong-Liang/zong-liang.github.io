---
title: 1280. 学生们参加各科测试的次数
date: 2024-04-19 06:00:00 +0800
categories: [Daily Coding, Top SQL 50, 连接]
tags: [连接]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121162006263.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：1280. 学生们参加各科测试的次数

**表结构:**

`Students`

| Column Name  | Type    |
| ------------ | ------- |
| student_id   | int     |
| student_name | varchar |

- `student_id` 是主键。
- 该表的每一行都记录有学校一名学生的信息。

`Subjects`

| Column Name  | Type    |
| ------------ | ------- |
| subject_name | varchar |

- `subject_name` 是主键。
- 每一行记录学校的一门科目名称。

`Examinations`

| Column Name  | Type    |
| ------------ | ------- |
| student_id   | int     |
| subject_name | varchar |

- 该表没有主键，可能包含重复数据。
- 学生表里的一个学生修读科目表里的一门科目。
- 这张考试表的每一行记录就表示学生表里的某个学生参加了一次科目表里某门科目的测试。

**问题描述:**

查询出每个学生参加每一门科目测试的次数，结果按 `student_id` 和 `subject_name` 排序。

**示例 1:**

**输入:**

`Students` table:

| student_id | student_name |
| ---------- | ------------ |
| 1          | Alice        |
| 2          | Bob          |
| 13         | John         |
| 6          | Alex         |

`Subjects` table:

| subject_name |
| ------------ |
| Math         |
| Physics      |
| Programming  |

`Examinations` table:

| student_id | subject_name |
| ---------- | ------------ |
| 1          | Math         |
| 1          | Physics      |
| 1          | Programming  |
| 2          | Programming  |
| 1          | Physics      |
| 1          | Math         |
| 13         | Math         |
| 13         | Programming  |
| 13         | Physics      |
| 2          | Math         |
| 1          | Math         |

**输出:**

| student_id | student_name | subject_name | attended_exams |
| ---------- | ------------ | ------------ | -------------- |
| 1          | Alice        | Math         | 3              |
| 1          | Alice        | Physics      | 2              |
| 1          | Alice        | Programming  | 1              |
| 2          | Bob          | Math         | 1              |
| 2          | Bob          | Physics      | 0              |
| 2          | Bob          | Programming  | 1              |
| 6          | Alex         | Math         | 0              |
| 6          | Alex         | Physics      | 0              |
| 6          | Alex         | Programming  | 0              |
| 13         | John         | Math         | 1              |
| 13         | John         | Physics      | 1              |
| 13         | John         | Programming  | 1              |

**解释:**

结果表需包含所有学生和所有科目（即便测试次数为 0）。

## 题解

这个问题的核心是需要为 **每个** 学生和 **每个** 科目的组合生成一个计数，即使某个学生从未参加过某个科目的考试。这可以通过 `CROSS JOIN` 生成所有可能的组合，然后 `LEFT JOIN` 考试记录来实现。

```sql
SELECT st.student_id,
       st.student_name,
       su.subject_name,
       COUNT(ex.subject_name) AS attended_exams
FROM Students st
         CROSS JOIN
     Subjects su
         LEFT JOIN
     Examinations ex ON st.student_id = ex.student_id AND su.subject_name = ex.subject_name
GROUP BY st.student_id,
         st.student_name,
         su.subject_name
ORDER BY st.student_id,
         su.subject_name;
```

**查询逻辑分解:**

1. **`FROM Students st CROSS JOIN Subjects su`**:

   - `CROSS JOIN` 会创建 `Students` 表和 `Subjects` 表的笛卡尔积。这意味着，它会为每个学生和每个科目生成一个组合行。这个步骤是关键，因为它确保了我们的结果中包含了所有可能的（学生, 科目）对。

2. **`LEFT JOIN Examinations ex ON st.student_id = ex.student_id AND su.subject_name = ex.subject_name`**:

   - 我们将上面生成的笛卡尔积与 `Examinations` 表进行 `LEFT JOIN`。
   - 连接条件 `st.student_id = ex.student_id AND su.subject_name = ex.subject_name` 尝试为每个（学生, 科目）对找到匹配的考试记录。
   - 如果一个学生参加了某个科目的考试，连接就会成功。
   - 如果一个学生 **没有** 参加某个科目的考试，连接会失败，来自 `Examinations` 表 (`ex`) 的列（特别是 `ex.subject_name`）将为 `NULL`。

3. **`GROUP BY st.student_id, st.student_name, su.subject_name`**:

   - 我们按学生 ID、学生姓名和科目名称进行分组，以便为每个（学生, 科目）对计算考试次数。

4. **`SELECT ..., COUNT(ex.subject_name) AS attended_exams`**:

   - `COUNT(ex.subject_name)`: 这是计算的核心。`COUNT` 函数只计算非 `NULL` 的值。

     - 对于参加过考试的组合，`ex.subject_name` 不为 `NULL`，`COUNT` 会计算出他们参加考试的次数。
     - 对于 **未** 参加过考试的组合，`ex.subject_name` 为 `NULL`，`COUNT` 的结果是 0。这正是我们想要的结果。

5. **`ORDER BY st.student_id, su.subject_name`**:

   - 最后，根据题目要求，按学生 ID 和科目名称对结果进行排序。
