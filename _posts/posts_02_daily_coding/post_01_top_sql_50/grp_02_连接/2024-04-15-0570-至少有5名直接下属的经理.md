---
title: 0570. 至少有5名直接下属的经理
date: 2024-04-15 06:00:00 +0800
categories: [Daily Coding, Top SQL 50, 连接]
tags: [连接]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121161611159.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：0570. 至少有 5 名直接下属的经理

**表:** `Employee`

| Column Name | Type    |
| ----------- | ------- |
| id          | int     |
| name        | varchar |
| department  | varchar |
| managerId   | int     |

- `id` 是此表的主键（具有唯一值的列）。
- 该表的每一行表示雇员的名字、他们的部门和他们的经理的 id。
- 如果`managerId`为空，则该员工没有经理。
- 没有员工会成为自己的管理者。

**问题描述:**

编写一个解决方案，找出至少有五个 **直接下属** 的经理。

以 **任意顺序** 返回结果表。


**示例 1:**

**输入:**
`Employee` 表:

| id  | name  | department | managerId |
| --- | ----- | ---------- | --------- |
| 101 | John  | A          | Null      |
| 102 | Dan   | A          | 101       |
| 103 | James | A          | 101       |
| 104 | Amy   | A          | 101       |
| 105 | Anne  | A          | 101       |
| 106 | Ron   | B          | 101       |

**输出:**

| name |
| ---- |
| John |


## 题解

你可以通过按 `managerId` 分组并计算每个组的员工数量来找到符合条件的经理。然后，使用子查询或自连接来获取这些经理的姓名。

**方法 1: 使用子查询**

```sql
SELECT e.name
FROM Employee e
WHERE e.id IN (SELECT managerId
               FROM Employee
               GROUP BY managerId
               HAVING COUNT(*) >= 5);
```

**方法 2: 使用自连接 (Self-Join)**

```sql
SELECT m.name
FROM Employee AS e
         JOIN
     Employee AS m ON e.managerId = m.id
GROUP BY m.id, m.name
HAVING COUNT(e.id) >= 5;
```

**查询逻辑分解 (方法 2 - 自连接):**

1. **`FROM Employee AS e JOIN Employee AS m ON e.managerId = m.id`**:

   - 这是一个自连接。我们将 `Employee` 表视为两个不同的实体：`e` 代表下属员工 (employee)，`m` 代表经理 (manager)。
   - 连接条件 `e.managerId = m.id` 将每个下属员工与其直接经理关联起来。这个 `INNER JOIN` 自动过滤掉了那些不是任何人员工经理的员工。

2. **`GROUP BY m.id, m.name`**:

   - 我们按经理的 `id` 和 `name` 进行分组。这样，所有直接向同一位经理汇报的员工都会被归为一组。

3. **`HAVING COUNT(e.id) >= 5`**:

   - 在分组后，我们使用 `HAVING` 子句来筛选结果。
   - `COUNT(e.id)` 计算每个经理分组中的下属员工数量。
   - 只有当这个数量大于或等于 5 时，该经理才会被保留。

4. **`SELECT m.name`**:
   - 最后，从通过筛选的经理分组中，选择经理的姓名 `m.name`。
