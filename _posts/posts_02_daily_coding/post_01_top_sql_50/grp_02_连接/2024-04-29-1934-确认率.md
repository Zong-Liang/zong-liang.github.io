---
title: 1934. 确认率
date: 2024-04-29 06:00:00 +0800
categories: [Daily Coding, Top SQL 50, 连接]
tags: [连接]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121162521468.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：1934. 确认率

**表:** `Signups`

| Column Name | Type     |
| ----------- | -------- |
| user_id     | int      |
| time_stamp  | datetime |

- `User_id` 是该表的主键。
- 每一行都包含 ID 为 `user_id` 的用户的注册时间信息。

**表:** `Confirmations`

| Column Name | Type                         |
| ----------- | ---------------------------- |
| user_id     | int                          |
| time_stamp  | datetime                     |
| action      | ENUM('confirmed', 'timeout') |

- `(user_id, time_stamp)` 是该表的主键。
- `user_id` 是一个引用到注册表的外键。
- 该表的每一行都表示 ID 为 `user_id` 的用户在 `time_stamp` 请求了一条确认消息，该确认消息要么被确认 ('confirmed')
  ，要么被过期 ('timeout')。

**问题描述:**

用户的 **确认率** 是 `'confirmed'` 消息的数量除以请求的确认消息的总数。没有请求任何确认消息的用户的确认率为 **0**。确认率
**四舍五入到小数点后两位**。

编写一个 SQL 查询来查找每个用户的确认率。

以 **任意顺序** 返回结果表。

**示例 1:**

**输入:**
`Signups` 表:

| user_id | time_stamp          |
| ------- | ------------------- |
| 3       | 2020-03-21 10:16:13 |
| 7       | 2020-01-04 13:57:59 |
| 2       | 2020-07-29 23:09:44 |
| 6       | 2020-12-09 10:39:37 |

`Confirmations` 表:

| user_id | time_stamp          | action    |
| ------- | ------------------- | --------- |
| 3       | 2021-01-06 03:30:46 | timeout   |
| 3       | 2021-07-14 14:00:00 | timeout   |
| 7       | 2021-06-12 11:57:29 | confirmed |
| 7       | 2021-06-13 12:58:28 | confirmed |
| 7       | 2021-06-14 13:59:27 | confirmed |
| 2       | 2021-01-22 00:00:00 | confirmed |
| 2       | 2021-02-28 23:59:59 | timeout   |

**输出:**

| user_id | confirmation_rate |
| ------- | ----------------- |
| 6       | 0.00              |
| 3       | 0.00              |
| 7       | 1.00              |
| 2       | 0.50              |

**解释:**

- 用户 6 没有请求任何确认消息。确认率为 0。
- 用户 3 进行了 2 次请求, 都超时了。确认率为 0。
- 用户 7 提出了 3 个请求, 所有请求都得到了确认。确认率为 1。
- 用户 2 做了 2 个请求, 其中一个被确认, 另一个超时。确认率为 1 / 2 = 0.5。

## 题解

为了确保所有注册用户（即使没有确认记录）都包含在结果中，我们需要使用 `LEFT JOIN`。然后，我们可以使用条件聚合来计算确认率。

```sql
SELECT s.user_id,
       ROUND(
               IFNULL(
                       SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(c.user_id),
                       0
               ), 2
       ) AS confirmation_rate
FROM Signups s
         LEFT JOIN
     Confirmations c ON s.user_id = c.user_id
GROUP BY s.user_id;

```

**查询逻辑分解:**

1. **`FROM Signups s LEFT JOIN Confirmations c ON s.user_id = c.user_id`**:

   - 我们从 `Signups` 表 (别名 `s`) 开始，并对其 `LEFT JOIN` `Confirmations` 表 (别名 `c`)。
   - `LEFT JOIN` 确保了即使某个用户在 `Confirmations` 表中没有任何记录，他也会出现在结果集中。对于这样的用户，所有来自 `c`
     表的列都将为 `NULL`。

2. **`GROUP BY s.user_id`**:

   - 按 `user_id` 对结果进行分组，以便为每个独立的用户计算确认率。

3. **`SELECT s.user_id, ROUND(IFNULL(..., 0), 2) AS confirmation_rate`**:
   - **计算比率**:
     - `SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END)`: 这是条件计数，用于计算每个用户 `confirmed`
       消息的数量（分子）。
     - `COUNT(c.user_id)`: 计算每个用户总的确认请求数（分母）。对于没有确认记录的用户，`c.user_id` 为 `NULL`，因此 `COUNT`
       的结果为 0。
     - 将分子除以分母得到确认率。
   - **处理 `NULL` 和 0**:
     - `IFNULL(..., 0)`: 如果一个用户没有任何确认记录，`COUNT(c.user_id)` 会是 0，导致除法结果为 `NULL`。`IFNULL` 函数会将这个
       `NULL` 结果转换为 0，满足题目要求。
   - **格式化输出**:
     - `ROUND(..., 2)`: 将计算出的确认率四舍五入到小数点后两位。
     - `AS confirmation_rate`: 将结果列重命名。
