---
title: 1661. 每台机器的进程平均运行时间
date: 2024-04-26 06:00:00 +0800
categories: [Daily Coding, Top SQL 50, 连接]
tags: [连接]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121162337872.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：1661. 每台机器的进程平均运行时间

**表:** `Activity`

| Column Name   | Type                 |
| ------------- | -------------------- |
| machine_id    | int                  |
| process_id    | int                  |
| activity_type | enum('start', 'end') |
| timestamp     | float                |

- `(machine_id, process_id, activity_type)` 是当前表的主键。
- `machine_id` 是一台机器的 ID 号。
- `process_id` 是运行在各机器上的进程 ID 号。
- `activity_type` 是枚举类型 ('start', 'end')。
- `timestamp` 是浮点类型, 代表当前时间(以秒为单位)。
- 'start' 代表该进程在这台机器上的开始运行时间戳, 'end' 代表该进程在这台机器上的终止运行时间戳。
- 同一台机器, 同一个进程都有一个开始时间戳和结束时间戳, 而且开始时间戳永远在结束时间戳前面。

**问题描述:**

现在有一个工厂网站由几台机器运行，每台机器上运行着相同数量的进程。编写解决方案，计算每台机器各自完成一个进程任务的平均耗时。

完成一个进程任务的时间指进程的 'end' 时间戳减去 'start' 时间戳。平均耗时通过计算每台机器上所有进程任务的总耗费时间除以机器上的总进程数量获得。

结果表必须必须包含 `machine_id` (机器 ID) 和对应的 `average time` (平均耗时) 别名 `processing_time`，且 **四舍五入保留 3 位小数
**。

以 **任意顺序** 返回结果表。


**示例 1:**

**输入:**
`Activity` table:

| machine_id | process_id | activity_type | timestamp |
| ---------- | ---------- | ------------- | --------- |
| 0          | 0          | start         | 0.712     |
| 0          | 0          | end           | 1.520     |
| 0          | 1          | start         | 3.140     |
| 0          | 1          | end           | 4.120     |
| 1          | 0          | start         | 0.550     |
| 1          | 0          | end           | 1.550     |
| 1          | 1          | start         | 0.430     |
| 1          | 1          | end           | 1.420     |
| 2          | 0          | start         | 4.100     |
| 2          | 0          | end           | 4.512     |
| 2          | 1          | start         | 2.500     |
| 2          | 1          | end           | 5.000     |

**输出:**

| machine_id | processing_time |
| ---------- | --------------- |
| 0          | 0.894           |
| 1          | 0.995           |
| 2          | 1.456           |

**解释:**

- 机器 0 的平均耗时: `((1.520 - 0.712) + (4.120 - 3.140)) / 2 = 0.894`
- 机器 1 的平均耗时: `((1.550 - 0.550) + (1.420 - 0.430)) / 2 = 0.995`
- 机器 2 的平均耗时: `((4.512 - 4.100) + (5.000 - 2.500)) / 2 = 1.456`


## 题解

你可以通过按 `machine_id` 和 `process_id` 分组，找出每个进程的开始和结束时间，计算差值，然后再按 `machine_id`
分组求平均值。一个更简洁的方法是直接按 `machine_id` 分组，并利用条件聚合。

```sql
SELECT machine_id,
       ROUND(
               SUM(CASE WHEN activity_type = 'end' THEN timestamp ELSE - timestamp END)
                   / COUNT(DISTINCT process_id),
               3
       ) AS processing_time
FROM Activity
GROUP BY machine_id;
```

**查询逻辑分解:**

1. **`GROUP BY machine_id`**:

   - 我们将所有记录按 `machine_id` 进行分组，这样聚合函数就可以为每台机器独立计算。

2. **`SUM(CASE WHEN activity_type = 'end' THEN timestamp ELSE -timestamp END)`**:

   - 这是计算总处理时间的巧妙方法。对于每个 `machine_id` 分组：
   - `CASE` 语句检查 `activity_type`。
   - 如果 `activity_type` 是 'end'，它就取 `timestamp` 的正值。
   - 如果 `activity_type` 是 'start'，它就取 `timestamp` 的负值 (`-timestamp`)。
   - `SUM()` 将这些值相加。对于同一个进程，`end_timestamp + (-start_timestamp)` 的结果就是
     `end_timestamp - start_timestamp`，即该进程的运行时间。
   - 将所有进程的这个差值相加，就得到了这台机器上所有进程的总运行时间。

3. **`COUNT(DISTINCT process_id)`**:

   - 对于每个 `machine_id` 分组，我们计算不重复的 `process_id` 的数量，这就是该机器上运行的总进程数。

4. **`... / ...`**:

   - 我们将总运行时间除以总进程数，得到平均处理时间。

5. **`ROUND(..., 3) AS processing_time`**:
   - 使用 `ROUND()` 函数将结果四舍五入到小数点后三位。
   - `AS processing_time` 将结果列重命名。
