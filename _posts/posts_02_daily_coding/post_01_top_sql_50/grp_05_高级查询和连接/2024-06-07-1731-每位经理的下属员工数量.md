---
title: 1731. 每位经理的下属员工数量
date: 2024-06-07 06:00:00 +0800
categories: [Daily Coding, Top SQL 50, 高级查询和连接]
tags: [高级查询和连接]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121165523741.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：1731. 每位经理的下属员工数量

**表:** `Employees`

| Column Name | Type    |
| ----------- | ------- |
| employee_id | int     |
| name        | varchar |
| reports_to  | int     |
| age         | int     |

- `employee_id` 是这个表中具有不同值的列。
- 该表包含员工以及需要听取他们汇报的上级经理的 ID 的信息。有些员工不需要向任何人汇报 (`reports_to` 为空)。

**问题描述:**

对于此问题，我们将至少有一个其他员工需要向他汇报的员工，视为一个经理。

编写一个解决方案来返回需要听取汇报的所有经理的 ID、名称、直接向该经理汇报的员工人数，以及这些员工的平均年龄，其中该平均年龄需要四舍五入到最接近的整数。

返回的结果集需要按照 `employee_id` 进行排序。

**示例 1:**

**输入:**
`Employees` 表:

| employee_id | name    | reports_to | age |
| ----------- | ------- | ---------- | --- |
| 9           | Hercy   | null       | 43  |
| 6           | Alice   | 9          | 41  |
| 4           | Bob     | 9          | 36  |
| 2           | Winston | null       | 37  |

**输出:**

| employee_id | name  | reports_count | average_age |
| ----------- | ----- | ------------- | ----------- |
| 9           | Hercy | 2             | 39          |

**解释:**
Hercy 有两个需要向他汇报的员工，他们是 Alice and Bob。他们的平均年龄是 (41+36)/2 = 38.5，四舍五入的结果是 39。

**示例 2:**

**输入:**
`Employees` 表:

| employee_id | name    | reports_to | age |
| ----------- | ------- | ---------- | --- |
| 1           | Michael | null       | 45  |
| 2           | Alice   | 1          | 38  |
| 3           | Bob     | 1          | 42  |
| 4           | Charlie | 2          | 34  |
| 5           | David   | 2          | 40  |
| 6           | Eve     | 3          | 37  |
| 7           | Frank   | null       | 50  |
| 8           | Grace   | null       | 48  |

**输出:**

| employee_id | name    | reports_count | average_age |
| ----------- | ------- | ------------- | ----------- |
| 1           | Michael | 2             | 40          |
| 2           | Alice   | 2             | 37          |
| 3           | Bob     | 1             | 37          |

## 正确答案 (MySQL)

你可以通过将 `Employees` 表与自身进行连接（self-join）来解决这个问题。一个表实例代表下属，另一个代表经理。

```sql
SELECT m.employee_id,
       m.name,
       COUNT(e.employee_id) AS reports_count,
       ROUND(AVG(e.age))    AS average_age
FROM Employees e
         JOIN
     Employees m ON e.reports_to = m.employee_id
GROUP BY m.employee_id, m.name
ORDER BY m.employee_id;
```

**查询逻辑分解:**

1. **`FROM Employees e JOIN Employees m ON e.reports_to = m.employee_id`**:

   - 这是一个自连接（self-join）。我们将 `Employees` 表视为两个不同的实体：`e` 代表下属员工 (employee)，`m` 代表经理 (
     manager)。
   - 连接条件 `e.reports_to = m.employee_id` 将每个下属员工与其直接经理关联起来。这个 `INNER JOIN` 自动过滤掉了没有下属的员工，因为他们的
     `employee_id` 不会出现在任何 `reports_to` 列中。

2. **`GROUP BY m.employee_id, m.name`**:

   - 我们按经理的 `employee_id` 和 `name` 进行分组，这样聚合函数就可以为每个经理计算其所有下属的统计数据。

3. **`SELECT ...`**:

   - `m.employee_id, m.name`: 选择经理的 ID 和姓名。
   - `COUNT(e.employee_id) AS reports_count`: 计算每个经理分组中的下属员工数量。
   - `AVG(e.age)`: 计算每个经理分组中下属员工的平均年龄。
   - `ROUND(...) AS average_age`: 将计算出的平均年龄四舍五入到最近的整数。

4. **`ORDER BY m.employee_id`**:
   - 最后，按照经理的 `employee_id` 对结果进行升序排序。
