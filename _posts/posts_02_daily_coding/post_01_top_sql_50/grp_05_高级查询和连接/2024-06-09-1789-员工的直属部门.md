---
title: 1789. 员工的直属部门
date: 2024-06-09 06:00:00 +0800
categories: [Daily Coding, Top SQL 50, 高级查询和连接]
tags: [高级查询和连接]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121165600157.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：1789. 员工的直属部门

**表:** `Employee`

| Column Name   | Type    |
| ------------- | ------- |
| employee_id   | int     |
| department_id | int     |
| primary_flag  | varchar |

- 这张表的主键为 `employee_id, department_id`。
- `employee_id` 是员工的 ID。
- `department_id` 是部门的 ID，表示员工与该部门有关系。
- `primary_flag` 是一个枚举类型，值分别为 ('Y', 'N')。如果值为'Y'，表示该部门是员工的直属部门。如果值是'N'，则否。

**问题描述:**

一个员工可以属于多个部门。当一个员工加入 **超过一个部门**
的时候，他需要决定哪个部门是他的直属部门。请注意，当员工只加入一个部门的时候，那个这个部门将默认为他的直属部门，虽然表记录的值为 '
N'。

请编写解决方案，查出员工所属的直属部门。

返回结果 **没有顺序要求**。

**示例 1:**

**输入:**
`Employee` table:

| employee_id | department_id | primary_flag |
| ----------- | ------------- | ------------ |
| 1           | 1             | N            |
| 2           | 1             | Y            |
| 2           | 2             | N            |
| 3           | 3             | N            |
| 4           | 2             | N            |
| 4           | 3             | Y            |
| 4           | 4             | N            |

**输出:**

| employee_id | department_id |
| ----------- | ------------- |
| 1           | 1             |
| 2           | 1             |
| 3           | 3             |
| 4           | 3             |

**解释:**

- 员工 1 的直属部门是 1 (因为他只在一个部门)。
- 员工 2 的直属部门是 1 (因为 `primary_flag` = 'Y')。
- 员工 3 的直属部门是 3 (因为他只在一个部门)。
- 员工 4 的直属部门是 3 (因为 `primary_flag` = 'Y')。

## 正确答案 (MySQL)

这个问题可以分解为两种情况来确定员工的直属部门：

1. 员工属于多个部门，其中一个部门的 `primary_flag` 被标记为 'Y'。
2. 员工只属于一个部门，那么这个部门就是他的直属部门。

我们可以分别查询这两种情况，然后使用 `UNION` 将结果合并起来。

```sql
-- 查询情况1: 员工在多个部门，找到 primary_flag = 'Y' 的部门
SELECT employee_id,
       department_id
FROM Employee
WHERE primary_flag = 'Y'

UNION

-- 查询情况2: 员工只在一个部门
SELECT employee_id,
       department_id
FROM Employee
GROUP BY employee_id
HAVING COUNT(department_id) = 1;
```

**查询逻辑分解:**

1. **第一个 `SELECT` 语句**:

   - `SELECT employee_id, department_id FROM Employee WHERE primary_flag = 'Y'`:
     这个查询直接找出所有被明确标记为直属部门 ('Y') 的员工和部门组合。

2. **第二个 `SELECT` 语句**:

   - `SELECT employee_id, department_id FROM Employee GROUP BY employee_id HAVING COUNT(department_id) = 1`:
     - `GROUP BY employee_id`: 按员工 ID 进行分组。
     - `HAVING COUNT(department_id) = 1`: 筛选出那些只属于一个部门的员工（即分组后计数为 1 的员工）。
     - 这个查询会返回所有只在一个部门的员工及其对应的唯一部门 ID。

3. **`UNION`**:
   - `UNION` 操作符将上述两个查询的结果合并成一个最终的结果集。它会自动去除重复的行（虽然在这个特定逻辑下不会产生重复），确保每个员工只返回一个直属部门。
