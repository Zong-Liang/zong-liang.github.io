---
title: 1164. 指定日期的产品价格
date: 2024-06-03 06:00:00 +0800
categories: [Daily Coding, Top SQL 50, 高级查询和连接]
tags: [高级查询和连接]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121165306182.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：1164. 指定日期的产品价格

**产品数据表:** `Products`

| Column Name | Type |
| ----------- | ---- |
| product_id  | int  |
| new_price   | int  |
| change_date | date |

- `(product_id, change_date)` 是此表的主键。
- 这张表的每一行分别记录了 某产品 在某个日期 更改后 的新价格。
- 一开始，所有产品价格都为 10。

**问题描述:**

编写一个解决方案，找出在 **2019-08-16** 所有产品的价格。

以 **任意顺序** 返回结果表。

**示例 1:**

**输入:**
`Products` 表:

| product_id | new_price | change_date |
| ---------- | --------- | ----------- |
| 1          | 20        | 2019-08-14  |
| 2          | 50        | 2019-08-14  |
| 1          | 30        | 2019-08-15  |
| 1          | 35        | 2019-08-16  |
| 2          | 65        | 2019-08-17  |
| 3          | 20        | 2019-08-18  |

**输出:**

| product_id | price |
| ---------- | ----- |
| 2          | 50    |
| 1          | 35    |
| 3          | 10    |

## 题解

这个问题的核心是找出每个产品在 `2019-08-16` 或此日期之前的最后一次价格变更。如果一个产品在该日期前从未变更过价格，则其价格为初始价
10。

```sql
SELECT p.product_id,
       IFNULL(last_price.price, 10) AS price
FROM (SELECT DISTINCT product_id FROM Products) AS p
         LEFT JOIN
     (SELECT product_id,
             new_price AS price
      FROM Products
      WHERE (product_id, change_date) IN (SELECT product_id,
                                                 MAX(change_date)
                                          FROM Products
                                          WHERE change_date <= '2019-08-16'
                                          GROUP BY product_id)) AS last_price ON p.product_id = last_price.product_id;
```

**查询逻辑分解:**

这个查询可以分为两个主要部分：

1. **内部子查询 `last_price`**:

   - 最内层的 `SELECT product_id, MAX(change_date) ...` 负责找出每个产品在 `2019-08-16` 或此日期之前的 **最后一次**
     价格变更日期。
   - 外一层的 `SELECT product_id, new_price ...` 使用 `IN` 子句，根据上面找到的 `(product_id, change_date)`
     组合，精确地获取到每个产品在最后一次有效变更时的 `new_price`。这个子查询的结果 `last_price` 包含了所有在
     `2019-08-16` 前有过价格变更的产品的有效价格。

2. **主查询 (外部 `SELECT`)**:
   - `FROM (SELECT DISTINCT product_id FROM Products) AS p`: 我们首先需要获取所有产品的 `product_id` 列表，以确保结果中包含每一个产品。
   - `LEFT JOIN ... AS last_price ON p.product_id = last_price.product_id`: 我们将所有产品列表 (`p`)
     与上面计算出的有效价格表 (`last_price`) 进行左连接。
     - 如果一个产品在 `2019-08-16` 前有过价格变更，它将在 `last_price` 中有对应的记录，连接成功。
     - 如果一个产品在该日期前从未变更过价格（如示例中的 `product_id = 3`），它在 `last_price` 中没有记录，连接后其
       `price` 字段将为 `NULL`。
   - `SELECT p.product_id, IFNULL(last_price.price, 10) AS price`:
     - `IFNULL(last_price.price, 10)` 是关键。如果 `last_price.price` 不为 `NULL`（连接成功），则使用该价格；如果为 `NULL`
       （连接失败），则使用初始价格 10。
