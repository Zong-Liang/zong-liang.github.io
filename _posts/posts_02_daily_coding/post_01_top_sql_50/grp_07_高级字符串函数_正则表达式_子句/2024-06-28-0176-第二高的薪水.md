---
title: 0176. 第二高的薪水
date: 2024-06-28 06:00:00 +0800
categories: [Daily Coding, Top SQL 50, 高级字符串函数_正则表达式_子句]
tags: [高级字符串函数_正则表达式_子句]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121170646549.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：0176. 第二高的薪水

**表结构:** `Employee`

| Column Name | Type |
| ----------- | ---- |
| id          | int  |
| salary      | int  |

`id` 是这个表的主键。表的每一行包含员工的工资信息。

**问题描述:**

查询并返回 `Employee` 表中第二高的 **不同** 薪水。如果不存在第二高的薪水，查询应该返回 `null`。

**示例 1:**

**输入:**
`Employee` 表:

| id  | salary |
| --- | ------ |
| 1   | 100    |
| 2   | 200    |
| 3   | 300    |

**输出:**

| SecondHighestSalary |
| ------------------- |
| 200                 |

**示例 2:**

**输入:**
`Employee` 表:

| id  | salary |
| --- | ------ |
| 1   | 100    |

**输出:**

| SecondHighestSalary |
| ------------------- |
| null                |

## 题解

你可以使用 `LIMIT` 和 `OFFSET` 子句来解决这个问题，并将整个查询作为子查询以处理不存在第二高薪水时返回 `NULL` 的情况。

```sql
SELECT (SELECT DISTINCT salary
        FROM Employee
        ORDER BY salary DESC
           LIMIT 1 OFFSET 1) AS SecondHighestSalary;

```

**查询逻辑分解:**

1. **`SELECT DISTINCT salary FROM Employee`**: 首先，从 `Employee` 表中选取所有唯一的薪水值。`DISTINCT`
   关键字确保了即使有多个员工拥有相同的薪水，该薪水值也只被考虑一次。
2. **`ORDER BY salary DESC`**: 将唯一的薪水值按降序排列，最高的薪水排在第一位。
3. **`LIMIT 1 OFFSET 1`**:
   - `OFFSET 1`: 跳过结果集中的第一行（即最高的薪水）。
   - `LIMIT 1`: 从跳过的位置开始，选取下一行（即第二高的薪水）。
4. **`SELECT (...) AS SecondHighestSalary`**: 将上述子查询的结果包装在外部 `SELECT`
   语句中。如果子查询没有找到结果（例如，表中只有一个薪水值，因此没有第二高的薪水），它将返回 `NULL`，这正是题目所要求的。结果列被重命名为
   `SecondHighestSalary`。
