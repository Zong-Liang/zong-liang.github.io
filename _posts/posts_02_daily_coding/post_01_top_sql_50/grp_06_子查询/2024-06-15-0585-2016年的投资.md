---
title: 0585. 2016年的投资
date: 2024-06-15 06:00:00 +0800
categories: [Daily Coding, Top SQL 50, 子查询]
tags: [子查询]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121170139430.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：0585. 2016 年的投资

**表结构:** `Insurance`

| Column Name | Type  |
| ----------- | ----- |
| pid         | int   |
| tiv_2015    | float |
| tiv_2016    | float |
| lat         | float |
| lon         | float |

- `pid` 是这张表的主键。
- 表中的每一行都包含一条保险信息，其中：
  - `pid` 是投保人的投保编号。
  - `tiv_2015` 是该投保人在 2015 年的总投保金额。
  - `tiv_2016` 是该投保人在 2016 年的总投保金额。
  - `lat` 是投保人所在城市的纬度。题目数据确保 `lat` 不为空。
  - `lon` 是投保人所在城市的经度。题目数据确保 `lon` 不为空。

**问题描述:**

编写解决方案报告 2016 年 (`tiv_2016`) 所有满足下述条件的投保人的投保金额之和：

- 他在 2015 年的投保额 (`tiv_2015`) 至少跟一个其他投保人在 2015 年的投保额相同。
- 他所在的城市必须与其他投保人都不同（也就是说 `(lat, lon)` 不能跟其他任何一个投保人完全相同）。

`tiv_2016` 四舍五入的 **两位小数**。


**示例 1:**

**输入:**
`Insurance` 表:

| pid | tiv_2015 | tiv_2016 | lat | lon |
| --- | -------- | -------- | --- | --- |
| 1   | 10       | 5        | 10  | 10  |
| 2   | 20       | 20       | 20  | 20  |
| 3   | 10       | 30       | 20  | 20  |
| 4   | 10       | 40       | 40  | 40  |

**输出:**

| tiv_2016 |
| -------- |
| 45.00    |

**解释:**

- 表中的第一条记录和最后一条记录都满足两个条件。
  `tiv_2015` 值为 10 与第三条和第四条记录相同，且其位置是唯一的。
- 第二条记录不符合任何一个条件。其 `tiv_2015` 与其他投保人不同，并且位置与第三条记录相同，这也导致了第三条记录不符合题目要求。
- 因此，结果是第一条记录和最后一条记录的 `tiv_2016` 之和，即 45。


## 题解

你可以使用子查询来分别筛选出满足两个条件的 `pid`，然后计算它们的 `tiv_2016` 之和。

```sql
SELECT ROUND(SUM(i.tiv_2016), 2) AS tiv_2016
FROM Insurance i
WHERE
  -- 条件1: 至少有一个其他人的 tiv_2015 与其相同
    i.tiv_2015 IN (SELECT tiv_2015
                   FROM Insurance
                   GROUP BY tiv_2015
                   HAVING COUNT(*) > 1)
  -- 条件2: 地理位置 (lat, lon) 是唯一的
  AND (i.lat, i.lon) IN (SELECT lat,
                                lon
                         FROM Insurance
                         GROUP BY lat, lon
                         HAVING COUNT(*) = 1);
```

**查询逻辑分解:**

1. **主查询**: `SELECT ROUND(SUM(i.tiv_2016), 2) AS tiv_2016 FROM Insurance i WHERE ...`
   - 目标是计算 `tiv_2016` 的总和，并使用 `ROUND(..., 2)` 函数将结果四舍五入到两位小数。
2. **第一个子查询 (条件 1)**: `i.tiv_2015 IN (SELECT ...)`
   - `SELECT tiv_2015 FROM Insurance GROUP BY tiv_2015 HAVING COUNT(*) > 1`: 这个子查询找出所有出现次数大于 1 的
     `tiv_2015` 值。
   - `i.tiv_2015 IN (...)`: 主查询通过 `IN` 子句筛选出那些 `tiv_2015` 值在上述子查询结果集中的记录。
3. **第二个子查询 (条件 2)**: `AND (i.lat, i.lon) IN (SELECT ...)`
   - `SELECT lat, lon FROM Insurance GROUP BY lat, lon HAVING COUNT(*) = 1`: 这个子查询按地理位置 (`lat`, `lon`)
     分组，并找出只出现过一次的地理位置组合。
   - `(i.lat, i.lon) IN (...)`: 主查询进一步筛选，要求记录的地理位置必须在上述唯一地理位置的结果集中。
4. **`AND`**: 只有同时满足这两个条件的记录才会被最终选中，并计入 `SUM` 的计算。
