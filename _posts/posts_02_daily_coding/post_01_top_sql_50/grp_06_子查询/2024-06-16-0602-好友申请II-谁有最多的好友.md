---
title: 0602. 好友申请 II ：谁有最多的好友
date: 2024-06-16 06:00:00 +0800
categories: [Daily Coding, Top SQL 50, 子查询]
tags: [子查询]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121170214086.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：0602. 好友申请 II ：谁有最多的好友

**表结构:** `RequestAccepted`

| Column Name  | Type |
| ------------ | ---- |
| requester_id | int  |
| accepter_id  | int  |
| accept_date  | date |

- `(requester_id, accepter_id)` 是这张表的主键。
- 这张表包含发送好友请求的人的 ID，接收好友请求的人的 ID，以及好友请求通过的日期。

**问题描述:**

编写解决方案，找出拥有最多的好友的人和他拥有的好友数目。

生成的测试用例保证拥有最多好友数目的只有 1 个人。


**示例 1:**

**输入:**
`RequestAccepted` 表:

| requester_id | accepter_id | accept_date |
| ------------ | ----------- | ----------- |
| 1            | 2           | 2016/06/03  |
| 1            | 3           | 2016/06/08  |
| 2            | 3           | 2016/06/08  |
| 3            | 4           | 2016/06/09  |

**输出:**

| id  | num |
| --- | --- |
| 3   | 3   |

**解释:**
编号为 3 的人是编号为 1，2 和 4 的人的好友，所以他总共有 3 个好友，比其他人都多。

**进阶:**
在真实世界里，可能会有多个人拥有好友数相同且最多，你能找到所有这些人吗？


## 题解

这个问题的关键在于，好友关系是双向的。如果 A 接受了 B 的请求，那么 A 和 B 都是彼此的好友。因此，我们需要统计每个 ID 在
`requester_id` 和 `accepter_id` 两列中出现的总次数。

```sql
SELECT id,
       COUNT(*) AS num
FROM (SELECT requester_id AS id
      FROM RequestAccepted
      UNION ALL
      SELECT accepter_id AS id
      FROM RequestAccepted) AS friends
GROUP BY id
ORDER BY num DESC LIMIT 1;
```

**查询逻辑分解:**

1. **创建好友关系全集**:

   - 我们使用一个子查询
     `(SELECT requester_id AS id FROM RequestAccepted UNION ALL SELECT accepter_id AS id FROM RequestAccepted)`
     来创建一个包含所有用户 ID 的临时表 `friends`。
   - `SELECT requester_id AS id`: 选取所有发起请求的用户 ID。
   - `SELECT accepter_id AS id`: 选取所有接受请求的用户 ID。
   - `UNION ALL`: 将这两个列表合并。使用 `UNION ALL` 而不是 `UNION` 是非常重要的，因为它会保留所有的 ID 实例，而 `UNION`
     会去重。每个 ID 在这个合并列表中出现一次，就代表他拥有一个好友。

2. **分组和计数**:

   - `GROUP BY id`: 我们按用户 ID 对这个合并后的列表进行分组。
   - `COUNT(*) AS num`: 对于每个分组（即每个用户），我们计算其出现的总次数，这个次数就是他所拥有的好友总数。

3. **排序和筛选**:
   - `ORDER BY num DESC`: 将结果按好友数量 (`num`) 降序排列。
   - `LIMIT 1`: 由于题目保证了只有一个用户拥有最多的好友，我们使用 `LIMIT 1` 来获取好友数最多的那一行记录。

**对于进阶问题的解答 (找出所有好友数最多的人):**

如果需要找出所有好友数最多的人（可能不止一个），可以使用窗口函数或者在上述查询的基础上再进行一次查询。使用公共表表达式 (CTE)
会更清晰：

```sql
WITH FriendCounts AS (SELECT id,
                             COUNT(*) AS num
                      FROM (SELECT requester_id AS id
                            FROM RequestAccepted
                            UNION ALL
                            SELECT accepter_id AS id
                            FROM RequestAccepted) AS friends
                      GROUP BY id)
SELECT id,
       num
FROM FriendCounts
WHERE num = (SELECT MAX(num) FROM FriendCounts);
```
