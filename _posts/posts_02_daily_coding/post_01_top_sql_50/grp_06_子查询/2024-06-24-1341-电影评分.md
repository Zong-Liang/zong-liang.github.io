---
title: 1341. 电影评分
date: 2024-06-24 06:00:00 +0800
categories: [Daily Coding, Top SQL 50, 子查询]
tags: [子查询]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121170517128.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：1341. 电影评分

**表结构:**

`Movies`

| Column Name | Type    |
| ----------- | ------- |
| movie_id    | int     |
| title       | varchar |

- `movie_id` 是这个表的主键。
- `title` 是电影的名字。
- 每部电影都有一个唯一的 `title`。

`Users`

| Column Name | Type    |
| ----------- | ------- |
| user_id     | int     |
| name        | varchar |

- `user_id` 是表的主键。
- `name` 列具有唯一值。

`MovieRating`

| Column Name | Type |
| ----------- | ---- |
| movie_id    | int  |
| user_id     | int  |
| rating      | int  |
| created_at  | date |

- `(movie_id, user_id)` 是这个表的主键。
- 这个表包含用户在其评论中对电影的评分 `rating`。
- `created_at` 是用户的点评日期。

**问题描述:**

请你编写一个解决方案：

- 查找评论电影数量最多的用户名。如果出现平局，返回字典序较小的用户名。
- 查找在 **February 2020** 平均评分最高的电影名称。如果出现平局，返回字典序较小的电影名称。

返回结果格式如下例所示。

**示例 1:**

**输入:**

`Movies` 表:

| movie_id | title    |
| -------- | -------- |
| 1        | Avengers |
| 2        | Frozen 2 |
| 3        | Joker    |

`Users` 表:

| user_id | name   |
| ------- | ------ |
| 1       | Daniel |
| 2       | Monica |
| 3       | Maria  |
| 4       | James  |

`MovieRating` 表:

| movie_id | user_id | rating | created_at |
| -------- | ------- | ------ | ---------- |
| 1        | 1       | 3      | 2020-01-12 |
| 1        | 2       | 4      | 2020-02-11 |
| 1        | 3       | 2      | 2020-02-12 |
| 1        | 4       | 1      | 2020-01-01 |
| 2        | 1       | 5      | 2020-02-17 |
| 2        | 2       | 2      | 2020-02-01 |
| 2        | 3       | 2      | 2020-03-01 |
| 3        | 1       | 3      | 2020-02-22 |
| 3        | 2       | 4      | 2020-02-25 |

**输出:**

`Result` 表:

| results  |
| -------- |
| Daniel   |
| Frozen 2 |

**解释:**

- Daniel 和 Monica 都点评了 3 部电影 ("Avengers", "Frozen 2" 和 "Joker") 但是 Daniel 字典序比较小。
- Frozen 2 和 Joker 在 2 月的评分都是 3.5, 但是 Frozen 2 的字典序比较小。

## 题解

这个问题需要执行两个独立的查询，然后将它们的结果合并。`UNION ALL` 是实现这一点的理想选择。

```sql
(
    -- 查询 1: 找到评论最多的用户
    SELECT u.name AS results
    FROM MovieRating mr
             JOIN
         Users u ON mr.user_id = u.user_id
    GROUP BY u.user_id
    ORDER BY COUNT(mr.movie_id) DESC, u.name ASC LIMIT 1)
UNION ALL
(
    -- 查询 2: 找到 2020年2月 平均分最高的电影
    SELECT m.title AS results
    FROM MovieRating mr
             JOIN
         Movies m ON mr.movie_id = m.movie_id
    WHERE DATE_FORMAT(mr.created_at, '%Y-%m') = '2020-02'
    GROUP BY m.movie_id
    ORDER BY AVG(mr.rating) DESC, m.title ASC LIMIT 1);
```

**查询逻辑分解:**

这个解决方案由两个独立的查询组成，并通过 `UNION ALL` 合并。

1. **第一个查询 (括号内上半部分):**

   - **目标:** 找到评论最多的用户。
   - `JOIN Users ...`: 连接 `MovieRating` 和 `Users` 表以获取用户名。
   - `GROUP BY u.user_id`: 按用户分组。
   - `ORDER BY COUNT(mr.movie_id) DESC, u.name ASC`: 首先按评论数降序排序，如果评论数相同（平局），则按用户名字典序（升序）排序。
   - `LIMIT 1`: 选取排序后的第一行，即为最终结果。
   - `SELECT u.name AS results`: 选择该用户的名字，并将其列别名设为 `results`。

2. **第二个查询 (括号内下半部分):**

   - **目标:** 找到 2020 年 2 月平均分最高的电影。
   - `JOIN Movies ...`: 连接 `MovieRating` 和 `Movies` 表以获取电影标题。
   - `WHERE DATE_FORMAT(mr.created_at, '%Y-%m') = '2020-02'`: 筛选出所有在 2020 年 2 月的评论。
   - `GROUP BY m.movie_id`: 按电影分组。
   - `ORDER BY AVG(mr.rating) DESC, m.title ASC`: 首先按平均分降序排序，如果平均分相同（平局），则按电影标题字典序（升序）排序。
   - `LIMIT 1`: 选取排序后的第一行，即为最终结果。
   - `SELECT m.title AS results`: 选择该电影的标题。

3. **`UNION ALL`**: 将两个查询的结果垂直合并到一个名为 `results` 的列中。
