---
title: 0185. 部门工资前三高的所有员工
date: 2024-06-13 06:00:00 +0800
categories: [Daily Coding, Top SQL 50, 子查询]
tags: [子查询]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121170043816.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：0185. 部门工资前三高的所有员工

**表结构:**

`Employee`

| Column Name  | Type    |
| ------------ | ------- |
| id           | int     |
| name         | varchar |
| salary       | int     |
| departmentId | int     |

- `id` 是该表的主键列。
- `departmentId` 是 `Department` 表中 `id` 的外键。
- 该表的每一行都表示员工的 ID、姓名和工资。它还包含了他们部门的 ID。

`Department`

| Column Name | Type    |
| ----------- | ------- |
| id          | int     |
| name        | varchar |

- `id` 是该表的主键列。
- 该表的每一行表示部门 ID 和部门名。

**问题描述:**

公司的主管们感兴趣的是公司每个部门中谁赚的钱最多。一个部门的 **高收入者** 是指一个员工的工资在该部门的 **不同** 工资中 **排名前三**。

编写解决方案，找出每个部门中收入高的员工。

以 **任意顺序** 返回结果表。

**示例 1:**

**输入:**

`Employee` 表:

| id  | name  | salary | departmentId |
| --- | ----- | ------ | ------------ |
| 1   | Joe   | 85000  | 1            |
| 2   | Henry | 80000  | 2            |
| 3   | Sam   | 60000  | 2            |
| 4   | Max   | 90000  | 1            |
| 5   | Janet | 69000  | 1            |
| 6   | Randy | 85000  | 1            |
| 7   | Will  | 70000  | 1            |

`Department` 表:

| id  | name  |
| --- | ----- |
| 1   | IT    |
| 2   | Sales |

**输出:**

| Department | Employee | Salary |
| ---------- | -------- | ------ |
| IT         | Max      | 90000  |
| IT         | Joe      | 85000  |
| IT         | Randy    | 85000  |
| IT         | Will     | 70000  |
| Sales      | Henry    | 80000  |
| Sales      | Sam      | 60000  |

**解释:**

在 IT 部门:

- Max 的工资最高
- 兰迪和乔都赚取第二高的独特的薪水
- 威尔的薪水是第三高的

在销售部:

- 亨利的工资最高
- 山姆的薪水第二高
- 没有第三高的工资，因为只有两名员工

## 题解

这个问题非常适合使用窗口函数 `DENSE_RANK()` 来解决，因为它可以处理薪资相同并列排名的情况，并且不会跳过排名。

```sql
WITH RankedSalaries AS (SELECT e.name AS    Employee,
                               e.salary,
                               e.departmentId,
                               DENSE_RANK() OVER (PARTITION BY e.departmentId ORDER BY e.salary DESC) AS salary_rank
                        FROM Employee e)
SELECT d.name    AS Department,
       rs.Employee,
       rs.salary AS Salary
FROM RankedSalaries rs
         JOIN
     Department d ON rs.departmentId = d.id
WHERE rs.salary_rank <= 3;
```

**查询逻辑分解:**

1. **`WITH RankedSalaries AS (...)`**: 使用公共表表达式 (CTE) 来创建一个临时的、已排名的结果集。
2. **`DENSE_RANK() OVER (PARTITION BY e.departmentId ORDER BY e.salary DESC) AS salary_rank`**: 这是窗口函数的核心部分。

   - `PARTITION BY e.departmentId`: 将员工按其所在的部门进行分组。排名将在每个部门内独立计算。
   - `ORDER BY e.salary DESC`: 在每个部门分组内，根据薪水进行降序排列。
   - `DENSE_RANK()`: 计算每一行的排名。如果薪水相同，则排名也相同，并且后续排名不会跳跃（例如，排名为 1, 2, 2, 3）。这完全符合题目中“不同工资中排名前三”的要求。

3. **`SELECT ... FROM RankedSalaries rs JOIN Department d ...`**: 将我们创建的排名结果 `RankedSalaries` (别名为 `rs`) 与 `Department` 表 (别名为 `d`) 进行连接，以便获取部门的名称。
4. **`WHERE rs.salary_rank <= 3`**: 从连接后的结果中筛选出薪水排名小于或等于 3 的所有员工。
