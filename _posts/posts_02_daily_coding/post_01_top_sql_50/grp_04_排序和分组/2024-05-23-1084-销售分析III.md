---
title: 1084. 销售分析 III
date: 2024-05-23 06:00:00 +0800
categories: [Daily Coding, Top SQL 50, 排序和分组]
tags: [排序和分组]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121164706267.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：1084. 销售分析 III

**表结构:**

`Product`

| Column Name  | Type    |
| ------------ | ------- |
| product_id   | int     |
| product_name | varchar |
| unit_price   | int     |

- `product_id` 是该表的主键（具有唯一值的列）。
- 该表的每一行显示每个产品的名称和价格。

`Sales`

| Column Name | Type |
| ----------- | ---- |
| seller_id   | int  |
| product_id  | int  |
| buyer_id    | int  |
| sale_date   | date |
| quantity    | int  |
| price       | int  |

- 这个表可能含有重复的行。
- `product_id` 是 `Product` 表的外键 (reference 列)。
- 该表的每一行包含关于一个销售的一些信息。

**问题描述:**

编写解决方案，报告 2019 年春季 **才** 售出的产品。即 **仅** 在 `2019-01-01` (含) 至 `2019-03-31` (含) 之间出售的商品。

以 **任意顺序** 返回结果表。


**示例 1:**

**输入:**
`Product` table:

| product_id | product_name | unit_price |
| ---------- | ------------ | ---------- |
| 1          | S8           | 1000       |
| 2          | G4           | 800        |
| 3          | iPhone       | 1400       |

`Sales` table:

| seller_id | product_id | buyer_id | sale_date  | quantity | price |
| --------- | ---------- | -------- | ---------- | -------- | ----- |
| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |
| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |
| 2         | 2          | 3        | 2019-06-02 | 1        | 800   |
| 3         | 3          | 4        | 2019-05-13 | 2        | 2800  |

**输出:**

| product_id | product_name |
| ---------- | ------------ |
| 1          | S8           |

**解释:**

- id 为 1 的产品仅在 2019 年春季销售。
- id 为 2 的产品在 2019 年春季销售, 但也在 2019 年春季之后销售。
- id 为 3 的产品在 2019 年春季之后销售。
- 我们只返回 id 为 1 的产品, 因为它是 2019 年春季才销售的产品。


## 正确答案 (MySQL)

这个问题的关键是找到那些 **所有** 销售日期都在指定范围内的产品。我们可以通过按产品分组，并检查其最小和最大销售日期来实现。

```sql
SELECT p.product_id,
       p.product_name
FROM Product p
         JOIN
     Sales s ON p.product_id = s.product_id
GROUP BY p.product_id, p.product_name
HAVING MIN(s.sale_date) >= '2019-01-01'
   AND MAX(s.sale_date) <= '2019-03-31';
```

**查询逻辑分解:**

1. **`FROM Product p JOIN Sales s ON p.product_id = s.product_id`**:

   - 首先，我们将 `Product` 表和 `Sales` 表连接起来，以便将产品信息（如 `product_name`）与销售信息（如 `sale_date`）关联起来。

2. **`GROUP BY p.product_id, p.product_name`**:

   - 我们按 `product_id` 和 `product_name` 对结果进行分组。这样，所有与同一产品相关的销售记录都会被归为一组，以便我们对每个产品的所有销售日期进行分析。

3. **`HAVING MIN(s.sale_date) >= '2019-01-01' AND MAX(s.sale_date) <= '2019-03-31'`**:

   - 这是筛选的核心逻辑，`HAVING` 子句在分组后对组进行过滤。
   - `MIN(s.sale_date) >= '2019-01-01'`: 对于每个产品组，检查其 **最早** 的销售日期是否在春季开始之后（或当天）。
   - `MAX(s.sale_date) <= '2019-03-31'`: 检查其 **最晚** 的销售日期是否在春季结束之前（或当天）。
   - 只有当一个产品的 **所有** 销售日期都满足这两个条件时（即最早和最晚的日期都在范围内），该产品组才会被保留。

4. **`SELECT p.product_id, p.product_name`**:
   - 最后，从通过 `HAVING` 子句筛选的组中，选择 `product_id` 和 `product_name`。
