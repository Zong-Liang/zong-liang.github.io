---
title: Java输入输出
date: 2024-06-15 06:00:00 +0800
categories: [Daily Coding, Coding Tips, Java输入输出]
tags: [Java输入输出]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251123152957906.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

Java I/O (Input/Output) 流是 Java 与外部世界（如文件、网络）进行数据交换的基础。

## 核心概念总结

1.  **I/O 流的分类**：字节流 vs. 字符流。
2.  **文件 I/O**：使用 `FileInputStream` / `FileOutputStream` (字节) 和 `FileReader` / `FileWriter` (字符)。
3.  **处理流 (装饰器模式)**：使用 `Buffered...` 流来提高性能。
4.  **对象序列化**：使用 `ObjectInputStream` / `ObjectOutputStream` 来读写 Java 对象。
5.  **桥接流**：使用 `InputStreamReader` 在字节流和字符流之间架起桥梁，并处理字符编码。
6.  **现代 I/O (NIO.2)**：介绍 `java.nio.file` 包中的 `Path` 和 `Files`，展示更简洁高效的文件操作方式。

## Java 代码

这个示例由两个文件组成。请将它们放在同一个文件夹中。

### 文件 1: `User.java` (一个可序列化的类)

这个类用于演示对象流。`implements Serializable` 标记告诉 JVM 这个类的对象可以被“扁平化”成一个字节序列。

```java
import java.io.Serializable;

/**
 * @author zongliang_i
 *
 * User.java - 一个简单的POJO (Plain Old Java Object)。
 * 为了能被 ObjectInputStream/ObjectOutputStream 处理，
 * 它必须实现 Serializable 接口。这是一个标记接口，没有需要实现的方法。
 */
public class User implements Serializable {
    // 序列化版本号，用于版本控制
    private static final long serialVersionUID = 1L;

    private String username;
    private int level;
    // transient 关键字标记的字段将不会被序列化
    private transient String password;

    public User(String username, int level, String password) {
        this.username = username;
        this.level = level;
        this.password = password;
    }

    @Override
    public String toString() {
        return "User{" +
               "username='" + username + '\'' +
               ", level=" + level +
               ", password='" + password + '\'' + // 在反序列化后，这个会是 null
               '}';
    }
}
```

### 文件 2: `Main.java` (主程序)

```java
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

/**
 * @author zongliang_i
 *
 * 这是一个用于学习Java中经典I/O流和现代NIO.2文件操作的综合示例。
 */
public class Main {

    // 定义将在程序中创建的文件的名称
    private static final String BYTE_FILE = "binary_data.dat";
    private static final String CHAR_FILE = "text_data.txt";
    private static final String OBJECT_FILE = "user_object.ser";
    private static final String NIO_FILE = "nio_text_data.txt";

    public static void main(String[] args) {
        try {
            System.out.println("--- 1. 字节流 (Byte Streams): 处理原始二进制数据 ---");
            demonstrateByteStreams();

            System.out.println("\n--- 2. 字符流 (Character Streams): 处理文本数据 ---");
            demonstrateCharacterStreams();

            System.out.println("\n--- 3. 对象流 (Object Streams): 序列化与反序列化 ---");
            demonstrateObjectStreams();

            System.out.println("\n--- 4. 现代 I/O (NIO.2): 更简洁的文件操作 ---");
            demonstrateNio2();

        } catch (IOException | ClassNotFoundException e) {
            // 捕获所有演示中可能出现的异常
            e.printStackTrace();
        }
    }

    /**
     * 1. 演示字节流：FileInputStream, FileOutputStream
     *    并使用 BufferedInputStream, BufferedOutputStream 提高性能。
     */
    public static void demonstrateByteStreams() throws IOException {
        System.out.println("正在向 " + BYTE_FILE + " 写入二进制数据...");
        // 使用 try-with-resources 自动关闭流
        try (
            // FileOutputStream: 直接写入文件的节点流
            FileOutputStream fos = new FileOutputStream(BYTE_FILE);
            // BufferedOutputStream: 包装节点流，提供缓冲功能以提高效率的处理流
            BufferedOutputStream bos = new BufferedOutputStream(fos)
        ) {
            byte[] data = {0x4A, 0x41, 0x56, 0x41}; // "JAVA" 的 ASCII 码
            bos.write(data);
        } // bos 和 fos 在这里会被自动关闭

        System.out.println("正在从 " + BYTE_FILE + " 读取二进制数据...");
        try (
            FileInputStream fis = new FileInputStream(BYTE_FILE);
            BufferedInputStream bis = new BufferedInputStream(fis)
        ) {
            int byteRead;
            System.out.print("读取到的字节 (十六进制): ");
            while ((byteRead = bis.read()) != -1) { // read() 返回 -1 表示到达文件末尾
                System.out.printf("0x%X ", byteRead);
            }
            System.out.println();
        }
    }

    /**
     * 2. 演示字符流：FileWriter, FileReader
     *    并使用 BufferedWriter, BufferedReader 提高性能，并提供便利方法。
     */
    public static void demonstrateCharacterStreams() throws IOException {
        System.out.println("正在向 " + CHAR_FILE + " 写入文本...");
        try (
            FileWriter fw = new FileWriter(CHAR_FILE);
            BufferedWriter writer = new BufferedWriter(fw)
        ) {
            writer.write("你好, Java IO!");
            writer.newLine(); // 写入一个平台无关的换行符
            writer.write("这是第二行。");
        }

        System.out.println("正在从 " + CHAR_FILE + " 逐行读取文本...");
        try (
            FileReader fr = new FileReader(CHAR_FILE);
            BufferedReader reader = new BufferedReader(fr)
        ) {
            String line;
            while ((line = reader.readLine()) != null) { // readLine() 是 BufferedReader 的便利方法
                System.out.println("  " + line);
            }
        }
    }

    /**
     * 3. 演示对象流：ObjectOutputStream, ObjectInputStream
     *    用于将Java对象写入文件（序列化），再从文件读回内存（反序列化）。
     */
    public static void demonstrateObjectStreams() throws IOException, ClassNotFoundException {
        User user = new User("Alice", 99, "mySecretPassword");
        System.out.println("原始对象: " + user);

        System.out.println("正在将 User 对象序列化到 " + OBJECT_FILE + "...");
        try (
            FileOutputStream fos = new FileOutputStream(OBJECT_FILE);
            ObjectOutputStream oos = new ObjectOutputStream(fos)
        ) {
            oos.writeObject(user);
        }

        System.out.println("正在从 " + OBJECT_FILE + " 反序列化 User 对象...");
        try (
            FileInputStream fis = new FileInputStream(OBJECT_FILE);
            ObjectInputStream ois = new ObjectInputStream(fis)
        ) {
            User userFromFile = (User) ois.readObject(); // readObject() 返回 Object，需要强制类型转换
            System.out.println("反序列化后的对象: " + userFromFile);
            System.out.println("注意: transient 字段 'password' 没有被序列化，所以是 null。");
        }
    }

    /**
     * 4. 演示 Java 7+ 的 NIO.2 (New IO)
     *    使用 Path 和 Files 工具类，代码更简洁。
     */
    public static void demonstrateNio2() throws IOException {
        Path path = Paths.get(NIO_FILE);
        System.out.println("使用 NIO.2 向 " + path.getFileName() + " 写入文本...");

        // 一行代码写入多行文本 (默认使用 UTF-8 编码)
        List<String> lines = List.of("NIO.2 is powerful.", "It simplifies file I/O.");
        Files.write(path, lines);

        System.out.println("使用 NIO.2 从 " + path.getFileName() + " 读取所有行...");
        // 一行代码读取所有行到 List
        List<String> readLines = Files.readAllLines(path);
        readLines.forEach(line -> System.out.println("  " + line));
    }
}
```
