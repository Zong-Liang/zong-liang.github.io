---
title: 比较最佳实践
date: 2024-12-27 06:00:00 +0800
categories: [Daily Coding, Coding Tips, 比较]
tags: [比较]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251129192831952.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

“比较”在 Java 开发中看似简单，实则暗坑无数。从基础的 `==` 到复杂的对象排序，再到分布式环境下的数据一致性校验，错误的比较方式轻则导致业务逻辑 BUG（如金额计算错误），重则导致内存泄漏（HashMap key 丢失）或严重的生产事故。

## 一、 对象相等性 (Equality) —— `equals` 与 `hashCode`

这是 Java 比较的基石。

### 1. 核心铁律

> **如果重写了 `equals()`，必须重写 `hashCode()`。**

- **原因**：Java 的哈希集合（`HashMap`, `HashSet`）是先通过 `hashCode` 确定桶位（Bucket），再通过 `equals` 比较 Key 是否相同。
- **后果**：如果违背此原则，两个逻辑上相等的对象（equals 为 true）可能有不同的 hash code，导致在这个 Set 中存入了两份数据，或者在 Map 中 `get()` 不到存入的值。

### 2. `equals` 的标准写法（IDE 生成模板解析）

不要手动去写，容易漏判空。推荐使用 IntelliJ IDEA 生成或 Lombok，但你要懂其中的逻辑：

```java
@Override
public boolean equals(Object o) {
    // 1. 引用物理地址比较：若是同一个对象，直接返回 true（性能优化，短路）
    if (this == o) return true;

    // 2. 类型检查：
    // 写法 A：if (o == null || getClass() != o.getClass()) return false;
    // 写法 B：if (!(o instanceof MyClass)) return false;

    // 建议：通常使用写法 A (getClass)。
    // 原因：写法 B (instanceof) 允许子类相等，这在某些设计（如 Hibernate 代理对象）中有用，
    // 但在大多数值对象（Value Object）比较中，我们不希望父类和子类被判定为相等，以免破坏对称性。
    if (o == null || getClass() != o.getClass()) return false;

    // 3. 强制类型转换
    User user = (User) o;

    // 4. 关键域比较：推荐使用 Objects.equals 工具类防止 NPE
    return Objects.equals(id, user.id) &&
           Objects.equals(name, user.name);
}
```

### 3. 避免 `NullPointerException` (NPE) 的技巧

- **错误**：`object.equals("constants")` -> 如果 object 为 null，报 NPE。
- **最佳实践**：

  - **常量在前**：`"constants".equals(object)`
  - **工具类**：`java.util.Objects.equals(a, b)` —— **这是最推荐的写法**，它自动处理了两个都是 null 或其中一个是 null 的情况。

## 二、 顺序比较 (Ordering) —— `Comparable` 与 `Comparator`

涉及排序（Sort）时的最佳实践。

### 1. `Comparable` (内部比较器)

- **场景**：定义类的**自然排序**（Natural Order）。例如 `String` 默认按字典序，`Integer` 默认按数值。
- **实践**：只有当这个类有且仅有一种“显而易见”的排序逻辑时，才实现此接口（如 ID、时间戳）。

### 2. `Comparator` (外部比较器) —— **推荐主力使用**

- **场景**：策略模式，灵活定义多种排序规则，且不侵入实体类代码。
- **现代 Java (Java 8+) 最佳实践**：

  不要再写那种 `if (x > y) return 1` 的冗长代码了，使用声明式语法，清晰且不易出错：

  ```java
  // 假设我们要对 Employee 按部门排序，部门相同按薪资降序，薪资相同按姓名处理 null
  Comparator<Employee> comparator = Comparator
      .comparing(Employee::getDepartment)                 // 第一关键字
      .thenComparing(Employee::getSalary, Comparator.reverseOrder()) // 第二关键字（降序）
      .thenComparing(Employee::getName, Comparator.nullsLast(String::compareTo)); // 处理 null

  list.sort(comparator);
  ```

### 3. 这里的坑：`compareTo` 与 `equals` 的一致性

`Set` 和 `Map` 的实现类中，`TreeSet`/`TreeMap` 使用 `compareTo` 判断唯一性，而 `HashSet`/`HashMap` 使用 `equals`。

- **反面教材**：`BigDecimal`。

  - `new BigDecimal("1.0").equals(new BigDecimal("1.00"))` -> **false** (equals 比较精度 scale)
  - `new BigDecimal("1.0").compareTo(new BigDecimal("1.00"))` -> **0** (compareTo 认为是相等的)

- **建议**：如果你在使用 `TreeSet` 存储自定义对象，务必保证 `compareTo` 返回 0 时，`equals` 也返回 true。

## 三、 特殊类型的比较陷阱

### 1. 包装类与基本类型 (Integer vs int)

- **现象**：

  ```java
  Integer a = 127, b = 127;
  System.out.println(a == b); // true (命中缓存)

  Integer c = 128, d = 128;
  System.out.println(c == d); // false (超出缓存范围 -128~127)
  ```

- **最佳实践**：

  - 所有 **对象引用类型**（Integer, Long, Boolean...）的比较，**必须使用 `equals()`**。
  - 禁止使用 `==` 比较包装类，除非你非常确定你在比较内存地址（极少情况）。
  - 在代码审查（Code Review）中，看到 `Integer == Integer` 直接打回。

### 2. 浮点数 (Float / Double)

- **现象**：`0.1 + 0.2 == 0.3` -> false。
- **最佳实践**：

  - **禁止**直接使用 `==` 比较浮点数。
  - **科学计算**：使用 `Double.compare(d1, d2) == 0` 或指定误差范围（Epsilon）。
  - **金额计算**：**必须使用 `BigDecimal`**，且构造时必须传入 String (`new BigDecimal("0.1")`)，比较时使用 `compareTo`（忽略精度差异）或视业务情况使用 `equals`。

### 3. 数组 (Array)

- **错误**：`arr1.equals(arr2)` —— 数组没有重写 equals，这比较的是地址。
- **最佳实践**：

  - 比较内容是否相同：`Arrays.equals(arr1, arr2)`
  - 比较多维数组/嵌套结构：`Arrays.deepEquals(arr1, arr2)`

### 4. 枚举 (Enum)

- **冷知识**：枚举是单例的。
- **最佳实践**：枚举可以使用 `==` 进行比较，这比 `equals` 效率更高且绝对安全（还能避免 NPE）。

  ```java
  if (status == Status.SUCCESS) { ... } // 推荐
  ```

### 5. String

- **切记**：字符串比较**永远**使用 `equals()`。
- **原因**：虽然 String Pool 存在，但 `new String("a")` 会强制在堆上创建新对象，导致 `==` 失败。

## 四、 工程化与架构层面的建议

### 1. 使用 Lombok 的 `@Data` 或 `@EqualsAndHashCode`

- **优点**：减少样板代码。
- **警告**：

  - **JPA/Hibernate 实体类**：**慎用** `@Data`。因为 Lombok 会默认将所有字段（包括关联的 `@OneToMany` 集合）加入 `hashCode` 计算，这会触发数据库懒加载（Lazy Loading），导致严重的性能问题甚至 `StackOverflowError`。
  - **继承关系**：如果使用继承，需加上 `@EqualsAndHashCode(callSuper = true)`，否则两个父类属性不同但子类属性相同的对象会被判定为相等。

### 2. Java 14+ Record (记录类)

如果是纯数据载体（DTO, BO），强烈建议使用 **Record**。

```java
public record User(Long id, String name) {}
```

- JDK 自动帮你生成了最标准、最高效的 `equals`、`hashCode` 和 `toString`，完全不需要操心。

### 3. 集合操作中的去重

如果你想对一个 `List<User>` 根据 ID 去重：

- **传统做法**：重写 User 的 equals/hashCode，扔进 `HashSet`。
- **流式做法 (Java 8)**：如果你不能修改 User 类，或者想临时根据不同字段去重：

  ```java
  // 假设这是一个自定义的工具方法 distinctByKey
  list.stream()
      .filter(distinctByKey(User::getId))
      .collect(Collectors.toList());
  ```

## 总结：

1.  **基本类型** (`int`, `char`)：用 `==`。
2.  **包装类型** (`Integer`, `Long`)：**永远**用 `equals`，或 `Objects.equals()`。
3.  **字符串** (`String`)：**永远**用 `equals`，且常量写前面。
4.  **枚举** (`Enum`)：可以用 `==`。
5.  **数组**：用 `Arrays.equals`。
6.  **BigDecimal**：数值比较用 `compareTo`，精确匹配（含精度）用 `equals`。
7.  **自定义对象**：

    - 同时重写 `equals` 和 `hashCode`。
    - 优先用 IDE 生成或 Lombok（注意 JPA 陷阱）。
    - 优先用 `java.util.Objects.equals` 处理属性。

8.  **排序**：优先使用 `Comparator.comparing(...)` 链式调用。
