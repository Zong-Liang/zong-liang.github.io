---
title: Java包装类
date: 2024-06-06 06:00:00 +0800
categories: [Daily Coding, Coding Tips, Java包装类]
tags: [Java包装类]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251123144230285.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

包装类（Wrapper Classes）是 Java 中一个非常重要的概念，它充当了基本数据类型与对象世界之间的桥梁。

## 核心要点总结

- **八大包装类**：`Byte`, `Short`, `Integer`, `Long`, `Float`, `Double`, `Character`, `Boolean`，分别对应八种基本数据类型。
- **桥梁作用**：使得基本类型能被存储在集合中，或作为泛型参数。
- **自动装箱/拆箱**：简化了基本类型和包装类之间的转换代码。
- **对象比较**：**永远使用 `.equals()` 方法来比较两个包装类实例的值是否相等**，`==` 比较的是对象的内存地址（除非触发了缓存机制）。
- **缓存池**：`Integer`（以及其他一些包装类如`Byte`, `Short`, `Long`, `Character`）对特定范围内的值有缓存，可以提高性能并节省内存。
- **可为 `null`**：包装类作为对象，可以被赋值为 `null`，但在自动拆箱时需要特别小心，否则可能导致 `NullPointerException`。

## Java 代码

```java
import java.util.ArrayList;
import java.util.List;

/**
 * @author zongliang_i
 */
public class Main {
    public static void main(String[] args) {
        System.out.println("--- 1. 为什么需要包装类？---");
        demonstrateWhyWeNeedWrappers();

        System.out.println("\n--- 2. 装箱与拆箱 (Boxing & Unboxing) ---");
        demonstrateBoxingUnboxing();

        System.out.println("\n--- 3. 包装类的创建与缓存机制 (重要！) ---");
        demonstrateCreationAndCaching();

        System.out.println("\n--- 4. 包装类的实用工具方法 ---");
        demonstrateUtilityMethods();

        System.out.println("\n--- 5. 包装类的特殊性：可为 null ---");
        demonstrateNullability();
    }

    /**
     * 1. 演示为什么需要包装类：连接基本类型与对象世界
     */
    public static void demonstrateWhyWeNeedWrappers() {
        // Java的集合框架（如ArrayList）只能存储对象，不能存储基本数据类型。
        // List<int> list = new ArrayList<>(); // 这行代码是错误的，会编译失败！

        // 为了将基本数据类型放入集合，我们必须使用其对应的包装类。
        List<Integer> numberList = new ArrayList<>();
        numberList.add(10); // 10 (int) 被自动转换成 Integer 对象
        numberList.add(20);
        System.out.println("ArrayList<Integer> 成功存储了数字: " + numberList);
        System.out.println("包装类使得基本数据类型能够参与到面向对象的操作中（如泛型）。");
    }

    /**
     * 2. 演示装箱、拆箱、自动装箱、自动拆箱
     */
    public static void demonstrateBoxingUnboxing() {
        // 在 JDK 5 之前，转换是手动的：
        // 手动装箱 (Primitive -> Wrapper)
        int primitiveInt = 100;
        Integer wrappedInt = Integer.valueOf(primitiveInt);
        System.out.println("手动装箱: " + wrappedInt);

        // 手动拆箱 (Wrapper -> Primitive)
        int unwrappedInt = wrappedInt.intValue();
        System.out.println("手动拆箱: " + unwrappedInt);
        System.out.println("---");

        // 从 JDK 5 开始，引入了自动装箱和自动拆箱，大大简化了代码。
        // 自动装箱 (Autoboxing)
        Integer autoWrapped = 200; // 编译器自动转换为 Integer.valueOf(200)
        System.out.println("自动装箱: " + autoWrapped);

        // 自动拆箱 (Autounboxing)
        int autoUnwrapped = autoWrapped; // 编译器自动转换为 autoWrapped.intValue()
        System.out.println("自动拆箱: " + autoUnwrapped);

        // 自动拆箱在算术运算中非常方便
        Integer a = 50;
        int result = a + 20; // 'a' 在运算前会自动拆箱为 int
        System.out.println("自动拆箱用于计算 (50 + 20): " + result);
    }

    /**
     * 3. 演示包装类的创建方式，并重点解释Integer的缓存机制
     */
    public static void demonstrateCreationAndCaching() {
        // 对于 Integer 类型，JVM 缓存了从 -128 到 127 的对象。
        // 通过自动装箱或 Integer.valueOf() 创建这个范围内的整数时，会直接返回缓存中的对象。

        Integer cachedA = 100;
        Integer cachedB = 100;
        System.out.println("对于值 100 (在-128到127范围内):");
        System.out.println("cachedA == cachedB ? " + (cachedA == cachedB)); // true, 因为它们指向缓存中的同一个对象

        // 超出缓存范围的值，每次都会创建新的对象。
        Integer nonCachedC = 200;
        Integer nonCachedD = 200;
        System.out.println("\n对于值 200 (超出缓存范围):");
        System.out.println("nonCachedC == nonCachedD ? " + (nonCachedC == nonCachedD)); // false, 因为它们是两个不同的对象

        // 在 Java 9 之前，使用 'new' 关键字会强制创建一个全新的对象，无论值是否在缓存范围内。
        // Integer newObjectE = new Integer(100);
        // System.out.println("\n使用 'new Integer(100)':");
        // System.out.println("cachedA == newObjectE ? " + (cachedA == newObjectE)); // false, new 总是创建新对象

        // ★★★ 结论：比较两个包装类对象的值时，应始终使用 .equals() 方法！ ★★★
        System.out.println("\n使用 .equals() 比较值:");
        System.out.println("nonCachedC.equals(nonCachedD) ? " + nonCachedC.equals(nonCachedD)); // true, 因为它们的值相等
    }

    /**
     * 4. 演示包装类作为工具类的常用方法
     */
    public static void demonstrateUtilityMethods() {
        String numberStr = "12345";

        // a) 将字符串解析为基本数据类型
        int parsedInt = Integer.parseInt(numberStr);
        System.out.println("字符串 \"" + numberStr + "\" 解析为 int: " + (parsedInt + 1));

        String doubleStr = "3.14";
        double parsedDouble = Double.parseDouble(doubleStr);
        System.out.println("字符串 \"" + doubleStr + "\" 解析为 double: " + (parsedDouble * 2));

        // b) 将基本数据类型转换为字符串
        int value = 99;
        String intAsString = Integer.toString(value);
        System.out.println("int " + value + " 转换为字符串: \"" + intAsString + "\"");

        // c) 比较 (compareTo)
        Integer x = 10;
        Integer y = 20;
        System.out.println("10.compareTo(20) 的结果: " + x.compareTo(y)); // 小于返回-1, 等于返回0, 大于返回1

        // d) 获取类型的常量
        System.out.println("int 的最大值 (Integer.MAX_VALUE): " + Integer.MAX_VALUE);
        System.out.println("double 的位数 (Double.SIZE): " + Double.SIZE + " bits");
    }

    /**
     * 5. 演示包装类可以为 null，以及由此引发的潜在问题
     */
    public static void demonstrateNullability() {
        // 包装类是对象，因此可以被赋值为 null
        Integer nullableInteger = null;
        System.out.println("包装类对象可以为 null: " + nullableInteger);

        // 基本数据类型不能为 null
        // int primitive = null; // 编译错误！

        // 陷阱：当一个为 null 的包装类对象被自动拆箱时，会抛出 NullPointerException！
        try {
            System.out.println("尝试对一个 null 的 Integer 对象进行自动拆箱...");
            int num = nullableInteger; // 这行代码会尝试调用 nullableInteger.intValue()
        } catch (NullPointerException e) {
            System.err.println("错误：发生了 NullPointerException！");
            System.err.println("这是因为对一个 null 对象执行了自动拆箱操作。");
        }
    }
}
```
