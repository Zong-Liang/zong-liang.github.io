---
title: 访问修饰符最佳实践
date: 2024-12-22 06:00:00 +0800
categories: [Daily Coding, Coding Tips, 访问修饰符]
tags: [访问修饰符]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251204162216148.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

在 Java 开发中，访问修饰符（Access Modifiers）不仅仅是语法规则，更是**软件架构设计**和**封装（Encapsulation）** 的核心工具。

这里先快速回顾一下 Java 中的访问修饰符：

| 修饰符          | 同一类内 (Same Class) | 同一包内 (Same Package) | 不同包的子类 (Subclass in Different Package) | 全局 (Everywhere) |
| :-------------- | :-------------------: | :---------------------: | :------------------------------------------: | :---------------: |
| **`public`**    |          ✅           |           ✅            |                      ✅                      |        ✅         |
| **`protected`** |          ✅           |           ✅            |                      ✅                      |        ❌         |
| **`default`**   |          ✅           |           ✅            |                      ❌                      |        ❌         |
| **`private`**   |          ✅           |           ❌            |                      ❌                      |        ❌         |

正确使用修饰符的核心原则只有一条：**最小权限原则（Principle of Least Privilege）**。即：**尽可能降低成员的访问权限，只有在确实需要时才提高权限。**

以下是各个修饰符在实际开发中的最佳实践：

## 1. `private`：默认的首选

**原则：** 除非有明确理由，否则所有的字段（Field）、构造函数（在特定模式下）和辅助方法都应该是 `private`。

- **字段（Fields）：**

  - **绝对规则：** 实例变量几乎永远应该是 `private`。
  - **反例：** 只有 `public static final` 定义的常量可以是公开的。
  - **原因：** 防止外部直接修改对象状态，破坏数据一致性。必须通过方法（如 Getter/Setter 或业务方法）来访问，以便在方法内添加校验逻辑或断点调试。

- **辅助方法（Helper Methods）：**

  - 如果一个方法只是为了帮助类内部的其他方法完成逻辑，不应该被外部看到，必须设为 `private`。这有助于保持 API 的整洁。

- **构造函数：**

  - 在 **单例模式（Singleton）** 或 **工具类（Utility Class，全静态方法）** 中，将构造函数设为 `private` 以禁止实例化。

## 2. `package-private` (无修饰符/默认)：模块内的秘密

**原则：** 用于同一包内的协作，是模块化设计的关键。

- **类可见性：**

  - 如果一个类只是作为某个接口的实现，且只在当前包的工厂类或业务逻辑中使用，不要给它加 `public`。
  - **场景：** 假设你有一个 `ExportService` 接口，以及 `PdfExportService` 和 `CsvExportService` 实现类。如果外部只需调用接口，那么这俩实现类就不应该 `public`，这样可以强制外部通过接口编程，而不是绑定具体实现。

- **单元测试：**

  - **实战技巧：** 有时为了测试方便，会将原本想设为 `private` 的方法放宽到 `package-private`，这样同包下的 Test 类可以直接调用。
  - _注意：可以使用 Google Guava 的 `@VisibleForTesting` 注解来标记这种情况，告知阅读代码的人“这本来应该是 private 的”。_

## 3. `protected`：给子类的特权

**原则：** 谨慎使用。`protected` 意味着你正在设计继承体系。

- **继承与扩展：**

  - 只有当你明确打算让这个类被继承，并且父类的某些方法或变量需要被子类访问或重写时才使用。
  - **模板方法模式（Template Method Pattern）：** 父类定义流程，子类重写某些步骤（`protected abstract` 或 `protected` 钩子方法）。

- **风险：**

  - `protected` 不仅对子类开放，对**同包下的其他类**也是可见的（Java 的特性）。这有时会造成意外的访问。
  - 一旦公开为 `protected`，它就成了 API 的一部分，修改它可能会破坏子类的逻辑。

## 4. `public`：对外的契约

**原则：** 只有必须对外暴露的 API 才设为 `public`。

- **接口方法：** 接口中的方法默认是 `public`（虽然 Java 9+ 允许 private 接口方法）。
- **API 入口：** Controller 的端点方法、Service 层的业务入口、DTO（数据传输对象）的 Getter/Setter。
- **不可变性原则：** 即便是 `public` 的类，也尽量保持字段 `private`。如果必须公开字段（极少见），请确保它是 `final` 的不可变对象。

## 实际开发场景中的“黄金法则”

### 1. 关于 Getter 和 Setter

**不要盲目生成 Getter/Setter！**

很多 IDE 或 Lombok 插件会让开发者习惯性地给所有字段加 `@Data` 或生成 `public` 的 Getter/Setter。

- **最佳实践：**

  - 如果一个字段只在类内部计算使用，不需要 Getter。
  - 如果一个字段初始化后不允许修改（如 ID），不要提供 Setter。
  - **领域驱动设计 (DDD)：** 倾向于提供具有业务含义的方法（如 `promote()`），而不是单纯的 `setLevel()`。

### 2. 关于常量

- **反模式：** 这是一个糟糕的写法：

  ```java
  public static int MAX_COUNT = 100; // 危险！外部可以修改它
  ```

- **最佳实践：** 必须加 `final`，且如果是对象引用（如 List/Map），要确保对象本身不可变。

  ```java
  public static final int MAX_COUNT = 100;
  public static final List<String> COLORS = Collections.unmodifiableList(...);
  ```

### 3. 内部类 (Inner Classes)

- 如果一个类只为另一个类服务（例如 `Node` 类服务于 `LinkedList`），将其定义为 **`private static` 内部类**。

  - `private`：外部看不见。
  - `static`：与外部类实例解耦，节省内存（不持有外部类引用）。

### 4. Java 9+ 模块化系统 (JPMS)

在 Java 9 引入模块系统后，`public` 的含义发生了变化。即使类是 `public` 的，如果 `module-info.java` 中没有 `exports` 该包，其他模块也无法访问。

- **最佳实践：** 利用模块系统进一步封装。只 export 包含接口和 DTO 的包，隐藏包含实现类的包。

## 总结：决策流程图

当你写下一行代码时，按以下顺序思考：

1.  **能不能是 `private`？**

    - 是 -> **定案**。这是最安全的选择。
    - 否 -> 下一步。

2.  **是不是只在当前包内使用（或者为了测试）？**

    - 是 -> 使用 **`package-private` (无修饰符)**。
    - 否 -> 下一步。

3.  **是不是专门给子类用的（模板方法、钩子）？**

    - 是 -> 使用 **`protected`** (同时文档注释说明覆盖规则)。
    - 否 -> 下一步。

4.  **这是否是对外承诺的 API 接口？**

    - 是 -> 使用 **`public`**。
    - _注意：一旦 Public，以后修改不仅要改代码，还要考虑兼容性。_

## 代码示例对比

**糟糕的设计（高耦合，不安全）：**

```java
public class BankAccount {
    public double balance; // 任何人都能直接改余额！

    public void updateBalance(double amount) {
        // 逻辑...
    }
}
```

**优秀的设计（高内聚，安全）：**

```java
public class BankAccount {
    // 1. Private 字段：只有类自己能碰
    private double balance;
    private final String accountNumber;

    public BankAccount(String accountNumber) {
        this.accountNumber = accountNumber;
        this.balance = 0.0;
    }

    // 2. Public 业务方法：对外暴露受控的操作
    public void deposit(double amount) {
        if (amount <= 0) throw new IllegalArgumentException("Invalid amount");
        logTransaction(amount); // 调用内部私有方法
        this.balance += amount;
    }

    // 3. Getter：只读访问
    public double getBalance() {
        return balance;
    }

    // 4. Private 辅助方法：隐藏内部实现细节
    private void logTransaction(double amount) {
        System.out.println("Log: " + amount);
    }

    // 没有 setBalance()，防止外部随意篡改金额
}
```
