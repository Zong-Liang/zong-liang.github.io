---
title: Lambda表达式
date: 2024-06-19 06:00:00 +0800
categories: [Daily Coding, Coding Tips, Lambda表达式]
tags: [Lambda表达式]
toc: true
math: true
pin: true
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251123151108147.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 概述

### 1. 什么是 Lambda 表达式？

Lambda 表达式本质上是一个匿名函数，它没有名称，但具有参数列表、函数体、返回类型等。它允许你将函数作为参数传递给方法，或者将其存储在变量中。

### 2. Lambda 表达式的语法

基本的 Lambda 表达式语法如下：

```java
(parameters) -> expression
```

或

```java
(parameters) -> { statements; }
```

- **`parameters`**: 参数列表。可以为空，可以包含一个或多个参数。如果只有一个参数，并且类型可以推断，括号可以省略。
- **`->`**: Lambda 运算符，分隔参数列表和 Lambda 主体。
- **`expression`**: Lambda 主体。如果主体只包含一个表达式，则 Lambda 会自动返回该表达式的结果。
- **`{ statements; }`**: Lambda 主体。如果主体包含多条语句，需要用花括号包围。如果存在返回值，需要使用`return`语句。

### 3. 函数式接口

Lambda 表达式需要一个“目标类型”来与之匹配。这个目标类型必须是一个“函数式接口”。
函数式接口是只有一个抽象方法的接口。Java 8 在`java.util.function`包中预定义了许多函数式接口，例如：

- `Runnable`: `void run()`
- `Callable<V>`: `V call()`
- `Consumer<T>`: `void accept(T t)`
- `Supplier<T>`: `T get()`
- `Function<T, R>`: `R apply(T t)`
- `Predicate<T>`: `boolean test(T t)`

你也可以定义自己的函数式接口，只需要在接口上添加`@FunctionalInterface`注解（这是一个可选的注解，但推荐使用，它能确保编译器检查该接口是否只有一个抽象方法）。

### 4. Lambda 表达式的优点

- **代码简洁：** 减少了匿名内部类的冗余代码。
- **易于阅读：** 更清晰地表达了代码的意图。
- **并行处理：** 结合 Stream API，可以方便地进行并行处理。

## Java 代码

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collectors;


/**
 * @author zongliang_i
 */
public class Main {

    // 1. 定义一个自定义函数式接口
    // @FunctionalInterface 注解是可选的，但建议使用，用于编译时检查
    @FunctionalInterface
    interface MathOperation {
        int operate(int a, int b);
    }

    // 2. 一个接受函数式接口作为参数的方法
    private static int operate(int a, int b, MathOperation mathOperation) {
        return mathOperation.operate(a, b);
    }

    public static void main(String[] args) {

        System.out.println("--- 1. 基本Lambda语法演示 ---");

        // 无参数，无返回值的Lambda (对应 Runnable 接口)
        Runnable greeting = () -> System.out.println("Hello from Lambda!");
        greeting.run();

        // 单参数，无返回值的Lambda (对应 Consumer 接口)
        Consumer<String> printer = message -> System.out.println("Printing: " + message);
        printer.accept("Java Lambda Expressions");

        // 两个参数，有返回值的Lambda (对应自定义的 MathOperation 接口)
        MathOperation addition = (a, b) -> a + b; // 简洁体，自动返回
        MathOperation subtraction = (a, b) -> { // 代码块体，需要 return
            return a - b;
        };
        MathOperation multiplication = (int a, int b) -> a * b; // 带类型声明的参数

        System.out.println("10 + 5 = " + operate(10, 5, addition));
        System.out.println("10 - 5 = " + operate(10, 5, subtraction));
        System.out.println("10 * 5 = " + operate(10, 5, multiplication));

        System.out.println("\n--- 2. 使用Java内置的函数式接口 ---");

        // Predicate<T>: 接收一个T类型参数，返回boolean
        Predicate<Integer> isEven = number -> number % 2 == 0;
        System.out.println("Is 4 even? " + isEven.test(4)); // true
        System.out.println("Is 7 even? " + isEven.test(7)); // false

        // Function<T, R>: 接收一个T类型参数，返回一个R类型结果
        Function<String, Integer> stringLength = s -> s.length();
        System.out.println("Length of 'hello': " + stringLength.apply("hello")); // 5

        // Consumer<T>: 接收一个T类型参数，不返回结果 (已在上面演示)
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        names.forEach(name -> System.out.println("Name: " + name));

        // Supplier<T>: 不接收参数，提供一个T类型结果
        Supplier<Double> randomValue = () -> Math.random();
        System.out.println("Random value: " + randomValue.get());

        System.out.println("\n--- 3. Lambda表达式在集合排序中的应用 (Comparator) ---");

        List<String> fruits = new ArrayList<>(Arrays.asList("Apple", "Banana", "Cherry", "Date"));

        // 使用匿名内部类进行排序（传统方式）
        Collections.sort(fruits, new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {
                return s1.compareTo(s2);
            }
        });
        System.out.println("Sorted fruits (traditional): " + fruits);

        // 使用Lambda表达式进行排序（更简洁）
        Collections.sort(fruits, (s1, s2) -> s2.compareTo(s1)); // 反向排序
        System.out.println("Sorted fruits (reverse with Lambda): " + fruits);

        // 使用Comparator的默认方法 (更简洁，方法引用)
        Collections.sort(fruits, Comparator.naturalOrder()); // 自然排序
        System.out.println("Sorted fruits (natural with method reference): " + fruits);

        System.out.println("\n--- 4. Lambda表达式与Stream API的结合使用 ---");

        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // 筛选偶数并乘以2，然后收集到新列表
        List<Integer> processedNumbers = numbers.stream()
            .filter(n -> n % 2 == 0) // Predicate
            .map(n -> n * 2)         // Function
            .collect(Collectors.toList());
        System.out.println("Processed numbers (even and multiplied by 2): " + processedNumbers);

        // 计算所有数字的和
        int sum = numbers.stream()
            .reduce(0, (accumulator, n) -> accumulator + n); // BinaryOperator (特殊Function)
        System.out.println("Sum of all numbers: " + sum);

        // 查找第一个大于5的偶数
        numbers.stream()
            .filter(n -> n > 5 && n % 2 == 0)
            .findFirst()
            .ifPresent(n -> System.out.println("First even number > 5: " + n));

        // 统计字符串列表中以'A'开头的字符串数量
        long countA = names.stream()
            .filter(name -> name.startsWith("A"))
            .count();
        System.out.println("Number of names starting with 'A': " + countA);

        System.out.println("\n--- 5. 方法引用 (Method References) ---");
        // 方法引用是Lambda表达式的一种简写形式，当Lambda表达式仅仅是调用一个现有方法时可以使用

        // 静态方法引用: Class::staticMethod
        Consumer<String> printer2 = System.out::println;
        printer2.accept("Printing with static method reference.");

        // 实例方法引用: instance::instanceMethod
        List<String> words = new ArrayList<>(Arrays.asList("hello", "world", "java"));
        words.forEach(String::toUpperCase); // 错误，toUpperCase返回新字符串，forEach期望Consumer
        List<String> upperWords = words.stream()
            .map(String::toUpperCase) // 实例方法引用：对每个元素调用toUpperCase()
            .collect(Collectors.toList());
        System.out.println("Uppercase words: " + upperWords);

        // 特定对象的实例方法引用: object::instanceMethod
        StringBuilder sb = new StringBuilder();
        Consumer<String> appender = sb::append;
        appender.accept("Appended by method reference.");
        System.out.println("StringBuilder content: " + sb.toString());

        // 构造器引用: Class::new
        Supplier<ArrayList<String>> listSupplier = ArrayList::new;
        List<String> newList = listSupplier.get();
        newList.add("Item 1");
        System.out.println("New list created by constructor reference: " + newList);
    }
}
```
