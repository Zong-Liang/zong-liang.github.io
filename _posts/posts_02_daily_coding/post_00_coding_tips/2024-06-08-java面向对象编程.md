---
title: Java面向对象编程
date: 2024-06-08 06:00:00 +0800
categories: [Daily Coding, Coding Tips, Java面向对象编程]
tags: [Java面向对象编程]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251123144451081.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

**面向对象编程（Object-Oriented Programming, OOP）** 的四大核心：

- **封装 (Encapsulation)**
- **继承 (Inheritance)**
- **多态 (Polymorphism)**
- **抽象 (Abstraction)**

## Java 代码

这个示例由多个文件（类）组成，请将它们保存在同一个文件夹中。

### 文件 1：`Pet.java` (接口 - Abstraction)

接口是抽象的极致体现。它定义了一套行为规范（契约），任何实现了这个接口的类都必须提供这些行为的具体实现。

```java
/**
 * Pet.java - 接口 (Interface)
 * 描述了一个“宠物”应该具备的行为。
 * 接口里的方法默认都是 public abstract 的。
 */
public interface Pet {
    // 任何宠物都应该能和人玩耍
    void play();
}
```

### 文件 2：`Animal.java` (抽象类 - Abstraction & Encapsulation)

抽象类作为一个“蓝图”或“模板”，它定义了一类事物的共性（属性和行为）。它不能被直接实例化（你不能创建一个叫“动物”的对象），但可以被继承。

```java
/**
 * Animal.java - 抽象类 (Abstract Class)
 * 这是所有动物的基类，体现了“抽象”。
 * 它也通过 private 字段和 public 方法体现了“封装”。
 */
public abstract class Animal {

    // 1. 封装 (Encapsulation):
    // 字段（属性）被声明为 private，外部无法直接访问。
    private String name;
    private int age;

    // 构造函数
    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 通过 public 的 getter/setter 方法来控制对私有字段的访问
    public String getName() {
        return name;
    }

    public void setName(String name) {
        // 可以在 setter 中加入控制逻辑，例如不允许名字为空
        if (name != null && !name.isEmpty()) {
            this.name = name;
        }
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        // 可以在 setter 中加入验证逻辑，例如年龄不能为负
        if (age >= 0) {
            this.age = age;
        }
    }

    // 这是一个所有动物共有的、具体的行为
    public void eat() {
        System.out.println(name + " 正在吃东西...");
    }

    // 2. 抽象 (Abstraction):
    // 抽象方法：定义了一个行为“发出声音”，但不知道具体怎么叫。
    // 这个方法的具体实现留给子类去完成。
    public abstract void makeSound();
}
```

### 文件 3：`Dog.java` (具体类 - Inheritance & Polymorphism)

这是一个具体的类，它继承了`Animal`并实现了`Pet`接口。

```java
/**
 * Dog.java - 具体子类
 * 它“继承”了 Animal 的属性和方法，并“实现”了 Pet 接口。
 * 它重写了父类的抽象方法，体现了“多态”。
 */
public class Dog extends Animal implements Pet { // 3. 继承 (Inheritance) 和实现接口

    private String breed; // Dog 特有的属性

    public Dog(String name, int age, String breed) {
        // 使用 super() 调用父类(Animal)的构造函数
        super(name, age);
        this.breed = breed;
    }

    // 4. 多态 (Polymorphism) - 方法重写 (Overriding)
    // 必须实现父类中的抽象方法 makeSound()
    @Override
    public void makeSound() {
        System.out.println(getName() + " (一只" + breed + ") 正在汪汪叫: Woof! Woof!");
    }

    // 必须实现接口 Pet 中的方法 play()
    @Override
    public void play() {
        System.out.println(getName() + " 正在开心地摇着尾巴玩耍！");
    }

    // Dog 类特有的方法
    public void fetch() {
        System.out.println(getName() + " 正在玩你丢我捡的游戏。");
    }
}
```

### 文件 4：`Cat.java` (具体类 - Inheritance & Polymorphism)

这是另一个具体的类，同样继承自`Animal`。

```java
/**
 * Cat.java - 具体子类
 * 和 Dog 一样，它也继承了 Animal 并实现了 Pet 接口。
 * 它以自己的方式实现了 makeSound()，进一步体现多态。
 */
public class Cat extends Animal implements Pet { // 继承 和 实现

    public Cat(String name, int age) {
        super(name, age); // 调用父类构造函数
    }

    // 多态 - 重写 makeSound()
    @Override
    public void makeSound() {
        System.out.println(getName() + " 正在喵喵叫: Meow~");
    }

    // 多态 - 实现 play()
    @Override
    public void play() {
        System.out.println(getName() + " 正在玩逗猫棒。");
    }

    // 4. 多态 (Polymorphism) - 方法重载 (Overloading)
    // 与父类的 eat() 方法同名，但参数不同，构成了重载
    public void eat(String food) {
        System.out.println(getName() + " 正在优雅地吃 " + food + "。");
    }
}
```

### 文件 5：`Main.java` (主程序 - 演示所有概念)

这是我们的主程序入口，它将把所有部分组合在一起，并清晰地演示 OOP 的四大特性。

```java
/**
 * Main.java - 主程序
 * 这个类是程序的入口，用于创建对象并演示OOP的四大核心概念。
 */
public class Main {

    public static void main(String[] args) {

        // --- 1. 封装 (Encapsulation) 演示 ---
        System.out.println("--- 1. 封装演示 ---");
        Dog dog1 = new Dog("旺财", 3, "金毛");
        // 你不能这样做，因为 name 是 private 的：
        // dog1.name = "小黑"; // -> 编译错误！
        // 必须通过 public 方法来访问和修改数据：
        dog1.setName("大黄");
        System.out.println("狗的名字是: " + dog1.getName());
        System.out.println("----------------------------\n");


        // --- 2. 继承 (Inheritance) 演示 ---
        System.out.println("--- 2. 继承演示 ---");
        // dog1 和 cat1 都是 Animal 的子类，所以它们都继承了 eat() 方法。
        dog1.eat();
        Cat cat1 = new Cat("咪咪", 2);
        cat1.eat(); // 这个 eat() 方法是从 Animal 类继承而来的
        System.out.println("----------------------------\n");


        // --- 3. 多态 (Polymorphism) 演示 (最核心！) ---
        System.out.println("--- 3. 多态演示 ---");
        // 创建一个 Animal 类型的数组，但可以存放其任何子类的对象
        Animal[] animals = new Animal[2];
        animals[0] = new Dog("Buddy", 5, "拉布拉多"); // Dog is-an Animal
        animals[1] = new Cat("Kitty", 4);           // Cat is-an Animal

        // 遍历数组，对每个动物调用 makeSound() 方法
        for (Animal animal : animals) {
            // ★★★ 多态的核心体现 ★★★
            // 同一个 `animal.makeSound()` 调用，
            // 当 animal 实际是 Dog 对象时，执行 Dog 的 makeSound()
            // 当 animal 实际是 Cat 对象时，执行 Cat 的 makeSound()
            // JVM 在运行时动态决定调用哪个版本的方法。
            animal.makeSound();

            // 使用 instanceof 关键字检查对象的真实类型，并调用其特有方法
            if (animal instanceof Dog) {
                // 需要进行类型转换，才能调用 Dog 特有的方法
                Dog specificDog = (Dog) animal;
                specificDog.fetch();
            }
        }
        System.out.println();
        // 方法重载 (Overloading) 也是多态的一种形式（编译时多态）
        cat1.eat(); // 调用从 Animal 继承的无参 eat()
        cat1.eat("鱼"); // 调用 Cat 类自己定义的有参 eat(String food)
        System.out.println("----------------------------\n");


        // --- 4. 抽象 (Abstraction) 演示 ---
        System.out.println("--- 4. 抽象演示 ---");
        // 你不能直接创建抽象类的实例：
        // Animal genericAnimal = new Animal("神秘生物", 10); // -> 编译错误！
        System.out.println("无法创建 'Animal' 的实例，因为它是一个抽象类。");

        // 接口也是抽象的，同样不能被实例化
        // Pet myPet = new Pet(); // -> 编译错误！
        System.out.println("无法创建 'Pet' 的实例，因为它是一个接口。");
        System.out.println("抽象类和接口是用来被继承和实现的蓝图，而不是用来创建具体对象的。");
        System.out.println("----------------------------\n");
    }
}
```
