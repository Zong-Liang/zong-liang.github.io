---
title: 建造者模式最佳实践
date: 2024-12-25 06:00:00 +0800
categories: [Daily Coding, Coding Tips, 建造者模式]
tags: [建造者模式]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251205101439337.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

在 Java 实际开发中，**Builder 模式（建造者模式）** 是解决“复杂对象创建”和“参数过多导致构造函数爆炸”问题的标准方案。

特别是 Joshua Bloch 在《Effective Java》中推崇的静态内部类 Builder 模式，已经成为业界标配。而在现代开发中，配合 **Lombok** 插件使用更是主流。

以下是 Builder 模式在实际开发中的最佳实践：

## 1. 核心应用场景：解决“伸缩构造函数”反模式

当一个类的参数满足以下条件时，必须使用 Builder 模式：

- **参数多于 4-5 个**。
- **参数具有可选性**（很多参数允许为 null 或默认值）。
- **参数类型相似**（例如全是 `String` 或 `int`，容易传错顺序）。

**反例（糟糕的构造函数）：**

```java
// 你能一眼看出第3个 true 和第5个 false 代表什么吗？
User user = new User("John", "Doe", true, 30, false, "123 Main St", ...);
```

**正例（Builder 模式）：**

```java
User user = User.builder()
    .firstName("John")
    .lastName("Doe")
    .isActive(true)
    .age(30)
    .emailVerified(false)
    .address("123 Main St")
    .build();
```

## 2. 现代开发首选：Lombok 的 `@Builder`

在 90% 的业务开发场景中，手写 Builder 代码冗余且难维护。**最佳实践是使用 Lombok。**

### 2.1 基础用法

```java
@Builder
@Getter
@ToString
public class Order {
    private String orderId;
    private BigDecimal amount;
    private String status;
}
```

### 2.2 关键实践：处理默认值 (`@Builder.Default`)

这是一个极其容易踩坑的地方。在使用 `@Builder` 时，直接在字段上赋值（如 `private int age = 18;`）**会被忽略**，构建出的对象该字段为 `0` 或 `null`。

**最佳实践：** 必须使用 `@Builder.Default` 注解。

```java
@Builder
@Getter
public class User {
    private String name;

    @Builder.Default // 必须加这个，否则默认值无效
    private int status = 1;

    @Builder.Default
    private List<String> roles = new ArrayList<>();
}
```

### 2.3 关键实践：修改现有对象 (`toBuilder = true`)

有时我们需要基于一个现有的对象，修改其中一两个属性得到一个新对象（类似“复制”）。

**最佳实践：**

```java
@Builder(toBuilder = true) // 开启此功能
@Getter
public class User { ... }

// 使用场景
User oldUser = ...;
User newUser = oldUser.toBuilder()
    .email("new@example.com") // 只修改 email
    .build();
```

## 3. 手写 Builder 的最佳实践（进阶控制）

虽然 Lombok 很好用，但在开发**公共 SDK**、**中间件**或需要**复杂校验逻辑**时，手写 Builder 更灵活。

### 3.1 保证不可变性 (Immutability)

Builder 模式的最佳拍档是**不可变对象**。

- 类应该是 `public final` 的（防止继承破坏）。
- 字段应该是 `private final` 的。
- 不提供 Setter，只提供 Getter。

### 3.2 校验逻辑放在 `build()` 方法中

不要在链式调用的 `setXXX()` 中校验，而是在最后调用 `build()` 时进行统一校验。这能确保你得到的一定是合法的对象（Fail-Fast 机制）。

```java
public class ConnectionConfig {
    private final String host;
    private final int port;

    private ConnectionConfig(Builder builder) {
        this.host = builder.host;
        this.port = builder.port;
    }

    public static class Builder {
        private String host;
        private int port;

        public Builder host(String host) { this.host = host; return this; }
        public Builder port(int port) { this.port = port; return this; }

        public ConnectionConfig build() {
            // 最佳实践：在此处进行业务校验
            if (host == null || host.isEmpty()) {
                throw new IllegalStateException("Host cannot be empty");
            }
            if (port <= 0 || port > 65535) {
                throw new IllegalStateException("Invalid port number");
            }
            return new ConnectionConfig(this);
        }
    }
}
```

### 3.3 集合的处理（防御性拷贝）

如果对象包含 `List` 或 `Map`，直接赋值是不安全的，外部依然引用着该集合。

**最佳实践：** 在 `build()` 内部进行深拷贝或包裹为不可变集合。

```java
// 手写 Builder 内部
public User build() {
    // 假设 this.roles 是 Builder 里的 List
    List<String> safeRoles;
    if (this.roles == null) {
        safeRoles = Collections.emptyList();
    } else {
        // 防御性拷贝，防止外部修改影响内部
        safeRoles = Collections.unmodifiableList(new ArrayList<>(this.roles));
    }
    return new User(this.name, safeRoles);
}
```

_注：Lombok 可以通过 `@Singular` 注解简化集合添加操作，但也需要注意底层实现。_

### 4. 必填项 vs 可选项

一个常见的争议是：**必填参数是放在构造函数里，还是也放在 Builder 里？**

- **学术派做法：** 必填参数通过 Builder 的构造函数传入，可选参数通过方法链。

  ```java
  // 强制 user id 必填
  new User.Builder("userId-123").age(20).build();
  ```

- **实际工程派做法（推荐）：** **全部使用 Builder 方法**。

  - 原因：混合写法会导致 API 不统一，阅读体验差。
  - 解决方案：依靠 `build()` 方法内的校验抛出异常来约束必填项。

## 5. 继承体系中的 Builder (`@SuperBuilder`)

在涉及继承时，普通 Builder 无法设置父类属性，且链式调用返回类型会断裂（返回父类 Builder 导致无法调用子类方法）。

**最佳实践：**

- **Lombok：** 使用 `@SuperBuilder`（Lombok v1.18.2+）。这是目前解决继承 Builder 最优雅的方式。

  ```java
  @SuperBuilder
  public class Parent {
      private String id;
  }

  @SuperBuilder
  public class Child extends Parent {
      private String name;
  }

  // 使用
  Child c = Child.builder()
      .id("1")   // 父类字段
      .name("A") // 子类字段
      .build();
  ```

- **手写：** 需要使用泛型递归类型（`Recursive Generics`），非常复杂且晦涩（`class Builder<T extends Builder<T>>`），除非写库，否则不推荐在业务代码中手写。

### 总结

1.  **首选 Lombok：** 除非有特殊需求，直接用 `@Builder`。
2.  **注意默认值：** 只要有字段初始化值，务必加 `@Builder.Default`。
3.  **校验滞后：** 校验逻辑写在 `build()` 方法里。
4.  **不可变性：** 生成的对象最好是无 Setter 的不可变对象。
5.  **处理继承：** 使用 `@SuperBuilder`。

Builder 模式让代码**写起来可能变多了**（如果手写），但**读起来和用起来舒服了很多**，这就是它的核心价值。
