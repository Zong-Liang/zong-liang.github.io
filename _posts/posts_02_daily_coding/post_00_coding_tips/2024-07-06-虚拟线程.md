---
title: 虚拟线程
date: 2024-07-06 06:00:00 +0800
categories: [Daily Coding, Coding Tips, 虚拟线程]
tags: [虚拟线程]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251125093814757.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

**虚拟线程（Virtual Threads）**是 Project Loom 项目的一部分，在 Java 19 中作为预览特性引入，并在**Java 21 中正式成为 LTS（长期支持）版本的一部分**。虚拟线程的引入旨在极大地简化高并发应用的开发。

## 概述

### 1. 什么是虚拟线程？

传统的 Java 线程（Platform Threads，也称为平台线程或 OS 线程）是操作系统线程的一对一封装。创建一个平台线程意味着操作系统必须分配资源，进行上下文切换等，这使得平台线程相对“重”且昂贵。因此，创建成千上万个平台线程是不切实际的，这限制了 Java 在高并发 I/O 密集型场景下的伸缩性。

**虚拟线程**是一种轻量级的线程，它由 Java 虚拟机（JVM）管理，而不是直接映射到操作系统线程。

- **由 JVM 调度：** 虚拟线程由 JVM 而不是操作系统来调度。
- **多对一映射：** 许多虚拟线程可以运行在一个（或少数几个）平台线程上。这些平台线程被称为**载体线程（Carrier Threads）**。
- **轻量级：** 虚拟线程的创建、销毁和上下文切换成本非常低，可以创建数百万个虚拟线程而不会耗尽系统资源。
- **阻塞友好：** 虚拟线程最大的优势在于，当一个虚拟线程执行阻塞 I/O 操作（如网络请求、数据库查询）时，JVM 可以“卸载”该虚拟线程，让其载体线程去执行其他虚拟线程，而不需要像传统平台线程那样阻塞整个操作系统线程。当 I/O 操作完成后，虚拟线程会“重新挂载”到载体线程上继续执行。
- **与现有 API 兼容：** 虚拟线程使用了相同的 `java.lang.Thread` API，这意味着现有的 `ExecutorService`、`synchronized` 等并发工具和模式可以直接应用于虚拟线程，大大降低了学习曲线和迁移成本。

### 2. 虚拟线程解决的问题

- **高并发下的伸缩性瓶颈：** 在 I/O 密集型服务中，传统平台线程数量有限导致吞吐量受限。虚拟线程通过允许创建大量线程来解决此问题。
- **编程模型复杂性：** 传统的异步编程（如 CompletableFuture、NIO、ReactiveX）虽然解决了伸缩性问题，但引入了回调地狱、栈追踪复杂等问题，降低了代码可读性和可维护性。虚拟线程允许你用直观的“一请求一线程”的同步编程模型来编写高并发应用。

### 3. 虚拟线程的适用场景

虚拟线程主要适用于**I/O 密集型**任务，例如：

- Web 服务器（处理大量并发 HTTP 请求）
- 微服务间通信（RESTful API 调用）
- 数据库访问
- 文件 I/O
  在这些场景下，线程大部分时间都处于等待 I/O 的状态。

对于**CPU 密集型**任务，虚拟线程并不能提供性能优势，因为它们仍然需要载体线程来执行实际的计算。在 CPU 密集型场景，平台线程或工作窃取池仍然是更合适的选择。

### 4. 虚拟线程的创建

- **`Thread.ofVirtual().start(Runnable)`**: 直接创建并启动一个虚拟线程。
- **`Thread.ofVirtual().factory()`**: 创建一个 `ThreadFactory`，用于生成虚拟线程。
- **`Executors.newVirtualThreadPerTaskExecutor()`**: 创建一个 `ExecutorService`，为每个提交的任务创建一个新的虚拟线程。
- **`Executors.newThreadPerTaskExecutor(Thread.ofVirtual().factory())`**: 类似上面，但更通用，可以传入自定义的虚拟线程工厂。

### 5. 注意事项

- **ThreadLocal：** 虚拟线程也支持 `ThreadLocal`，但由于虚拟线程数量巨大，大量使用 `ThreadLocal` 可能会导致内存消耗增加。
- **`synchronized` 关键字：** 虚拟线程可以使用 `synchronized` 关键字进行同步，但当虚拟线程在 `synchronized` 块中阻塞时，它的载体线程会被“钉住”（pinned），无法执行其他虚拟线程。为了获得最佳性能，应优先使用 `java.util.concurrent.locks` 中的锁或 `ReentrantLock`。
- **调试：** 现代 IDE（如 IntelliJ IDEA）已经支持虚拟线程的调试，可以像调试普通线程一样查看调用栈。

## Java 代码

```java
package com.java_se.se_10_new_features.grp_16_virtual_thread;

import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;

/**
 * @author zongliang_i
 *
 * 这是一个用于学习 Java 21 核心特性——虚拟线程的示例程序。
 */
public class Main {

    private static final String EXAMPLE_URL = "https://www.baidu.com";
    private static final int NUM_TASKS = 5000; // 模拟大量并发任务

    // 模拟一个耗时的I/O操作
    private static String performIOOperation(int taskId) {
        try {
            // 模拟网络请求
            HttpClient client = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(5))
                .build();
            HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(EXAMPLE_URL))
                .GET()
                .build();
            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
            // System.out.printf("Task %d: Fetched URL, status %d%n", taskId, response.statusCode());
            return "Task " + taskId + ": Fetched " + EXAMPLE_URL + " (status " + response.statusCode() + ")";
        } catch (IOException | InterruptedException e) {
            // Thread.currentThread().isInterrupted() check is good practice
            Thread.currentThread().interrupt(); // Restore interrupt status
            return "Task " + taskId + ": Failed with " + e.getMessage();
        }
    }

    // 模拟一个耗时的CPU密集型操作
    private static long performCPUOperation(int taskId) {
        long sum = 0;
        for (int i = 0; i < 1_000_000; i++) { // 执行大量计算
            sum += i;
        }
        // System.out.printf("Task %d: Performed CPU heavy computation, sum = %d%n", taskId, sum);
        return sum;
    }

    public static void main(String[] args) throws InterruptedException {

        System.out.println("--- 1. 平台线程 (Platform Threads) 执行 I/O 密集型任务 ---");
        // 使用传统的固定大小线程池来模拟平台线程
        // 如果NUM_TAS很大，可能会因为线程数量限制或资源消耗导致性能瓶颈甚至OOM
        long startPlatformIO = System.currentTimeMillis();
        try (ExecutorService platformExecutor = Executors.newFixedThreadPool(200)) { // 限制线程数量
            IntStream.range(0, NUM_TASKS).forEach(i -> {
                platformExecutor.submit(() -> {
                    // System.out.println("Platform thread performing IO task: " + i);
                    String result = performIOOperation(i);
                    // System.out.println(result);
                    return result;
                });
            });
            platformExecutor.shutdown();
            platformExecutor.awaitTermination(10, TimeUnit.MINUTES);
        }
        long endPlatformIO = System.currentTimeMillis();
        System.out.printf("平台线程 I/O 密集型任务完成，总耗时: %d ms%n%n", (endPlatformIO - startPlatformIO));

        System.out.println("--- 2. 虚拟线程 (Virtual Threads) 执行 I/O 密集型任务 ---");
        // 使用虚拟线程，为每个任务创建一个线程，理论上可以无限多
        long startVirtualIO = System.currentTimeMillis();
        // newVirtualThreadPerTaskExecutor 为每个任务创建一个虚拟线程
        try (ExecutorService virtualExecutor = Executors.newVirtualThreadPerTaskExecutor()) {
            IntStream.range(0, NUM_TASKS).forEach(i -> {
                virtualExecutor.submit(() -> {
                    // System.out.println("Virtual thread performing IO task: " + i);
                    String result = performIOOperation(i);
                    // System.out.println(result);
                    return result;
                });
            });
            virtualExecutor.shutdown();
            virtualExecutor.awaitTermination(10, TimeUnit.MINUTES);
        }
        long endVirtualIO = System.currentTimeMillis();
        System.out.printf("虚拟线程 I/O 密集型任务完成，总耗时: %d ms%n%n", (endVirtualIO - startVirtualIO));

        System.out.println("--- 3. 虚拟线程 vs 平台线程 (CPU 密集型任务) ---");
        // 对于CPU密集型任务，虚拟线程并不能提供明显的性能优势，
        // 因为它们最终还是需要平台线程来执行CPU计算。
        // 过多的虚拟线程反而可能导致上下文切换开销。

        System.out.println("--- 3.1 平台线程执行 CPU 密集型任务 ---");
        long startPlatformCPU = System.currentTimeMillis();
        try (ExecutorService platformCpuExecutor =
                 Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors())) { // 线程数通常等于CPU核心数
            IntStream.range(0, NUM_TASKS / 10).forEach(i -> { // 减少任务数量，避免过度阻塞
                platformCpuExecutor.submit(() -> {
                    long result = performCPUOperation(i);
                    // System.out.printf("Platform CPU Task %d, sum: %d%n", i, result);
                    return result;
                });
            });
            platformCpuExecutor.shutdown();
            platformCpuExecutor.awaitTermination(10, TimeUnit.MINUTES);
        }
        long endPlatformCPU = System.currentTimeMillis();
        System.out.printf("平台线程 CPU 密集型任务完成，总耗时: %d ms%n%n", (endPlatformCPU - startPlatformCPU));


        System.out.println("--- 3.2 虚拟线程执行 CPU 密集型任务 ---");
        long startVirtualCPU = System.currentTimeMillis();
        try (ExecutorService virtualCpuExecutor = Executors.newVirtualThreadPerTaskExecutor()) {
            IntStream.range(0, NUM_TASKS / 10).forEach(i -> { // 减少任务数量
                virtualCpuExecutor.submit(() -> {
                    long result = performCPUOperation(i);
                    // System.out.printf("Virtual CPU Task %d, sum: %d%n", i, result);
                    return result;
                });
            });
            virtualCpuExecutor.shutdown();
            virtualCpuExecutor.awaitTermination(10, TimeUnit.MINUTES);
        }
        long endVirtualCPU = System.currentTimeMillis();
        System.out.printf("虚拟线程 CPU 密集型任务完成，总耗时: %d ms%n%n", (endVirtualCPU - startVirtualCPU));

        System.out.println("--- 4. 直接创建并启动虚拟线程 ---");
        Thread virtualThread = Thread.ofVirtual().name("MyVirtualThread").start(() -> {
            System.out.println("Hello from a directly started Virtual Thread: " + Thread.currentThread().getName());
            try {
                Thread.sleep(100); // 模拟一点工作
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        virtualThread.join(); // 等待虚拟线程执行完毕
        System.out.println("Directly started Virtual Thread finished.");

        // 确保所有示例代码执行完毕
        System.out.println("\n--- 示例程序执行完毕 ---");
    }
}
```

**总结：**

虚拟线程是 Java 高并发编程的一个革命性进步，它让开发者能够以简单、直观的同步编程风格来编写高性能的 I/O 密集型应用，而无需处理复杂的异步编程模型。对于传统的 CPU 密集型任务，平台线程（通常使用固定大小的线程池，线程数与 CPU 核心数匹配）仍然是更好的选择。
