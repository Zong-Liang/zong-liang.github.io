---
title: 比较最佳实践
date: 2025-01-04 06:00:00 +0800
categories: [Daily Coding, Coding Tips, 比较]
tags: [比较]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251129192831952.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

在 Java 中，“比较”看似基础（不就是 `==` 和 `equals` 吗？），实则暗藏杀机。从基础的数据类型陷阱，到集合框架的哈希碰撞，再到分布式系统中的数据一致性，**错误的比较方式是导致 NullPointerException (NPE)、逻辑 Bug 甚至生产事故的主要原因之一**。

## 一、 对象相等性（Equality）：`equals` 与 `hashCode`

### 1. 黄金法则：重写 `equals` 必须重写 `hashCode`

- **为什么？** HashMap、HashSet 等集合依赖 `hashCode` 快速定位桶（Bucket），再用 `equals` 确定元素。如果只重写 `equals`，两个逻辑相同的对象会有不同的 HashCode，导致 Set 无法去重，Map 无法取值（内存泄漏隐患）。
- **最佳实践**：

  - **不要手写**：手写容易漏掉字段或逻辑错误。
  - **使用工具**：

    - **IDE 生成**：IDEA / Eclipse 自带 Generate `equals() and hashCode()`。
    - **Lombok**：使用 `@EqualsAndHashCode`（注意继承关系时的 `callSuper` 配置）。
    - **Java Records (JDK 14+)**：如果你的类只是数据载体（DTO/VO），直接用 `record`，它天生自带正确的比较逻辑。

### 2. `equals` 的标准模板（性能优化版）

如果你必须手写，请遵循以下顺序以提升性能：

```java
@Override
public boolean equals(Object o) {
    // 1. 引用物理地址比较（最快，直接拦截）
    if (this == o) return true;

    // 2. 类型检查（用 getClass 而不是 instanceof，除非你的语义允许子类相等）
    if (o == null || getClass() != o.getClass()) return false;

    // 3. 强转
    User user = (User) o;

    // 4. 关键字段比较（优先比较最可能不相等的字段，或者开销小的基本类型）
    return Objects.equals(this.id, user.id) &&
           Objects.equals(this.name, user.name);
}
```

### 3. 数组的比较

- **错误**：`arr1.equals(arr2)` —— 这比较的是数组对象的内存地址。
- **正确**：

  - 一维数组：`Arrays.equals(arr1, arr2)`
  - 多维数组：`Arrays.deepEquals(arr1, arr2)`

## 二、 数值比较：陷阱最多的地方

### 1. 包装类（Integer, Long）的比较

- **陷阱**：Java 缓存机制（Integer Cache: -128 到 127）。

  ```java
  Integer a = 127; Integer b = 127;
  System.out.println(a == b); // true (命中缓存)

  Integer c = 128; Integer d = 128;
  System.out.println(c == d); // false (不同对象)
  ```

- **最佳实践**：**对象类型永远用 `.equals()`**，或者拆箱后比较。

  - 禁止在业务代码中对包装类使用 `==`，除非你在做底层性能极致优化且确信数值范围。

### 2. 浮点数（Float, Double）的比较

- **陷阱**：精度丢失。`0.1 + 0.2 == 0.3` 在计算机中通常是 `false`。
- **正确**：

  - **使用指定误差范围（Epsilon）**：`Math.abs(a - b) < 1e-6`
  - **使用标准库**：`Double.compare(a, b) == 0` （注意处理 NaN 和 Infinity 的情况）
  - **涉及金额**：**绝对禁止使用 float/double**。

### 3. 金额比较（BigDecimal）—— _高频考点_

- **错误**：`bigDecimalA.equals(bigDecimalB)`

  - 原因：`equals` 会比较精度（Scale）。`1.0` 和 `1.00` 在 `equals` 下是 `false`。

- **正确**：使用 `compareTo()`

  ```java
  BigDecimal a = new BigDecimal("1.0");
  BigDecimal b = new BigDecimal("1.00");

  // 推荐
  if (a.compareTo(b) == 0) {
      // 认为是相等的
  }
  ```

## 三、 排序与顺序：`Comparable` vs `Comparator`

### 1. 职责分离

- **`Comparable` (内部)**：定义对象的**自然顺序**（Natural Order）。例如 `Date` 按时间排序，`String` 按字典序。如果不实现此接口，List 无法直接 `Collections.sort()`。
- **`Comparator` (外部)**：定义**特定场景的策略**。例如“按年龄倒序”、“按薪资正序”。

### 2. Java 8+ 的链式比较（最优雅的写法）

拒绝编写复杂的 `if-else` 匿名内部类，使用 `Comparator` 的链式调用，清晰且易维护：

```java
// 假设有个 User 类
List<User> users = ...;

// 需求：先按部门ID排序，部门相同的按年龄倒序，如果年龄还空则排最后
users.sort(
    Comparator.comparing(User::getDeptId)
              .thenComparing(User::getAge, Comparator.nullsLast(Comparator.reverseOrder()))
              .thenComparing(User::getName) // 防御性兜底
);
```

## 四、 防御性编程与 Null 安全

### 1. 避免 NPE 的 Yoda Condition（尤达条件式）

- **传统做法**：`"expectedStr".equals(variable)`。
- **现代观点**：虽然“常量在前”可以避免 variable 为 null 时的 NPE，但可读性稍差。
- **最佳实践**：使用 `java.util.Objects` 工具类。

  ```java
  // 优雅且安全
  if (Objects.equals(variable, "expectedStr")) { ... }
  ```

### 2. 集合中的 null 比较

- 在实现 `Comparable` 的 `compareTo` 方法时，必须考虑传入对象为 `null` 的情况，或者明确文档说明不支持 null。
- 使用 `Comparator.nullsFirst()` 或 `nullsLast()` 是处理排序中 null 值的最佳方案。

### 总结：

1.  **基本对象**：用 `Objects.equals(a, b)` 代替 `a.equals(b)` 以防止 NPE。
2.  **DTO/Entity**：尽量用 **Lombok** 或 **Java Records** 生成 `equals/hashCode`，别手写。
3.  **包装类 (Integer)**：严禁使用 `==`，一律用 `.equals()`。
4.  **金额 (BigDecimal)**：严禁使用 `.equals()`，一律用 `.compareTo()`。
5.  **列表排序**：利用 Java 8 `Comparator.comparing(...)` 链式写法，可读性完胜传统写法。
6.  **集合去重**：一旦对象要放入 `Set` 或作为 `Map` 的 Key，必须检查 `hashCode` 是否正确实现。
