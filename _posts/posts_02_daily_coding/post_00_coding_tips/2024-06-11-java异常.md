---
title: Java异常
date: 2024-06-11 06:00:00 +0800
categories: [Daily Coding, Coding Tips, Java异常]
tags: [Java异常]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251123151301984.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

异常处理 (Exception Handling) 是编写健壮、可靠的 Java 程序的关键。它是一种机制，用于在程序运行时处理错误和意外情况，从而避免程序突然崩溃。

## 核心概念总结

- **异常**：程序执行期间发生的中断正常流程的事件。
- **Checked Exception**：**必须**在编译时处理的异常（如`IOException`）。代表了可预见的、可恢复的外部问题。
- **Unchecked Exception** (运行时异常)：**不必**在编译时处理的异常（如`NullPointerException`）。通常代表了程序中的逻辑错误 (Bug)。
- **`try`**：包裹可能出错的代码。
- **`catch`**：捕获并处理特定类型的异常。
- **`finally`**：无论如何都会执行的代码块，用于资源清理。
- **`throw`**：手动抛出一个异常实例。
- **`throws`**：在方法签名上声明该方法可能抛出的受检异常。
- **`try-with-resources`**：自动管理资源的语法糖，能确保资源被正确关闭。

## Java 代码

这个示例由两个文件组成。

### 文件 1: `InsufficientFundsException.java` (自定义异常)

创建一个我们自己的异常类型，可以使错误信息更具业务含义。

```java
/**
 * @author zongliang_i
 *
 * InsufficientFundsException.java - 这是一个自定义的受检异常 (Checked Exception)。
 * 我们通过继承 java.lang.Exception 来创建它。
 * 当取款金额超过账户余额时，我们将抛出这个异常。
 */
public class InsufficientFundsException extends Exception {

    // 构造函数，接收一个错误信息
    public InsufficientFundsException(String message) {
        // 调用父类 Exception 的构造函数
        super(message);
    }
}
```

### 文件 2: `Main.java` (主程序)

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 * @author zongliang_i
 * <p>
 * 这是一个用于学习Java中异常处理机制的综合示例程序。
 */
public class Main {

    public static void main(String[] args) {
        System.out.println("--- 1. 演示 Unchecked Exception (运行时异常) ---");
        demonstrateUncheckedException();

        System.out.println("\n--- 2. 演示 Checked Exception (受检异常) 与 throws ---");
        // processFile 方法声明了它可能会抛出 IOException，所以调用者必须处理它。
        try {
            processFile("non_existent_file.txt");
        } catch (IOException e) {
            System.err.println("在 main 方法中捕获到错误: " + e.getMessage());
        }

        System.out.println("\n--- 3. 演示 try-catch-finally 完整流程 ---");
        demonstrateTryCatchFinally(10, 2); // 正常情况
        demonstrateTryCatchFinally(10, 0); // 发生异常情况

        System.out.println("\n--- 4. 演示 throw 和自定义异常 ---");
        try {
            withdraw(1000.0, 500.0);  // 成功取款
            withdraw(1000.0, 1500.0); // 余额不足，将抛出自定义异常
        } catch (InsufficientFundsException e) {
            System.err.println("取款失败: " + e.getMessage());
        }

        System.out.println("\n--- 5. 演示 try-with-resources (现代最佳实践) ---");
        demonstrateTryWithResources("some_file.txt"); // 即使文件不存在，资源也会被正确关闭
    }

    /**
     * 1. Unchecked Exception (非受检异常)
     *    - 通常是程序逻辑错误，如 NullPointerException, ArithmeticException, ArrayIndexOutOfBoundsException。
     *    - 编译器不强制你处理它们。
     */
    public static void demonstrateUncheckedException() {
        try {
            System.out.println("尝试进行 10 / 0 的运算...");
            int result = 10 / 0; // 这将抛出 ArithmeticException
            System.out.println("结果是: " + result);
        } catch (ArithmeticException e) {
            System.err.println("错误: 发生了算术异常！" + e.getMessage());
        }
    }

    /**
     * 2. Checked Exception (受检异常)
     *    - 是程序在正常执行中可能遇到的外部错误，如文件找不到 (IOException)。
     *    - 编译器强制你必须处理它们，要么用 try-catch，要么用 throws 声明抛出。
     *    - 'throws' 关键字：表示“我这个方法不处理这个异常，让调用我的人去处理”。
     */
    public static void processFile(String fileName) throws IOException {
        // FileReader 的构造函数会抛出 FileNotFoundException (IOException 的子类)
        // 我们在这里不捕获它，而是使用 throws 将它抛给 main 方法处理。
        FileReader fileReader = new FileReader(fileName);
        System.out.println("文件 '" + fileName + "' 成功打开。");
        // ... 其他文件处理逻辑 ...
    }

    /**
     * 3. 演示 try-catch-finally 块
     *    - try: 包含可能抛出异常的代码。
     *    - catch: 捕获并处理异常。
     *    - finally: 无论是否发生异常，这里的代码都【总是】会执行（除非JVM关闭）。常用于释放资源。
     */
    public static void demonstrateTryCatchFinally(int numerator, int denominator) {
        System.out.println("计算 " + numerator + " / " + denominator + "...");
        try {
            int result = numerator / denominator;
            System.out.println("结果: " + result);
        } catch (ArithmeticException e) {
            System.err.println("捕获到异常: " + e.getMessage());
        } finally {
            // 这个块总是会被执行
            System.out.println("Finally 块被执行了。通常用于清理工作。");
        }
    }

    /**
     * 4. 演示 throw 关键字和自定义异常
     *    - 'throw': 用于手动抛出一个异常对象。
     */
    public static void withdraw(double balance, double amount) throws InsufficientFundsException {
        System.out.println("尝试从余额 " + balance + " 中取款 " + amount);
        if (amount > balance) {
            // 业务逻辑不满足，手动创建一个异常实例并抛出
            throw new InsufficientFundsException("余额不足。当前余额: " + balance + ", 需要: " + amount);
        }
        balance -= amount;
        System.out.println("取款成功！剩余余额: " + balance);
    }

    /**
     * 5. 演示 try-with-resources (Java 7+)
     *    - 适用于任何实现了 AutoCloseable 接口的资源。
     *    - 不再需要手动写 finally 来关闭资源，JVM 会自动帮你关闭。
     */
    public static void demonstrateTryWithResources(String fileName) {
        // 将资源声明在 try() 的括号内
        try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {
            System.out.println("文件 '" + fileName + "' 打开成功 (try-with-resources)。");
            // 读取文件第一行...
            System.out.println("文件第一行: " + reader.readLine());
        } catch (IOException e) {
            System.err.println("处理文件时出错: " + e.getMessage());
        }
        // 当 try 块结束时（无论是正常结束还是因异常结束），
        // reader.close() 方法会被自动调用。
        System.out.println("try-with-resources 块已执行完毕，资源已自动关闭。");
    }
}
```
