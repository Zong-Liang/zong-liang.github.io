---
title: Stream流
date: 2024-06-21 06:00:00 +0800
categories: [Daily Coding, Coding Tips, Stream流]
tags: [Stream流]
toc: true
math: true
pin: true
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251124102717810.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 概述

### 1. 什么是 Stream？

Stream（流）不是数据结构，它不存储数据。Stream 是数据源的视图，它专注于对数据源进行各种计算操作。数据源可以是集合、数组、I/O 通道等。Stream API 允许你以声明式的方式处理数据，这意味着你只需描述“做什么”，而不是“怎么做”。

### 2. Stream 的特点

- **非存储性：** Stream 不存储数据，它只是对数据源的一个封装，数据源可以是一个集合、数组、I/O 资源等。
- **函数式：** Stream 操作是函数式的。它不会修改数据源本身，而是生成一个新的 Stream 或一个结果。
- **惰性求值：** 许多 Stream 操作是惰性求值的。这意味着它们只有在终端操作被调用时才会被执行。
- **可消费一次：** 一个 Stream 只能被消费（遍历）一次。一旦执行了终端操作，Stream 就关闭了，不能再次使用。
- **支持并行处理：** Stream 可以很容易地进行并行处理，这在处理大量数据时非常有用。

### 3. Stream 操作的分类

Stream 操作分为两大类：

- **中间操作 (Intermediate Operations):**

  - 返回一个新的 Stream。
  - 它们是惰性求值的，不会立即执行，而是构建一个操作链。
  - 常见的中间操作包括：`filter()`（过滤）、`map()`（映射/转换）、`flatMap()`（扁平化映射）、`distinct()`（去重）、`sorted()`（排序）、`peek()`（查看元素）、`limit()`（截断）、`skip()`（跳过）等。

- **终端操作 (Terminal Operations):**
  - 触发 Stream 管道的执行。
  - 生成一个非 Stream 的结果（例如：一个集合、一个值、一个副作用）。
  - 一个 Stream 只能有一个终端操作。
  - 常见的终端操作包括：`forEach()`（遍历）、`collect()`（收集到集合）、`reduce()`（归约）、`count()`（计数）、`min()`/`max()`（最小值/最大值）、`findFirst()`/`findAny()`（查找）、`allMatch()`/`anyMatch()`/`noneMatch()`（匹配）等。

### 4. Stream 的创建

- **从集合：** `collection.stream()` 或 `collection.parallelStream()`
- **从数组：** `Arrays.stream(array)`
- **从值：** `Stream.of(val1, val2, ...)`
- **从文件：** `Files.lines(path)`
- **生成无限流：** `Stream.generate()` 或 `Stream.iterate()`

## Java 代码

```java
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/**
 * @author zongliang_i
 */
public class Main {
    public static void main(String[] args) {

        System.out.println("--- 1. Stream的创建 ---");
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David", "Alice");
        Stream<String> nameStream = names.stream(); // 从List创建Stream
        String[] colors = {"Red", "Green", "Blue"};
        Stream<String> colorStream = Arrays.stream(colors); // 从数组创建Stream
        Stream<String> stringStream = Stream.of("One", "Two", "Three"); // 从若干值创建Stream
        IntStream intStream = IntStream.range(1, 5); // 原始类型Stream (1到4)
        IntStream intStreamClosed = IntStream.rangeClosed(1, 5); // 原始类型Stream (1到5)

        System.out.println("\n--- 2. 中间操作 ---");

        List<Person> people = Arrays.asList(
            new Person("Alice", 30, "New York"),
            new Person("Bob", 25, "London"),
            new Person("Charlie", 35, "New York"),
            new Person("David", 25, "Paris"),
            new Person("Eve", 40, "London"),
            new Person("Frank", 30, "New York")
        );

        System.out.println("\n--- 2.1 filter(): 过滤 ---");
        // 找出所有年龄大于30的人
        List<Person> olderPeople = people.stream()
            .filter(p -> p.getAge() > 30) // Lambda表达式作为Predicate
            .collect(Collectors.toList()); // 终端操作：收集到List
        System.out.println("Older people (>30): " + olderPeople);

        System.out.println("\n--- 2.2 map(): 映射/转换 ---");
        // 获取所有人的名字并转换为大写
        List<String> upperCaseNames = people.stream()
            .map(p -> p.getName().toUpperCase()) // Lambda表达式作为Function
            .collect(Collectors.toList());
        System.out.println("Uppercase names: " + upperCaseNames);

        System.out.println("\n--- 2.3 distinct(): 去重 ---");
        // 从原始名字列表中去重
        List<String> distinctNames = names.stream()
            .distinct()
            .collect(Collectors.toList());
        System.out.println("Distinct names: " + distinctNames);

        System.out.println("\n--- 2.4 sorted(): 排序 ---");
        // 按年龄升序排序
        List<Person> sortedByAge = people.stream()
            .sorted(Comparator.comparing(Person::getAge)) // 方法引用
            .collect(Collectors.toList());
        System.out.println("Sorted by age: " + sortedByAge);

        // 按年龄降序，年龄相同则按名字升序
        List<Person> sortedComplex = people.stream()
            .sorted(Comparator.comparing(Person::getAge).reversed()
                .thenComparing(Person::getName))
            .collect(Collectors.toList());
        System.out.println("Sorted by age (desc) then name (asc): " + sortedComplex);

        System.out.println("\n--- 2.5 limit() & skip(): 限制和跳过 ---");
        // 跳过前两个，然后取接下来的两个
        List<String> limitedAndSkipped = names.stream()
            .skip(2)
            .limit(2)
            .collect(Collectors.toList());
        System.out.println("Skipped 2, then limited to 2: " + limitedAndSkipped); // Charlie, David

        System.out.println("\n--- 2.6 flatMap(): 扁平化映射 ---");
        // 假设每个Person有一个List<String> hobbies
        List<List<String>> hobbiesList = Arrays.asList(
            Arrays.asList("Reading", "Swimming"),
            Arrays.asList("Gaming", "Hiking", "Reading"),
            Arrays.asList("Cooking")
        );
        // 将所有爱好扁平化到一个Stream中
        List<String> allHobbies = hobbiesList.stream()
            .flatMap(List::stream) // 将每个内部List转换为一个Stream，然后合并
            .distinct() // 去重
            .collect(Collectors.toList());
        System.out.println("All distinct hobbies: " + allHobbies);

        System.out.println("\n--- 3. 终端操作 ---");

        System.out.println("\n--- 3.1 forEach(): 遍历 ---");
        System.out.print("Names: ");
        names.stream().forEach(name -> System.out.print(name + " "));
        System.out.println();

        System.out.println("\n--- 3.2 collect(): 收集结果 ---");
        // 收集到Set (去重)
        Set<String> distinctNameSet = names.stream()
            .collect(Collectors.toSet());
        System.out.println("Distinct names in Set: " + distinctNameSet);

        // 收集到Map (例如：按城市分组)
        Map<String, List<Person>> peopleByCity = people.stream()
            .collect(Collectors.groupingBy(Person::getCity));
        System.out.println("People grouped by city: " + peopleByCity);

        // 收集到Map (例如：城市 -> 城市中人的名字)
        Map<String, List<String>> namesByCity = people.stream()
            .collect(Collectors.groupingBy(Person::getCity, // 分组键
                Collectors.mapping(Person::getName, Collectors.toList()))); // 值的映射和收集
        System.out.println("Names grouped by city: " + namesByCity);

        // 收集到Map (城市 -> 该城市年龄最大的一个人，处理同键冲突)
        Map<String, Optional<Person>> oldestPersonInCity = people.stream()
            .collect(Collectors.groupingBy(Person::getCity,
                Collectors.maxBy(Comparator.comparing(Person::getAge))));
        System.out.println("Oldest person in each city: " + oldestPersonInCity);


        System.out.println("\n--- 3.3 reduce(): 归约 ---");
        // 计算所有数字的和 (初始值0, 加法操作)
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        Optional<Integer> sumOptional = numbers.stream().reduce((a, b) -> a + b); // 没有初始值，返回Optional
        sumOptional.ifPresent(s -> System.out.println("Sum of numbers: " + s));

        int sumWithIdentity = numbers.stream().reduce(0, (a, b) -> a + b); // 有初始值
        System.out.println("Sum of numbers (with identity): " + sumWithIdentity);

        // 字符串连接
        String combinedNames = names.stream()
            .reduce("Combined: ", (acc, name) -> acc + name + " ");
        System.out.println(combinedNames);

        System.out.println("\n--- 3.4 count(), min(), max(): 统计 ---");
        long personCount = people.stream().count();
        System.out.println("Total number of people: " + personCount);

        Optional<Person> youngest = people.stream()
            .min(Comparator.comparing(Person::getAge));
        youngest.ifPresent(p -> System.out.println("Youngest person: " + p.getName()));

        Optional<Person> oldest = people.stream()
            .max(Comparator.comparing(Person::getAge));
        oldest.ifPresent(p -> System.out.println("Oldest person: " + p.getName()));

        System.out.println("\n--- 3.5 findFirst(), findAny(): 查找 ---");
        // 找到第一个居住在New York且年龄大于30的人
        Optional<Person> firstNYPersonOver30 = people.stream()
            .filter(p -> p.getCity().equals("New York") && p.getAge() > 30)
            .findFirst(); // 对于有序流，总是返回第一个
        firstNYPersonOver30.ifPresent(p -> System.out.println("First NY person over 30: " + p));

        // findAny() 在并行流中可能更高效，因为它不需要保证顺序
        Optional<Person> anyLondonPerson = people.stream()
            .filter(p -> p.getCity().equals("London"))
            .findAny();
        anyLondonPerson.ifPresent(p -> System.out.println("Any London person: " + p));


        System.out.println("\n--- 3.6 allMatch(), anyMatch(), noneMatch(): 匹配 ---");
        boolean allAdults = people.stream()
            .allMatch(p -> p.getAge() >= 18);
        System.out.println("Are all people adults? " + allAdults);

        boolean anyLondoner = people.stream()
            .anyMatch(p -> p.getCity().equals("London"));
        System.out.println("Is there any Londoner? " + anyLondoner);

        boolean noParisian = people.stream()
            .noneMatch(p -> p.getCity().equals("Paris"));
        System.out.println("Are there no Parisians? " + noParisian); // false, because David is from Paris

        System.out.println("\n--- 4. 并行Stream (Parallel Stream) ---");
        // 在大数据量操作时，并行流可以显著提高性能
        long start = System.nanoTime();
        long parallelSum = IntStream.rangeClosed(1, 100_000_000)
            .parallel() // 启用并行处理
            .sum();
        long end = System.nanoTime();
        System.out.printf("Parallel sum of 1 to 100,000,000: %d (took %d ms)%n", parallelSum,
            (end - start) / 1_000_000);

        start = System.nanoTime();
        long sequentialSum = IntStream.rangeClosed(1, 100_000_000)
            .sum();
        end = System.nanoTime();
        System.out.printf("Sequential sum of 1 to 100,000,000: %d (took %d ms)%n", sequentialSum,
            (end - start) / 1_000_000);

        System.out.println("\n--- 5. 无限流 (Infinite Streams) ---");

        System.out.println("First 5 even numbers generated: ");
        Stream.iterate(0, n -> n + 2) // 从0开始，每次加2
            .limit(5) // 取前5个
            .forEach(n -> System.out.print(n + " ")); // 0 2 4 6 8
        System.out.println();

        System.out.println("First 3 random numbers generated: ");
        Stream.generate(Math::random) // 生成随机数
            .limit(3)
            .forEach(n -> System.out.print(n + " "));
        System.out.println();
    }
}
```
