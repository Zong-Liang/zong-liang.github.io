---
title: Java集合
date: 2024-06-09 06:00:00 +0800
categories: [Daily Coding, Coding Tips, Java集合]
tags: [Java集合]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251123151222794.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## List 接口

### 核心概念总结

- **接口与实现**：`List` 是一个接口，定义了列表的行为规范。`ArrayList` 和 `LinkedList` 是它的两个主要实现，具有不同的内部数据结构和性能特点。
- **`ArrayList` (默认首选)**：内部是**动态数组**。非常适合**随机访问（`get`）和遍历**。在列表末尾添加元素也很快。但在列表**中间或开头插入/删除元素很慢**，因为需要移动大量元素。
- **`LinkedList`**：内部是**双向链表**。**在列表的开头和结尾进行插入/删除操作非常快**。但是**随机访问（`get`）很慢**，因为它需要从头或尾开始遍历链表。
- **安全删除**：在遍历 `List` 并需要删除元素时，必须使用**迭代器（`Iterator`）的 `remove()` 方法**，以避免 `ConcurrentModificationException`。

### Java 代码

```java
package com.java_se.se_07_collection.grp_01_list;

import java.util.*;
import java.util.stream.Collectors;

/**
 * @author zongliang_i
 *
 * 这是一个用于学习Java中List接口及其主要实现的综合示例程序。
 * 它涵盖了：
 * 1. List的创建与初始化 (ArrayList & LinkedList)
 * 2. 核心操作 (增、删、改、查)
 * 3. 多种遍历方式 (包括安全的删除)
 * 4. ArrayList 与 LinkedList 的关键区别与性能对比
 * 5. 其他常用方法和现代Stream API用法
 */
public class Main {
    public static void main(String[] args) {
        System.out.println("--- 1. List 的创建与初始化 ---");
        demonstrateListCreation();

        System.out.println("\n--- 2. List 的核心操作 (CRUD) ---");
        demonstrateCoreOperations();

        System.out.println("\n--- 3. 遍历 List 的四种主要方式 ---");
        demonstrateIteration();

        System.out.println("\n--- 4. ArrayList vs. LinkedList (重要！) ---");
        demonstrateArrayListVsLinkedList();

        System.out.println("\n--- 5. 其他实用方法 ---");
        demonstrateUsefulMethods();

        System.out.println("\n--- 6. 使用 Stream API 操作 List (现代Java) ---");
        demonstrateListWithStreams();
    }

    /**
     * 1. 演示创建List的多种方式
     */
    public static void demonstrateListCreation() {
        // 推荐的方式：使用接口类型(List)作为引用，具体实现(ArrayList)作为对象。
        // 这被称为“面向接口编程”。
        System.out.println("a) 创建 ArrayList (最常用):");
        List<String> fruits = new ArrayList<>();
        fruits.add("Apple");
        fruits.add("Banana");
        System.out.println("   " + fruits);

        System.out.println("\nb) 创建 LinkedList:");
        List<Integer> numbers = new LinkedList<>();
        numbers.add(100);
        numbers.add(200);
        System.out.println("   " + numbers);

        // 使用 Arrays.asList()，注意它返回的是一个固定大小的List
        System.out.println("\nc) 使用 Arrays.asList() 创建:");
        List<String> fixedSizeList = Arrays.asList("Java", "Python", "Go");
        // fixedSizeList.add("C++"); // 这行会抛出 UnsupportedOperationException，因为大小固定
        System.out.println("   " + fixedSizeList);

        // Java 9+ 的 List.of()，返回一个不可变的List
        System.out.println("\nd) 使用 List.of() 创建 (Java 9+):");
        List<String> immutableList = List.of("Read-Only", "Immutable");
        // immutableList.add("Modify"); // 同样会抛出 UnsupportedOperationException
        System.out.println("   " + immutableList);
    }

    /**
     * 2. 演示List的增、删、改、查 (CRUD: Create, Read, Update, Delete)
     */
    public static void demonstrateCoreOperations() {
        List<String> languages = new ArrayList<>();

        // 增 (Add)
        languages.add("Java");      // 在末尾添加
        languages.add("C++");
        languages.add(1, "Python"); // 在指定索引位置添加
        System.out.println("添加元素后: " + languages);

        // 查 (Get)
        String languageAtIndex2 = languages.get(2);
        System.out.println("索引为2的元素是: " + languageAtIndex2);

        // 改 (Set)
        languages.set(2, "JavaScript"); // 替换指定索引的元素
        System.out.println("修改元素后: " + languages);

        // 删 (Remove)
        languages.remove(0);           // 按索引删除
        languages.remove("Python");    // 按对象值删除
        System.out.println("删除元素后: " + languages);

        // 获取大小
        System.out.println("当前List的大小: " + languages.size());

        // 清空
        languages.clear();
        System.out.println("清空后List的大小: " + languages.size());
    }

    /**
     * 3. 演示遍历List的多种方式
     */
    public static void demonstrateIteration() {
        List<String> techGiants = new ArrayList<>(Arrays.asList("Google", "Microsoft", "Amazon", "Apple"));
        System.out.println("原始List: " + techGiants);

        // 方式一：增强 For 循环 (For-Each) - 最常用
        System.out.println("\na) 使用 For-Each 循环:");
        for (String company : techGiants) {
            System.out.println("   - " + company);
        }

        // 方式二：传统 For 循环 (需要使用索引时)
        System.out.println("\nb) 使用传统 For 循环:");
        for (int i = 0; i < techGiants.size(); i++) {
            System.out.println("   - 索引 " + i + ": " + techGiants.get(i));
        }

        // 方式三：迭代器 (Iterator) - 唯一能在遍历时安全删除元素的方式
        System.out.println("\nc) 使用迭代器 (Iterator) 并安全删除 'Amazon':");
        Iterator<String> iterator = techGiants.iterator();
        while (iterator.hasNext()) {
            String company = iterator.next();
            if (company.equals("Amazon")) {
                iterator.remove(); // ★★★ 正确的删除方式 ★★★
            }
        }
        System.out.println("   删除后: " + techGiants);
        // 如果在 for-each 循环中直接调用 list.remove() 会抛出 ConcurrentModificationException

        // 方式四：Lambda 表达式 (Java 8+)
        System.out.println("\nd) 使用 Lambda forEach:");
        techGiants.forEach(company -> System.out.println("   - " + company));
    }

    /**
     * 4. 演示 ArrayList 和 LinkedList 的关键区别
     */
    public static void demonstrateArrayListVsLinkedList() {
        // 理论：
        // ArrayList:  基于动态数组。查询快 (O(1))，中间增删慢 (O(n))。
        // LinkedList: 基于双向链表。查询慢 (O(n))，头尾增删极快 (O(1))。

        System.out.println("进行性能测试: 在列表头部插入 100,000 个元素...");

        // ArrayList 头部插入测试
        List<Integer> arrayList = new ArrayList<>();
        long startTime = System.nanoTime();
        for (int i = 0; i < 100000; i++) {
            arrayList.add(0, i); // 每次都在头部插入，效率极低
        }
        long endTime = System.nanoTime();
        System.out.println("ArrayList 耗时: " + (endTime - startTime) / 1_000_000 + " ms");

        // LinkedList 头部插入测试
        List<Integer> linkedList = new LinkedList<>();
        startTime = System.nanoTime();
        for (int i = 0; i < 100000; i++) {
            linkedList.add(0, i); // 在头部插入是 LinkedList 的强项
        }
        endTime = System.nanoTime();
        System.out.println("LinkedList 耗时: " + (endTime - startTime) / 1_000_000 + " ms");

        System.out.println("结论: 在需要频繁在列表头尾进行增删操作时，LinkedList性能远超ArrayList。其他大部分情况，请默认使用ArrayList。");
    }

    /**
     * 5. 演示 List 的一些其他实用方法
     */
    public static void demonstrateUsefulMethods() {
        List<String> colors = new ArrayList<>(Arrays.asList("Red", "Green", "Blue", "Green", "Yellow"));
        System.out.println("原始List: " + colors);

        // 包含判断 (contains)
        System.out.println("是否包含 'Blue'? " + colors.contains("Blue"));

        // 查找索引 (indexOf / lastIndexOf)
        System.out.println("'Green' 首次出现的索引: " + colors.indexOf("Green"));
        System.out.println("'Green' 最后出现的索引: " + colors.lastIndexOf("Green"));

        // 子列表 (subList)
        List<String> subList = colors.subList(1, 4); // [1, 4) 左闭右开
        System.out.println("从索引1到3的子列表: " + subList);

        // 转换为数组 (toArray)
        String[] colorArray = colors.toArray(new String[0]);
        System.out.println("转换为数组后的第一个元素: " + colorArray[0]);
    }

    /**
     * 6. 演示使用 Java 8 Stream API
     */
    public static void demonstrateListWithStreams() {
        List<Integer> data = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        System.out.println("原始数据: " + data);

        // 需求：筛选出所有偶数，将它们乘以2，然后收集到一个新的List中
        List<Integer> result = data.stream()            // 1. 创建流
            .filter(n -> n % 2 == 0) // 2. 筛选偶数
            .map(n -> n * 2)         // 3. 将每个元素乘以2
            .collect(Collectors.toList()); // 4. 收集结果

        System.out.println("Stream处理后的结果: " + result);
    }
}
```

## Set 接口

### 核心概念总结

- **`Set` 接口**：一个不包含重复元素的集合。
- **`HashSet` (首选)**：
  - **特点**：无序，唯一。
  - **底层**：基于哈希表（`HashMap`）实现。
  - **性能**：添加、删除、查找操作的平均时间复杂度都是 **O(1)**，性能极高。
  - **要求**：存入的对象必须正确实现 `hashCode()` 和 `equals()` 方法。
- **`LinkedHashSet`**：
  - **特点**：保持**插入顺序**，唯一。
  - **底层**：基于链表和哈希表，是 `HashSet` 的子类。
  - **性能**：略低于 `HashSet`，但提供了顺序保证。
- **`TreeSet`**：
  - **特点**：**有序**（自然排序或自定义排序），唯一。
  - **底层**：基于红黑树实现。
  - **性能**：添加、删除、查找操作的时间复杂度是 **O(log n)**。
  - **要求**：存入的对象必须是**可比较的**（实现 `Comparable` 接口或提供 `Comparator`）。
- **`equals()` & `hashCode()` 契约**：使用 `HashSet` 或 `LinkedHashSet` 存储自定义对象时，**必须**同时重写这两个方法，以确保 `Set` 能够正确判断元素的唯一性。

### Java 代码

为了演示 `hashCode()` 和 `equals()` 的重要性，这个示例会包含一个自定义的 `Book` 类。

#### 文件 1: `Book.java` (用于演示自定义对象)

```java
import java.util.Objects;

/**
 * @author zongliang_i
 *
 * Book.java - 一个自定义类
 * 为了让 Book 对象能够被正确地存储在 HashSet 或 LinkedHashSet 中，
 * 我们必须重写 equals() 和 hashCode() 方法。
 */
public class Book {
    private String title;
    private String author;

    public Book(String title, String author) {
        this.title = title;
        this.author = author;
    }

    public String getTitle() {
        return title;
    }

    public String getAuthor() {
        return author;
    }

    @Override
    public String toString() {
        return "Book{" +
               "title='" + title + '\'' +
               ", author='" + author + '\'' +
               '}';
    }

    // ★★★ 关键部分 1: 重写 equals() ★★★
    // 定义了“什么情况下两本书被认为是相同的” -> 当书名和作者都相同时。
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Book book = (Book) o;
        return Objects.equals(title, book.title) &&
               Objects.equals(author, book.author);
    }

    // ★★★ 关键部分 2: 重写 hashCode() ★★★
    // 约定：如果两本书通过 equals() 比较是相等的，那么它们的 hashCode() 必须返回相同的值。
    // Set 使用 hashCode() 来快速定位元素应该存储在哪个“桶”里。
    @Override
    public int hashCode() {
        return Objects.hash(title, author);
    }
}
```

#### 文件 2: `Main.java` (主程序)

```java
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.TreeSet;

/**
 * @author zongliang_i
 *
 * 这是一个用于学习Java中Set接口及其主要实现的综合示例程序。
 * 它涵盖了：
 * 1. HashSet: 无序、唯一
 * 2. LinkedHashSet: 插入顺序、唯一
 * 3. TreeSet: 自然排序、唯一
 * 4. Set 的核心操作和集合运算
 * 5. 自定义对象在 Set 中的存储 (hashCode 和 equals 的重要性)
 */
public class Main {

    public static void main(String[] args) {
        System.out.println("--- 1. HashSet: 无序、唯一 (最常用) ---");
        demonstrateHashSet();

        System.out.println("\n--- 2. LinkedHashSet: 保持插入顺序、唯一 ---");
        demonstrateLinkedHashSet();

        System.out.println("\n--- 3. TreeSet: 自动排序、唯一 ---");
        demonstrateTreeSet();

        System.out.println("\n--- 4. Set 的集合运算 ---");
        demonstrateSetOperations();

        System.out.println("\n--- 5. 自定义对象存入 Set (重要！) ---");
        demonstrateCustomObjectsInSet();
    }

    /**
     * 1. 演示 HashSet: 元素无序存储，性能高。
     */
    public static void demonstrateHashSet() {
        Set<String> fruits = new HashSet<>();

        // 添加元素
        fruits.add("Banana");
        fruits.add("Apple");
        fruits.add("Orange");

        // 尝试添加一个重复元素
        boolean isAdded = fruits.add("Apple"); // 这次添加会失败

        System.out.println("Set 中的元素: " + fruits); // 注意：输出顺序不一定是添加顺序
        System.out.println("再次添加 'Apple' 是否成功? " + isAdded); // false
        System.out.println("Set 的大小: " + fruits.size());

        // 检查是否包含某个元素 (效率非常高)
        System.out.println("是否包含 'Banana'? " + fruits.contains("Banana")); // true

        // 删除元素
        fruits.remove("Orange");
        System.out.println("删除 'Orange' 后的 Set: " + fruits);
    }

    /**
     * 2. 演示 LinkedHashSet: 按照元素插入的顺序进行存储。
     */
    public static void demonstrateLinkedHashSet() {
        Set<String> days = new LinkedHashSet<>();
        days.add("Monday");
        days.add("Tuesday");
        days.add("Wednesday");
        System.out.println("LinkedHashSet 中的元素: " + days); // 输出顺序与添加顺序一致
    }

    /**
     * 3. 演示 TreeSet: 元素会自动进行自然排序。
     *    存入 TreeSet 的对象必须实现 Comparable 接口，或者在创建 TreeSet 时提供一个 Comparator。
     */
    public static void demonstrateTreeSet() {
        Set<Integer> numbers = new TreeSet<>();
        numbers.add(50);
        numbers.add(10);
        numbers.add(90);
        numbers.add(30);
        System.out.println("TreeSet 中的元素: " + numbers); // 输出结果是 [10, 30, 50, 90]，已自动排序

        // 对于字符串，会按字母顺序排序
        Set<String> names = new TreeSet<>();
        names.add("David");
        names.add("Alice");
        names.add("Charlie");
        names.add("Bob");
        System.out.println("TreeSet 中的字符串: " + names); // [Alice, Bob, Charlie, David]
    }

    /**
     * 4. 演示 Set 的常见集合运算：并集、交集、差集
     */
    public static void demonstrateSetOperations() {
        Set<Integer> setA = new HashSet<>(Set.of(1, 2, 3, 4, 5));
        Set<Integer> setB = new HashSet<>(Set.of(4, 5, 6, 7, 8));
        System.out.println("Set A: " + setA);
        System.out.println("Set B: " + setB);

        // 并集 (Union): 合并两个Set，去除重复项
        Set<Integer> union = new HashSet<>(setA);
        union.addAll(setB);
        System.out.println("并集 (A U B): " + union);

        // 交集 (Intersection): 只保留两个Set中都存在的元素
        Set<Integer> intersection = new HashSet<>(setA);
        intersection.retainAll(setB);
        System.out.println("交集 (A ∩ B): " + intersection);

        // 差集 (Difference): 从Set A中移除所有在Set B中也存在的元素
        Set<Integer> difference = new HashSet<>(setA);
        difference.removeAll(setB);
        System.out.println("差集 (A - B): " + difference);
    }

    /**
     * 5. 演示将自定义对象存入 Set，并解释 equals() 和 hashCode() 的重要性
     */
    public static void demonstrateCustomObjectsInSet() {
        Set<Book> bookSet = new HashSet<>();

        Book book1 = new Book("Java Core", "Cay S. Horstmann");
        Book book2 = new Book("Effective Java", "Joshua Bloch");
        // book3 与 book1 的内容完全相同
        Book book3 = new Book("Java Core", "Cay S. Horstmann");

        bookSet.add(book1);
        bookSet.add(book2);
        bookSet.add(book3); // Set 会使用 hashCode() 和 equals() 来判断 book3 是否已存在

        System.out.println("书架上的书 (Set):");
        // 因为我们正确重写了 equals() 和 hashCode()，
        // Set 能够识别出 book1 和 book3 是“相同”的，因此只存储了一个。
        for (Book book : bookSet) {
            System.out.println(" - " + book);
        }
        System.out.println("Set 的大小: " + bookSet.size()); // 输出 2
        System.out.println("结论: 如果没有正确重写 equals() 和 hashCode(), Set 的大小会是3。");
    }
}
```

## Queue 接口

### 核心概念总结

- **`Queue` 接口**：定义了先进先出（FIFO）的集合行为。
- **实现类**：
  - `LinkedList`：最通用的 `Queue` 实现，基于链表。
  - `PriorityQueue`：不是 FIFO，而是一个“堆”，元素按其自然顺序或指定的比较器顺序出队。
  - `ArrayDeque`：`Deque`接口的实现，基于动态数组，效率很高。是实现**队列**和**栈**的首选。
- **核心方法（推荐使用）**：
  - `offer(e)`: 添加元素。
  - `poll()`: 移除并返回队首元素，如果队列为空则返回 `null`。
  - `peek()`: 查看队首元素但不移除，如果队列为空则返回 `null`。
- **`Deque` 接口**：`Queue` 的子接口，表示“双端队列”，允许在队列的头尾两端进行添加和删除操作。这使得它既能当队列用，也能当栈用。

### Java 代码

为了演示 `PriorityQueue` 的自定义排序，这个示例会包含一个自定义的 `Task` 类。

#### 文件 1: `Task.java` (用于 PriorityQueue)

```java
/**
 * @author zongliang_i
 *
 * Task.java - 一个自定义类，用于演示 PriorityQueue。
 * 它有一个名称和优先级。我们希望优先级数字越小，代表优先级越高。
 */
public class Task {
    private String name;
    private int priority; // 1 = 最高优先级

    public Task(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }

    public String getName() {
        return name;
    }

    public int getPriority() {
        return priority;
    }

    @Override
    public String toString() {
        return "Task{" +
               "name='" + name + '\'' +
               ", priority=" + priority +
               '}';
    }
}
```

#### 文件 2: `Main.java` (主程序)

```java
import java.util.ArrayDeque;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Deque;
import java.util.NoSuchElementException;

/**
 * @author zongliang_i
 *
 * 这是一个用于学习Java中Queue接口及其主要实现的综合示例程序。
 * 它涵盖了：
 * 1. 使用 LinkedList 实现标准FIFO队列。
 * 2. Queue 接口两套核心方法 (抛异常 vs. 返回特殊值) 的区别。
 * 3. PriorityQueue: 基于优先级的队列。
 * 4. Deque (双端队列) 及其作为队列和栈的使用。
 */
public class Main {

    public static void main(String[] args) {
        System.out.println("--- 1. 使用 LinkedList 实现标准 FIFO 队列 ---");
        demonstrateLinkedListAsQueue();

        System.out.println("\n--- 2. Queue 核心方法的两套 API 对比 (重要！) ---");
        demonstrateMethodPairs();

        System.out.println("\n--- 3. PriorityQueue: 按优先级出队的队列 ---");
        demonstratePriorityQueue();

        System.out.println("\n--- 4. Deque (双端队列): 更强大的队列 ---");
        demonstrateDeque();
    }

    /**
     * 1. 演示 LinkedList 作为标准的先进先出 (FIFO) 队列。
     */
    public static void demonstrateLinkedListAsQueue() {
        // 使用接口类型 Queue 引用具体的实现 LinkedList
        Queue<String> waitingLine = new LinkedList<>();

        // offer(): 向队尾添加元素。这是推荐的添加方法。
        waitingLine.offer("Customer 1");
        waitingLine.offer("Customer 2");
        waitingLine.offer("Customer 3");
        System.out.println("当前排队的人: " + waitingLine);

        // peek(): 查看队首元素，但不移除它。
        String nextPerson = waitingLine.peek();
        System.out.println("下一位是: " + nextPerson);
        System.out.println("查看后，队列依然是: " + waitingLine);

        // poll(): 移除并返回队首元素。
        System.out.println("\n开始处理业务...");
        while (!waitingLine.isEmpty()) {
            String processedPerson = waitingLine.poll();
            System.out.println(processedPerson + " 已被处理。剩余队列: " + waitingLine);
        }

        // 队列为空后，poll() 和 peek() 会返回 null
        System.out.println("\n队列为空后, waitingLine.poll() 返回: " + waitingLine.poll()); // null
    }

    /**
     * 2. 演示 Queue 接口中两套方法的区别。
     *    - 一套在操作失败时抛出异常。
     *    - 另一套在操作失败时返回特殊值 (null 或 false)。
     */
    public static void demonstrateMethodPairs() {
        Queue<Integer> queue = new LinkedList<>();

        // 添加: add() vs offer()
        // 两者通常表现相同，但在有容量限制的队列中，add()会抛异常，offer()会返回false。
        queue.add(1);
        queue.offer(2);
        System.out.println("Queue: " + queue);

        // 移除: remove() vs poll() - 在空队列上操作
        queue.clear(); // 清空队列
        System.out.println("队列已清空。");
        System.out.println("调用 poll() on empty queue: " + queue.poll()); // 返回 null
        try {
            queue.remove(); // 抛出 NoSuchElementException
        } catch (NoSuchElementException e) {
            System.err.println("调用 remove() on empty queue: 抛出了 " + e);
        }

        // 查看: element() vs peek() - 在空队列上操作
        System.out.println("调用 peek() on empty queue: " + queue.peek()); // 返回 null
        try {
            queue.element(); // 抛出 NoSuchElementException
        } catch (NoSuchElementException e) {
            System.err.println("调用 element() on empty queue: 抛出了 " + e);
        }
        System.out.println("结论: 推荐使用 offer(), poll(), peek()，因为它们不会因队列为空而使程序崩溃。");
    }

    /**
     * 3. 演示 PriorityQueue，元素不按插入顺序，而是按优先级排序。
     */
    public static void demonstratePriorityQueue() {
        // 默认情况下，PriorityQueue 对数字使用自然排序（从小到大）
        Queue<Integer> numberPriority = new PriorityQueue<>();
        numberPriority.offer(30);
        numberPriority.offer(10);
        numberPriority.offer(20);
        System.out.println("PriorityQueue (数字): " + numberPriority);
        System.out.println("按优先级出队:");
        while (!numberPriority.isEmpty()) {
            System.out.print(numberPriority.poll() + " "); // 输出 10 20 30
        }
        System.out.println();

        // 对于自定义对象，需要提供一个 Comparator 来定义“优先级”
        // 这里我们让 priority 数字越小，优先级越高
        Queue<Task> taskQueue = new PriorityQueue<>(Comparator.comparingInt(Task::getPriority));
        taskQueue.offer(new Task("修复Bug", 2));
        taskQueue.offer(new Task("发布新版本", 3));
        taskQueue.offer(new Task("处理线上紧急故障", 1)); // 最高优先级

        System.out.println("\n任务优先级队列:");
        while (!taskQueue.isEmpty()) {
            System.out.println("正在处理: " + taskQueue.poll());
        }
    }

    /**
     * 4. 演示 Deque (Double-Ended Queue)，它比 Queue 更强大。
     *    ArrayDeque 是 Deque 的推荐实现。
     */
    public static void demonstrateDeque() {
        Deque<String> deque = new ArrayDeque<>();

        // --- 1. 把它当作普通队列 (FIFO) 使用 ---
        System.out.println("--- Deque as a Queue (FIFO) ---");
        deque.offerLast("A");  // 在队尾添加
        deque.offerLast("B");
        deque.offerLast("C");
        System.out.println("Deque: " + deque);
        System.out.println("移除队首: " + deque.pollFirst()); // 移除队首
        System.out.println("移除队首: " + deque.pollFirst());
        System.out.println("剩余Deque: " + deque);
        deque.clear();

        // --- 2. 把它当作栈 (LIFO) 使用 ---
        // 现代Java中推荐使用 Deque/ArrayDeque 来替代老旧的 Stack 类
        System.out.println("\n--- Deque as a Stack (LIFO) ---");
        deque.push("Item 1"); // 等同于 addFirst()
        deque.push("Item 2");
        deque.push("Item 3");
        System.out.println("Deque: " + deque);

        System.out.println("弹出栈顶: " + deque.pop()); // 等同于 removeFirst()
        System.out.println("弹出栈顶: " + deque.pop());
        System.out.println("剩余Deque: " + deque);
    }
}
```

## Map 接口

### 核心概念总结

- **`Map` 接口**：存储键值对 (`<K, V>`) 的集合，**键 (Key) 必须唯一**。
- **`HashMap` (90%的情况下使用它)**：
  - **特点**：键无序，允许一个 `null` 键和多个 `null` 值。
  - **性能**：添加、删除、查找的平均时间复杂度为 **O(1)**，性能极好。
- **`LinkedHashMap`**：
  - **特点**：保持键的**插入顺序**。
  - **性能**：略低于 `HashMap`，但提供了顺序保证。
- **`TreeMap`**：
  - **特点**：键是**有序的**（自然排序或自定义排序）。
  - **性能**：添加、删除、查找的时间复杂度为 **O(log n)**。
- **`equals()` & `hashCode()` 契约**：这是`Map`的灵魂。`Map`使用`key.hashCode()`来快速定位存储位置，然后使用`key.equals()`来解决哈希冲突，并最终确认键是否已存在。两者必须协同工作，才能保证`Map`的正确性。

### Java 代码

和 `Set` 一样，为了演示自定义对象作为`Key`，我们需要一个辅助类。

#### 文件 1: `Employee.java` (自定义 Key)

```java
import java.util.Objects;

/**
 * @author zongliang_i
 *
 * Employee.java - 一个自定义类，用于作为 Map 的键 (Key)。
 * 为了让 Employee 对象能够被正确地用作 HashMap 或 LinkedHashMap 的键，
 * 我们必须重写 equals() 和 hashCode() 方法。
 */
public class Employee {
    private int id;
    private String department;

    public Employee(int id, String department) {
        this.id = id;
        this.department = department;
    }

    // Getters
    public int getId() { return id; }
    public String getDepartment() { return department; }

    @Override
    public String toString() {
        return "Employee{id=" + id + ", dept='" + department + "'}";
    }

    // ★★★ 关键部分 1: 重写 equals() ★★★
    // 定义了“什么情况下两个员工被认为是相同的 Key” -> 当部门和ID都相同时。
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return id == employee.id &&
               Objects.equals(department, employee.department);
    }

    // ★★★ 关键部分 2: 重写 hashCode() ★★★
    // 约定：如果两个员工通过 equals() 比较是相等的，那么它们的 hashCode() 必须返回相同的值。
    // Map 使用 hashCode() 来快速计算 Key 应该存储在哪个位置。
    @Override
    public int hashCode() {
        return Objects.hash(id, department);
    }
}
```

#### 文件 2: `Main.java` (主程序)

```java
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.TreeMap;

/**
 * @author zongliang_i
 *
 * 这是一个用于学习Java中Map接口及其主要实现的综合示例程序。
 * 它涵盖了：
 * 1. HashMap: 无序、键唯一 (最常用)
 * 2. LinkedHashMap: 插入顺序、键唯一
 * 3. TreeMap: 按键排序、键唯一
 * 4. Map 的核心操作和多种遍历方式
 * 5. 自定义对象作为键 (hashCode 和 equals 的重要性)
 */
public class Main {

    public static void main(String[] args) {
        System.out.println("--- 1. HashMap: 无序、键唯一 (性能最高) ---");
        demonstrateHashMap();

        System.out.println("\n--- 2. LinkedHashMap: 保持插入顺序 ---");
        demonstrateLinkedHashMap();

        System.out.println("\n--- 3. TreeMap: 按键自动排序 ---");
        demonstrateTreeMap();

        System.out.println("\n--- 4. 遍历 Map 的最佳实践 ---");
        demonstrateIteration();

        System.out.println("\n--- 5. 自定义对象作为 Key (最重要！) ---");
        demonstrateCustomKeyObject();
    }

    /**
     * 1. 演示 HashMap: 键是无序的。
     */
    public static void demonstrateHashMap() {
        Map<String, Integer> studentScores = new HashMap<>();

        // put(key, value): 添加键值对
        studentScores.put("Alice", 95);
        studentScores.put("Bob", 88);
        studentScores.put("Charlie", 92);

        // 如果 key 已存在，put() 会更新 value 并返回旧的 value
        Integer oldScore = studentScores.put("Bob", 90);
        System.out.println("Bob 的旧分数: " + oldScore);

        System.out.println("HashMap 内容: " + studentScores); // 注意：输出顺序不保证

        // get(key): 根据键获取值
        System.out.println("Charlie 的分数: " + studentScores.get("Charlie"));

        // remove(key): 根据键删除条目
        studentScores.remove("Alice");
        System.out.println("删除 Alice 后的 Map: " + studentScores);

        // getOrDefault(key, defaultValue): 获取值，如果键不存在则返回默认值 (Java 8+)
        Integer davidScore = studentScores.getOrDefault("David", 60);
        System.out.println("David (不存在) 的分数: " + davidScore);
    }

    /**
     * 2. 演示 LinkedHashMap: 键保持插入顺序。
     */
    public static void demonstrateLinkedHashMap() {
        Map<String, String> requestHeaders = new LinkedHashMap<>();
        requestHeaders.put("Host", "example.com");
        requestHeaders.put("User-Agent", "MyClient/1.0");
        requestHeaders.put("Accept", "application/json");
        // LinkedHashMap 会记住元素的插入顺序
        System.out.println("LinkedHashMap 内容: " + requestHeaders);
    }

    /**
     * 3. 演示 TreeMap: 键会根据自然顺序或提供的 Comparator 进行排序。
     */
    public static void demonstrateTreeMap() {
        Map<Integer, String> productCodes = new TreeMap<>();
        productCodes.put(102, "Laptop");
        productCodes.put(100, "Mouse");
        productCodes.put(101, "Keyboard");
        // TreeMap 会自动按 Key (Integer) 进行排序
        System.out.println("TreeMap 内容: " + productCodes);
    }

    /**
     * 4. 演示遍历 Map 的三种方式，并推荐最佳实践。
     */
    public static void demonstrateIteration() {
        Map<String, String> capitals = new HashMap<>();
        capitals.put("China", "Beijing");
        capitals.put("USA", "Washington D.C.");
        capitals.put("Japan", "Tokyo");

        // 方式一：遍历 KeySet (效率较低，因为需要再次 get())
        System.out.println("\na) 遍历 KeySet:");
        for (String country : capitals.keySet()) {
            String capital = capitals.get(country);
            System.out.println("   " + country + " -> " + capital);
        }

        // 方式二：遍历 Values (无法访问 Key)
        System.out.println("\nb) 遍历 Values:");
        for (String capital : capitals.values()) {
            System.out.println("   Capital: " + capital);
        }

        // 方式三：遍历 EntrySet (★★★ 最佳实践 ★★★)
        // 一次性获取 Key 和 Value，效率最高。
        System.out.println("\nc) 遍历 EntrySet (推荐):");
        for (Map.Entry<String, String> entry : capitals.entrySet()) {
            System.out.println("   " + entry.getKey() + " -> " + entry.getValue());
        }

        // 方式四：使用 Lambda (Java 8+) - 语法简洁
        System.out.println("\nd) 使用 Lambda forEach (Java 8+):");
        capitals.forEach((country, capital) ->
            System.out.println("   " + country + " -> " + capital)
        );
    }

    /**
     * 5. 演示使用自定义对象作为 Key
     */
    public static void demonstrateCustomKeyObject() {
        Map<Employee, Double> employeeSalaries = new HashMap<>();

        Employee emp1 = new Employee(101, "Engineering");
        Employee emp2 = new Employee(102, "Marketing");
        // emp3 与 emp1 的内容完全相同，但它们是不同的对象
        Employee emp3 = new Employee(101, "Engineering");

        employeeSalaries.put(emp1, 80000.0);
        employeeSalaries.put(emp2, 75000.0);

        System.out.println("emp1 的 hashCode: " + emp1.hashCode());
        System.out.println("emp3 的 hashCode: " + emp3.hashCode());
        System.out.println("emp1.equals(emp3) ? " + emp1.equals(emp3));

        // 因为我们正确重写了 equals() 和 hashCode(), Map 能够识别出 emp3 和 emp1 是同一个键。
        // 所以下面的 put 操作会更新 emp1 对应的 value，而不是插入一个新条目。
        employeeSalaries.put(emp3, 85000.0);

        System.out.println("\n员工薪资表:");
        employeeSalaries.forEach((employee, salary) ->
            System.out.println("   " + employee + " -> " + salary)
        );
        System.out.println("Map 的大小: " + employeeSalaries.size()); // 输出 2

        // 同样，我们可以用 emp3 来获取 emp1 存入的值
        Double salary = employeeSalaries.get(emp3);
        System.out.println("使用 emp3 获取的薪水: " + salary);
        System.out.println("\n结论: 如果没有正确重写 equals() 和 hashCode(), Map 的大小会是3，且 get(emp3) 会返回 null。");
    }
}
```
