---
title: 64. 最小路径和
date: 2024-12-04 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 多维动态规划]
tags: [多维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251122000024724.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个包含非负整数的 `m x n` 网格 `grid`，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：** 每次只能向下或者向右移动一步。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

- **输入:** `grid = [[1,3,1],[1,5,1],[4,2,1]]`
- **输出:** 7
- **解释:** 因为路径 1→3→1→1→1 的总和最小。

**示例 2:**

- **输入:** `grid = [[1,2,3],[4,5,6]]`
- **输出:** 12

**提示:**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 200`
- `0 <= grid[i][j] <= 200`

## 题解

### 解法：动态规划 (Dynamic Programming)

**思路：**

这是一个经典的二维动态规划问题。我们要计算到达网格右下角的最小路径和，可以定义一个状态 `dp[i][j]`，表示从左上角 `(0, 0)` 到达单元格 `(i, j)` 的最小路径和。

由于每次只能向下或向右移动，到达 `(i, j)` 只有两种情况：

1.  从上方 `(i-1, j)` 走下来。
2.  从左方 `(i, j-1)` 走过来。

因此，到达 `(i, j)` 的最小路径和，等于“上方”和“左方”两者的较小值，加上当前格子的数值。

**状态转移方程：**

$$dp[i][j] = \min(dp[i-1][j], dp[i][j-1]) + grid[i][j]$$

**边界处理：**

- **第一行**：只能从左边走过来，所以每个格子等于前一个格子加当前值。
- **第一列**：只能从上边走下来，所以每个格子等于上一个格子加当前值。

**空间优化：**

我们可以直接在原数组 `grid` 上修改，用 `grid[i][j]` 代替 `dp[i][j]`，从而不需要额外的空间。

**复杂度分析：**

- **时间复杂度：** $O(m \times n)$，需要遍历整个网格一次。
- **空间复杂度：** $O(1)$，直接在原数组上修改，不使用额外空间。（如果不允许修改原数组，空间复杂度为 $O(m \times n)$）。

**代码片段：**

```java
public int minPathSum(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;

    // 初始化第一行
    for (int j = 1; j < n; j++) {
        grid[0][j] += grid[0][j - 1];
    }

    // 初始化第一列
    for (int i = 1; i < m; i++) {
        grid[i][0] += grid[i - 1][0];
    }

    // 推导其余格子
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
        }
    }

    // 返回右下角的值
    return grid[m - 1][n - 1];
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    /**
     * 64. 最小路径和 - 动态规划 (原地修改版)
     */
    public static int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }

        int m = grid.length;
        int n = grid[0].length;

        // 1. 初始化第一行
        // 第一行的元素只能从左边的元素到达
        for (int j = 1; j < n; j++) {
            grid[0][j] += grid[0][j - 1];
        }

        // 2. 初始化第一列
        // 第一列的元素只能从上边的元素到达
        for (int i = 1; i < m; i++) {
            grid[i][0] += grid[i - 1][0];
        }

        // 3. 填充剩余网格
        // 对于中间的元素，取上方和左方的较小值 + 当前值
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
            }
        }

        // 右下角即为最小路径和
        return grid[m - 1][n - 1];
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[][] grid1 = {
            {1, 3, 1},
            {1, 5, 1},
            {4, 2, 1}
        };
        System.out.println("示例 1 输入: " + Arrays.deepToString(grid1));
        // 注意：Arrays.deepToString 打印二维数组不直观，手动排版如下：
        // [1, 3, 1]
        // [1, 5, 1]
        // [4, 2, 1]

        // 为了不影响后续测试（因为代码修改了原数组），我们在实际工程中可能需要拷贝一份
        // 这里为了演示简单，直接调用
        int result1 = minPathSum(grid1);
        System.out.println("示例 1 输出: " + result1);
        // 解释: 1->3->1->1->1 总和为 7
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[][] grid2 = {
            {1, 2, 3},
            {4, 5, 6}
        };
        System.out.println("示例 2 输入: [[1, 2, 3], [4, 5, 6]]");
        int result2 = minPathSum(grid2);
        System.out.println("示例 2 输出: " + result2);
        // 解释: 1->2->3->6 总和为 12
        System.out.println("-----------------------------");
    }
}
```
