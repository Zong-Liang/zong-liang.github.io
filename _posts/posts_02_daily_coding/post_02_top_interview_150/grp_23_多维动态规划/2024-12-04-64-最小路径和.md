---
title: 64. 最小路径和
date: 2024-12-04 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 多维动态规划]
tags: [多维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251122000024724.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：64. 最小路径和

给定一个包含非负整数的 `m x n` 网格 `grid`，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：** 每次只能向下或者向右移动一步。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

- **输入:** `grid = [[1,3,1],[1,5,1],[4,2,1]]`
- **输出:** 7
- **解释:** 因为路径 1→3→1→1→1 的总和最小。

**示例 2:**

- **输入:** `grid = [[1,2,3],[4,5,6]]`
- **输出:** 12

**提示:**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 200`
- `0 <= grid[i][j] <= 200`

## Java 代码

**算法思路：(动态规划 - 原地修改)**

这是一个典型的动态规划问题。我们可以直接在原始的 `grid` 数组上进行修改，以达到 O(1) 的额外空间复杂度。

`grid[i][j]` 的值可以被更新为从左上角 `(0,0)` 到达该点 `(i,j)` 的最小路径和。

- **状态定义:** `grid[i][j]` 更新后表示到达 `(i,j)` 的最小路径和。
- **状态转移方程:** 由于只能向下或向右移动，要到达 `(i,j)`，只能从其上方 `(i-1,j)` 或其左方 `(i,j-1)` 过来。因此，到达 `(i,j)` 的最小路径和等于当前 `grid[i][j]` 的值加上来自上方和左方路径中的较小者。
  `grid[i][j] = grid[i][j] + min(grid[i-1][j], grid[i][j-1])`
- **初始化:**
  - 第一行的路径和是累加的：`grid[0][j] += grid[0][j-1]`。
  - 第一列的路径和也是累加的：`grid[i][0] += grid[i-1][0]`。

遍历整个网格并更新值后，右下角的 `grid[m-1][n-1]` 就是最终的答案。

```java
import java.util.Arrays;


public class Main {

    /**
     * 找出从左上角到右下角的最小路径和。
     *
     * @param grid 包含非负整数的 m x n 网格。
     * @return 最小路径和。
     */
    public static int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }

        int rows = grid.length;
        int cols = grid[0].length;

        // 初始化第一行
        for (int j = 1; j < cols; j++) {
            grid[0][j] += grid[0][j - 1];
        }

        // 初始化第一列
        for (int i = 1; i < rows; i++) {
            grid[i][0] += grid[i - 1][0];
        }

        // 遍历其余格子，更新路径和
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < cols; j++) {
                grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
            }
        }

        // 返回右下角的值
        return grid[rows - 1][cols - 1];
    }


    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[][] grid1 = {{1, 3, 1}, {1, 5, 1}, {4, 2, 1}};
        System.out.println("输入: grid = [[1,3,1],[1,5,1],[4,2,1]]");
        int result1 = minPathSum(grid1);
        System.out.println("输出: " + result1); // 预期输出: 7
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[][] grid2 = {{1, 2, 3}, {4, 5, 6}};
        System.out.println("输入: grid = [[1,2,3],[4,5,6]]");
        int result2 = minPathSum(grid2);
        System.out.println("输出: " + result2); // 预期输出: 12
        System.out.println();
    }
}
```
