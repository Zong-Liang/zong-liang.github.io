---
title: 97. 交错字符串
date: 2024-12-09 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 多维动态规划]
tags: [多维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251122000143028.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：97. 交错字符串

给定三个字符串 `s1`、`s2`、`s3`，请你帮忙验证 `s3` 是否是由 `s1` 和 `s2` **交错** 组成的。

两个字符串 `s` 和 `t` **交错** 的定义与过程如下，其中每个字符串都会被分割成若干 **非空** 子字符串：

- `s = s1 + s2 + ... + sn`
- `t = t1 + t2 + ... + tm`
- `|n - m| <= 1`
- 交错是 `s1 + t1 + s2 + t2 + s3 + t3 + ...` 或者 `t1 + s1 + t2 + s2 + t3 + s3 + ...`

**注意：** `a + b` 意味着字符串 `a` 和 `b` 连接。
（简而言之，交错意味着 `s1` 和 `s2` 中的字符相对顺序保持不变。）

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg)

- **输入:** `s1 = "aabcc"`, `s2 = "dbbca"`, `s3 = "aadbbcbcac"`
- **输出:** `true`

**示例 2:**

- **输入:** `s1 = "aabcc"`, `s2 = "dbbca"`, `s3 = "aadbbbaccc"`
- **输出:** `false`

**示例 3:**

- **输入:** `s1 = ""`, `s2 = ""`, `s3 = ""`
- **输出:** `true`

**提示:**

- `0 <= s1.length, s2.length <= 100`
- `0 <= s3.length <= 200`
- `s1`、`s2`、和 `s3` 都由小写英文字母组成

**进阶:** 您能否仅使用 O(s2.length) 额外的内存空间来解决它？

## Java 代码

**算法思路：(动态规划 - 空间优化)**

这是一个经典的动态规划问题。为了满足进阶要求，我们使用一维数组来优化空间复杂度。

- **状态定义:** 我们使用一个布尔数组 `dp`，其中 `dp[j]` 表示 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符是否能交错组成 `s3` 的前 `i+j` 个字符。
- **状态转移:**
  - 要判断 `dp[j]` (代表 `s1` 的前 `i` 个和 `s2` 的前 `j` 个)，可以从两种情况转移而来：
    1.  `s3` 的最后一个字符 `s3.charAt(i+j-1)` 来自 `s1` 的最后一个字符 `s1.charAt(i-1)`。这要求 `s1` 的前 `i-1` 个和 `s2` 的前 `j` 个能组成 `s3` 的前 `i+j-1` 个。
    2.  `s3` 的最后一个字符 `s3.charAt(i+j-1)` 来自 `s2` 的最后一个字符 `s2.charAt(j-1)`。这要求 `s1` 的前 `i` 个和 `s2` 的前 `j-1` 个能组成 `s3` 的前 `i+j-1` 个。
- **空间优化:** 在计算 `i` 这一行的 `dp` 值时，我们只需要 `i-1` 行的 `dp` 值。因此，可以用一个一维数组 `dp` 滚动计算，其中 `dp[j]` 在更新前代表上一行（`i-1`）的结果，`dp[j-1]` 代表当前行（`i`）刚刚更新完的结果。

```java
public class Main {

    /**
     * 验证 s3 是否是由 s1 和 s2 交错组成的。
     *
     * @param s1 字符串1
     * @param s2 字符串2
     * @param s3 字符串3
     * @return 如果 s3 是 s1 和 s2 的交错字符串，则返回 true
     */
    public static boolean isInterleave(String s1, String s2, String s3) {
        int n1 = s1.length(), n2 = s2.length(), n3 = s3.length();

        // 长度校验，如果长度不匹配，直接返回 false
        if (n1 + n2 != n3) {
            return false;
        }

        // dp[j] 表示 s1 的前 i 个字符和 s2 的前 j 个字符能否组成 s3 的前 i+j 个字符
        boolean[] dp = new boolean[n2 + 1];

        for (int i = 0; i <= n1; i++) {
            for (int j = 0; j <= n2; j++) {
                if (i == 0 && j == 0) {
                    // 两个空字符串可以组成一个空字符串
                    dp[j] = true;
                } else if (i == 0) {
                    // s1 为空，s3 完全由 s2 构成
                    dp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);
                } else if (j == 0) {
                    // s2 为空，s3 完全由 s1 构成
                    dp[j] = dp[j] && s1.charAt(i - 1) == s3.charAt(i - 1);
                } else {
                    // 状态转移
                    // dp[j] on RHS is the old value from row i-1
                    // dp[j-1] on RHS is the new value for row i
                    dp[j] = (dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) ||
                            (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));
                }
            }
        }

        return dp[n2];
    }


    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        String s1_1 = "aabcc", s2_1 = "dbbca", s3_1 = "aadbbcbcac";
        System.out.println("输入: s1 = \"" + s1_1 + "\", s2 = \"" + s2_1 + "\", s3 = \"" + s3_1 + "\"");
        boolean result1 = isInterleave(s1_1, s2_1, s3_1);
        System.out.println("输出: " + result1); // 预期输出: true
        System.out.println();

        System.out.println("--- 示例 2 ---");
        String s1_2 = "aabcc", s2_2 = "dbbca", s3_2 = "aadbbbaccc";
        System.out.println("输入: s1 = \"" + s1_2 + "\", s2 = \"" + s2_2 + "\", s3 = \"" + s3_2 + "\"");
        boolean result2 = isInterleave(s1_2, s2_2, s3_2);
        System.out.println("输出: " + result2); // 预期输出: false
        System.out.println();

        System.out.println("--- 示例 3 ---");
        String s1_3 = "", s2_3 = "", s3_3 = "";
        System.out.println("输入: s1 = \"" + s1_3 + "\", s2 = \"" + s2_3 + "\", s3 = \"" + s3_3 + "\"");
        boolean result3 = isInterleave(s1_3, s2_3, s3_3);
        System.out.println("输出: " + result3); // 预期输出: true
        System.out.println();
    }
}
```
