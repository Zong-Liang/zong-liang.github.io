---
title: 97. 交错字符串
date: 2024-12-09 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 多维动态规划]
tags: [多维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251122000143028.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定三个字符串 `s1`、`s2`、`s3`，请你帮忙验证 `s3` 是否是由 `s1` 和 `s2` **交错** 组成的。

两个字符串 `s` 和 `t` **交错** 的定义与过程如下，其中每个字符串都会被分割成若干 **非空** 子字符串：

- `s = s1 + s2 + ... + sn`
- `t = t1 + t2 + ... + tm`
- `|n - m| <= 1`
- 交错是 `s1 + t1 + s2 + t2 + s3 + t3 + ...` 或者 `t1 + s1 + t2 + s2 + t3 + s3 + ...`

**注意：** `a + b` 意味着字符串 `a` 和 `b` 连接。

（简而言之，交错意味着 `s1` 和 `s2` 中的字符相对顺序保持不变。）

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg)

- **输入:** `s1 = "aabcc"`, `s2 = "dbbca"`, `s3 = "aadbbcbcac"`
- **输出:** `true`

**示例 2:**

- **输入:** `s1 = "aabcc"`, `s2 = "dbbca"`, `s3 = "aadbbbaccc"`
- **输出:** `false`

**示例 3:**

- **输入:** `s1 = ""`, `s2 = ""`, `s3 = ""`
- **输出:** `true`

**提示:**

- `0 <= s1.length, s2.length <= 100`
- `0 <= s3.length <= 200`
- `s1`、`s2`、和 `s3` 都由小写英文字母组成

**进阶:** 您能否仅使用 O(s2.length) 额外的内存空间来解决它？

## 题解

### 解法一：二维动态规划 (2D Dynamic Programming)

**思路：**

这是一个典型的判定性动态规划问题。我们需要判断 `s1` 的前 $i$ 个字符和 `s2` 的前 $j$ 个字符能否交错组成 `s3` 的前 $i+j$ 个字符。

1.  **前置检查**：如果 `s1` 和 `s2` 的长度之和不等于 `s3` 的长度，直接返回 `false`。
2.  **状态定义**：定义 `dp[i][j]` 为布尔值，表示 `s1` 的前 $i$ 个字符和 `s2` 的前 $j$ 个字符是否能交错组成 `s3` 的前 $i+j$ 个字符。
3.  **状态转移**：`dp[i][j]` 为 `true` 的情况有两种：

    - `s3` 的最后一个字符（第 $i+j$ 个）来自于 `s1`（第 $i$ 个）：要求 `s1[i-1] == s3[i+j-1]` 且 `dp[i-1][j]` 为真。
    - `s3` 的最后一个字符（第 $i+j$ 个）来自于 `s2`（第 $j$ 个）：要求 `s2[j-1] == s3[i+j-1]` 且 `dp[i][j-1]` 为真。
    - 只要满足上述任意一种，`dp[i][j]` 即为 `true`。

4.  **初始化**：

    - `dp[0][0] = true`（空串 + 空串 = 空串）。
    - 第一列 `dp[i][0]`：只用 `s1` 匹配 `s3`。
    - 第一行 `dp[0][j]`：只用 `s2` 匹配 `s3`。

**复杂度分析：**

- **时间复杂度：** $O(n \times m)$，$n$ 和 $m$ 分别是 `s1` 和 `s2` 的长度，需要填充整个二维表格。
- **空间复杂度：** $O(n \times m)$，使用了二维数组存储状态。

**代码片段：**

```java
public boolean isInterleave(String s1, String s2, String s3) {
    int n = s1.length(), m = s2.length(), t = s3.length();
    if (n + m != t) return false;

    boolean[][] dp = new boolean[n + 1][m + 1];
    dp[0][0] = true;

    // 初始化第一列 (只考虑 s1)
    for (int i = 1; i <= n; i++) {
        dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);
    }
    // 初始化第一行 (只考虑 s2)
    for (int j = 1; j <= m; j++) {
        dp[0][j] = dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            char c3 = s3.charAt(i + j - 1);
            boolean fromS1 = (s1.charAt(i - 1) == c3) && dp[i - 1][j];
            boolean fromS2 = (s2.charAt(j - 1) == c3) && dp[i][j - 1];
            dp[i][j] = fromS1 || fromS2;
        }
    }
    return dp[n][m];
}
```

### 解法二：一维动态规划 - 滚动数组 (Rolling Array DP) —— 进阶解法

**思路：**

根据题目进阶要求，我们需要将空间复杂度优化到 $O(s2.length)$。

观察状态转移方程：

`dp[i][j]` 只依赖于 `dp[i-1][j]` (上一行，同列) 和 `dp[i][j-1]` (当前行，前一列)。

因此，我们可以去掉行的维度，只用一个一维数组 `dp[j]` 来表示当前行的状态。

- 在计算当前行之前，`dp[j]` 存储的是上一行的结果（即逻辑上的 `dp[i-1][j]`）。
- 在计算当前行时，`dp[j-1]` 已经是当前行更新过的结果（即逻辑上的 `dp[i][j-1]`）。

**状态更新逻辑：**

`dp[j] = (来自于S1 && dp[j]) || (来自于S2 && dp[j-1])`

_注：这里的 `dp[j]` 在赋值号右边代表上一行的状态，赋值后代表当前行的状态。_

**复杂度分析：**

- **时间复杂度：** $O(n \times m)$，依然需要遍历所有可能的组合。
- **空间复杂度：** $O(m)$，只使用了一个长度为 `s2.length + 1` 的一维数组。

**代码片段：**

```java
public boolean isInterleaveOptimized(String s1, String s2, String s3) {
    int n = s1.length(), m = s2.length(), t = s3.length();
    if (n + m != t) return false;

    // dp[j] 表示 s1 的前 i 个字符和 s2 的前 j 个字符能否匹配
    // 这里的 i 是隐含的外层循环变量
    boolean[] dp = new boolean[m + 1];
    dp[0] = true;

    // 初始化 dp 数组，相当于二维 DP 中的第一行 (i=0, 只用 s2)
    for (int j = 1; j <= m; j++) {
        dp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);
    }

    // 遍历 s1 的每个字符
    for (int i = 1; i <= n; i++) {
        // 更新 dp[0]，相当于二维 DP 中的第一列 (j=0, 只用 s1)
        // 当前 dp[0] 依赖于上一轮的 dp[0]
        dp[0] = dp[0] && s1.charAt(i - 1) == s3.charAt(i - 1);

        for (int j = 1; j <= m; j++) {
            char c3 = s3.charAt(i + j - 1);
            boolean fromS1 = (s1.charAt(i - 1) == c3) && dp[j]; // dp[j] 还是上一轮的值(i-1)
            boolean fromS2 = (s2.charAt(j - 1) == c3) && dp[j - 1]; // dp[j-1] 是本轮已更新的值(j-1)
            dp[j] = fromS1 || fromS2;
        }
    }

    return dp[m];
}
```

### 完整代码

```java
public class Main {

    // --- 解法一：二维 DP ---
    public static boolean isInterleave(String s1, String s2, String s3) {
        int n = s1.length();
        int m = s2.length();
        if (n + m != s3.length()) return false;

        boolean[][] dp = new boolean[n + 1][m + 1];
        dp[0][0] = true;

        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                int k = i + j - 1; // s3 的下标
                if (i > 0) {
                    // 尝试从 s1 取字符
                    dp[i][j] = dp[i][j] || (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(k));
                }
                if (j > 0) {
                    // 尝试从 s2 取字符
                    dp[i][j] = dp[i][j] || (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(k));
                }
            }
        }
        return dp[n][m];
    }

    // --- 解法二：一维滚动数组 DP (进阶优化) ---
    public static boolean isInterleaveOptimized(String s1, String s2, String s3) {
        int n = s1.length();
        int m = s2.length();
        if (n + m != s3.length()) return false;

        // 使用 O(m) 的空间
        boolean[] dp = new boolean[m + 1];
        dp[0] = true;

        // 初始化：只用 s2 匹配 s3
        for (int j = 1; j <= m; j++) {
            dp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);
        }

        // 逐步引入 s1 的字符
        for (int i = 1; i <= n; i++) {
            // 处理每行的第 0 列 (即 j=0, 只用 s1 的情况)
            // dp[0] 在进入内层循环前代表 dp[i-1][0]
            dp[0] = dp[0] && s1.charAt(i - 1) == s3.charAt(i - 1);

            for (int j = 1; j <= m; j++) {
                // dp[j] 目前存储的是上一行(i-1)的结果
                boolean fromS1 = dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);
                // dp[j-1] 刚刚被更新过，存储的是当前行(i)前一列的结果
                boolean fromS2 = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);

                dp[j] = fromS1 || fromS2;
            }
        }
        return dp[m];
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        String s1_1 = "aabcc", s2_1 = "dbbca", s3_1 = "aadbbcbcac";
        System.out.println("示例 1 输入: s1=" + s1_1 + ", s2=" + s2_1 + ", s3=" + s3_1);
        System.out.println("示例 1 输出: " + isInterleaveOptimized(s1_1, s2_1, s3_1));
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        String s1_2 = "aabcc", s2_2 = "dbbca", s3_2 = "aadbbbaccc";
        System.out.println("示例 2 输入: s1=" + s1_2 + ", s2=" + s2_2 + ", s3=" + s3_2);
        System.out.println("示例 2 输出: " + isInterleaveOptimized(s1_2, s2_2, s3_2));
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        String s1_3 = "", s2_3 = "", s3_3 = "";
        System.out.println("示例 3 输入: s1=\"\", s2=\"\", s3=\"\"");
        System.out.println("示例 3 输出: " + isInterleaveOptimized(s1_3, s2_3, s3_3));
    }
}
```
