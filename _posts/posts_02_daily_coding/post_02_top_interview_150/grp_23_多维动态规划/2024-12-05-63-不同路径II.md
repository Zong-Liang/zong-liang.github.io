---
title: 63. 不同路径II
date: 2024-12-05 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 多维动态规划]
tags: [多维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251122000048198.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个 `m x n` 的整数数组 `grid`。一个机器人初始位于 **左上角**（即 `grid[0][0]`）。机器人尝试移动到 **右下角**（即 `grid[m - 1][n - 1]`）。机器人每次只能向下或者向右移动一步。

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。机器人的移动路径中不能包含 **任何** 有障碍物的方格。

返回机器人能够到达右下角的不同路径数量。

测试用例保证答案小于等于 `2 * 10^9`。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)

**输入:** `obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]`

- **输出:** 2
- **解释:** 3x3 网格的正中间有一个障碍物。
  从左上角到右下角一共有 **2** 条不同的路径：
  1.  向右 -> 向右 -> 向下 -> 向下
  2.  向下 -> 向下 -> 向右 -> 向右

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg)

- **输入:** `obstacleGrid = [[0,1],[0,0]]`
- **输出:** 1

**提示:**

- `m == obstacleGrid.length`
- `n == obstacleGrid[i].length`
- `1 <= m, n <= 100`
- `obstacleGrid[i][j]` 为 `0` 或 `1`

## 题解

### 解法：动态规划 + 滚动数组 (Dynamic Programming with Space Optimization)

**思路：**

这是一道经典的动态规划问题，是“不同路径”问题的变种。主要区别在于网格中出现了障碍物。

1.  **状态定义**：

    我们可以使用一个二维数组 `dp[i][j]` 来表示从起点到达 `(i, j)` 的路径数量。
    但为了优化空间，我们可以只使用一个一维数组 `dp[j]`（滚动数组）。此时 `dp[j]` 表示在当前行，到达第 `j` 列的路径数量。

2.  **状态转移**：

    - **遇到障碍物**：如果 `obstacleGrid[i][j] == 1`，说明此路不通，机器人无法到达该位置，直接将 `dp[j]` 设为 `0`。
    - **空位置**：

      - 如果是二维 DP，转移方程为 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`（上方路径数 + 左方路径数）。
      - 在一维滚动数组中，等式右边的 `dp[j]` 存储的是上一行的值（相当于 `dp[i-1][j]`），`dp[j-1]` 存储的是当前行刚刚更新过的值（相当于 `dp[i][j-1]`）。
      - 因此转移方程简化为：`dp[j] += dp[j-1]`。

3.  **初始化**：

    - 如果起点 `(0, 0)` 就是障碍物，直接返回 0。
    - 初始化 `dp[0] = 1`（起点只有 1 种方式到达）。

**复杂度分析：**

- **时间复杂度：** $O(m \times n)$，需要遍历整个网格。
- **空间复杂度：** $O(n)$，利用滚动数组优化，只需要一个长度为列数 `n` 的数组。

**代码片段：**

```java
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    int m = obstacleGrid.length;
    int n = obstacleGrid[0].length;

    // 如果起点就是障碍物，直接返回 0
    if (obstacleGrid[0][0] == 1) {
        return 0;
    }

    int[] dp = new int[n];
    dp[0] = 1; // 起点初始化

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (obstacleGrid[i][j] == 1) {
                // 当前是障碍物，路径数归零
                dp[j] = 0;
            } else if (j > 0) {
                // 当前不是障碍物，且不是第一列
                // dp[j] (新) = dp[j] (旧，来自上方) + dp[j-1] (新，来自左方)
                dp[j] += dp[j - 1];
            }
            // 如果是第一列 (j=0) 且不是障碍物，dp[0] 保持不变（继承上一行的值）
            // 除非上一行的 dp[0] 已经是 0（被障碍物阻断），那它继续保持 0
        }
    }

    return dp[n - 1];
}
```

### 完整代码

```java
public class Main {

    /**
     * 63. 不同路径 II - 动态规划
     */
    public static int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid == null || obstacleGrid.length == 0) {
            return 0;
        }

        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;

        // 起点若有障碍，直接无解
        if (obstacleGrid[0][0] == 1) {
            return 0;
        }

        // dp[j] 表示到达当前行第 j 列的路径数
        int[] dp = new int[n];
        dp[0] = 1;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (obstacleGrid[i][j] == 1) {
                    // 遇到障碍物，路径数清零
                    dp[j] = 0;
                } else if (j > 0) {
                    // 状态转移：当前路径数 = 上方路径数(dp[j]当前值) + 左方路径数(dp[j-1])
                    dp[j] += dp[j - 1];
                }
                // 注意：对于 j=0 的情况（第一列），逻辑隐含在循环中：
                // 如果当前格不是障碍物，dp[0] 保持不变（等于上一行的 dp[0]）。
                // 如果当前格是障碍物，dp[0] 会被置为 0。
            }
        }

        return dp[n - 1];
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[][] grid1 = {
            {0, 0, 0},
            {0, 1, 0},
            {0, 0, 0}
        };
        System.out.println("示例 1 输入: [[0,0,0],[0,1,0],[0,0,0]]");
        System.out.println("示例 1 输出: " + uniquePathsWithObstacles(grid1));
        // 解释: 2 种走法，避开中间障碍物
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[][] grid2 = {
            {0, 1},
            {0, 0}
        };
        System.out.println("示例 2 输入: [[0,1],[0,0]]");
        System.out.println("示例 2 输出: " + uniquePathsWithObstacles(grid2));
        // 解释: 只能向下再向右，1 种走法
        System.out.println("-----------------------------");

        // --- 示例 3 (起点障碍) ---
        int[][] grid3 = {
            {1, 0}
        };
        System.out.println("示例 3 输入: [[1, 0]]");
        System.out.println("示例 3 输出: " + uniquePathsWithObstacles(grid3));
        // 解释: 起点被堵死，0 种
        System.out.println("-----------------------------");

        // --- 示例 4 (终点障碍) ---
        int[][] grid4 = {
            {0, 0},
            {1, 1}
        };
        System.out.println("示例 4 输入: [[0, 0], [1, 1]]");
        System.out.println("示例 4 输出: " + uniquePathsWithObstacles(grid4));
        // 解释: 终点是障碍物，0 种
    }
}
```
