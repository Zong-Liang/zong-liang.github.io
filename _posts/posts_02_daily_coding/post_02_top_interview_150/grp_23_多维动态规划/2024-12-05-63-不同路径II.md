---
title: 63. 不同路径II
date: 2024-12-05 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 多维动态规划]
tags: [多维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251122000048198.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：63. 不同路径 II

给定一个 `m x n` 的整数数组 `grid`。一个机器人初始位于 **左上角**（即 `grid[0][0]`）。机器人尝试移动到 **右下角**（即 `grid[m - 1][n - 1]`）。机器人每次只能向下或者向右移动一步。

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。机器人的移动路径中不能包含 **任何** 有障碍物的方格。

返回机器人能够到达右下角的不同路径数量。

测试用例保证答案小于等于 `2 * 10^9`。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)

**输入:** `obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]`

- **输出:** 2
- **解释:** 3x3 网格的正中间有一个障碍物。
  从左上角到右下角一共有 **2** 条不同的路径：
  1.  向右 -> 向右 -> 向下 -> 向下
  2.  向下 -> 向下 -> 向右 -> 向右

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg)

- **输入:** `obstacleGrid = [[0,1],[0,0]]`
- **输出:** 1

**提示:**

- `m == obstacleGrid.length`
- `n == obstacleGrid[i].length`
- `1 <= m, n <= 100`
- `obstacleGrid[i][j]` 为 `0` 或 `1`

## 题解

**算法思路：(动态规划 - 空间优化)**

这个问题可以使用动态规划来解决。由于我们计算到达当前单元格 `(i, j)` 的路径数时，只依赖于其上方 `(i-1, j)` 和左方 `(i, j-1)` 的路径数，因此我们可以将二维的 DP 数组优化为一维数组，将空间复杂度降低到 O(n)。

1.  创建一个大小为 `n`（网格列数）的一维数组 `dp`。`dp[j]` 将表示到达当前行第 `j` 列的路径数。
2.  初始化 `dp[0] = 1`，因为到达第一列的路径只有从上面下来这一种。
3.  遍历整个 `obstacleGrid` 网格。
4.  对于每个单元格 `(i, j)`：
    - 如果该单元格是障碍物 (`obstacleGrid[i][j] == 1`)，那么到达此处的路径数为 0，所以设置 `dp[j] = 0`。
    - 如果不是障碍物，并且它不是第一列 (`j > 0`)，那么到达该点的路径数等于从上面来的路径数（`dp[j]` 的旧值）加上从左边来的路径数（`dp[j-1]` 的新值）。因此，更新 `dp[j] = dp[j] + dp[j-1]`。
5.  遍历结束后，`dp[n-1]` 就存储了到达右下角的所有路径数。

```java
import java.util.Arrays;


public class Main {

    /**
     * 计算从左上角到右下角的不同路径数量，考虑障碍物。
     *
     * @param obstacleGrid 包含障碍物的 m x n 网格。
     * @return 不同的路径数量。
     */
    public static int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0) {
            return 0;
        }

        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;

        // 如果起点或终点是障碍物，则无法到达
        if (obstacleGrid[0][0] == 1 || obstacleGrid[m - 1][n - 1] == 1) {
            return 0;
        }

        // dp[j] 表示到达当前行第 j 列的路径数
        int[] dp = new int[n];

        // 初始化起点
        dp[0] = 1;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 如果遇到障碍物，到达此点的路径数为0
                if (obstacleGrid[i][j] == 1) {
                    dp[j] = 0;
                } else if (j > 0) {
                    // 状态转移方程：
                    // 到达 (i, j) 的路径数 = 到达 (i-1, j) 的路径数 + 到达 (i, j-1) 的路径数
                    // dp[j] 此刻代表 (i-1, j) 的路径数，dp[j-1] 代表 (i, j-1) 的路径数
                    dp[j] = dp[j] + dp[j - 1];
                }
            }
        }

        return dp[n - 1];
    }


    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[][] obstacleGrid1 = {{0, 0, 0}, {0, 1, 0}, {0, 0, 0}};
        System.out.println("输入: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]");
        int result1 = uniquePathsWithObstacles(obstacleGrid1);
        System.out.println("输出: " + result1); // 预期输出: 2
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[][] obstacleGrid2 = {{0, 1}, {0, 0}};
        System.out.println("输入: obstacleGrid = [[0,1],[0,0]]");
        int result2 = uniquePathsWithObstacles(obstacleGrid2);
        System.out.println("输出: " + result2); // 预期输出: 1
        System.out.println();
    }
}
```
