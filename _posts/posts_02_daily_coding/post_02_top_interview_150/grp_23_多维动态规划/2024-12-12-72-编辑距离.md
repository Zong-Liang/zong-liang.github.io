---
title: 72. 编辑距离
date: 2024-12-12 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 多维动态规划]
tags: [多维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251122000206976.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你两个单词 `word1` 和 `word2`，请返回将 `word1` 转换成 `word2` 所使用的最少操作数。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**示例 1:**

- **输入:** `word1 = "horse"`, `word2 = "ros"`
- **输出:** 3
- **解释:**

  horse -> rorse (将 'h' 替换为 'r')

  rorse -> rose (删除 'r')

  rose -> ros (删除 'e')

**示例 2:**

- **输入:** `word1 = "intention"`, `word2 = "execution"`
- **输出:** 5
- **解释:**

  intention -> inention (删除 't')

  inention -> enention (将 'i' 替换为 'e')

  enention -> exention (将 'n' 替换为 'x')

  exention -> exection (将 'n' 替换为 'c')

  exection -> execution (插入 'u')

**提示:**

- `0 <= word1.length, word2.length <= 500`
- `word1` 和 `word2` 由小写英文字母组成

## 题解

### 解法：动态规划 (Dynamic Programming)

**思路：**

这是一个经典的字符串动态规划问题，通常称为 **Levenshtein Distance**（莱文斯坦距离）。我们要将 `word1` 转换为 `word2`，本质上是在寻找两个字符串之间的最小差异。

我们定义一个二维数组 `dp[i][j]`，其含义是：**`word1` 的前 `i` 个字符转换成 `word2` 的前 `j` 个字符所需要的最少操作数**。

1.  **状态定义**：

    `dp[i][j]` 表示 `word1[0...i-1]` 到 `word2[0...j-1]` 的编辑距离。

2.  **边界初始化**：

    - 当 `word2` 为空串（`j=0`），要把 `word1` 的前 `i` 个字符全删掉才能变成空串，操作数为 `i`。即 `dp[i][0] = i`。
    - 当 `word1` 为空串（`i=0`），要插入 `word2` 的前 `j` 个字符才能变过去，操作数为 `j`。即 `dp[0][j] = j`。

3.  **状态转移方程**：

    对于 `word1` 的第 `i` 个字符 `word1[i-1]` 和 `word2` 的第 `j` 个字符 `word2[j-1]`：

    - **情况一：字符相等** (`word1[i-1] == word2[j-1]`)

      不需要进行任何操作，当前的编辑距离等于去掉这两个字符后的编辑距离。

      $$dp[i][j] = dp[i-1][j-1]$$

    - **情况二：字符不相等** (`word1[i-1] != word2[j-1]`)

      我们需要在以下三种操作中选择步数最少的一种，并在其基础上 `+1`：

      1.  **替换**：将 `word1[i-1]` 替换为 `word2[j-1]`。依赖于 `dp[i-1][j-1]`。
      2.  **删除**：删除 `word1[i-1]`。依赖于 `dp[i-1][j]`。
      3.  **插入**：在 `word1` 末尾插入 `word2[j-1]`。依赖于 `dp[i][j-1]`。

      $$dp[i][j] = \min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1$$

**复杂度分析：**

- **时间复杂度：** $O(m \times n)$，其中 $m$ 和 $n$ 分别是两个字符串的长度。需要填充整个 DP 表。
- **空间复杂度：** $O(m \times n)$，需要一个二维数组存储状态。（注：可以通过滚动数组优化到 $O(\min(m, n))$，但为了代码可读性，通常使用二维数组）。

**代码片段：**

```java
public int minDistance(String word1, String word2) {
    int m = word1.length();
    int n = word2.length();

    // dp[i][j] 代表 word1 前 i 个字符转换到 word2 前 j 个字符的步数
    int[][] dp = new int[m + 1][n + 1];

    // 初始化第一列 (word2 为空)
    for (int i = 0; i <= m; i++) dp[i][0] = i;
    // 初始化第一行 (word1 为空)
    for (int j = 0; j <= n; j++) dp[0][j] = j;

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                // 字符相同，继承左上角的状态
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                // 字符不同，取 (替换, 删除, 插入) 中的最小值 + 1
                dp[i][j] = Math.min(dp[i - 1][j - 1],
                           Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
            }
        }
    }
    return dp[m][n];
}
```

### 完整代码

```java
public class Main {

    /**
     * 72. 编辑距离 - 动态规划解法
     */
    public static int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();

        // dp[i][j] 表示 word1 的前 i 个字符和 word2 的前 j 个字符的编辑距离
        // 大小为 (m+1) x (n+1) 是为了处理空字符串的情况
        int[][] dp = new int[m + 1][n + 1];

        // 1. 初始化边界
        // word2 为空串时，word1 需要删除 i 个字符
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        // word1 为空串时，word1 需要插入 j 个字符
        for (int j = 0; j <= n; j++) {
            dp[0][j] = j;
        }

        // 2. 填充 DP 表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 注意：字符串索引从 0 开始，所以是 i-1 和 j-1
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    // 如果字符相等，不需要操作，距离等于去掉这两个字符后的距离
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    // 如果字符不等，取三种操作的最小值 + 1
                    // dp[i-1][j-1] -> 替换操作
                    // dp[i-1][j]   -> 删除操作 (word1 删除一个变为 word1[0...i-2])
                    // dp[i][j-1]   -> 插入操作 (word1 插入一个变为 word2[j-1])
                    dp[i][j] = Math.min(dp[i - 1][j - 1],
                               Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
                }
            }
        }

        // 返回最终结果
        return dp[m][n];
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        String w1_ex1 = "horse";
        String w2_ex1 = "ros";
        System.out.println("示例 1 输入: word1 = \"" + w1_ex1 + "\", word2 = \"" + w2_ex1 + "\"");
        System.out.println("示例 1 输出: " + minDistance(w1_ex1, w2_ex1));
        // 解释: horse -> rorse (替换) -> rose (删除) -> ros (删除) = 3
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        String w1_ex2 = "intention";
        String w2_ex2 = "execution";
        System.out.println("示例 2 输入: word1 = \"" + w1_ex2 + "\", word2 = \"" + w2_ex2 + "\"");
        System.out.println("示例 2 输出: " + minDistance(w1_ex2, w2_ex2));
        // 解释: 5步操作
        System.out.println("-----------------------------");

        // --- 示例 3 (空串测试) ---
        String w1_ex3 = "";
        String w2_ex3 = "a";
        System.out.println("示例 3 输入: word1 = \"" + w1_ex3 + "\", word2 = \"" + w2_ex3 + "\"");
        System.out.println("示例 3 输出: " + minDistance(w1_ex3, w2_ex3));
        // 解释: 插入 'a'，共 1 步
    }
}
```
