---
title: 221. 最大正方形
date: 2024-12-16 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 多维动态规划]
tags: [多维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251122000420511.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：221. 最大正方形

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg)

- **输入:** `matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]`
- **输出:** 4

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg)

- **输入:** `matrix = [["0","1"],["1","0"]]`
- **输出:** 1

**示例 3:**

- **输入:** `matrix = [["0"]]`
- **输出:** 0

**提示:**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 300`
- `matrix[i][j]` 为 `'0'` 或 `'1'`

## Java 代码

**算法思路：(动态规划)**

这个问题可以使用动态规划来高效解决。

- **状态定义:** 我们创建一个二维数组 `dp`，尺寸比原矩阵大一圈。`dp[i][j]` 表示以原矩阵中 `matrix[i-1][j-1]` 为 **右下角** 的、且只包含 '1' 的最大正方形的 **边长**。
- **状态转移方程:**
  - 如果 `matrix[i-1][j-1]` 的值是 `'0'`，那么以它为右下角的正方形边长只能是 0，即 `dp[i][j] = 0`。
  - 如果 `matrix[i-1][j-1]` 的值是 `'1'`，那么 `dp[i][j]` 的值取决于其 **上方** (`dp[i-1][j]`)、**左方** (`dp[i][j-1]`) 和 **左上方** (`dp[i-1][j-1]`) 的 `dp` 值。一个更大的正方形要成立，这三个方向必须也都能构成正方形。因此，`dp[i][j]` 等于这三者中的最小值加 1。
    `dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])`
- **求解:** 在填充 `dp` 表的过程中，我们记录下出现过的最大边长 `maxSide`。最终的结果就是 `maxSide * maxSide`。

```java
public class Main {

    /**
     * 找到只包含 '1' 的最大正方形，并返回其面积。
     *
     * @param matrix 由 '0' 和 '1' 组成的二维矩阵。
     * @return 最大正方形的面积。
     */
    public static int maximalSquare(char[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }

        int rows = matrix.length;
        int cols = matrix[0].length;
        // dp[i][j] 表示以 (i-1, j-1) 为右下角的最大正方形的边长
        int[][] dp = new int[rows + 1][cols + 1];
        int maxSide = 0;

        for (int i = 1; i <= rows; i++) {
            for (int j = 1; j <= cols; j++) {
                // 如果当前格子是 '1'
                if (matrix[i - 1][j - 1] == '1') {
                    // 状态转移方程
                    dp[i][j] = 1 + Math.min(dp[i - 1][j - 1],
                                         Math.min(dp[i - 1][j], dp[i][j - 1]));
                    // 更新最大边长
                    maxSide = Math.max(maxSide, dp[i][j]);
                }
            }
        }

        // 返回面积
        return maxSide * maxSide;
    }


    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        char[][] matrix1 = {
            {'1', '0', '1', '0', '0'},
            {'1', '0', '1', '1', '1'},
            {'1', '1', '1', '1', '1'},
            {'1', '0', '0', '1', '0'}
        };
        System.out.println("输入: matrix = [...]");
        int result1 = maximalSquare(matrix1);
        System.out.println("输出: " + result1); // 预期输出: 4
        System.out.println();

        System.out.println("--- 示例 2 ---");
        char[][] matrix2 = {
            {'0', '1'},
            {'1', '0'}
        };
        System.out.println("输入: matrix = [['0','1'],['1','0']]");
        int result2 = maximalSquare(matrix2);
        System.out.println("输出: " + result2); // 预期输出: 1
        System.out.println();

        System.out.println("--- 示例 3 ---");
        char[][] matrix3 = {{'0'}};
        System.out.println("输入: matrix = [['0']]");
        int result3 = maximalSquare(matrix3);
        System.out.println("输出: " + result3); // 预期输出: 0
    }
}
```
