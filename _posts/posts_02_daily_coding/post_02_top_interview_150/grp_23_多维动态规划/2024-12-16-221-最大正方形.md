---
title: 221. 最大正方形
date: 2024-12-16 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 多维动态规划]
tags: [多维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251122000420511.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg)

- **输入:** `matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]`
- **输出:** 4

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg)

- **输入:** `matrix = [["0","1"],["1","0"]]`
- **输出:** 1

**示例 3:**

- **输入:** `matrix = [["0"]]`
- **输出:** 0

**提示:**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 300`
- `matrix[i][j]` 为 `'0'` 或 `'1'`

## 题解

### 解法：动态规划 (Dynamic Programming)

**思路：**

我们要找到最大的正方形，关键在于确定正方形的**边长**。

我们可以定义一个二维 DP 数组 `dp`，其中 `dp[i][j]` 表示以坐标 `(i, j)` 为**右下角**的、只包含 `'1'` 的正方形的**最大边长**。

1.  **状态转移方程**：

    - 如果当前位置是 `'0'` (`matrix[i][j] == '0'`)：显然无法构成正方形，`dp[i][j] = 0`。
    - 如果当前位置是 `'1'` (`matrix[i][j] == '1'`)：

      以 `(i, j)` 为右下角的正方形的大小，取决于它的**左边**、**上边**和**左上角**这三个邻居的正方形大小。只有当这三个方向都能提供足够的支持时，当前正方形才能变大。

      因此，当前的最大边长等于这三个邻居中的**最小值**加 1。

      $$dp[i][j] = \min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1$$

2.  **边界条件**：

    - 如果 `i == 0` 或 `j == 0`，且 `matrix[i][j] == '1'`，那么 `dp[i][j] = 1`（因为没有左边或上边的邻居，只能靠自己构成边长为 1 的正方形）。

3.  **最终结果**：

    - 在遍历过程中维护一个全局变量 `maxSide`，记录出现过的最大边长。
    - 最终返回面积：`maxSide * maxSide`。

**复杂度分析：**

- **时间复杂度：** $O(m \times n)$，我们需要遍历整个矩阵一次。
- **空间复杂度：** $O(m \times n)$，需要一个与原矩阵大小相同的 DP 数组。（注：可以使用滚动数组优化至 $O(n)$，但在面试中通常二维 DP 已足够）。

**代码片段：**

```java
public int maximalSquare(char[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return 0;
    }

    int m = matrix.length;
    int n = matrix[0].length;
    int[][] dp = new int[m][n];
    int maxSide = 0;

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (matrix[i][j] == '1') {
                if (i == 0 || j == 0) {
                    // 边界处理
                    dp[i][j] = 1;
                } else {
                    // 状态转移：取左、上、左上的最小值 + 1
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                }
                maxSide = Math.max(maxSide, dp[i][j]);
            }
        }
    }

    return maxSide * maxSide;
}
```

### 完整代码

```java
public class Main {

    /**
     * 221. 最大正方形 - 动态规划解法
     */
    public static int maximalSquare(char[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }

        int m = matrix.length;
        int n = matrix[0].length;

        // dp[i][j] 表示以 (i, j) 为右下角的最大正方形边长
        int[][] dp = new int[m][n];
        int maxSide = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 只有当前是 '1' 才有可能构成正方形
                if (matrix[i][j] == '1') {
                    if (i == 0 || j == 0) {
                        // 处于第一行或第一列，如果值为 '1'，最大边长只能是 1
                        dp[i][j] = 1;
                    } else {
                        // 核心转移方程：木桶效应，取决于最短的那块板
                        dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                    }

                    // 更新全局最大边长
                    maxSide = Math.max(maxSide, dp[i][j]);
                }
            }
        }

        // 返回面积
        return maxSide * maxSide;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        char[][] matrix1 = {
            {'1', '0', '1', '0', '0'},
            {'1', '0', '1', '1', '1'},
            {'1', '1', '1', '1', '1'},
            {'1', '0', '0', '1', '0'}
        };
        System.out.println("示例 1 输出: " + maximalSquare(matrix1));
        // 解释: 最大正方形边长为 2 (右下角在 (2,4) 或 (2,3))，面积为 4
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        char[][] matrix2 = {
            {'0', '1'},
            {'1', '0'}
        };
        System.out.println("示例 2 输出: " + maximalSquare(matrix2));
        // 解释: 边长为 1，面积 1
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        char[][] matrix3 = {
            {'0'}
        };
        System.out.println("示例 3 输出: " + maximalSquare(matrix3));
        // 解释: 没有 '1'，面积 0
        System.out.println("-----------------------------");

        // --- 示例 4 (全1矩阵) ---
        char[][] matrix4 = {
            {'1', '1', '1'},
            {'1', '1', '1'},
            {'1', '1', '1'}
        };
        System.out.println("示例 4 输出: " + maximalSquare(matrix4));
        // 解释: 边长 3，面积 9
    }
}
```
