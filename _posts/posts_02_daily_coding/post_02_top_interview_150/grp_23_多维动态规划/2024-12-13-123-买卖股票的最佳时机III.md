---
title: 123. 买卖股票的最佳时机III
date: 2024-12-13 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 多维动态规划]
tags: [多维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251122000246370.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

- **输入:** `prices = [3,3,5,0,0,3,1,4]`
- **输出:** 6
- **解释:**

  在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3。

  随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3。总利润 = 3 + 3 = 6。

**示例 2:**

- **输入:** `prices = [1,2,3,4,5]`
- **输出:** 4
- **解释:**

  在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。

  注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
  因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

**示例 3:**

- **输入:** `prices = [7,6,4,3,1]`
- **输出:** 0
- **解释:** 在这个情况下, 没有交易完成, 所以最大利润为 0。

**示例 4:**

- **输入:** `prices = [1]`
- **输出:** 0

**提示:**

- `1 <= prices.length <= 10^5`
- `0 <= prices[i] <= 10^5`

## 题解

### 解法：动态规划 (有限状态机)

**思路：**

由于题目限制最多只能进行 **两笔** 交易，且必须先卖出再买入。对于任意一天结束时，我们可能处于以下 5 种状态之一（忽略“未进行任何操作”的状态，因为它利润为 0）：

1.  **第一次买入 (`buy1`)**：只进行过一次买入操作，目前持有股票。
2.  **第一次卖出 (`sell1`)**：完成了一次买卖，目前不持有股票。
3.  **第二次买入 (`buy2`)**：在完成第一次交易后，又进行了第二次买入，目前持有股票。
4.  **第二次卖出 (`sell2`)**：完成了两次买卖，目前不持有股票。

我们需要遍历价格数组，计算每一天结束时这 4 种状态下能获得的最大利润。

**状态转移方程：**

假设当前价格为 `p`：

- `buy1`：要么保持昨天的状态，要么今天第一次买入（利润为 `-p`）。

  $$buy1 = \max(buy1, -p)$$

- `sell1`：要么保持昨天的状态，要么今天卖出第一次买的股票。

  $$sell1 = \max(sell1, buy1 + p)$$

- `buy2`：要么保持昨天的状态，要么今天第二次买入（使用第一次卖出的利润减去当前价格）。

  $$buy2 = \max(buy2, sell1 - p)$$

- `sell2`：要么保持昨天的状态，要么今天卖出第二次买的股票。

  $$sell2 = \max(sell2, buy2 + p)$$

**初始化：**

- `buy1` 和 `buy2` 初始化为 `-prices[0]`（第一天买入）。
- `sell1` 和 `sell2` 初始化为 `0`（第一天不可能卖出盈利，或者当天买当天卖利润为 0）。

**最终结果：**

返回 `sell2`。即使实际只做了一笔交易最优，`sell2` 的逻辑也会包含这种情况（相当于第二次交易在同一天买入卖出，利润增加 0），因此 `sell2` 始终是最大值。

**复杂度分析：**

- **时间复杂度：** $O(n)$，只需要遍历一次数组。
- **空间复杂度：** $O(1)$，只需要 4 个变量来维护状态。

**代码片段：**

```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) return 0;

    int buy1 = -prices[0];
    int sell1 = 0;
    int buy2 = -prices[0];
    int sell2 = 0;

    for (int i = 1; i < prices.length; i++) {
        // 第一次买入：保持原状 或 今天买
        buy1 = Math.max(buy1, -prices[i]);
        // 第一次卖出：保持原状 或 卖掉第一次买的
        sell1 = Math.max(sell1, buy1 + prices[i]);
        // 第二次买入：保持原状 或 用第一次赚的钱买新的
        buy2 = Math.max(buy2, sell1 - prices[i]);
        // 第二次卖出：保持原状 或 卖掉第二次买的
        sell2 = Math.max(sell2, buy2 + prices[i]);
    }

    return sell2;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    /**
     * 123. 买卖股票的最佳时机 III - 动态规划解法
     */
    public static int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }

        // 初始化状态
        // buy1: 第一次买入后的最大利润（成本，所以是负数）
        int buy1 = -prices[0];
        // sell1: 第一次卖出后的最大利润
        int sell1 = 0;
        // buy2: 第二次买入后的最大利润
        int buy2 = -prices[0];
        // sell2: 第二次卖出后的最大利润
        int sell2 = 0;

        for (int i = 1; i < prices.length; i++) {
            // 更新四个状态
            // 注意：这里的更新顺序允许"同一天买入又卖出"，这在逻辑上是允许的（利润变动为0）
            // 这种写法节省了临时变量，且逻辑正确
            buy1 = Math.max(buy1, -prices[i]);
            sell1 = Math.max(sell1, buy1 + prices[i]);
            buy2 = Math.max(buy2, sell1 - prices[i]);
            sell2 = Math.max(sell2, buy2 + prices[i]);
        }

        return sell2;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] prices1 = {3, 3, 5, 0, 0, 3, 1, 4};
        System.out.println("示例 1 输入: " + Arrays.toString(prices1));
        System.out.println("示例 1 输出: " + maxProfit(prices1));
        // 解释: 4-0=4 (第4天买第6天卖，赚3；第7天买第8天卖，赚3) -> 总共 6
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] prices2 = {1, 2, 3, 4, 5};
        System.out.println("示例 2 输入: " + Arrays.toString(prices2));
        System.out.println("示例 2 输出: " + maxProfit(prices2));
        // 解释: 1买 5卖，赚4。只能做一笔，因为不能同时持有多笔。
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        int[] prices3 = {7, 6, 4, 3, 1};
        System.out.println("示例 3 输入: " + Arrays.toString(prices3));
        System.out.println("示例 3 输出: " + maxProfit(prices3));
        // 解释: 不交易，0
        System.out.println("-----------------------------");

        // --- 示例 4 ---
        int[] prices4 = {1};
        System.out.println("示例 4 输入: " + Arrays.toString(prices4));
        System.out.println("示例 4 输出: " + maxProfit(prices4));
        // 解释: 0
    }
}
```
