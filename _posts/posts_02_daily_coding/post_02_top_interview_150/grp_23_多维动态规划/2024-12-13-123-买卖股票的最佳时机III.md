---
title: 123-买卖股票的最佳时机III
date: 2024-12-13 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 多维动态规划]
tags: [多维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251122000246370.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


### 题目：123. 买卖股票的最佳时机 III

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

---

**示例 1:**

- **输入:** `prices = [3,3,5,0,0,3,1,4]`
- **输出:** 6
- **解释:** 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3。
  随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3。总利润 = 3 + 3 = 6。

**示例 2:**

- **输入:** `prices = [1,2,3,4,5]`
- **输出:** 4
- **解释:** 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。
  注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
  因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

**示例 3:**

- **输入:** `prices = [7,6,4,3,1]`
- **输出:** 0
- **解释:** 在这个情况下, 没有交易完成, 所以最大利润为 0。

**示例 4:**

- **输入:** `prices = [1]`
- **输出:** 0

---

**提示:**

- `1 <= prices.length <= 10^5`
- `0 <= prices[i] <= 10^5`

---

### Java 8 解答 (赛码网格式)

**算法思路：(动态规划)**
这个问题可以通过动态规划解决。由于最多可以进行两次交易，我们需要跟踪四个状态：第一次买入后的最大利润、第一次卖出后的最大利润、第二次买入后的最大利润、以及第二次卖出后的最大利润。

我们可以定义四个变量来表示这四个状态，并在遍历价格数组时动态更新它们：

- `buy1`: 到当前天为止，进行 **一次买入** 操作后，手上持有的最大利润。
- `sell1`: 到当前天为止，进行 **一次卖出** 操作后，手上不持有股票的最大利润。
- `buy2`: 到当前天为止，进行 **第二次买入** 操作后，手上持有的最大利润。
- `sell2`: 到当前天为止，进行 **第二次卖出** 操作后，手上不持有股票的最大利润。

遍历每一天的价格 `price`：

- 更新 `buy1`: `max(之前的buy1, -price)` (要么维持之前的买入状态，要么今天买入)
- 更新 `sell1`: `max(之前的sell1, 之前的buy1 + price)` (要么维持之前的卖出状态，要么今天卖出获利)
- 更新 `buy2`: `max(之前的buy2, 之前的sell1 - price)` (要么维持之前的第二次买入状态，要么在第一次卖出后，今天进行第二次买入)
- 更新 `sell2`: `max(之前的sell2, 之前的buy2 + price)` (要么维持之前的第二次卖出状态，要么今天进行第二次卖出获利)

最终，`sell2` 就是我们所求的、完成最多两次交易后的最大利润。

```java
import java.util.Arrays;

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    /**
     * 计算最多可以完成两笔交易的最大利润。
     *
     * @param prices 股票价格数组。
     * @return 最大利润。
     */
    public static int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) {
            return 0;
        }

        // 初始化四个状态
        int buy1 = Integer.MIN_VALUE;  // 第一次买入后的最大利润
        int sell1 = 0;                 // 第一次卖出后的最大利润
        int buy2 = Integer.MIN_VALUE;  // 第二次买入后的最大利润
        int sell2 = 0;                 // 第二次卖出后的最大利润

        for (int price : prices) {
            // 为了保证在计算当天的 sell1 时使用的是昨天的 buy1，
            // 以及在计算 buy2 时使用的是昨天的 sell1，
            // 我们需要按照 sell2 -> buy2 -> sell1 -> buy1 的顺序更新

            sell2 = Math.max(sell2, buy2 + price);
            buy2 = Math.max(buy2, sell1 - price);
            sell1 = Math.max(sell1, buy1 + price);
            buy1 = Math.max(buy1, -price);
        }

        return sell2;
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[] prices1 = {3, 3, 5, 0, 0, 3, 1, 4};
        System.out.println("输入: prices = " + Arrays.toString(prices1));
        int result1 = maxProfit(prices1);
        System.out.println("输出: " + result1); // 预期输出: 6
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[] prices2 = {1, 2, 3, 4, 5};
        System.out.println("输入: prices = " + Arrays.toString(prices2));
        int result2 = maxProfit(prices2);
        System.out.println("输出: " + result2); // 预期输出: 4
        System.out.println();

        System.out.println("--- 示例 3 ---");
        int[] prices3 = {7, 6, 4, 3, 1};
        System.out.println("输入: prices = " + Arrays.toString(prices3));
        int result3 = maxProfit(prices3);
        System.out.println("输出: " + result3); // 预期输出: 0
        System.out.println();

        System.out.println("--- 示例 4 ---");
        int[] prices4 = {1};
        System.out.println("输入: prices = " + Arrays.toString(prices4));
        int result4 = maxProfit(prices4);
        System.out.println("输出: " + result4); // 预期输出: 0
    }
}
```
