---
title: 120-三角形最小路径和
date: 2024-12-02 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 多维动态规划]
tags: [多维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235955943.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


### 题目：120. 三角形最小路径和

给定一个三角形 `triangle`，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。**相邻的结点** 在这里指的是 **下标** 与上一层结点下标 **相同** 或者等于 **上一层结点下标 + 1** 的两个结点。也就是说，如果正位于当前行的下标 `i`，那么下一步可以移动到下一行的下标 `i` 或 `i + 1`。

---

**示例 1:**

- **输入:** `triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]`
- **输出:** 11
- **解释:** 如下面简图所示：
  ```
     2
    3 4
   6 5 7
  4 1 8 3
  ```
  自顶向下的最小路径和为 11 (即, `2 + 3 + 5 + 1 = 11`)。

**示例 2:**

- **输入:** `triangle = [[-10]]`
- **输出:** -10

---

**提示:**

- `1 <= triangle.length <= 200`
- `triangle[0].length == 1`
- `triangle[i].length == triangle[i - 1].length + 1`
- `-10^4 <= triangle[i][j] <= 10^4`

**进阶:**

- 你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？

---

### Java 8 解答 (赛码网格式)

**算法思路：(动态规划 - 自底向上)**
为了满足进阶要求中的 O(n) 空间复杂度，我们采用自底向上的动态规划方法。

1.  创建一个大小为 `n+1` 的一维数组 `dp`（`n` 是三角形的行数）。
2.  从三角形的 **最后一行** 开始向上遍历。
3.  对于每一行 `i`，我们更新 `dp` 数组。`dp[j]` 的新值将等于当前行 `triangle[i][j]` 的值，加上从下一行可以到达的两个位置（即 `dp[j]` 和 `dp[j+1]`）中的较小值。
4.  状态转移方程为：`dp[j] = triangle[i][j] + min(dp[j], dp[j+1])`。
5.  当我们遍历到三角形的顶端（第 0 行）时，`dp[0]` 中存储的就是从顶部到底部的最小路径和。

这种方法巧妙地复用了一维数组，将空间复杂度从 O(n^2) 优化到了 O(n)。

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    /**
     * 找出自顶向下的最小路径和。
     *
     * @param triangle 表示三角形的列表。
     * @return 最小路径和。
     */
    public static int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();
        // dp 数组，多一位可以避免边界检查
        int[] dp = new int[n + 1];

        // 从倒数第二行开始，自底向上进行动态规划
        for (int i = n - 1; i >= 0; i--) {
            List<Integer> currentRow = triangle.get(i);
            for (int j = 0; j < currentRow.size(); j++) {
                // 状态转移方程
                dp[j] = currentRow.get(j) + Math.min(dp[j], dp[j + 1]);
            }
        }

        // 最终结果存储在 dp[0]
        return dp[0];
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        List<List<Integer>> triangle1 = new ArrayList<>();
        triangle1.add(Collections.singletonList(2));
        triangle1.add(Arrays.asList(3, 4));
        triangle1.add(Arrays.asList(6, 5, 7));
        triangle1.add(Arrays.asList(4, 1, 8, 3));
        System.out.println("输入: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]");
        int result1 = minimumTotal(triangle1);
        System.out.println("输出: " + result1); // 预期输出: 11
        System.out.println();

        System.out.println("--- 示例 2 ---");
        List<List<Integer>> triangle2 = new ArrayList<>();
        triangle2.add(Collections.singletonList(-10));
        System.out.println("输入: triangle = [[-10]]");
        int result2 = minimumTotal(triangle2);
        System.out.println("输出: " + result2); // 预期输出: -10
        System.out.println();
    }
}
```
