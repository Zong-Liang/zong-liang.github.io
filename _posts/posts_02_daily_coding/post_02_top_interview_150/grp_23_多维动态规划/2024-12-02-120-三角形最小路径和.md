---
title: 120. 三角形最小路径和
date: 2024-12-02 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 多维动态规划]
tags: [多维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235955943.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个三角形 `triangle`，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。**相邻的结点** 在这里指的是 **下标** 与上一层结点下标 **相同** 或者等于 **上一层结点下标 + 1** 的两个结点。也就是说，如果正位于当前行的下标 `i`，那么下一步可以移动到下一行的下标 `i` 或 `i + 1`。

**示例 1:**

- **输入:** `triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]`
- **输出:** 11
- **解释:** 如下面简图所示：

  ```
     2
    3 4
   6 5 7
  4 1 8 3
  ```

  自顶向下的最小路径和为 11 (即, `2 + 3 + 5 + 1 = 11`)。

**示例 2:**

- **输入:** `triangle = [[-10]]`
- **输出:** -10

**提示:**

- `1 <= triangle.length <= 200`
- `triangle[0].length == 1`
- `triangle[i].length == triangle[i - 1].length + 1`
- `-10^4 <= triangle[i][j] <= 10^4`

**进阶:**

- 你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？

## 题解

### 解法一：动态规划 - 二维数组 (Standard DP)

**思路：**

我们要寻找从顶点到底部的最小路径和。如果在某一个位置 `(i, j)`，我们只能从上一行的 `(i-1, j-1)` 或者 `(i-1, j)` 移动过来（自顶向下思考）。反过来思考（自底向上），如果在位置 `(i, j)`，下一步只能走到下一行的 `(i+1, j)` 或者 `(i+1, j+1)`。

**自底向上（Bottom-Up）** 的动态规划通常比自顶向下更容易处理边界条件，且最后不需要遍历最后一行寻找最小值，`dp[0][0]` 就是答案。

1.  **定义状态**：`dp[i][j]` 表示从三角形底部走到位置 `(i, j)` 的最小路径和。
2.  **状态转移方程**：

    `dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])`

    即：当前位置的值 + 下一行相邻两个位置中较小的那个路径和。

3.  **初始化**：最底下一层的 `dp` 值就等于 `triangle` 最底下一层的值。
4.  **遍历顺序**：从倒数第二层开始向上遍历，直到第 0 层。

**复杂度分析：**

- **时间复杂度：** $O(N^2)$，$N$ 为行数。我们需要计算三角形中所有元素的状态，元素总数为 $N(N+1)/2$。
- **空间复杂度：** $O(N^2)$，我们需要一个二维数组来存储状态。

**代码片段：**

```java
public int minimumTotal(List<List<Integer>> triangle) {
    int n = triangle.size();
    // dp[i][j] 表示从点 (i, j) 到底部的最小路径和
    int[][] dp = new int[n][n];

    // 1. 初始化最后一行
    for (int i = 0; i < n; i++) {
        dp[n - 1][i] = triangle.get(n - 1).get(i);
    }

    // 2. 从倒数第二行开始向上计算
    for (int i = n - 2; i >= 0; i--) {
        for (int j = 0; j <= i; j++) {
            // 当前值 + 下一行相邻两者的最小值
            dp[i][j] = triangle.get(i).get(j) + Math.min(dp[i + 1][j], dp[i + 1][j + 1]);
        }
    }

    return dp[0][0];
}
```

### 解法二：空间优化 - 一维数组 (Space Optimized DP) —— 进阶解法

**思路：**

观察解法一中的状态转移方程：`dp[i][j]` 只依赖于下一行（`i+1` 行）的 `dp` 值。这意味着我们在计算第 `i` 行时，只需要第 `i+1` 行的数据。

我们可以只使用一个长度为 $N+1$ 的一维数组 `dp`。

- 在计算第 `i` 行时，`dp[j]` 存储的是第 `i+1` 行第 `j` 列的路径和。
- `dp[j+1]` 存储的是第 `i+1` 行第 `j+1` 列的路径和。
- 计算出的新结果可以直接覆盖到 `dp[j]` 中，因为计算第 `i` 行第 `j+1` 个元素时，并不需要旧的 `dp[j]` 数据，所以覆盖它是安全的。

**逻辑流程：**

1. 创建一个长度为 `n + 1` 的数组 `dp`，初始化为 0。
2. 从三角形的最后一行开始向上遍历。
3. 对于每一行的每一个元素，计算 `min(dp[j], dp[j+1])` 并加上当前元素的值，更新 `dp[j]`。
4. 这种方式甚至不需要专门初始化最后一行（如果我们把数组长度设为 `n+1`，最开始全是 0，第一次循环处理最后一行时，`min(0, 0)` 还是 0，直接加上本身的值，逻辑自洽）。

**复杂度分析：**

- **时间复杂度：** $O(N^2)$，依然需要遍历所有节点。
- **空间复杂度：** $O(N)$，只使用了一个长度为 $N+1$ 的一维数组。

**代码片段：**

```java
public int minimumTotalOptimized(List<List<Integer>> triangle) {
    int n = triangle.size();
    // 只需要一个一维数组，长度 n+1 是为了处理边界或简化初始化逻辑
    int[] dp = new int[n + 1];

    // 从最后一行开始向上遍历到第 0 行
    for (int i = n - 1; i >= 0; i--) {
        List<Integer> row = triangle.get(i);
        for (int j = 0; j < row.size(); j++) {
            // dp[j] 代表正下方的最小路径
            // dp[j+1] 代表右下方的最小路径
            // 计算结果直接存回 dp[j]，也就是复用了空间
            dp[j] = row.get(j) + Math.min(dp[j], dp[j + 1]);
        }
    }
    return dp[0];
}
```

### 完整代码

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Main {

    // --- 解法一：标准二维 DP ---
    public static int minimumTotal(List<List<Integer>> triangle) {
        if (triangle == null || triangle.size() == 0) return 0;
        int n = triangle.size();
        int[][] dp = new int[n][n];

        // 初始化最后一行
        for (int i = 0; i < n; i++) {
            dp[n - 1][i] = triangle.get(n - 1).get(i);
        }

        // 自底向上递推
        for (int i = n - 2; i >= 0; i--) {
            for (int j = 0; j <= i; j++) {
                dp[i][j] = triangle.get(i).get(j) + Math.min(dp[i + 1][j], dp[i + 1][j + 1]);
            }
        }
        return dp[0][0];
    }

    // --- 解法二：空间优化一维 DP (进阶) ---
    public static int minimumTotalOptimized(List<List<Integer>> triangle) {
        if (triangle == null || triangle.size() == 0) return 0;
        int n = triangle.size();

        // 申请 n+1 的空间，默认值为 0
        // 多这 1 个空间是为了让处理最后一行时，dp[j] 和 dp[j+1] 都是 0，
        // 从而不需要单独写逻辑初始化最后一行
        int[] dp = new int[n + 1];

        for (int i = n - 1; i >= 0; i--) {
            List<Integer> currentRow = triangle.get(i);
            for (int j = 0; j < currentRow.size(); j++) {
                // 状态转移：当前值 + min(下, 右下)
                dp[j] = currentRow.get(j) + Math.min(dp[j], dp[j + 1]);
            }
        }

        return dp[0];
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        // 构造输入: [[2],[3,4],[6,5,7],[4,1,8,3]]
        List<List<Integer>> triangle = new ArrayList<>();
        triangle.add(Arrays.asList(2));
        triangle.add(Arrays.asList(3, 4));
        triangle.add(Arrays.asList(6, 5, 7));
        triangle.add(Arrays.asList(4, 1, 8, 3));

        System.out.println("示例 1 输入: " + triangle);

        int resultStandard = minimumTotal(triangle);
        System.out.println("标准解法输出: " + resultStandard);

        int resultOptimized = minimumTotalOptimized(triangle);
        System.out.println("优化解法输出: " + resultOptimized);
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        // 构造输入: [[-10]]
        List<List<Integer>> triangle2 = new ArrayList<>();
        triangle2.add(Arrays.asList(-10));

        System.out.println("示例 2 输入: " + triangle2);
        System.out.println("标准解法输出: " + minimumTotal(triangle2));
        System.out.println("优化解法输出: " + minimumTotalOptimized(triangle2));
    }
}
```
