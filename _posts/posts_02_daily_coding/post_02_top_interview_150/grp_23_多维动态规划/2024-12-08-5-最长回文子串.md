---
title: 5. 最长回文子串
date: 2024-12-08 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 多维动态规划]
tags: [多维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251122000111007.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


## 题目：5. 最长回文子串

给你一个字符串 `s`，找到 `s` 中最长的**回文子串**。


**示例 1:**

- **输入:** `s = "babad"`
- **输出:** `"bab"`
- **解释:** `"aba"` 同样是符合题意的答案。

**示例 2:**

- **输入:** `s = "cbbd"`
- **输出:** `"bb"`


**提示:**

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母组成


## Java 代码

**算法思路：(中心扩展法)**

这是一个高效且直观的解法。我们遍历字符串中的每一个字符，并以该字符（或该字符与下一个字符的间隙）为中心，向两边扩展，以查找最长的回文串。

1.  一个回文串的中心可能是一个字符（如 "a**b**a"），也可能是两个相同字符的间隙（如 "a**bb**a"）。
2.  我们遍历字符串的所有 `2n-1` 个可能的中心（`n` 个单字符中心和 `n-1` 个双字符间隙中心）。
3.  对于每个中心，我们向两边扩展指针，直到遇到边界或不匹配的字符。
4.  在扩展过程中，我们持续记录并更新找到的最长回文子串的起始和结束位置。
5.  遍历结束后，根据记录的起始和结束位置截取子串即可。

该算法的时间复杂度为 O(n^2)，空间复杂度为 O(1)。

```java
public class Main {

    /**
     * 找到 s 中最长的回文子串。
     *
     * @param s 输入字符串。
     * @return 最长的回文子串。
     */
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) {
            return "";
        }

        int start = 0;
        int end = 0;

        for (int i = 0; i < s.length(); i++) {
            // 情况1: 回文串长度为奇数，中心是 s[i]
            int len1 = expandAroundCenter(s, i, i);
            // 情况2: 回文串长度为偶数，中心是 s[i] 和 s[i+1] 之间
            int len2 = expandAroundCenter(s, i, i + 1);

            int len = Math.max(len1, len2);

            // 如果找到了更长的回文串，则更新其起始和结束位置
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }

        return s.substring(start, end + 1);
    }

    /**
     * 从中心向两边扩展，查找并返回回文串的长度。
     */
    private int expandAroundCenter(String s, int left, int right) {
        // 当指针在边界内且指向的字符相同时，继续扩展
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        // 返回回文串的长度
        return right - left - 1;
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        // 需要创建 Main 类的实例来调用非静态方法
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        String s1 = "babad";
        System.out.println("输入: s = \"" + s1 + "\"");
        String result1 = solution.longestPalindrome(s1);
        System.out.println("输出: \"" + result1 + "\""); // 预期输出: "bab" 或 "aba"
        System.out.println();

        System.out.println("--- 示例 2 ---");
        String s2 = "cbbd";
        System.out.println("输入: s = \"" + s2 + "\"");
        String result2 = solution.longestPalindrome(s2);
        System.out.println("输出: \"" + result2 + "\""); // 预期输出: "bb"
        System.out.println();
    }
}
```
