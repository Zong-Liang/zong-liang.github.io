---
title: 5. 最长回文子串
date: 2024-12-08 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 多维动态规划]
tags: [多维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251122000111007.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个字符串 `s`，找到 `s` 中最长的**回文子串**。

**示例 1:**

- **输入:** `s = "babad"`
- **输出:** `"bab"`
- **解释:** `"aba"` 同样是符合题意的答案。

**示例 2:**

- **输入:** `s = "cbbd"`
- **输出:** `"bb"`

**提示:**

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母组成

## 题解

### 解法：中心扩散法 (Expand Around Center)

**思路：**

回文串的一个核心特性是**对称性**。与其像暴力法那样枚举所有可能的子串然后判断是否回文（时间复杂度 $O(n^3)$），不如枚举回文串的**中心**，然后尝试向两边扩散，直到字符不相等为止。

1.  **确定中心**：

    一个回文串的中心可能是一个字符（例如 `"aba"` 的中心是 `'b'`），也可能是两个字符之间的空隙（例如 `"abba"` 的中心是中间两个 `'b'` 之间的缝隙）。

    对于长度为 `n` 的字符串，共有 `n` 个单字符中心和 `n-1` 个双字符中心，总计 `2n - 1` 个中心。

2.  **扩散过程**：

    我们遍历字符串中的每一个索引 `i`：

    - 以 `i` 为中心扩散（处理奇数长度的情况）。
    - 以 `i` 和 `i+1` 之间为中心扩散（处理偶数长度的情况）。
    - 每次扩散后，计算当前找到的回文子串长度。

3.  **更新结果**：

    维护一个全局的最大长度 `maxLen` 和起始位置 `start`。如果当前找到的长度大于 `maxLen`，则更新这两个值。

**复杂度分析：**

- **时间复杂度：** $O(n^2)$，我们需要枚举 $O(n)$ 个中心，每个中心向外扩散最坏情况需要 $O(n)$ 的时间。
- **空间复杂度：** $O(1)$，我们只需要常数级别的变量来存储索引和长度，不需要像动态规划那样维护二维数组。

**代码片段：**

```java
public String longestPalindrome(String s) {
    if (s == null || s.length() < 1) return "";
    int start = 0, end = 0;

    for (int i = 0; i < s.length(); i++) {
        // 情况1：以字符为中心（奇数长度）
        int len1 = expandAroundCenter(s, i, i);
        // 情况2：以空隙为中心（偶数长度）
        int len2 = expandAroundCenter(s, i, i + 1);

        int len = Math.max(len1, len2);

        // 如果发现了更长的回文串，更新起始和结束下标
        if (len > end - start) {
            // 根据中心 i 和长度 len 计算新的边界
            start = i - (len - 1) / 2;
            end = i + len / 2;
        }
    }
    return s.substring(start, end + 1);
}

// 辅助函数：从 left 和 right 向两边扩散，返回回文串长度
private int expandAroundCenter(String s, int left, int right) {
    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
        left--;
        right++;
    }
    // 跳出循环时，left 和 right 已经不满足回文条件了
    // 回文串范围是 (left + 1) 到 (right - 1)
    // 长度 = (right - 1) - (left + 1) + 1 = right - left - 1
    return right - left - 1;
}
```

### 完整代码

```java
public class Main {

    /**
     * 5. 最长回文子串 - 中心扩散法
     */
    public static String longestPalindrome(String s) {
        if (s == null || s.length() < 1) {
            return "";
        }

        // 记录最长回文子串的起始和结束索引（包含 end）
        int start = 0, end = 0;

        for (int i = 0; i < s.length(); i++) {
            // 1. 以当前字符 s[i] 为中心扩散 (如 "aba")
            int len1 = expandAroundCenter(s, i, i);

            // 2. 以当前字符 s[i] 和 s[i+1] 之间为中心扩散 (如 "abba")
            int len2 = expandAroundCenter(s, i, i + 1);

            // 取两者的最大长度
            int len = Math.max(len1, len2);

            // 如果找到了比之前更长的回文串，更新记录
            // 当前找到的回文长度为 len
            // 之前的回文长度为 end - start + 1 (或者直接比较 end - start，因为是比较大小，常数项不影响)
            if (len > end - start) {
                // 计算新的起点和终点
                // 示例：i=2, len=5 ("cabac"), start = 2 - (4)/2 = 0
                // 示例：i=2, len=4 ("baab"), start = 2 - (3)/2 = 1
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }

        // substring 左闭右开，所以 end 需要 +1
        return s.substring(start, end + 1);
    }

    /**
     * 中心扩散辅助函数
     * @param s 字符串
     * @param left 左边界初始值
     * @param right 右边界初始值
     * @return 扩散后的回文串长度
     */
    private static int expandAroundCenter(String s, int left, int right) {
        // 当索引未越界且左右字符相等时，继续向外扩散
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        // 循环结束时，s[left] != s[right]
        // 实际回文范围是 [left + 1, right - 1]
        // 长度公式: (right - 1) - (left + 1) + 1 = right - left - 1
        return right - left - 1;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        String s1 = "babad";
        System.out.println("示例 1 输入: s = \"" + s1 + "\"");
        System.out.println("示例 1 输出: \"" + longestPalindrome(s1) + "\"");
        // 解释: "bab" 或 "aba" 均可
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        String s2 = "cbbd";
        System.out.println("示例 2 输入: s = \"" + s2 + "\"");
        System.out.println("示例 2 输出: \"" + longestPalindrome(s2) + "\"");
        // 解释: "bb"
        System.out.println("-----------------------------");

        // --- 示例 3 (单字符) ---
        String s3 = "a";
        System.out.println("示例 3 输入: s = \"" + s3 + "\"");
        System.out.println("示例 3 输出: \"" + longestPalindrome(s3) + "\"");
        System.out.println("-----------------------------");

        // --- 示例 4 (全相同) ---
        String s4 = "aaaa";
        System.out.println("示例 4 输入: s = \"" + s4 + "\"");
        System.out.println("示例 4 输出: \"" + longestPalindrome(s4) + "\"");
        // 解释: "aaaa"
    }
}
```
