---
title: 188. 买卖股票的最佳时机IV
date: 2024-12-14 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 多维动态规划]
tags: [多维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251122000317533.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个整数数组 `prices` 和一个整数 `k`，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意：** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

- **输入:** `k = 2`, `prices = [2,4,1]`
- **输出:** 2
- **解释:** 在第 1 天（股票价格 = 2）的时候买入，在第 2 天（股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-2 = 2。

**示例 2:**

- **输入:** `k = 2`, `prices = [3,2,6,5,0,3]`
- **输出:** 7
- **解释:**

  在第 2 天（股票价格 = 2）的时候买入，在第 3 天（股票价格 = 6）的时候卖出，这笔交易所能获得利润 = 6-2 = 4。

  随后，在第 5 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3。

**提示:**

- `1 <= k <= 100`
- `1 <= prices.length <= 1000`
- `0 <= prices[i] <= 1000`

## 题解

### 解法：动态规划 (Dynamic Programming)

**思路：**

这是一道通用的股票买卖问题，是“买卖股票的最佳时机 III”（只能买卖 2 次）的推广版。我们需要求在最多 `k` 次交易下的最大利润。

我们可以维护两个数组（或二维数组的一行）来记录状态：

1.  `buy[j]`：表示在进行第 `j` 次交易的**买入**操作后，手里的最大现金（因为买了股票，现金通常减少，或者是负数）。
2.  `sell[j]`：表示在进行第 `j` 次交易的**卖出**操作后，手里的最大现金（利润）。

**状态转移方程：**

对于每一天价格 `p`，我们要更新从第 `1` 次到第 `k` 次交易的所有状态：

- **第 `j` 次买入 (`buy[j]`)**：

  我们可以选择保持昨天的持股状态，或者在今天买入。如果今天买入，那么我们的资金来源于“第 `j-1` 次交易卖出后的利润”减去“当前股价”。

  $$buy[j] = \max(buy[j], sell[j-1] - p)$$

- **第 `j` 次卖出 (`sell[j]`)**：

  我们可以选择保持昨天的空仓状态，或者在今天卖出。如果今天卖出，那么资金来源于“第 `j` 次买入后的资金”加上“当前股价”。

  $$sell[j] = \max(sell[j], buy[j] + p)$$

**初始化：**

- `buy` 数组的所有元素初始化为 `-prices[0]`。这是因为在第 0 天，无论我们进行第几次买入（逻辑上允许同一天买卖多次），成本都是第一天的价格。
- `sell` 数组的所有元素初始化为 `0`。

**复杂度分析：**

- **时间复杂度：** $O(n \cdot k)$，其中 $n$ 是天数，$k$ 是允许的交易次数。
- **空间复杂度：** $O(k)$，只需要两个长度为 $k+1$ 的数组（或一个 $k \times 2$ 的数组）存储状态。

**代码片段：**

```java
public int maxProfit(int k, int[] prices) {
    if (k == 0 || prices == null || prices.length == 0) {
        return 0;
    }

    // buy[j] 表示第 j 次买入后的最大状态
    int[] buy = new int[k + 1];
    // sell[j] 表示第 j 次卖出后的最大状态
    int[] sell = new int[k + 1];

    // 初始化
    Arrays.fill(buy, -prices[0]);
    Arrays.fill(sell, 0);

    for (int p : prices) {
        for (int j = 1; j <= k; j++) {
            // 第 j 次买入：要么保持不动，要么用第 j-1 次卖出的钱买入
            buy[j] = Math.max(buy[j], sell[j - 1] - p);
            // 第 j 次卖出：要么保持不动，要么卖出第 j 次买入的股票
            sell[j] = Math.max(sell[j], buy[j] + p);
        }
    }

    return sell[k];
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    /**
     * 188. 买卖股票的最佳时机 IV - 动态规划
     */
    public static int maxProfit(int k, int[] prices) {
        // 边界检查
        if (k <= 0 || prices == null || prices.length == 0) {
            return 0;
        }

        // 优化：如果 k 超过了天数的一半，相当于可以无限次交易
        // 这是一个可选的优化，虽然不加也能通过（因为 k <= 100 比较小），
        // 但加上可以处理 k 很大的情况，转为 O(n) 的贪心算法。
        int n = prices.length;
        if (k >= n / 2) {
            return maxProfitUnlimited(prices);
        }

        // 状态数组
        // buy[j]: 第 j 次交易持有股票时的最大利润
        int[] buy = new int[k + 1];
        // sell[j]: 第 j 次交易卖出股票后的最大利润
        int[] sell = new int[k + 1];

        // 初始化
        // 无论第几次买入，初始时（第0天）如果买入，收益都是 -prices[0]
        Arrays.fill(buy, -prices[0]);
        // 卖出状态初始为 0
        Arrays.fill(sell, 0);

        for (int i = 0; i < n; i++) {
            int p = prices[i];
            for (int j = 1; j <= k; j++) {
                // 状态转移
                // 1. 更新第 j 次买入的状态
                // max(继续持有, 前一次卖出后剩下的钱 - 当前股价)
                buy[j] = Math.max(buy[j], sell[j - 1] - p);

                // 2. 更新第 j 次卖出的状态
                // max(继续空仓, 第 j 次买入后的状态 + 当前股价)
                sell[j] = Math.max(sell[j], buy[j] + p);
            }
        }

        return sell[k];
    }

    /**
     * 辅助函数：处理无限次交易的情况 (类似于 LeetCode 122)
     */
    private static int maxProfitUnlimited(int[] prices) {
        int maxProfit = 0;
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i - 1]) {
                maxProfit += prices[i] - prices[i - 1];
            }
        }
        return maxProfit;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int k1 = 2;
        int[] prices1 = {2, 4, 1};
        System.out.println("示例 1 输入: k = " + k1 + ", prices = " + Arrays.toString(prices1));
        System.out.println("示例 1 输出: " + maxProfit(k1, prices1));
        // 解释: 2买 4卖，利润 2
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int k2 = 2;
        int[] prices2 = {3, 2, 6, 5, 0, 3};
        System.out.println("示例 2 输入: k = " + k2 + ", prices = " + Arrays.toString(prices2));
        System.out.println("示例 2 输出: " + maxProfit(k2, prices2));
        // 解释: 2买 6卖(赚4); 0买 3卖(赚3); 总共 7
        System.out.println("-----------------------------");

        // --- 示例 3 (k 很大) ---
        int k3 = 100;
        int[] prices3 = {1, 2, 3, 4, 5};
        System.out.println("示例 3 输入: k = " + k3 + ", prices = " + Arrays.toString(prices3));
        System.out.println("示例 3 输出: " + maxProfit(k3, prices3));
        // 解释: 相当于无限次交易，1买 5卖，利润 4
    }
}
```
