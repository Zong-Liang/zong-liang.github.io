---
title: 188. 买卖股票的最佳时机IV
date: 2024-12-14 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 多维动态规划]
tags: [多维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251122000317533.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：188. 买卖股票的最佳时机 IV

给你一个整数数组 `prices` 和一个整数 `k`，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意：** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

- **输入:** `k = 2`, `prices = [2,4,1]`
- **输出:** 2
- **解释:** 在第 1 天（股票价格 = 2）的时候买入，在第 2 天（股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-2 = 2。

**示例 2:**

- **输入:** `k = 2`, `prices = [3,2,6,5,0,3]`
- **输出:** 7
- **解释:** 在第 2 天（股票价格 = 2）的时候买入，在第 3 天（股票价格 = 6）的时候卖出，这笔交易所能获得利润 = 6-2 = 4。
  随后，在第 5 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3。

**提示:**

- `1 <= k <= 100`
- `1 <= prices.length <= 1000`
- `0 <= prices[i] <= 1000`

## 题解

**算法思路：(动态规划)**

这是买卖股票系列问题的通用解法。我们可以使用动态规划来跟踪在最多 `k` 次交易下的状态。

我们创建两个数组，`buy` 和 `sell`，长度为 `k+1`：

- `buy[j]`：表示到当前天为止，恰好进行 **j 次买入** 操作后，手上持有的最大利润。
- `sell[j]`：表示到当前天为止，恰好进行 **j 次卖出** 操作后，手上不持有股票的最大利润。

遍历每一天的价格 `price`，然后对 `1` 到 `k` 的每一次交易进行状态更新：

- `buy[j] = max(之前的 buy[j], 之前的 sell[j-1] - price)`
  - 这个状态表示：要么维持前一天第 `j` 次买入的状态，要么在前一天第 `j-1` 次卖出的基础上，今天进行第 `j` 次买入。
- `sell[j] = max(之前的 sell[j], 之前的 buy[j] + price)`
  - 这个状态表示：要么维持前一天第 `j` 次卖出的状态，要么在前一天第 `j` 次买入的基础上，今天进行第 `j` 次卖出。

**优化:** 当 `k` 大于或等于 `prices.length / 2` 时，问题就退化成了可以进行无限次交易（买卖股票的最佳时机 II），因为在 `n` 天内最多只能进行 `n/2` 次交易。此时，我们可以使用一个更简单的贪心算法来解决。

```java
import java.util.Arrays;

public class Main {

    /**
     * 计算最多可以完成 k 笔交易的最大利润。
     *
     * @param k      最多交易次数。
     * @param prices 股票价格数组。
     * @return 最大利润。
     */
    public static int maxProfit(int k, int[] prices) {
        if (prices == null || prices.length < 2 || k == 0) {
            return 0;
        }

        int n = prices.length;

        // 特殊情况优化：如果 k 足够大，问题等价于无限次交易
        if (k >= n / 2) {
            int maxProfit = 0;
            for (int i = 1; i < n; i++) {
                if (prices[i] > prices[i - 1]) {
                    maxProfit += prices[i] - prices[i - 1];
                }
            }
            return maxProfit;
        }

        // buy[j]: 第 j 次买入后的最大利润
        // sell[j]: 第 j 次卖出后的最大利润
        int[] buy = new int[k + 1];
        int[] sell = new int[k + 1];

        // 初始化 buy 数组为一个极小值
        Arrays.fill(buy, Integer.MIN_VALUE);

        for (int price : prices) {
            for (int j = 1; j <= k; j++) {
                // 更新第 j 次买入的状态
                buy[j] = Math.max(buy[j], sell[j - 1] - price);
                // 更新第 j 次卖出的状态
                sell[j] = Math.max(sell[j], buy[j] + price);
            }
        }

        return sell[k];
    }


    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int k1 = 2;
        int[] prices1 = {2, 4, 1};
        System.out.println("输入: k = " + k1 + ", prices = " + Arrays.toString(prices1));
        int result1 = maxProfit(k1, prices1);
        System.out.println("输出: " + result1); // 预期输出: 2
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int k2 = 2;
        int[] prices2 = {3, 2, 6, 5, 0, 3};
        System.out.println("输入: k = " + k2 + ", prices = " + Arrays.toString(prices2));
        int result2 = maxProfit(k2, prices2);
        System.out.println("输出: " + result2); // 预期输出: 7
        System.out.println();
    }
}
```
