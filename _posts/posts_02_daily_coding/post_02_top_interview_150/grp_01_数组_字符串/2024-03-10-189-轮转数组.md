---
title: 189. 轮转数组
date: 2024-03-10 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数组_字符串]
tags: [数组_字符串]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121222210666.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**示例 1:**

- **输入:** `nums = [1,2,3,4,5,6,7], k = 3`
- **输出:** `[5,6,7,1,2,3,4]`
- **解释:**

  向右轮转 1 步: `[7,1,2,3,4,5,6]`

  向右轮转 2 步: `[6,7,1,2,3,4,5]`

  向右轮转 3 步: `[5,6,7,1,2,3,4]`

**示例 2:**

- **输入:** `nums = [-1,-100,3,99], k = 2`
- **输出:** `[3,99,-1,-100]`
- **解释:**

  向右轮转 1 步: `[99,-1,-100,3]`

  向右轮转 2 步: `[3,99,-1,-100]`

**提示:**

- `1 <= nums.length <= 10^5`
- `-2^31 <= nums[i] <= 2^31 - 1`
- `0 <= k <= 10^5`

**进阶:**

- 尽可能想出更多的解决方案，至少有 **三种** 不同的方法可以解决这个问题。
- 你可以使用空间复杂度为 `O(1)` 的 **原地** 算法解决这个问题吗？

## 题解

### 解法一：使用额外数组

**思路：**

这是最直观的方法。我们可以创建一个新的数组 `newArr`，其长度与原数组相同。

遍历原数组，将原数组下标为 `i` 的元素放置在新数组下标为 `(i + k) % n` 的位置。

最后，将新数组的所有元素复制回原数组。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是数组的长度。
- **空间复杂度：** $O(n)$，我们需要创建一个额外的数组来存储结果。

**代码片段：**

```java
public void rotate(int[] nums, int k) {
    int n = nums.length;
    k = k % n; // 防止 k 大于数组长度
    int[] newArr = new int[n];

    for (int i = 0; i < n; ++i) {
        newArr[(i + k) % n] = nums[i];
    }

    // 将新数组拷贝回原数组
    System.arraycopy(newArr, 0, nums, 0, n);
}
```

### 解法二：环状替换 (原地算法)

**思路：**

如果我们想原地完成，可以模拟元素移动的过程。

1.  从位置 `0` 开始，将 `nums[0]` 移动到 `(0 + k) % n`。
2.  将被替换的元素保存在临时变量中，继续移动到下一个位置，直到回到起点。
3.  如果回到起点时还有元素未移动（当 `n` 和 `k` 的最大公约数不为 1 时会发生这种情况），则从下一个位置（`start + 1`）开始重复上述过程。
4.  我们可以用一个计数器 `count` 来记录已经移动过的元素数量，当 `count == n` 时结束。

**复杂度分析：**

- **时间复杂度：** $O(n)$，每个元素只会被访问一次。
- **空间复杂度：** $O(1)$，不需要额外数组，只需要常数个变量。

**代码片段：**

```java
public void rotate(int[] nums, int k) {
    int n = nums.length;
    k = k % n;
    int count = 0; // 记录交换了多少个元素

    for (int start = 0; count < n; start++) {
        int current = start;
        int prev = nums[start];
        do {
            int next = (current + k) % n;
            int temp = nums[next];
            nums[next] = prev;
            prev = temp;
            current = next;
            count++;
        } while (start != current);
    }
}
```

### 解法三：数组翻转 (推荐解法)

**思路：**

这是一个非常巧妙的解法，基于观察规律得出。我们可以通过三次翻转来实现旋转：

1.  首先，**翻转整个数组**。
2.  然后，**翻转前 k 个元素**。
3.  最后，**翻转剩余的 n - k 个元素**。

例如：`nums = [1, 2, 3, 4, 5, 6, 7]`, `k = 3`

1.  整体翻转：`[7, 6, 5, 4, 3, 2, 1]`
2.  翻转前 3 个 (`7, 6, 5`)：`[5, 6, 7, 4, 3, 2, 1]`
3.  翻转后 4 个 (`4, 3, 2, 1`)：`[5, 6, 7, 1, 2, 3, 4]` -> 结果正确。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是数组的长度。三个翻转操作总共遍历数组 2 次。
- **空间复杂度：** $O(1)$，原地修改，仅使用常数级额外空间。

**代码片段：**

```java
public void rotate(int[] nums, int k) {
    int n = nums.length;
    k %= n; // 这是一个防御性编程，防止 k > n

    reverse(nums, 0, n - 1);     // 1. 翻转全部
    reverse(nums, 0, k - 1);     // 2. 翻转前 k 个
    reverse(nums, k, n - 1);     // 3. 翻转剩余部分
}

// 辅助函数：翻转数组中指定范围的元素
private void reverse(int[] nums, int start, int end) {
    while (start < end) {
        int temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
        start++;
        end--;
    }
}
```

### 完整代码

这里展示最常用且容易实现的**解法三（数组翻转法）**。

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现：数组翻转法
    public static void rotate(int[] nums, int k) {
        int n = nums.length;
        // 如果 k 大于数组长度，取模处理
        k %= n;

        // 步骤 1: 翻转整个数组
        reverse(nums, 0, n - 1);
        // 步骤 2: 翻转前 k 个元素
        reverse(nums, 0, k - 1);
        // 步骤 3: 翻转剩余元素
        reverse(nums, k, n - 1);
    }

    // 双指针翻转辅助函数
    private static void reverse(int[] nums, int start, int end) {
        while (start < end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        }
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1 = new int[]{1, 2, 3, 4, 5, 6, 7};
        int k1 = 3;

        System.out.println("示例 1 输入:");
        System.out.println("nums = " + Arrays.toString(nums1) + ", k = " + k1);

        rotate(nums1, k1);

        System.out.println("示例 1 输出: " + Arrays.toString(nums1));
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums2 = new int[]{-1, -100, 3, 99};
        int k2 = 2;

        System.out.println("示例 2 输入:");
        System.out.println("nums = " + Arrays.toString(nums2) + ", k = " + k2);

        rotate(nums2, k2);

        System.out.println("示例 2 输出: " + Arrays.toString(nums2));
    }
}
```
