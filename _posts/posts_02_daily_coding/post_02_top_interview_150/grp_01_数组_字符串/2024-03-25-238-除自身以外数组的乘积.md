---
title: 238. 除自身以外数组的乘积
date: 2024-03-25 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数组_字符串]
tags: [数组_字符串]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121222720953.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。

请 **不要使用除法**，且在 `O(n)` 时间复杂度内完成此题。

**示例 1:**

- **输入:** `nums = [1,2,3,4]`
- **输出:** `[24,12,8,6]`

**示例 2:**

- **输入:** `nums = [-1,1,0,-3,3]`
- **输出:** `[0,0,9,0,0]`

**提示:**

- `2 <= nums.length <= 10^5`
- `-30 <= nums[i] <= 30`
- 输入 **保证** 数组 `answer[i]` 在 **32 位** 整数范围内

**进阶：** 你可以在 `O(1)` 的额外空间复杂度内完成这个题目吗？（出于对空间复杂度分析的目的，输出数组 **不被视为** 额外空间。）

## 题解

### 标准解法：左右乘积列表

**思路：**

题目要求不能使用除法，因此我们不能先算出所有元素的乘积再除以当前元素。我们可以将问题转化为：`answer[i]` 等于 `i` 左侧所有元素的乘积乘以 `i` 右侧所有元素的乘积。

1.  初始化两个数组 `L` 和 `R`。
2.  `L[i]` 表示索引 `i` 左侧所有元素的乘积。对于索引 `0`，其左侧没有元素，初始化为 `1`。

    - 递推公式：`L[i] = L[i-1] * nums[i-1]`。

3.  `R[i]` 表示索引 `i` 右侧所有元素的乘积。对于索引 `n-1`，其右侧没有元素，初始化为 `1`。

    - 递推公式：`R[i] = R[i+1] * nums[i+1]`。

4.  最终结果 `answer[i] = L[i] * R[i]`。

**复杂度分析：**

- **时间复杂度：** $O(n)$，我们需要遍历数组三次（计算 L，计算 R，计算结果）。
- **空间复杂度：** $O(n)$，需要创建两个长度为 $n$ 的辅助数组 `L` 和 `R`。

**代码片段：**

```java
public int[] productExceptSelf(int[] nums) {
    int length = nums.length;
    int[] L = new int[length];
    int[] R = new int[length];
    int[] answer = new int[length];

    // L[i] 为索引 i 左侧所有元素的乘积
    L[0] = 1;
    for (int i = 1; i < length; i++) {
        L[i] = nums[i - 1] * L[i - 1];
    }

    // R[i] 为索引 i 右侧所有元素的乘积
    R[length - 1] = 1;
    for (int i = length - 2; i >= 0; i--) {
        R[i] = nums[i + 1] * R[i + 1];
    }

    // 构造最终结果
    for (int i = 0; i < length; i++) {
        answer[i] = L[i] * R[i];
    }

    return answer;
}
```

### 进阶解法：空间优化 ($O(1)$ 空间)

**思路：**

题目提示输出数组不视为额外空间。我们可以直接利用 `answer` 数组来充当 `L` 数组，然后用一个变量动态维护右侧乘积 `R`，从而省去 `L` 和 `R` 的额外空间开销。

1.  **第一遍遍历**：从左到右，在 `answer` 数组中计算前缀乘积。
    - `answer[i]` 存储 `i` 左侧所有元素的乘积（同标准解法中的 `L`）。
2.  **第二遍遍历**：从右到左，使用一个变量 `R` 维护后缀乘积。

    - 初始化 `R = 1`。
    - 对于每个 `i`，`answer[i]` 目前已经是前缀乘积了，只需要 `answer[i] = answer[i] * R`。
    - 更新 `R`：`R = R * nums[i]`，为下一个位置做准备。

**复杂度分析：**

- **时间复杂度：** $O(n)$，遍历数组两次。
- **空间复杂度：** $O(1)$，除了返回的数组外，只使用了常数级别的变量。

**代码片段：**

```java
public int[] productExceptSelf(int[] nums) {
    int length = nums.length;
    int[] answer = new int[length];

    // answer[i] 表示索引 i 左侧所有元素的乘积
    // 因为索引 0 左侧没有元素，所以 answer[0] = 1
    answer[0] = 1;
    for (int i = 1; i < length; i++) {
        answer[i] = answer[i - 1] * nums[i - 1];
    }

    // R 为右侧所有元素的乘积
    // 刚开始右边没有元素，所以 R = 1
    int R = 1;
    for (int i = length - 1; i >= 0; i--) {
        // 对于索引 i，左边的乘积是 answer[i]，右边的乘积是 R
        answer[i] = answer[i] * R;
        // 更新 R，包含当前元素 nums[i]
        R *= nums[i];
    }

    return answer;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现（进阶优化版）
    public static int[] productExceptSelf(int[] nums) {
        int length = nums.length;
        int[] answer = new int[length];

        // 1. 先计算左侧乘积，存入 answer
        answer[0] = 1;
        for (int i = 1; i < length; i++) {
            answer[i] = answer[i - 1] * nums[i - 1];
        }

        // 2. 动态计算右侧乘积并更新 answer
        int R = 1;
        for (int i = length - 1; i >= 0; i--) {
            answer[i] = answer[i] * R;
            R *= nums[i];
        }

        return answer;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1 = new int[]{1, 2, 3, 4};

        System.out.println("示例 1 输入:");
        System.out.println("nums = " + Arrays.toString(nums1));

        int[] result1 = productExceptSelf(nums1);

        System.out.println("示例 1 输出: " + Arrays.toString(result1));
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums2 = new int[]{-1, 1, 0, -3, 3};

        System.out.println("示例 2 输入:");
        System.out.println("nums = " + Arrays.toString(nums2));

        int[] result2 = productExceptSelf(nums2);

        System.out.println("示例 2 输出: " + Arrays.toString(result2));
    }
}
```
