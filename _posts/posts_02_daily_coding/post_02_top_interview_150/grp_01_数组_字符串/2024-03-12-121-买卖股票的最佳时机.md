---
title: 121. 买卖股票的最佳时机
date: 2024-03-12 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数组_字符串]
tags: [数组_字符串]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121222303119.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

**示例 1:**

- **输入:** `[7,1,5,3,6,4]`
- **输出:** 5
- **解释:** 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

**示例 2:**

- **输入:** `prices = [7,6,4,3,1]`
- **输出:** 0
- **解释:** 在这种情况下, 没有交易完成, 所以最大利润为 0。

**提示:**

- `1 <= prices.length <= 10^5`
- `0 <= prices[i] <= 10^4`

## 题解

### 解法一：暴力法

**思路：**

最简单的思维方式是计算每一对可能买卖组合的利润，然后找出最大值。

我们需要两层循环：

1.  外层循环 `i` 表示买入的那一天（从 `0` 到 `n-2`）。
2.  内层循环 `j` 表示卖出的那一天（从 `i+1` 到 `n-1`）。
3.  计算 `prices[j] - prices[i]`，如果大于当前的 `maxProfit`，则更新。

**复杂度分析：**

- **时间复杂度：** $O(n^2)$。如果有 $n$ 个元素，我们需要进行 $n(n-1)/2$ 次比较。对于题目给定的 $10^5$ 数据规模，这种解法会超时（Time Limit Exceeded）。
- **空间复杂度：** $O(1)$。只使用了常数个变量。

**代码片段：**

```java
public int maxProfit(int[] prices) {
    int maxProfit = 0;
    for (int i = 0; i < prices.length - 1; i++) {
        for (int j = i + 1; j < prices.length; j++) {
            int profit = prices[j] - prices[i];
            if (profit > maxProfit) {
                maxProfit = profit;
            }
        }
    }
    return maxProfit;
}
```

### 解法二：一次遍历（贪心 / 动态规划）

**思路：**

要在一天卖出股票获得最大利润，我们必须在**之前的某一天**以**最低价格**买入。

因此，我们在遍历数组时，只需要维护两个变量：

1.  `minPrice`：记录到当前位置为止的**历史最低价格**。
2.  `maxProfit`：记录到当前位置为止能获取的**最大利润**。

**具体步骤：**

1.  初始化 `minPrice` 为整型最大值（或者数组第一个元素），`maxProfit` 为 0。
2.  遍历数组：

    - 如果当前价格 `prices[i]` 小于 `minPrice`，则更新 `minPrice`。
    - 否则，如果 `prices[i] - minPrice` 大于 `maxProfit`，则更新 `maxProfit`。

3.  返回 `maxProfit`。

这种方法只需要遍历一次数组，就能找到最优解。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是数组的长度。只需要遍历一次。
- **空间复杂度：** $O(1)$，只使用了两个变量。

**代码片段：**

```java
public int maxProfit(int[] prices) {
    int minPrice = Integer.MAX_VALUE;
    int maxProfit = 0;

    for (int price : prices) {
        if (price < minPrice) {
            // 找到了更低的价格，更新最低价
            minPrice = price;
        } else if (price - minPrice > maxProfit) {
            // 如果当前价格卖出能获得更高利润，更新最大利润
            maxProfit = price - minPrice;
        }
    }
    return maxProfit;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现：一次遍历法
    public static int maxProfit(int[] prices) {
        int minPrice = Integer.MAX_VALUE;
        int maxProfit = 0;

        for (int price : prices) {
            if (price < minPrice) {
                // 此时买入更便宜，更新最低买入价
                minPrice = price;
            } else if (price - minPrice > maxProfit) {
                // 此时卖出更赚钱，更新最大利润
                maxProfit = price - minPrice;
            }
        }
        return maxProfit;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] prices1 = new int[]{7, 1, 5, 3, 6, 4};

        System.out.println("示例 1 输入:");
        System.out.println("prices = " + Arrays.toString(prices1));

        int result1 = maxProfit(prices1);

        System.out.println("示例 1 输出: " + result1);
        // 解释：在第 2 天（价格=1）买入，在第 5 天（价格=6）卖出，利润 = 5。
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] prices2 = new int[]{7, 6, 4, 3, 1};

        System.out.println("示例 2 输入:");
        System.out.println("prices = " + Arrays.toString(prices2));

        int result2 = maxProfit(prices2);

        System.out.println("示例 2 输出: " + result2);
        // 解释：价格持续下跌，找不到比买入价更高的卖出价，利润为 0。
    }
}
```
