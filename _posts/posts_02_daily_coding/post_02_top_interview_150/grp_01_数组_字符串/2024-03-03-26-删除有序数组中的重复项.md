---
title: 26. 删除有序数组中的重复项
date: 2024-03-03 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数组_字符串]
tags: [数组_字符串]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121221807305.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个 **非严格递增排列** 的数组 `nums` ，请你 **原地** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k`，去重后，返回 `k`。`nums` 的前 `k` 个元素应包含排序后的唯一数字。下标 `k-1` 之后的剩余元素可以忽略。

**判题标准：**

系统会用下面的代码来测试你的题解:

```java
int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

**示例 1:**

- **输入:** `nums = [1,1,2]`
- **输出:** `2`, `nums = [1,2,_]`
- **解释:** 函数应该返回新的长度 `2` ，并且原数组 `nums` 的前两个元素被修改为 `1, 2` 。不需要考虑数组中超出新长度后面的元素。

**示例 2:**

- **输入:** `nums = [0,0,1,1,1,2,2,3,3,4]`
- **输出:** `5`, `nums = [0,1,2,3,4,_,_,_,_,_]`
- **解释:** 函数应该返回新的长度 `5` ， 并且原数组 `nums` 的前五个元素被修改为 `0, 1, 2, 3, 4` 。

**提示:**

- `1 <= nums.length <= 3 * 10^4`
- `-100 <= nums[i] <= 100`
- `nums` 已按 **非递减** 顺序排列。

## 题解

### 解法：双指针法

**思路：**

由于数组已经按 **非严格递增**（即有序）排列，相同的元素一定是连续相邻的。我们可以利用双指针技巧，原地修改数组以删除重复项。

1.  定义两个指针：
    - **慢指针 (`slow`)**：指向当前已处理好的、不含重复元素的数组序列的末尾。
    - **快指针 (`fast`)**：用于遍历数组，寻找下一个与 `nums[slow]` 不同的元素。
2.  初始化 `slow = 0`，`fast = 1`。
3.  遍历数组（当 `fast < nums.length`）：
    - 如果 `nums[fast]` 与 `nums[slow]` **不相等**：说明找到了一个新的唯一元素。
      - 先将 `slow` 向后移动一位 (`slow++`)。
      - 将 `nums[fast]` 的值复制到 `nums[slow]` 位置。
    - 如果相等，则忽略（`fast` 继续后移）。
4.  遍历结束后，有效元素的下标范围是 `0` 到 `slow`，因此返回新长度 `slow + 1`。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是数组的长度。我们需要遍历整个数组一次。
- **空间复杂度：** $O(1)$，只需要常数级别的额外空间用于存储指针变量，原地修改。

**代码片段：**

```java
public int removeDuplicates(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }

    int slow = 0;
    // fast 从 1 开始，因为第 0 个元素肯定是不重复的起始点
    for (int fast = 1; fast < nums.length; fast++) {
        // 发现不同的元素
        if (nums[fast] != nums[slow]) {
            slow++;
            nums[slow] = nums[fast];
        }
    }
    // 返回长度，下标 + 1
    return slow + 1;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现
    public static int removeDuplicates(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int slow = 0;
        for (int fast = 1; fast < nums.length; fast++) {
            if (nums[fast] != nums[slow]) {
                slow++;
                nums[slow] = nums[fast];
            }
        }
        return slow + 1;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1 = new int[]{1, 1, 2};

        System.out.println("示例 1 输入:");
        System.out.println("nums = " + Arrays.toString(nums1));

        int k1 = removeDuplicates(nums1);

        // 截取有效部分打印
        int[] result1 = Arrays.copyOfRange(nums1, 0, k1);
        System.out.println("示例 1 输出: " + k1 + ", nums = " + Arrays.toString(result1));
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums2 = new int[]{0, 0, 1, 1, 1, 2, 2, 3, 3, 4};

        System.out.println("示例 2 输入:");
        System.out.println("nums = " + Arrays.toString(nums2));

        int k2 = removeDuplicates(nums2);

        int[] result2 = Arrays.copyOfRange(nums2, 0, k2);
        System.out.println("示例 2 输出: " + k2 + ", nums = " + Arrays.toString(result2));
    }
}
```
