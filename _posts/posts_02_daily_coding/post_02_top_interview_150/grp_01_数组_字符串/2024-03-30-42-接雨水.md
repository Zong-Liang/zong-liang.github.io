---
title: 42. 接雨水
date: 2024-03-30 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数组_字符串]
tags: [数组_字符串]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121223001450.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定 `n` 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1:**

- **输入:** `height = [0,1,0,2,1,0,1,3,2,1,2,1]`
- **输出:** 6
- **解释:** 上面是由数组 `[0,1,0,2,1,0,1,3,2,1,2,1]` 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

**示例 2:**

- **输入:** `height = [4,2,0,3,2,5]`
- **输出:** 9

**提示:**

- `n == height.length`
- `1 <= n <= 2 * 10^4`
- `0 <= height[i] <= 10^5`

## 题解

### 解法一：动态规划（按列求）

**思路：**

对于下标 `i` 处的柱子，它能接到的雨水高度，取决于它**左边**最高的柱子和**右边**最高的柱子中较矮的那一个。

具体公式为：`water[i] = min(maxLeft[i], maxRight[i]) - height[i]`。

如果结果为负数，说明当前柱子比两边都高，存不了水（或者取 0）。

为了避免在每个位置都向左向右遍历（会导致 $O(n^2)$），我们可以通过**动态规划**预处理出两个数组：

1.  `leftMax[i]`：表示下标 `i` 及其左边所有柱子的最大高度。
2.  `rightMax[i]`：表示下标 `i` 及其右边所有柱子的最大高度。

**复杂度分析：**

- **时间复杂度：** $O(n)$，需要遍历三次数组（计算左最大、计算右最大、计算结果）。
- **空间复杂度：** $O(n)$，需要两个额外的数组 `leftMax` 和 `rightMax`。

**代码片段：**

```java
public int trap(int[] height) {
    int n = height.length;
    if (n == 0) return 0;

    int[] leftMax = new int[n];
    leftMax[0] = height[0];
    for (int i = 1; i < n; i++) {
        leftMax[i] = Math.max(leftMax[i - 1], height[i]);
    }

    int[] rightMax = new int[n];
    rightMax[n - 1] = height[n - 1];
    for (int i = n - 2; i >= 0; i--) {
        rightMax[i] = Math.max(rightMax[i + 1], height[i]);
    }

    int ans = 0;
    for (int i = 0; i < n; i++) {
        ans += Math.min(leftMax[i], rightMax[i]) - height[i];
    }
    return ans;
}
```

### 解法二：双指针法（空间优化）

**思路：**

这是对动态规划解法的空间优化。

在动态规划中，我们发现对于位置 `i`，我们只需要 `min(leftMax[i], rightMax[i])`。

我们可以使用双指针 `left` 和 `right` 从两头向中间移动：

1.  维护两个变量 `leftMax` 和 `rightMax`，分别表示左指针左边的最大高度和右指针右边的最大高度。
2.  在移动指针时：

    - 如果 `height[left] < height[right]`：说明左边的柱子较矮，瓶颈在左边。此时 `leftMax` 一定小于 `rightMax`（或者是当前考察的右侧某个值，总之左侧是短板）。因此下标 `left` 处的雨水量可以直接由 `leftMax - height[left]` 计算。计算后 `left` 右移。
    - 如果 `height[left] >= height[right]`：说明右边的柱子较矮（或相等），瓶颈在右边。下标 `right` 处的雨水量由 `rightMax - height[right]` 计算。计算后 `right` 左移。

**复杂度分析：**

- **时间复杂度：** $O(n)$，只需要遍历一次数组。
- **空间复杂度：** $O(1)$，只使用了常数个变量。

**代码片段：**

```java
public int trap(int[] height) {
    int left = 0, right = height.length - 1;
    int leftMax = 0, rightMax = 0;
    int ans = 0;

    while (left < right) {
        leftMax = Math.max(leftMax, height[left]);
        rightMax = Math.max(rightMax, height[right]);

        // 哪边矮，哪边就是瓶颈，先处理哪边
        if (height[left] < height[right]) {
            ans += leftMax - height[left];
            left++;
        } else {
            ans += rightMax - height[right];
            right--;
        }
    }
    return ans;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现：双指针法（最优解）
    public static int trap(int[] height) {
        if (height == null || height.length == 0) {
            return 0;
        }

        int left = 0;
        int right = height.length - 1;
        int leftMax = 0;
        int rightMax = 0;
        int ans = 0;

        while (left < right) {
            // 更新当前左右指针遇到的最大高度
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);

            // 木桶原理：接水取决于短板
            // 如果左边的高度小于右边，说明对于 left 位置来说，右边一定有比 leftMax 更高的挡板
            // 所以 left 位置能接的水量完全由 leftMax 决定
            if (height[left] < height[right]) {
                ans += leftMax - height[left];
                left++;
            } else {
                // 同理，如果右边较矮，right 位置的水量由 rightMax 决定
                ans += rightMax - height[right];
                right--;
            }
        }
        return ans;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] height1 = new int[]{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};

        System.out.println("示例 1 输入:");
        System.out.println("height = " + Arrays.toString(height1));

        int result1 = trap(height1);

        System.out.println("示例 1 输出: " + result1);
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] height2 = new int[]{4, 2, 0, 3, 2, 5};

        System.out.println("示例 2 输入:");
        System.out.println("height = " + Arrays.toString(height2));

        int result2 = trap(height2);

        System.out.println("示例 2 输出: " + result2);
    }
}
```
