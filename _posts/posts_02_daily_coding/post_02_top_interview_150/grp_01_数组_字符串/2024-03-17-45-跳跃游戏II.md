---
title: 45. 跳跃游戏II
date: 2024-03-17 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数组_字符串]
tags: [数组_字符串]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121222508362.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个长度为 `n` 的 **0 索引** 整数数组 `nums`。初始位置在下标 0。

每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在索引 `i` 处，你可以跳转到任意 `(i + j)` 处:

- `0 <= j <= nums[i]` 且
- `i + j < n`

返回到达 `n - 1` 的最小跳跃次数。测试用例保证可以到达 `n - 1`。

**示例 1:**

- **输入:** `nums = [2,3,1,1,4]`
- **输出:** 2
- **解释:** 跳到最后一个位置的最小跳跃数是 2。从下标 0 跳到下标 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

**示例 2:**

- **输入:** `nums = [2,3,0,1,4]`
- **输出:** 2

**提示:**

- `1 <= nums.length <= 10^4`
- `0 <= nums[i] <= 1000`
- 题目保证可以到达 `n - 1`

## 题解

### 解法：贪心算法

**思路：**

与“跳跃游戏 I”不同，本题保证了**一定能到达**终点，目标是求**最小**跳跃次数。

我们需要统计两个变量：

1.  **当前覆盖的最远距离 (`end`)**：表示在当前步数下，能到达的最远右边界。
2.  **下一步能到达的最远距离 (`maxPosition`)**：在当前覆盖范围内遍历时，记录下一步能跳到的最远位置。

**具体逻辑：**

我们遍历数组（注意：不需要遍历最后一个元素，因为我们是从起点跳到终点，一旦到达终点就不需要再跳了）。

- 在遍历过程中，不断计算并更新 `maxPosition = Math.max(maxPosition, i + nums[i])`。
- 当遍历索引 `i` 到达了当前的边界 `end` 时：

  - 说明这一步的潜力已经耗尽，必须进行下一次跳跃了。
  - **跳跃次数 +1**。
  - 更新 `end` 为 `maxPosition`（即把下一次跳跃的起跳范围更新为刚才找到的最远距离）。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是数组的长度。我们只需要遍历数组一次。
- **空间复杂度：** $O(1)$，不需要额外的存储空间。

**代码片段：**

```java
public int jump(int[] nums) {
    int end = 0;
    int maxPosition = 0;
    int steps = 0;

    // 注意：这里是 i < nums.length - 1
    // 因为若是已经到了最后一个位置，就不需要再跳了
    for (int i = 0; i < nums.length - 1; i++) {
        // 找能跳的最远的位置
        maxPosition = Math.max(maxPosition, i + nums[i]);

        // 遇到边界，就更新边界，并且步数加一
        if (i == end) {
            end = maxPosition;
            steps++;
        }
    }
    return steps;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现：贪心算法
    public static int jump(int[] nums) {
        // 记录当前跳跃步数能到达的最远边界
        int end = 0;
        // 记录在当前边界内，下一步能到达的最远位置
        int maxPosition = 0;
        int steps = 0;

        // 遍历数组，注意不需要访问最后一个元素
        // 因为当我们到达最后一个元素时，不需要再进行跳跃
        for (int i = 0; i < nums.length - 1; i++) {
            // 更新下一步能跳到的最远距离
            maxPosition = Math.max(maxPosition, i + nums[i]);

            // 如果遍历到了当前步数的边界
            if (i == end) {
                // 更新边界为刚才找到的最远位置
                end = maxPosition;
                // 增加跳跃次数
                steps++;
            }
        }
        return steps;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1 = new int[]{2, 3, 1, 1, 4};

        System.out.println("示例 1 输入:");
        System.out.println("nums = " + Arrays.toString(nums1));

        int result1 = jump(nums1);

        System.out.println("示例 1 输出: " + result1);
        // 解释: 0->1 (跳1步), 1->4 (跳3步)，共2步。
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums2 = new int[]{2, 3, 0, 1, 4};

        System.out.println("示例 2 输入:");
        System.out.println("nums = " + Arrays.toString(nums2));

        int result2 = jump(nums2);

        System.out.println("示例 2 输出: " + result2);
    }
}
```
