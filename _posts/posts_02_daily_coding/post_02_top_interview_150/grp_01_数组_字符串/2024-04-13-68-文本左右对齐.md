---
title: 68. 文本左右对齐
date: 2024-04-13 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数组_字符串]
tags: [数组_字符串]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121223609058.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个单词数组 `words` 和一个长度 `maxWidth` ，重新排版单词，使其成为每行恰好有 `maxWidth` 个字符，且左右两端对齐的文本。

你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 `' '` 填充，使得每行恰好有 `maxWidth` 个字符。

要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。

文本的最后一行应为左对齐，且单词之间不插入额外的空格。

**注意：**

- 单词是指由非空格字符组成的字符序列。
- 每个单词的长度大于 0，小于等于 `maxWidth`。
- 输入单词数组 `words` 至少包含一个单词。

**示例 1:**

- **输入:** `words = ["This", "is", "an", "example", "of", "text", "justification."], maxWidth = 16`
- **输出:**
  ```
  [
     "This    is    an",
     "example  of text",
     "justification.  "
  ]
  ```

**示例 2:**

- **输入:** `words = ["What","must","be","acknowledgment","shall","be"], maxWidth = 16`
- **输出:**
  ```
  [
    "What   must   be",
    "acknowledgment  ",
    "shall be        "
  ]
  ```
- **解释:** 注意最后一行和只包含一个单词的行的格式。

**示例 3:**

- **输入:** `words = ["Science","is","what","we","understand","well","enough","to","explain","to","a","computer.","Art","is","everything","else","we","do"], maxWidth = 20`
- **输出:**
  ```
  [
    "Science  is  what we",
    "understand      well",
    "enough to explain to",
    "a  computer.  Art is",
    "everything  else  we",
    "do                  "
  ]
  ```

**提示：**

- `1 <= words.length <= 300`
- `1 <= words[i].length <= 20`
- `words[i]` 由小写英文字母和符号组成
- `1 <= maxWidth <= 100`
- `words[i].length <= maxWidth`

## 题解

### 解法：贪心 + 模拟

**思路：**

这是一个纯粹的字符串模拟题目，核心逻辑在于**贪心**地选取每一行能放下的单词，然后根据题目规则**计算空格**进行填充。可以将过程分解为三个步骤：

1.  **确定当前行能放哪些单词**：

    - 使用指针 `i` 遍历单词数组。
    - 尝试尽可能多地向当前行添加单词。判断条件是：`当前行已有长度 + 1个空格 + 下一个单词长度 <= maxWidth`。

2.  **计算空格分配**：

    - 一旦确定了当前行的单词范围 `[left, right)`，计算这一行所有单词的总字符长度 `sumLen`。
    - 总共需要的空格数 `totalSpaces = maxWidth - sumLen`。
    - 单词之间的间隔数 `gaps = (right - left) - 1`。

3.  **构造字符串（分情况讨论）**：

    - **情况一：最后一行** 或 **该行只有一个单词**。

      - **规则**：左对齐。单词之间用一个空格隔开，行尾填充剩余空格直 `maxWidth`。

    - **情况二：普通行（左右对齐）**。

      - **规则**：空格需要均匀分配。
      - 平均每个间隔的空格数 `avgSpaces = totalSpaces / gaps`。
      - 多余的空格数 `extraSpaces = totalSpaces % gaps`。
      - 前 `extraSpaces` 个间隔每个分配 `avgSpaces + 1` 个空格，剩余的间隔分配 `avgSpaces` 个空格。

**复杂度分析：**

- **时间复杂度：** $O(N)$，其中 $N$ 是所有单词字符的总长度。我们需要遍历所有单词，并且构建结果字符串。
- **空间复杂度：** $O(M)$，其中 $M$ 是结果列表的字符总数（即 $words.length \times maxWidth$）。除了存储结果，我们只需要常数级的辅助变量。

**代码片段：**

```java
public List<String> fullJustify(String[] words, int maxWidth) {
    List<String> res = new ArrayList<>();
    int n = words.length;
    int i = 0;

    while (i < n) {
        // 1. 确定当前行包含哪些单词
        int left = i;
        int lineLen = 0; // 当前行单纯单词加最少空格的长度

        while (i < n) {
            // 如果是该行第一个单词，不需要前置空格；否则需要 1 个空格
            int newLen = lineLen + words[i].length() + (lineLen > 0 ? 1 : 0);
            if (newLen > maxWidth) break;
            lineLen = newLen;
            i++;
        }

        int right = i; // 当前行的单词范围是 [left, right)
        int numWords = right - left;
        int gaps = numWords - 1;

        StringBuilder sb = new StringBuilder();

        // 2. 分情况构造字符串
        // 如果是最后一行，或者该行只有一个单词 -> 左对齐
        if (right == n || numWords == 1) {
            for (int j = left; j < right; j++) {
                sb.append(words[j]);
                // 单词之间补 1 个空格（最后一个单词除外）
                if (j < right - 1) sb.append(" ");
            }
            // 剩余部分补足空格
            while (sb.length() < maxWidth) sb.append(" ");
        } else {
            // 左右对齐
            int totalWordLen = 0;
            for (int j = left; j < right; j++) totalWordLen += words[j].length();

            int totalSpaces = maxWidth - totalWordLen;
            int avgSpaces = totalSpaces / gaps;
            int extraSpaces = totalSpaces % gaps;

            for (int j = left; j < right - 1; j++) {
                sb.append(words[j]);
                // 基础空格
                for (int k = 0; k < avgSpaces; k++) sb.append(" ");
                // 额外空格（分配给左边的空隙）
                if (j - left < extraSpaces) sb.append(" ");
            }
            sb.append(words[right - 1]); // 最后一个单词不需要后置空格
        }

        res.add(sb.toString());
    }
    return res;
}
```

### 完整代码

```java
import java.util.ArrayList;
import java.util.List;

public class Main {

    // 核心算法实现
    public static List<String> fullJustify(String[] words, int maxWidth) {
        List<String> res = new ArrayList<>();
        int n = words.length;
        int i = 0; // 当前处理到的单词索引

        while (i < n) {
            // --- 步骤 1: 贪心选取单词 ---
            int left = i; // 当前行起始单词索引
            int lineLen = 0; // 记录单词长度 + 必要的单个空格

            while (i < n) {
                // 计算加入下一个单词后的长度：当前累积 + 单词长度 + (如果不是第一个单词 ? 1 : 0)
                int nextLen = lineLen + words[i].length() + (lineLen > 0 ? 1 : 0);
                if (nextLen > maxWidth) {
                    break; // 放不下了，结束当前行
                }
                lineLen = nextLen;
                i++;
            }
            // 当前行的单词范围是 words[left ... i-1]
            int right = i;
            int numWords = right - left;
            int gaps = numWords - 1; // 间隙数量

            StringBuilder sb = new StringBuilder();

            // --- 步骤 2: 生成行内容 ---
            // 情况 A: 最后一行 或者 单个单词的行 -> 左对齐
            if (right == n || numWords == 1) {
                for (int j = left; j < right; j++) {
                    sb.append(words[j]);
                    // 单词之间只加一个空格，最后一个单词后面不加
                    if (j < right - 1) {
                        sb.append(" ");
                    }
                }
                // 右侧填充满空格
                while (sb.length() < maxWidth) {
                    sb.append(" ");
                }
            }
            // 情况 B: 普通行 -> 左右对齐 (均匀分配空格)
            else {
                // 计算单纯单词的总长度
                int wordsTotalLen = 0;
                for (int j = left; j < right; j++) {
                    wordsTotalLen += words[j].length();
                }

                int totalSpaces = maxWidth - wordsTotalLen;
                int avgSpaces = totalSpaces / gaps;
                int extraSpaces = totalSpaces % gaps; // 需要多分配一个空格的间隙数量

                for (int j = left; j < right - 1; j++) {
                    sb.append(words[j]);

                    // 填充平均空格
                    for (int k = 0; k < avgSpaces; k++) {
                        sb.append(" ");
                    }
                    // 填充额外空格（贪心分配给左侧）
                    if (j - left < extraSpaces) {
                        sb.append(" ");
                    }
                }
                sb.append(words[right - 1]); // 添加该行最后一个单词
            }

            res.add(sb.toString());
        }

        return res;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        String[] words1 = {"This", "is", "an", "example", "of", "text", "justification."};
        int maxWidth1 = 16;

        System.out.println("示例 1 输出:");
        printResult(fullJustify(words1, maxWidth1));
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        String[] words2 = {"What","must","be","acknowledgment","shall","be"};
        int maxWidth2 = 16;

        System.out.println("示例 2 输出:");
        printResult(fullJustify(words2, maxWidth2));
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        String[] words3 = {"Science","is","what","we","understand","well","enough","to","explain","to","a","computer.","Art","is","everything","else","we","do"};
        int maxWidth3 = 20;

        System.out.println("示例 3 输出:");
        printResult(fullJustify(words3, maxWidth3));
    }

    // 辅助打印方法
    private static void printResult(List<String> result) {
        for (String line : result) {
            System.out.println("\"" + line + "\"");
        }
    }
}
```
