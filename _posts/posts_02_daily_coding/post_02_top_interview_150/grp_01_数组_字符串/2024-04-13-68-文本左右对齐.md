---
title: 68. 文本左右对齐
date: 2024-04-13 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数组_字符串]
tags: [数组_字符串]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121223609058.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：68. 文本左右对齐

**描述**

给定一个单词数组 `words` 和一个长度 `maxWidth` ，重新排版单词，使其成为每行恰好有 `maxWidth` 个字符，且左右两端对齐的文本。

你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 `' '` 填充，使得每行恰好有 `maxWidth` 个字符。

要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。

文本的最后一行应为左对齐，且单词之间不插入额外的空格。

**注意：**

- 单词是指由非空格字符组成的字符序列。
- 每个单词的长度大于 0，小于等于 `maxWidth`。
- 输入单词数组 `words` 至少包含一个单词。

**示例 1:**

- **输入:** `words = ["This", "is", "an", "example", "of", "text", "justification."], maxWidth = 16`
- **输出:**
  ```
  [
     "This    is    an",
     "example  of text",
     "justification.  "
  ]
  ```

**示例 2:**

- **输入:** `words = ["What","must","be","acknowledgment","shall","be"], maxWidth = 16`
- **输出:**
  ```
  [
    "What   must   be",
    "acknowledgment  ",
    "shall be        "
  ]
  ```
- **解释:** 注意最后一行和只包含一个单词的行的格式。

**示例 3:**

- **输入:** `words = ["Science","is","what","we","understand","well","enough","to","explain","to","a","computer.","Art","is","everything","else","we","do"], maxWidth = 20`
- **输出:**
  ```
  [
    "Science  is  what we",
    "understand      well",
    "enough to explain to",
    "a  computer.  Art is",
    "everything  else  we",
    "do                  "
  ]
  ```

**提示：**

- `1 <= words.length <= 300`
- `1 <= words[i].length <= 20`
- `words[i]` 由小写英文字母和符号组成
- `1 <= maxWidth <= 100`
- `words[i].length <= maxWidth`

## Java 代码

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Main {

    /**
     * 将单词数组重新排版为左右对齐的文本。
     *
     * @param words     单词数组
     * @param maxWidth  每行的最大宽度
     * @return 排版后的文本行列表
     */
    public static List<String> fullJustify(String[] words, int maxWidth) {
        List<String> result = new ArrayList<>();
        int i = 0;
        int n = words.length;

        while (i < n) {
            // 1. 确定当前行可以放下的单词
            List<String> currentLineWords = new ArrayList<>();
            int currentLength = 0; // 当前行单词的总长度
            int startIndex = i;

            // 贪心选择单词
            while (i < n && currentLength + words[i].length() + (currentLineWords.size()) <= maxWidth) {
                currentLineWords.add(words[i]);
                currentLength += words[i].length();
                i++;
            }

            StringBuilder sb = new StringBuilder();

            // 2. 判断是最后一行或只有单个单词的行
            if (i == n || currentLineWords.size() == 1) {
                // 左对齐处理
                for (int j = 0; j < currentLineWords.size(); j++) {
                    sb.append(currentLineWords.get(j));
                    if (j < currentLineWords.size() - 1) {
                        sb.append(" ");
                    }
                }
                // 补齐末尾的空格
                while (sb.length() < maxWidth) {
                    sb.append(" ");
                }
            } else {
                // 3. 正常情况，需要左右对齐
                int totalSpaces = maxWidth - currentLength;
                int numGaps = currentLineWords.size() - 1;

                int baseSpaces = totalSpaces / numGaps; // 每个间隔至少有多少个空格
                int extraSpaces = totalSpaces % numGaps; // 多余的空格数，要从左到右分配

                for (int j = 0; j < currentLineWords.size(); j++) {
                    sb.append(currentLineWords.get(j));
                    if (j < numGaps) { // 不是最后一个单词
                        // 添加基础空格
                        for (int k = 0; k < baseSpaces; k++) {
                            sb.append(" ");
                        }
                        // 添加额外空格
                        if (extraSpaces > 0) {
                            sb.append(" ");
                            extraSpaces--;
                        }
                    }
                }
            }
            result.add(sb.toString());
        }
        return result;
    }

    public static void main(String[] args) {
        // 示例 1
        String[] words1 = {"This", "is", "an", "example", "of", "text", "justification."};
        int maxWidth1 = 16;
        System.out.println("示例 1 输入:");
        System.out.println("words = " + Arrays.toString(words1) + ", maxWidth = " + maxWidth1);
        System.out.println("输出:");
        fullJustify(words1, maxWidth1).forEach(line -> System.out.println("\"" + line + "\""));
        System.out.println("---");

        // 示例 2
        String[] words2 = {"What", "must", "be", "acknowledgment", "shall", "be"};
        int maxWidth2 = 16;
        System.out.println("示例 2 输入:");
        System.out.println("words = " + Arrays.toString(words2) + ", maxWidth = " + maxWidth2);
        System.out.println("输出:");
        fullJustify(words2, maxWidth2).forEach(line -> System.out.println("\"" + line + "\""));
        System.out.println("---");

        // 示例 3
        String[] words3 = {"Science", "is", "what", "we", "understand", "well", "enough", "to", "explain", "to", "a", "computer.", "Art", "is", "everything", "else", "we", "do"};
        int maxWidth3 = 20;
        System.out.println("示例 3 输入:");
        System.out.println("words = " + Arrays.toString(words3) + ", maxWidth = " + maxWidth3);
        System.out.println("输出:");
        fullJustify(words3, maxWidth3).forEach(line -> System.out.println("\"" + line + "\""));
        System.out.println("---");
    }
}
```
