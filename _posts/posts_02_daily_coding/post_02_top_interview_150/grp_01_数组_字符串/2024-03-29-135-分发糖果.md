---
title: 135. 分发糖果
date: 2024-03-29 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数组_字符串]
tags: [数组_字符串]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121222832730.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 1 个糖果。
- 相邻两个孩子中，评分更高的那个会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

**示例 1:**

- **输入:** `ratings = [1,0,2]`
- **输出:** 5
- **解释:** 你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。

**示例 2:**

- **输入:** `ratings = [1,2,2]`
- **输出:** 4
- **解释:** 你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。

**提示:**

- `n == ratings.length`
- `1 <= n <= 2 * 10^4`
- `0 <= ratings[i] <= 2 * 10^4`

## 题解

### 解法：贪心算法（两次遍历）

**思路：**

题目要求“相邻的孩子中，评分高的获得更多糖果”，这实际上包含两个规则：

1.  **左规则**：如果当前孩子 `i` 的评分比左边 `i-1` 高，那么 `i` 的糖果数必须比 `i-1` 多。
2.  **右规则**：如果当前孩子 `i` 的评分比右边 `i+1` 高，那么 `i` 的糖果数必须比 `i+1` 多。

我们需要同时满足这两个规则。与其试图一次遍历解决所有依赖关系，不如将其拆解为两次遍历：

1.  **初始化**：每个孩子至少得 1 个糖果，先给所有位置初始化为 1。
2.  **从左向右遍历**：处理 **左规则**。

    - 只要 `ratings[i] > ratings[i-1]`，当前孩子的糖果数就设置为 `candies[i-1] + 1`。

3.  **从右向左遍历**：处理 **右规则**。

    - 只要 `ratings[i] > ratings[i+1]`，我们需要确保 `i` 的糖果比 `i+1` 多。
    - **注意**：此时 `i` 可能在第一遍遍历中已经获得了较多的糖果。为了同时满足左右两边的规则，我们需要取 **当前糖果数** 和 **`candies[i+1] + 1`** 中的 **最大值**。

4.  **求和**：遍历最终的糖果数组，计算总数。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是数组的长度。我们需要遍历数组三次（两次填充，一次求和）。
- **空间复杂度：** $O(n)$，需要一个额外的数组来存储每个孩子的糖果数量。

**代码片段：**

```java
public int candy(int[] ratings) {
    int n = ratings.length;
    int[] candies = new int[n];
    // 每个孩子至少分配到 1 个糖果
    Arrays.fill(candies, 1);

    // 1. 从左向右遍历，保证评分比左边高的孩子糖果更多
    for (int i = 1; i < n; i++) {
        if (ratings[i] > ratings[i - 1]) {
            candies[i] = candies[i - 1] + 1;
        }
    }

    // 2. 从右向左遍历，保证评分比右边高的孩子糖果更多
    // 同时要保留第一次遍历的结果，所以取 max
    for (int i = n - 2; i >= 0; i--) {
        if (ratings[i] > ratings[i + 1]) {
            candies[i] = Math.max(candies[i], candies[i + 1] + 1);
        }
    }

    // 3. 计算总糖果数
    int sum = 0;
    for (int count : candies) {
        sum += count;
    }
    return sum;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现：贪心算法（两次遍历）
    public static int candy(int[] ratings) {
        int n = ratings.length;
        int[] candies = new int[n];

        // 初始状态，每个人至少一颗
        Arrays.fill(candies, 1);

        // --- 第一遍：从左向右 ---
        // 确保若当前学生比左边学生分高，则糖果数比左边多
        for (int i = 1; i < n; i++) {
            if (ratings[i] > ratings[i - 1]) {
                candies[i] = candies[i - 1] + 1;
            }
        }

        // --- 第二遍：从右向左 ---
        // 确保若当前学生比右边学生分高，则糖果数比右边多
        // 此时需要取 Math.max，以同时满足左边和右边的规则
        for (int i = n - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1]) {
                candies[i] = Math.max(candies[i], candies[i + 1] + 1);
            }
        }

        // 计算总和
        int totalCandies = 0;
        for (int count : candies) {
            totalCandies += count;
        }

        return totalCandies;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] ratings1 = new int[]{1, 0, 2};

        System.out.println("示例 1 输入:");
        System.out.println("ratings = " + Arrays.toString(ratings1));

        int result1 = candy(ratings1);

        System.out.println("示例 1 输出: " + result1);
        // 解释: 分别为 [2, 1, 2]，总和 5
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] ratings2 = new int[]{1, 2, 2};

        System.out.println("示例 2 输入:");
        System.out.println("ratings = " + Arrays.toString(ratings2));

        int result2 = candy(ratings2);

        System.out.println("示例 2 输出: " + result2);
        // 解释: 分别为 [1, 2, 1]，总和 4
    }
}
```
