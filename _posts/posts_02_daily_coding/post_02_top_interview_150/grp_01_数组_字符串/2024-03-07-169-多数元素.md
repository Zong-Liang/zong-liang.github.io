---
title: 169. 多数元素
date: 2024-03-07 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数组_字符串]
tags: [数组_字符串]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121222122728.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个大小为 `n` 的数组 `nums` ，返回其中的 **多数元素** 。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1:**

- **输入:** `nums = [3,2,3]`
- **输出:** 3

**示例 2:**

- **输入:** `nums = [2,2,1,1,1,2,2]`
- **输出:** 2

**提示:**

- `n == nums.length`
- `1 <= n <= 5 * 10^4`
- `-10^9 <= nums[i] <= 10^9`
- 输入保证数组中一定有一个多数元素。

**进阶：** 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

## 题解

### 标准解法：排序法

**思路：**

题目说明多数元素出现的次数 **大于** `⌊ n/2 ⌋`。这意味着如果我们把数组中的所有元素按大小排序，那么数组中间位置的那个元素（下标为 `n/2`）**一定**是多数元素。

1.  使用标准库函数对数组进行排序。
2.  直接返回下标为 `n/2` 的元素。

**复杂度分析：**

- **时间复杂度：** $O(n\log n)$，主要是排序的开销。
- **空间复杂度：** $O(\log n)$，Java 中的 `Arrays.sort` 对于基本数据类型通常使用双轴快速排序（Dual-Pivot Quicksort），递归调用栈需要一定的空间。

**代码片段：**

```java
public int majorityElement(int[] nums) {
    Arrays.sort(nums);
    return nums[nums.length / 2];
}
```

### 进阶解法：摩尔投票法（Boyer-Moore Voting Algorithm）

**思路：**

这是解决此类问题的进阶解法，能够满足 $O(n)$ 时间复杂度和 $O(1)$ 空间复杂度的要求。它的核心思想是**抵消**。

可以将数组中的数字分为两类：“多数元素”和“非多数元素”。

1.  维护一个 `candidate`（候选人）和一个 `count`（票数）。
2.  遍历数组：

    - 如果 `count` 为 0，说明前面的都抵消完了，当前数字设为新的 `candidate`，并将 `count` 设为 1。
    - 如果当前数字等于 `candidate`，则 `count` 加 1（给自己拉票）。
    - 如果当前数字不等于 `candidate`，则 `count` 减 1（不同阵营相互抵消）。

3.  因为多数元素的数量大于 `n/2`，即便它与其他所有非多数元素通过“一换一”的方式抵消，最终剩下的 `candidate` 也一定就是多数元素。

**复杂度分析：**

- **时间复杂度：** $O(n)$，只需要遍历数组一次。
- **空间复杂度：** $O(1)$，只需要常数级别的额外空间维护变量。

**代码片段：**

```java
public int majorityElement(int[] nums) {
    int count = 0;
    Integer candidate = null;

    for (int num : nums) {
        // 如果当前票数为 0，更换候选人
        if (count == 0) {
            candidate = num;
        }
        //如果是自己人，票数+1，否则-1
        count += (num == candidate) ? 1 : -1;
    }

    return candidate;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现（摩尔投票法）
    public static int majorityElement(int[] nums) {
        int count = 0;
        //由于题目保证数组非空，candidate 最终会被赋值，初始 null 或 0 均可
        Integer candidate = null;

        for (int num : nums) {
            if (count == 0) {
                candidate = num;
            }
            if (num == candidate) {
                count++;
            } else {
                count--;
            }
        }
        return candidate;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1 = new int[]{3, 2, 3};

        System.out.println("示例 1 输入:");
        System.out.println("nums = " + Arrays.toString(nums1));

        int result1 = majorityElement(nums1);

        System.out.println("示例 1 输出: " + result1);
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums2 = new int[]{2, 2, 1, 1, 1, 2, 2};

        System.out.println("示例 2 输入:");
        System.out.println("nums = " + Arrays.toString(nums2));

        int result2 = majorityElement(nums2);

        System.out.println("示例 2 输出: " + result2);
    }
}
```
