---
title: 14. 最长公共前缀
date: 2024-04-04 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数组_字符串]
tags: [数组_字符串]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121223306087.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

**示例 1:**

- **输入:** `strs = ["flower","flow","flight"]`
- **输出:** `"fl"`

**示例 2:**

- **输入:** `strs = ["dog","racecar","car"]`
- **输出:** `""`
- **解释:** 输入不存在公共前缀。

**提示:**

- `1 <= strs.length <= 200`
- `0 <= strs[i].length <= 200`
- `strs[i]` 如果非空，则仅由小写英文字母组成

## 题解

### 解法一：横向扫描法（标准解法）

**思路：**

最直观的方法是依次遍历字符串数组。

1.  我们将数组中的第一个字符串 `strs[0]` 设为初始的 **公共前缀 (`prefix`)**。
2.  依次将 `prefix` 与后面的每一个字符串 `strs[i]` 进行比较。
3.  如果不匹配（即 `strs[i]` 不以 `prefix` 开头），我们就将 `prefix` 的长度减 1（去掉最后一个字符），再次尝试匹配。
4.  重复此过程，直到找到匹配的前缀，或者 `prefix` 变为空字符串为止。

**复杂度分析：**

- **时间复杂度：** $O(S)$，其中 $S$ 是所有字符串中字符数量的总和。最坏情况下，所有字符串都相同，我们需要比较每一个字符。
- **空间复杂度：** $O(1)$，不需要额外的复杂空间，只利用原有的字符串空间进行子串截取。

**代码片段：**

```java
public String longestCommonPrefix(String[] strs) {
    if (strs.length == 0) return "";

    // 初始化前缀为第一个字符串
    String prefix = strs[0];

    // 依次遍历后面的字符串
    for (int i = 1; i < strs.length; i++) {
        // 只要 strs[i] 不以 prefix 开头，就不断缩短 prefix
        while (strs[i].indexOf(prefix) != 0) {
            prefix = prefix.substring(0, prefix.length() - 1);
            // 如果缩短到空了，直接返回
            if (prefix.isEmpty()) return "";
        }
    }
    return prefix;
}
```

### 解法二：排序比较法（代码简洁）

**思路：**

利用字符串排序的特性。

1.  将字符串数组按字母顺序进行排序 (`Arrays.sort`)。
2.  排序后，**最长公共前缀** 一定出现在 **第一个字符串** 和 **最后一个字符串** 之间。因为排序会将相似的字符串靠在一起，如果第一个和最后一个都有共同前缀，那么中间所有的字符串肯定也有该前缀。
3.  因此，我们只需要比较排序后的第一个字符串和最后一个字符串，找出它们的公共部分即可。

**复杂度分析：**

- **时间复杂度：** $O(N \cdot L \cdot \log N)$，其中 $N$ 是数组长度，$L$ 是字符串的最大长度。主要开销在于排序。虽然理论复杂度高于扫描法，但在 $N$ 较小（本题提示 $N \le 200$）的情况下，效率非常高且代码简洁。
- **空间复杂度：** $O(\log N)$，主要是排序算法使用的栈空间。

**代码片段：**

```java
public String longestCommonPrefix(String[] strs) {
    Arrays.sort(strs);
    String s1 = strs[0];
    String s2 = strs[strs.length - 1];

    int idx = 0;
    // 只需比较首尾两个字符串
    while (idx < s1.length() && idx < s2.length()) {
        if (s1.charAt(idx) == s2.charAt(idx)) {
            idx++;
        } else {
            break;
        }
    }
    return s1.substring(0, idx);
}
```

### 完整代码

这里展示**横向扫描法**的完整实现，因为它是时间复杂度最优的标准解法。

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现：横向扫描
    public static String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }

        // 假设第一个字符串就是公共前缀
        String prefix = strs[0];

        // 从第二个字符串开始遍历
        for (int i = 1; i < strs.length; i++) {
            // 当当前的字符串 strs[i] 不是以 prefix 开头时
            // indexOf 返回 0 表示从开头匹配
            while (strs[i].indexOf(prefix) != 0) {
                // 将 prefix 的长度减 1
                prefix = prefix.substring(0, prefix.length() - 1);

                // 如果减为空了，说明没有公共前缀
                if (prefix.isEmpty()) {
                    return "";
                }
            }
        }
        return prefix;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        String[] strs1 = new String[]{"flower", "flow", "flight"};

        System.out.println("示例 1 输入: " + Arrays.toString(strs1));
        System.out.println("示例 1 输出: \"" + longestCommonPrefix(strs1) + "\"");
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        String[] strs2 = new String[]{"dog", "racecar", "car"};

        System.out.println("示例 2 输入: " + Arrays.toString(strs2));
        System.out.println("示例 2 输出: \"" + longestCommonPrefix(strs2) + "\"");
        // 解释: 不存在公共前缀

        // --- 额外测试 ---
        String[] strs3 = new String[]{"ab", "a"};
        System.out.println("-----------------------------");
        System.out.println("额外测试 输入: " + Arrays.toString(strs3));
        System.out.println("额外测试 输出: \"" + longestCommonPrefix(strs3) + "\"");
    }
}
```
