---
title: 151. 反转字符串中的单词
date: 2024-04-07 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数组_字符串]
tags: [数组_字符串]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121223345109.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。

**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。

返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。

**注意：** 输入字符串 `s` 中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

**示例 1:**

- **输入:** `s = "the sky is blue"`
- **输出:** `"blue is sky the"`

**示例 2:**

- **输入:** `s = "  hello world  "`
- **输出:** `"world hello"`
- **解释:** 反转后的字符串中不能存在前导空格和尾随空格。

**示例 3:**

- **输入:** `s = "a good   example"`
- **输出:** `"example good a"`
- **解释:** 如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。

**提示:**

- `1 <= s.length <= 10^4`
- `s` 包含英文大小写字母、数字和空格 `' '`
- `s` 中 **至少存在一个** 单词

**进阶：** 如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 `O(1)` 额外空间复杂度的 **原地** 解法。

## 题解

### 标准解法：利用内置函数（分割 + 倒序拼接）

**思路：**

这是最符合直觉的解法。我们可以利用语言提供的字符串处理函数来简化操作。

1.  **去除首尾空格**：使用 `trim()`。
2.  **分割字符串**：利用正则表达式 `\s+`（匹配一个或多个空格）将字符串分割成单词数组。
3.  **倒序拼接**：从数组末尾向前遍历，将单词取出，并用单个空格拼接成新的字符串。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是字符串的长度。`trim`、`split` 和遍历拼接都需要线性时间。
- **空间复杂度：** $O(n)$，需要存储分割后的单词列表和结果字符串。

**代码片段：**

```java
public String reverseWords(String s) {
    // 1. 去除首尾空格并按一个或多个空格分割
    String[] words = s.trim().split("\\s+");

    // 2. 倒序拼接
    StringBuilder sb = new StringBuilder();
    for (int i = words.length - 1; i >= 0; i--) {
        sb.append(words[i]);
        if (i > 0) {
            sb.append(" ");
        }
    }
    return sb.toString();
}
```

### 进阶解法：双重反转 + 双指针去空格（模拟原地操作）

**思路：**

题目进阶要求 $O(1)$ 空间复杂度的原地解法。虽然 Java 的 `String` 是不可变的（Immutable），无法真正实现原地修改，但我们可以将字符串转换为 `char[]` 或 `StringBuilder` 来模拟这一过程，理解其背后的算法思想。

核心思想是 **“负负得正”**：

1.  **移除多余空格**：使用双指针法（类似移除数组元素的逻辑），将字符串整理为“单词间仅保留一个空格，无首尾空格”的形式。
2.  **反转整个字符串**：将 "the sky is blue" 变为 "eulb si yks eht"。
3.  **反转每个单词**：再把单词内部反转回来，"eulb" -> "blue"，最终得到 "blue is sky the"。

**步骤：**

1.  **去空格**：使用 `slow` 指针构建不含多余空格的字符串。
2.  **整体反转**：调用反转函数。
3.  **局部反转**：遍历处理后的字符串，以空格为界，反转每个单词。

**复杂度分析：**

- **时间复杂度：** $O(n)$，去空格、整体反转、局部反转均为线性遍历。
- **空间复杂度：** $O(1)$（如果不考虑将 String 转为 char[] 或 StringBuilder 所需的空间，纯算法逻辑是原地操作的）。

**代码片段：**

```java
public String reverseWords(String s) {
    StringBuilder sb = trimSpaces(s); // 1. 去除多余空格
    reverse(sb, 0, sb.length() - 1);  // 2. 反转整个字符串
    reverseEachWord(sb);              // 3. 反转每个单词
    return sb.toString();
}

// 辅助函数实现见下方完整代码
```


### 完整代码

```java
public class Main {

    // --- 进阶解法：模拟原地操作 ---
    public static String reverseWords(String s) {
        // 由于 Java String 不可变，必须开辟空间，这里用 StringBuilder 模拟字符数组
        StringBuilder sb = trimSpaces(s);

        // 1. 反转整个字符串
        reverse(sb, 0, sb.length() - 1);

        // 2. 反转每个单词
        reverseEachWord(sb);

        return sb.toString();
    }

    // 步骤 1: 去除多余空格（双指针法）
    private static StringBuilder trimSpaces(String s) {
        int left = 0, right = s.length() - 1;
        // 去掉字符串开头的空白字符
        while (left <= right && s.charAt(left) == ' ') {
            left++;
        }
        // 去掉字符串末尾的空白字符
        while (left <= right && s.charAt(right) == ' ') {
            right--;
        }

        StringBuilder sb = new StringBuilder();
        while (left <= right) {
            char c = s.charAt(left);
            if (c != ' ') {
                sb.append(c);
            } else if (sb.charAt(sb.length() - 1) != ' ') {
                // 如果当前是空格，且 sb 最后一位不是空格（避免连续空格），则追加一个空格
                sb.append(c);
            }
            left++;
        }
        return sb;
    }

    // 步骤 2: 反转指定区间的字符
    private static void reverse(StringBuilder sb, int left, int right) {
        while (left < right) {
            char temp = sb.charAt(left);
            sb.setCharAt(left, sb.charAt(right));
            sb.setCharAt(right, temp);
            left++;
            right--;
        }
    }

    // 步骤 3: 反转每个单词
    private static void reverseEachWord(StringBuilder sb) {
        int n = sb.length();
        int start = 0;
        int end = 0;

        while (start < n) {
            // 找到单词的末尾
            while (end < n && sb.charAt(end) != ' ') {
                end++;
            }
            // 反转当前单词
            reverse(sb, start, end - 1);
            // 更新指针，跳过空格
            start = end + 1;
            end = start;
        }
    }

    // --- 标准解法（仅作对比使用）---
    public static String reverseWordsStandard(String s) {
        String[] words = s.trim().split("\\s+");
        StringBuilder sb = new StringBuilder();
        for (int i = words.length - 1; i >= 0; i--) {
            sb.append(words[i]);
            if (i > 0) sb.append(" ");
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        String s1 = "the sky is blue";
        System.out.println("示例 1 输入: \"" + s1 + "\"");
        String res1 = reverseWords(s1);
        System.out.println("示例 1 输出: \"" + res1 + "\"");
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        String s2 = "  hello world  ";
        System.out.println("示例 2 输入: \"" + s2 + "\"");
        String res2 = reverseWords(s2);
        System.out.println("示例 2 输出: \"" + res2 + "\""); // 应去除首尾空格
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        String s3 = "a good   example";
        System.out.println("示例 3 输入: \"" + s3 + "\"");
        String res3 = reverseWords(s3);
        System.out.println("示例 3 输出: \"" + res3 + "\""); // 应合并中间空格
    }
}
```
