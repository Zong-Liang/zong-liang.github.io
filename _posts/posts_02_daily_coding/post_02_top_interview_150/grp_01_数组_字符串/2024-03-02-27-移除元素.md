---
title: 27. 移除元素
date: 2024-03-02 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数组_字符串]
tags: [数组_字符串]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121221430260.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个数组 `nums` 和一个值 `val`，你需要 **原地** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：

- 更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。
- 返回 `k`。

**用户评测:**

评测机将使用以下代码测试您的解决方案：

```java
int[] nums = [...]; // 输入数组
int val = ...; // 要移除的值
int[] expectedNums = [...]; // 长度正确的预期答案

int k = removeElement(nums, val); // 调用你的实现

assert k == expectedNums.length;
sort(nums, 0, k); // 排序 nums 的前 k 个元素
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

**示例 1:**

- **输入:** `nums = [3,2,2,3]`, `val = 3`
- **输出:** 2, `nums = [2,2,_,_]`
- **解释:** 你的函数函数应该返回 `k = 2`, 并且 `nums` 中的前两个元素均为 2。
  
  你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。

**示例 2:**

- **输入:** `nums = [0,1,2,2,3,0,4,2]`, `val = 2`
- **输出:** 5, `nums = [0,1,4,0,3,_,_,_]`
- **解释:** 你的函数应该返回 `k = 5`，并且 `nums` 中的前五个元素为 `0,0,1,3,4`。
  
  注意这五个元素可以任意顺序返回。

  你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。

**提示:**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

## 题解

### 解法：双指针（快慢指针）

**思路：**

由于题目要求 **原地** 修改数组，且不使用额外的数组空间，双指针法是解决此类问题的标准做法。我们可以定义两个指针：

1.  **快指针 (`fast`)**：用于遍历当前数组，寻找所有 **不等于** `val` 的元素。
2.  **慢指针 (`slow`)**：指向下一个将要被赋值的位置（即新数组的尾部）。

**具体步骤：**

1.  初始化 `slow = 0`。
2.  使用 `fast` 从 `0` 到 `nums.length - 1` 遍历数组。
3.  当 `nums[fast]` 与 `val` **不相等** 时：

    - 将 `nums[fast]` 的值复制到 `nums[slow]`。
    - 将 `slow` 向后移动一位 (`slow++`)。

4.  当 `nums[fast]` 与 `val` **相等** 时：

    - 直接跳过，不做处理（相当于删除了该元素）。

5.  遍历结束后，`slow` 的值即为新数组的长度。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是数组的长度。我们只需要遍历数组一次。
- **空间复杂度：** $O(1)$，只需要常数级别的额外空间用于存储指针变量。

**代码片段：**

```java
public int removeElement(int[] nums, int val) {
    int slow = 0;
    // fast 指针负责遍历
    for (int fast = 0; fast < nums.length; fast++) {
        // 遇到不需要移除的元素，就把它填入 slow 的位置
        if (nums[fast] != val) {
            nums[slow] = nums[fast];
            slow++;
        }
    }
    return slow;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现
    public static int removeElement(int[] nums, int val) {
        int slow = 0;
        for (int fast = 0; fast < nums.length; fast++) {
            if (nums[fast] != val) {
                nums[slow] = nums[fast];
                slow++;
            }
        }
        return slow;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1 = new int[]{3, 2, 2, 3};
        int val1 = 3;

        System.out.println("示例 1 输入:");
        System.out.println("nums = " + Arrays.toString(nums1) + ", val = " + val1);

        int k1 = removeElement(nums1, val1);

        // 截取前 k 个元素进行打印，模拟评测机的行为
        int[] result1 = Arrays.copyOfRange(nums1, 0, k1);
        System.out.println("示例 1 输出: " + k1 + ", nums = " + Arrays.toString(result1));
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums2 = new int[]{0, 1, 2, 2, 3, 0, 4, 2};
        int val2 = 2;

        System.out.println("示例 2 输入:");
        System.out.println("nums = " + Arrays.toString(nums2) + ", val = " + val2);

        int k2 = removeElement(nums2, val2);

        int[] result2 = Arrays.copyOfRange(nums2, 0, k2);
        System.out.println("示例 2 输出: " + k2 + ", nums = " + Arrays.toString(result2));
    }
}
```
