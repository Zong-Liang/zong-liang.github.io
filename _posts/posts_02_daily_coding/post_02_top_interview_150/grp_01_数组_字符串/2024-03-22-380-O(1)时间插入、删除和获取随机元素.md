---
title: 380. O(1)时间插入、删除和获取随机元素
date: 2024-03-22 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数组_字符串]
tags: [数组_字符串]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121222634446.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

实现 `RandomizedSet` 类：

- `RandomizedSet()` 初始化 `RandomizedSet` 对象
- `bool insert(int val)` 当元素 `val` 不存在时，向集合中插入该项，并返回 `true` ；否则，返回 `false` 。
- `bool remove(int val)` 当元素 `val` 存在时，从集合中移除该项，并返回 `true` ；否则，返回 `false` 。
- `int getRandom()` 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 **相同的概率** 被返回。

你必须实现类的所有函数，并满足每个函数的 **平均** 时间复杂度为 `O(1)` 。

**示例:**

- **输入**
  `["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]`
  `[[], [1], [2], [2], [], [1], [2], []]`
- **输出**
  `[null, true, false, true, 2, true, false, 2]`
  _(getRandom 的输出可能是 1 或 2)_

**提示:**

- `-2^31 <= val <= 2^31 - 1`
- 最多调用 `insert`、`remove` 和 `getRandom` 函数 `2 * 10^5` 次
- 在调用 `getRandom` 方法时，数据结构中 **至少** 存在一个元素。

## 题解

### 解法：哈希表 + 动态数组（变长数组）

**思路：**

为了在 $O(1)$ 时间内完成 `insert`、`remove` 和 `getRandom`，我们需要结合哈希表和动态数组的特性：

1.  **为什么需要数组？**
    
    只有数组（`ArrayList`）支持通过索引在 $O(1)$ 时间内随机访问元素，这是实现 `getRandom` 的基础。
2.  **为什么需要哈希表？**
    
    我们需要在 $O(1)$ 时间内判断元素是否存在，以及获取元素在数组中的索引，这是 `insert` 和 `remove` 的基础。

**核心逻辑设计：**

- **数据结构**：

  - `nums` (`List<Integer>`): 存储具体数值。
  - `indices` (`Map<Integer, Integer>`): 存储 `数值 -> nums中的下标` 的映射。

- **`insert(val)`**：

  - 检查 `indices` 是否包含 `val`，若包含则返回 false。
  - 将 `val` 添加到 `nums` 的**末尾**。
  - 在 `indices` 中记录 `val` 对应的下标（即 `nums.size() - 1`）。

- **`getRandom()`**：

  - 生成一个 `0` 到 `nums.size() - 1` 之间的随机数 `randomIndex`。
  - 返回 `nums.get(randomIndex)`。

- **`remove(val)` （难点）**：
  
  - 若直接删除数组中间的元素，会导致后续元素前移，时间复杂度为 $O(N)$。
  - **优化技巧（交换移除法）**：
    
    1.  从 `indices` 中拿到 `val` 的下标 `index`。
    2.  拿到 `nums` 数组中**最后一个元素** `lastElement`。
    3.  将 `nums[index]` 的值修改为 `lastElement`（相当于把最后一个元素挪到了要删除的元素的位置）。
    4.  更新 `indices` 中 `lastElement` 的下标为 `index`。
    5.  删除 `nums` 的最后一个元素，并删除 `indices` 中的 `val`。

**复杂度分析：**

- **时间复杂度：** `insert`, `remove`, `getRandom` 均为 $O(1)$。虽然哈希表在极端冲突下是 $O(N)$，但平均情况下是 $O(1)$。
- **空间复杂度：** $O(N)$，需要存储 $N$ 个元素的值和索引映射。

**代码片段：**

```java
class RandomizedSet {
    List<Integer> nums;
    Map<Integer, Integer> indices;
    Random random;

    public RandomizedSet() {
        nums = new ArrayList<>();
        indices = new HashMap<>();
        random = new Random();
    }

    public boolean insert(int val) {
        if (indices.containsKey(val)) {
            return false;
        }
        indices.put(val, nums.size());
        nums.add(val);
        return true;
    }

    public boolean remove(int val) {
        if (!indices.containsKey(val)) {
            return false;
        }
        // 核心逻辑：将要删除的元素与最后一个元素交换，然后删除最后一个元素
        int index = indices.get(val);
        int lastElement = nums.get(nums.size() - 1);

        nums.set(index, lastElement); // 覆盖要删除的位置
        indices.put(lastElement, index); // 更新原本最后一个元素的索引映射

        nums.remove(nums.size() - 1); // 移除数组末尾
        indices.remove(val); // 移除哈希表条目
        return true;
    }

    public int getRandom() {
        return nums.get(random.nextInt(nums.size()));
    }
}
```

### 完整代码

```java
import java.util.*;

public class Main {

    static class RandomizedSet {
        private List<Integer> nums;
        private Map<Integer, Integer> indices;
        private Random random;

        public RandomizedSet() {
            nums = new ArrayList<>();
            indices = new HashMap<>();
            random = new Random();
        }

        public boolean insert(int val) {
            if (indices.containsKey(val)) {
                return false;
            }
            // 记录索引，添加元素
            indices.put(val, nums.size());
            nums.add(val);
            return true;
        }

        public boolean remove(int val) {
            if (!indices.containsKey(val)) {
                return false;
            }

            // 获取要删除元素的索引
            int index = indices.get(val);
            // 获取数组最后一个元素
            int lastElement = nums.get(nums.size() - 1);

            // 将最后一个元素填入要删除元素的位置
            nums.set(index, lastElement);
            // 更新最后一个元素在哈希表中的索引
            indices.put(lastElement, index);

            // 删除数组的最后一项（O(1)操作）
            nums.remove(nums.size() - 1);
            // 删除哈希表中的记录
            indices.remove(val);

            return true;
        }

        public int getRandom() {
            return nums.get(random.nextInt(nums.size()));
        }
    }

    public static void main(String[] args) {
        // --- 示例 ---
        System.out.println("开始测试 RandomizedSet:");

        RandomizedSet randomizedSet = new RandomizedSet();

        // insert 1
        boolean i1 = randomizedSet.insert(1);
        System.out.println("insert(1): " + i1); // 预期 true

        // remove 2
        boolean r2 = randomizedSet.remove(2);
        System.out.println("remove(2): " + r2); // 预期 false

        // insert 2
        boolean i2 = randomizedSet.insert(2);
        System.out.println("insert(2): " + i2); // 预期 true

        // getRandom
        int rand1 = randomizedSet.getRandom();
        System.out.println("getRandom(): " + rand1); // 预期 1 或 2

        // remove 1
        boolean r1 = randomizedSet.remove(1);
        System.out.println("remove(1): " + r1); // 预期 true

        // insert 2
        boolean i2_again = randomizedSet.insert(2);
        System.out.println("insert(2): " + i2_again); // 预期 false

        // getRandom
        int rand2 = randomizedSet.getRandom();
        System.out.println("getRandom(): " + rand2); // 预期 2

        System.out.println("-----------------------------");
    }
}
```
