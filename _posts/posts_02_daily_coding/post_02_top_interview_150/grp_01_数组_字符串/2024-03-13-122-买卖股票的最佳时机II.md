---
title: 122. 买卖股票的最佳时机II
date: 2024-03-13 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数组_字符串]
tags: [数组_字符串]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121222339844.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以在 **同一天** 多次买卖该股票，但要确保你持有的股票不超过一股。

返回你能获得的 **最大利润** 。

**示例 1:**

- **输入:** `prices = [7,1,5,3,6,4]`
- **输出:** 7
- **解释:** 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。最大总利润为 4 + 3 = 7 。

**示例 2:**

- **输入:** `prices = [1,2,3,4,5]`
- **输出:** 4
- **解释:** 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。最大总利润为 4 。

**示例 3:**

- **输入:** `prices = [7,6,4,3,1]`
- **输出:** 0
- **解释:** 在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。

**提示:**

- `1 <= prices.length <= 3 * 10^4`
- `0 <= prices[i] <= 10^4`

## 题解

### 解法：贪心算法

**思路：**

这道题与「买卖股票的最佳时机 I」不同，因为我们可以进行无限次交易。

核心在于理解利润的来源：

假如第 1 天买入，第 3 天卖出，且价格是上涨的（例如 `1 -> 5 -> 10`），那么利润 `10 - 1 = 9` 其实等价于 `(5 - 1) + (10 - 5) = 4 + 5 = 9`。

也就是说，**任何长期的上涨利润，都可以分解为每天的单日利润之和**。

基于这个性质，我们只需要使用 **贪心** 策略：

1.  遍历整个价格数组。
2.  只要 **今天比昨天贵**（`prices[i] > prices[i-1]`），我们就认为昨天买入、今天卖出赚到了钱。
3.  将所有这些正向的差价（利润）累加起来，就是我们能获得的最大总利润。
4.  如果今天比昨天便宜，我们就不操作（或者想象成昨天卖了，今天没买）。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是数组的长度。我们需要遍历一次数组。
- **空间复杂度：** $O(1)$，不需要额外的数组空间，只使用了常数个变量。

**代码片段：**

```java
public int maxProfit(int[] prices) {
    int totalProfit = 0;
    for (int i = 1; i < prices.length; i++) {
        // 只要今天的价格比昨天高，就计算利润
        if (prices[i] > prices[i - 1]) {
            totalProfit += prices[i] - prices[i - 1];
        }
    }
    return totalProfit;
}
```


### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现：贪心算法
    public static int maxProfit(int[] prices) {
        int totalProfit = 0;
        // 从第二天开始遍历
        for (int i = 1; i < prices.length; i++) {
            // 如果今天的价格高于昨天，就卖出赚取差价
            // (相当于昨天买入今天卖出，若明天更高，相当于今天又买入)
            if (prices[i] > prices[i - 1]) {
                totalProfit += prices[i] - prices[i - 1];
            }
        }
        return totalProfit;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] prices1 = new int[]{7, 1, 5, 3, 6, 4};

        System.out.println("示例 1 输入:");
        System.out.println("prices = " + Arrays.toString(prices1));

        int result1 = maxProfit(prices1);

        System.out.println("示例 1 输出: " + result1);
        // 解释: (5-1) + (6-3) = 4 + 3 = 7
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] prices2 = new int[]{1, 2, 3, 4, 5};

        System.out.println("示例 2 输入:");
        System.out.println("prices = " + Arrays.toString(prices2));

        int result2 = maxProfit(prices2);

        System.out.println("示例 2 输出: " + result2);
        // 解释: (2-1) + (3-2) + (4-3) + (5-4) = 4
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        int[] prices3 = new int[]{7, 6, 4, 3, 1};

        System.out.println("示例 3 输入:");
        System.out.println("prices = " + Arrays.toString(prices3));

        int result3 = maxProfit(prices3);

        System.out.println("示例 3 输出: " + result3);
        // 解释: 价格一路下跌，不进行任何交易，利润为 0
    }
}
```
