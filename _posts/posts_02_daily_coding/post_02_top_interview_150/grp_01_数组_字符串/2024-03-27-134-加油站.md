---
title: 134. 加油站
date: 2024-03-27 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数组_字符串]
tags: [数组_字符串]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251122140554456.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 **保证** 它是 **唯一** 的。

**示例 1:**

- **输入:** `gas = [1,2,3,4,5]`, `cost = [3,4,5,1,2]`
- **输出:** 3
- **解释:**

  从 3 号加油站（索引为 3 处）出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油

  开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油

  开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油

  开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油

  开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油

  开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。

  因此，3 可为起始索引。

**示例 2:**

- **输入:** `gas = [2,3,4]`, `cost = [3,4,3]`
- **输出:** -1

**提示:**

- `n == gas.length == cost.length`
- `1 <= n <= 10^5`
- `0 <= gas[i], cost[i] <= 10^4`
- 输入保证答案唯一。

## 题解

### 解法：贪心算法

**思路：**

这道题的核心在于两个关键点：

1.  **全局检查**：如果所有加油站的总油量 `sum(gas)` 小于总消耗 `sum(cost)`，那么无论从哪里出发，车都不可能跑完一圈。我们可以通过维护一个 `totalSum` 变量来判断，如果最终 `totalSum < 0`，直接返回 -1。

2.  **局部贪心**：假设我们从下标 `0` 出发，累加当前的剩余油量 `currentSum`。

    - 如果在到达下标 `i` 时，`currentSum` 跌破 0（即 `currentSum < 0`），说明从起点到 `i` 之间的任何一个位置作为起点，都无法到达 `i + 1`。
    - **为什么？** 假设在 0 到 `i` 之间有个位置 `k`，我们到达 `k` 时不仅没断油，可能还有剩余（或者刚好为 0）。如果在有基础油量的情况下从 `k` 走到 `i` 都断油了，那么从 `k` 零油量起步肯定更无法到达 `i`。
    - **策略**：一旦在 `i` 处断油，就说明起点肯定在 `i + 1` 之后。我们将起点重置为 `i + 1`，并将 `currentSum` 重置为 0，继续寻找。

只要总油量充足（`totalSum >= 0`），根据数学证明，贪心策略最后选定的起点一定是唯一的可行解。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是数组的长度。我们只需要遍历数组一次。
- **空间复杂度：** $O(1)$，只需要常数级别的额外空间维护变量。

**代码片段：**

```java
public int canCompleteCircuit(int[] gas, int[] cost) {
    int totalSum = 0;
    int currentSum = 0;
    int start = 0;

    for (int i = 0; i < gas.length; i++) {
        int diff = gas[i] - cost[i];
        totalSum += diff;
        currentSum += diff;

        // 如果当前累积的油量小于 0，说明之前的起点无法到达这里
        if (currentSum < 0) {
            // 重新选择起点为下一个位置
            start = i + 1;
            // 重置当前油量
            currentSum = 0;
        }
    }

    // 如果总油量小于总消耗，说明无法跑完一圈
    if (totalSum < 0) {
        return -1;
    }

    return start;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现：贪心算法
    public static int canCompleteCircuit(int[] gas, int[] cost) {
        int totalSum = 0;   // 记录全程的总剩余油量（判断是否有解）
        int currentSum = 0; // 记录当前起点的累积剩余油量
        int start = 0;      // 记录可能的起始位置

        for (int i = 0; i < gas.length; i++) {
            int remaining = gas[i] - cost[i];
            totalSum += remaining;
            currentSum += remaining;

            // 如果当前累积油量小于 0，说明从 start 到 i 肯定是走不通的
            // 且 start 到 i 之间的任何一点都不可能作为起点
            if (currentSum < 0) {
                // 尝试下一个位置作为起点
                start = i + 1;
                // 重置当前累积量
                currentSum = 0;
            }
        }

        // 全局判断：如果总油量不够总消耗，绝对不可能跑完一圈
        if (totalSum < 0) {
            return -1;
        }

        // 题目保证如果有解则唯一，且能跑完一圈，所以直接返回找到的 start
        return start;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] gas1 = new int[]{1, 2, 3, 4, 5};
        int[] cost1 = new int[]{3, 4, 5, 1, 2};

        System.out.println("示例 1 输入:");
        System.out.println("gas = " + Arrays.toString(gas1));
        System.out.println("cost = " + Arrays.toString(cost1));

        int result1 = canCompleteCircuit(gas1, cost1);

        System.out.println("示例 1 输出: " + result1);
        // 解释：从索引 3 (gas=4, cost=1) 出发是可行的
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] gas2 = new int[]{2, 3, 4};
        int[] cost2 = new int[]{3, 4, 3};

        System.out.println("示例 2 输入:");
        System.out.println("gas = " + Arrays.toString(gas2));
        System.out.println("cost = " + Arrays.toString(cost2));

        int result2 = canCompleteCircuit(gas2, cost2);

        System.out.println("示例 2 输出: " + result2);
        // 解释：总油量 9，总消耗 10，不可能跑完
    }
}
```
