---
title: 134. 加油站
date: 2024-03-27 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数组_字符串]
tags: [数组_字符串]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251122140554456.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：134. 加油站

**描述**

在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 **保证** 它是 **唯一** 的。

**示例 1:**

- **输入:** `gas = [1,2,3,4,5]`, `cost = [3,4,5,1,2]`
- **输出:** 3
- **解释:**
  从 3 号加油站（索引为 3 处）出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
  开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
  开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
  开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
  开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
  开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
  因此，3 可为起始索引。

**示例 2:**

- **输入:** `gas = [2,3,4]`, `cost = [3,4,3]`
- **输出:** -1

**提示:**

- `n == gas.length == cost.length`
- `1 <= n <= 10^5`
- `0 <= gas[i], cost[i] <= 10^4`
- 输入保证答案唯一。

## 题解

```java
import java.util.Arrays;

public class Main {

    /**
     * 找到可以绕环路行驶一周的起始加油站。
     * 采用一次遍历的贪心算法。
     *
     * @param gas  每个加油站的汽油量
     * @param cost 到达下一个加油站的消耗量
     * @return 起始加油站的索引，如果不能完成则返回 -1
     */
    public static int canCompleteCircuit(int[] gas, int[] cost) {
        int n = gas.length;

        // totalTank 记录总的油量缺口
        int totalTank = 0;
        // currentTank 记录从某个起点开始的当前油量
        int currentTank = 0;
        // startStation 记录可能的起始点
        int startStation = 0;

        for (int i = 0; i < n; i++) {
            // 计算总油量和总消耗的差值
            totalTank += gas[i] - cost[i];
            // 计算从 startStation 出发到当前站 i 的油量结余
            currentTank += gas[i] - cost[i];

            // 如果 currentTank < 0，说明从 startStation 到不了 i+1 站
            if (currentTank < 0) {
                // 那么，[startStation, i] 之间的任何一个站都不可能是起点
                // 因为如果从中间某个站 k 出发，到达 i 时油量会更少
                // 所以，将下一个可能的起点设为 i + 1
                startStation = i + 1;
                // 并重置当前油箱
                currentTank = 0;
            }
        }

        // 关键点：如果总的 gas 量小于总的 cost 量 (totalTank < 0)，
        // 那么无论从哪里出发，都绝对不可能跑完全程。
        // 反之，如果 totalTank >= 0，就一定存在一个解。
        // 而这个解就是我们上面循环找到的 startStation。
        return totalTank >= 0 ? startStation : -1;
    }

    public static void main(String[] args) {
        // 示例 1
        int[] gas1 = {1, 2, 3, 4, 5};
        int[] cost1 = {3, 4, 5, 1, 2};
        System.out.println("输入: gas = " + Arrays.toString(gas1) + ", cost = " + Arrays.toString(cost1));
        System.out.println("输出: " + canCompleteCircuit(gas1, cost1)); // 预期: 3
        System.out.println("---");

        // 示例 2
        int[] gas2 = {2, 3, 4};
        int[] cost2 = {3, 4, 3};
        System.out.println("输入: gas = " + Arrays.toString(gas2) + ", cost = " + Arrays.toString(cost2));
        System.out.println("输出: " + canCompleteCircuit(gas2, cost2)); // 预期: -1
        System.out.println("---");
    }
}
```
