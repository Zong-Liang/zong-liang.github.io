---
title: 28. 找出字符串中第一个匹配项的下标
date: 2024-04-11 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数组_字符串]
tags: [数组_字符串]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121223531446.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。

**示例 1:**

- **输入:** `haystack = "sadbutsad"`, `needle = "sad"`
- **输出:** 0
- **解释:** `"sad"` 在下标 0 和 6 处匹配。第一个匹配项的下标是 0 ，所以返回 0 。

**示例 2:**

- **输入:** `haystack = "leetcode"`, `needle = "leeto"`
- **输出:** -1
- **解释:** `"leeto"` 没有在 `"leetcode"` 中出现，所以返回 -1 。

**提示:**

- `1 <= haystack.length, needle.length <= 10^4`
- `haystack` 和 `needle` 仅由小写英文字符组成

## 题解

### 解法一：暴力匹配法（滑动窗口）

**思路：**

最直观的方法是让字符串 `needle` 在 `haystack` 上“滑动”。

1.  遍历 `haystack` 的每一个字符，将其作为潜在的起点 `i`。
2.  对于每一个起点 `i`，检查其后的字符是否能完整匹配 `needle`。
3.  如果在某个位置完全匹配，返回当前下标 `i`。
4.  如果遍历结束（直到剩余长度不足以容纳 `needle`）仍未找到，返回 -1。

**复杂度分析：**

- **时间复杂度：** $O((n - m) \times m)$，其中 $n$ 是 `haystack` 的长度，$m$ 是 `needle` 的长度。最坏情况下（例如 `haystack` 为 "aaaaa", `needle` 为 "aab"），我们需要对每个位置都进行大量比较。
- **空间复杂度：** $O(1)$，不需要额外的存储空间。

**代码片段：**

```java
public int strStr(String haystack, String needle) {
    int n = haystack.length(), m = needle.length();
    // 只需要遍历到 n - m 的位置，后面长度不够了没必要看
    for (int i = 0; i <= n - m; i++) {
        int j = 0;
        // 逐个字符比较
        while (j < m && haystack.charAt(i + j) == needle.charAt(j)) {
            j++;
        }
        // 如果 j 走到了 m，说明完全匹配
        if (j == m) {
            return i;
        }
    }
    return -1;
}
```

### 解法二：KMP 算法 (Knuth-Morris-Pratt)

**思路：**

暴力法的缺点在于，当出现字符不匹配时，它会将 `needle` 的起始位置向后移动一位，然后**从头开始**比较。这导致了大量的重复比较。

KMP 算法的核心在于：当出现不匹配时，我们可以利用**已经匹配过的部分**的信息，将 `needle` 向后移动不止一位，从而跳过那些肯定不会匹配的位置。

1.  **构建前缀表（Next 数组）**：

    我们需要先对 `needle` 进行预处理，计算出一个 `next` 数组。`next[i]` 表示子串 `needle[0...i]` 中，**最长相等前后缀的长度**。

    - **前缀**：指不包含最后一个字符的所有以第一个字符开头的连续子串。
    - **后缀**：指不包含第一个字符的所有以最后一个字符结尾的连续子串。

2.  **匹配过程**：

    - 使用指针 `i` 遍历 `haystack`，指针 `j` 遍历 `needle`。
    - 如果 `haystack[i] == needle[j]`，则 `i++`, `j++`。
    - 如果 `haystack[i] != needle[j]`，我们不需要回退 `i`，而是查询 `next` 数组，将 `j` 更新为 `next[j-1]`。这意味着 `needle` 向右移动，对齐到上一个最长相等前缀的后面，继续比较。

**复杂度分析：**

- **时间复杂度：** $O(n + m)$。生成 `next` 数组需要 $O(m)$，匹配过程需要 $O(n)$。这比暴力法快得多。
- **空间复杂度：** $O(m)$，需要一个长度为 $m$ 的数组来存储前缀表。

**代码片段：**

```java
public int strStr(String haystack, String needle) {
    if (needle.length() == 0) return 0;

    int[] next = new int[needle.length()];
    getNext(next, needle);

    int j = 0;
    for (int i = 0; i < haystack.length(); i++) {
        // 发生不匹配，j 回退到 next[j-1]
        while (j > 0 && haystack.charAt(i) != needle.charAt(j)) {
            j = next[j - 1];
        }
        // 匹配成功，j 前进
        if (haystack.charAt(i) == needle.charAt(j)) {
            j++;
        }
        // j 到达 needle 末尾，说明完全匹配
        if (j == needle.length()) {
            return i - needle.length() + 1;
        }
    }
    return -1;
}

// 构建 next 数组（最长相等前后缀长度）
private void getNext(int[] next, String s) {
    int j = 0; // j 代表前缀末尾位置，也是当前子串的最长相等前后缀长度
    next[0] = 0;
    for (int i = 1; i < s.length(); i++) { // i 代表后缀末尾位置
        // 前后缀不相同，j 回退
        while (j > 0 && s.charAt(i) != s.charAt(j)) {
            j = next[j - 1];
        }
        // 前后缀相同，j 前进
        if (s.charAt(i) == s.charAt(j)) {
            j++;
        }
        next[i] = j;
    }
}
```

---

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现：KMP 算法
    public static int strStr(String haystack, String needle) {
        if (needle.length() == 0) return 0;

        // 1. 获取 next 数组
        int[] next = new int[needle.length()];
        getNext(next, needle);

        // 2. 开始匹配
        int j = 0; // j 指向 needle
        for (int i = 0; i < haystack.length(); i++) { // i 指向 haystack
            // 如果不匹配，根据 next 数组回退 j，i 不回退
            while (j > 0 && haystack.charAt(i) != needle.charAt(j)) {
                j = next[j - 1];
            }
            // 匹配成功，两个指针同时后移
            if (haystack.charAt(i) == needle.charAt(j)) {
                j++;
            }
            // 如果 j 走到了 needle 的末尾，说明找到了
            if (j == needle.length()) {
                return i - needle.length() + 1;
            }
        }
        return -1;
    }

    // 计算 next 数组（最长相等前后缀表）
    private static void getNext(int[] next, String s) {
        // j: 前缀末尾位置 (同时也是最长相等前后缀的长度)
        // i: 后缀末尾位置
        int j = 0;
        next[0] = 0;
        for (int i = 1; i < s.length(); i++) {
            // 前后缀不匹配，j 寻找之前的最长相等前后缀
            while (j > 0 && s.charAt(i) != s.charAt(j)) {
                j = next[j - 1];
            }
            // 匹配，长度 + 1
            if (s.charAt(i) == s.charAt(j)) {
                j++;
            }
            next[i] = j;
        }
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        String haystack1 = "sadbutsad";
        String needle1 = "sad";

        System.out.println("示例 1 输入: haystack = \"" + haystack1 + "\", needle = \"" + needle1 + "\"");
        System.out.println("示例 1 输出: " + strStr(haystack1, needle1));
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        String haystack2 = "leetcode";
        String needle2 = "leeto";

        System.out.println("示例 2 输入: haystack = \"" + haystack2 + "\", needle = \"" + needle2 + "\"");
        System.out.println("示例 2 输出: " + strStr(haystack2, needle2));

        // --- 额外测试 ---
        System.out.println("-----------------------------");
        String haystack3 = "hello";
        String needle3 = "ll";
        System.out.println("额外测试 输入: haystack = \"" + haystack3 + "\", needle = \"" + needle3 + "\"");
        System.out.println("额外测试 输出: " + strStr(haystack3, needle3));
    }
}
```
