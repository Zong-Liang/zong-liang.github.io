---
title: 88. 合并两个有序数组
date: 2024-03-01 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数组_字符串]
tags: [数组_字符串]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121221327460.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：** 最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

**示例 1:**

- **输入:** `nums1 = [1,2,3,0,0,0]`, `m = 3`, `nums2 = [2,5,6]`, `n = 3`
- **输出:** `[1,2,2,3,5,6]`
- **解释:** 需要合并 `[1,2,3]` 和 `[2,5,6]` 。

  合并结果是 `[1,2,2,3,5,6]`。

**示例 2:**

- **输入:** `nums1 = [1]`, `m = 1`, `nums2 = []`, `n = 0`
- **输出:** `[1]`
- **解释:** 需要合并 `[1]` 和 `[]` 。

  合并结果是 `[1]`。

**示例 3:**

- **输入:** `nums1 = [0]`, `m = 0`, `nums2 = [1]`, `n = 1`
- **输出:** `[1]`
- **解释:** 需要合并 `[]` 和 `[1]` 。

  合并结果是 `[1]`。

  注意，因为 `m = 0` ，所以 `nums1` 中没有元素。`nums1` 中仅存的 `0` 仅仅是为了确保合并结果可以顺利存放到 `nums1` 中。

**提示:**

- `nums1.length == m + n`
- `nums2.length == n`
- `0 <= m, n <= 200`
- `1 <= m + n <= 200`
- `-10^9 <= nums1[i], nums2[j] <= 10^9`

**进阶：** 你可以设计实现一个时间复杂度为 `O(m + n)` 的算法解决此问题吗？

## 题解

### 标准解法：合并后排序

**思路：**

最直观的方法是将 `nums2` 的所有元素直接拷贝到 `nums1` 的后半部分（即为 `0` 的位置），然后对整个 `nums1` 数组进行排序。

**复杂度分析：**

- 时间复杂度：$O((m+n)\log(m+n))$，主要是排序的开销。
- 空间复杂度：$O(1)$ 或 $O(\log(m+n))$（取决于排序算法的实现细节）。

**代码片段：**

```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
    // 将 nums2 的内容复制到 nums1 的后 n 位
    for (int i = 0; i < n; i++) {
        nums1[m + i] = nums2[i];
    }
    // 对整个 nums1 进行排序
    Arrays.sort(nums1);
}
```

### 进阶解法：双指针（从后向前）

**思路：**

因为 `nums1` 和 `nums2` 已经是**有序**的，且 `nums1` 的尾部有足够的空间（值为 0 的部分）。我们可以利用这一特点，**从后向前**进行合并，避免了从前向后合并时需要移动大量元素的问题。

1.  定义三个指针：

    - `p1` 指向 `nums1` 有效数据的末尾（即下标 `m-1`）。
    - `p2` 指向 `nums2` 的末尾（即下标 `n-1`）。
    - `tail` 指向 `nums1` 的最末尾（即下标 `m+n-1`），用于存放当前最大的数。

2.  比较 `nums1[p1]` 和 `nums2[p2]`：

    - 谁大，就将谁放入 `nums1[tail]` 位置。
    - 将对应的指针（`p1` 或 `p2`）向前移动，同时 `tail` 向前移动。

3.  **边界处理**：

    - 如果 `nums1` 的元素先处理完（`p1 < 0`），说明 `nums2` 还有剩余较小的元素，直接将它们拷贝到 `nums1` 的头部。
    - 如果 `nums2` 先处理完（`p2 < 0`），`nums1` 剩余的元素已经在正确位置，无需操作。

**复杂度分析：**

- **时间复杂度：** $O(m+n)$，指针最多移动 $m+n$ 次。
- **空间复杂度：** $O(1)$，原地修改，不使用额外空间。

**代码片段：**

```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
    int p1 = m - 1;
    int p2 = n - 1;
    int tail = m + n - 1;

    // 当两个数组都还有元素没比较完时
    while (p1 >= 0 && p2 >= 0) {
        if (nums1[p1] > nums2[p2]) {
            nums1[tail] = nums1[p1];
            p1--;
        } else {
            nums1[tail] = nums2[p2];
            p2--;
        }
        tail--;
    }

    // 如果 nums2 还有剩余元素（nums1 已经走完了），将 nums2 剩下的填入 nums1 前面
    // 如果是 nums1 剩下了，那它本身就在那里，不需要动
    while (p2 >= 0) {
        nums1[tail] = nums2[p2];
        p2--;
        tail--;
    }
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现（进阶解法）
    public static void merge(int[] nums1, int m, int[] nums2, int n) {
        int p1 = m - 1;      // nums1 有效部分最后元素的索引
        int p2 = n - 1;      // nums2 最后元素的索引
        int tail = m + n - 1; // nums1 总长度最后位置的索引

        // 从后向前遍历，比较并填充最大的元素到 tail 位置
        while (p1 >= 0 && p2 >= 0) {
            if (nums1[p1] > nums2[p2]) {
                nums1[tail] = nums1[p1];
                p1--;
            } else {
                nums1[tail] = nums2[p2];
                p2--;
            }
            tail--;
        }

        // 如果 nums2 还有剩余元素，直接复制到 nums1 前面
        // 此时 nums1 的 p1 已经小于 0，说明 nums1 原有的数都移到后面去了
        while (p2 >= 0) {
            nums1[tail] = nums2[p2];
            p2--;
            tail--;
        }
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1_ex1 = new int[]{1, 2, 3, 0, 0, 0};
        int m1 = 3;
        int[] nums2_ex1 = new int[]{2, 5, 6};
        int n1 = 3;

        System.out.println("示例 1 输入:");
        System.out.println("nums1 = " + Arrays.toString(nums1_ex1) + ", m = " + m1);
        System.out.println("nums2 = " + Arrays.toString(nums2_ex1) + ", n = " + n1);

        merge(nums1_ex1, m1, nums2_ex1, n1);

        System.out.println("示例 1 输出: " + Arrays.toString(nums1_ex1));
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums1_ex2 = new int[]{1};
        int m2 = 1;
        int[] nums2_ex2 = new int[]{};
        int n2 = 0;

        System.out.println("示例 2 输入:");
        System.out.println("nums1 = " + Arrays.toString(nums1_ex2) + ", m = " + m2);
        System.out.println("nums2 = " + Arrays.toString(nums2_ex2) + ", n = " + n2);

        merge(nums1_ex2, m2, nums2_ex2, n2);

        System.out.println("示例 2 输出: " + Arrays.toString(nums1_ex2));
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        int[] nums1_ex3 = new int[]{0};
        int m3 = 0;
        int[] nums2_ex3 = new int[]{1};
        int n3 = 1;

        System.out.println("示例 3 输入:");
        System.out.println("nums1 = " + Arrays.toString(nums1_ex3) + ", m = " + m3);
        System.out.println("nums2 = " + Arrays.toString(nums2_ex3) + ", n = " + n3);

        merge(nums1_ex3, m3, nums2_ex3, n3);

        System.out.println("示例 3 输出: " + Arrays.toString(nums1_ex3));
    }
}
```
