---
title: 230. 二叉搜索树中第K小的元素
date: 2024-08-17 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉搜索树]
tags: [二叉搜索树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232310093.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：230. 二叉搜索树中第 K 小的元素

给定一个二叉搜索树的根节点 `root`，和一个整数 `k`，请你设计一个算法查找其中第 `k` 小的元素（从 1 开始计数）。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)

- **输入:** `root = [3,1,4,null,2]`, `k = 1`
- **输出:** 1

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)

- **输入:** `root = [5,3,6,2,4,null,null,1]`, `k = 3`
- **输出:** 3

**提示:**

- 树中的节点数为 `n`。
- `1 <= k <= n <= 10^4`
- `0 <= Node.val <= 10^4`

**进阶：** 如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 `k` 小的值，你将如何优化算法？

## Java 代码

**算法思路：(中序遍历)**

二叉搜索树的一个基本性质是，它的 **中序遍历** 结果是一个升序序列。因此，第 `k` 小的元素就是中序遍历序列中的第 `k` 个元素。

我们可以通过迭代的方式实现中序遍历，这样可以在找到第 `k` 个元素后立即停止，而不需要遍历整棵树。

1.  **使用栈：** 创建一个栈来辅助遍历。
2.  **迭代中序遍历:**
    a. 从根节点 `root` 开始，只要当前节点不为 `null`，就将其压入栈，并继续向其左子节点移动。
    b. 当到达最左边的节点（`root` 变为 `null`）时，从栈中弹出一个节点。这就是当前中序遍历访问到的节点。
    c. 我们将 `k` 减 1。如果此时 `k` 变为 0，说明当前弹出的节点就是我们要找的第 `k` 小的元素，返回它的值。
    d. 然后，将当前节点转向其右子树，重复步骤 a。

这个过程会按升序访问树的节点，并在访问到第 `k` 个时停止。

```java
import java.util.Stack;

/**
 * 二叉树节点的定义
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val) { this.val = val; }
}


public class Main {

    /**
     * 查找二叉搜索树中第 k 小的元素。
     *
     * @param root 二叉搜索树的根节点
     * @param k    整数 k
     * @return 第 k 小的元素的值
     */
    public static int kthSmallest(TreeNode root, int k) {
        Stack<TreeNode> stack = new Stack<>();

        while (root != null || !stack.isEmpty()) {
            // 1. 将所有左子节点压入栈
            while (root != null) {
                stack.push(root);
                root = root.left;
            }

            // 2. 弹出节点（中序访问）
            root = stack.pop();

            // 3. 计数并检查
            k--;
            if (k == 0) {
                return root.val;
            }

            // 4. 转向右子树
            root = root.right;
        }

        // 理论上不会执行到这里，因为 k 总是在有效范围内
        return -1;
    }


    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        TreeNode root1 = new TreeNode(3);
        root1.left = new TreeNode(1);
        root1.right = new TreeNode(4);
        root1.left.right = new TreeNode(2);
        int k1 = 1;
        System.out.println("输入: root = [3,1,4,null,2], k = " + k1);
        int result1 = kthSmallest(root1, k1);
        System.out.println("输出: " + result1); // 预期输出: 1
        System.out.println();

        System.out.println("--- 示例 2 ---");
        TreeNode root2 = new TreeNode(5);
        root2.left = new TreeNode(3);
        root2.right = new TreeNode(6);
        root2.left.left = new TreeNode(2);
        root2.left.right = new TreeNode(4);
        root2.left.left.left = new TreeNode(1);
        int k2 = 3;
        System.out.println("输入: root = [5,3,6,2,4,null,null,1], k = " + k2);
        int result2 = kthSmallest(root2, k2);
        System.out.println("输出: " + result2); // 预期输出: 3
        System.out.println();

        // 进阶问题讨论：
        // 如果树经常被修改且查询频繁，可以在 TreeNode 结构中增加一个字段，
        // 用于记录其左子树的节点数量。
        // class TreeNodeWithCount {
        //     int val;
        //     int leftCount; // 左子树节点数
        //     TreeNodeWithCount left;
        //     TreeNodeWithCount right;
        // }
        // 这样，在查找第 k 小元素时，可以根据 leftCount 的值来决定是
        // 在左子树、右子树还是当前节点中查找，将查询时间复杂度从 O(n) 降低到 O(H)，其中 H 是树的高度。
        // 当然，这会增加插入和删除操作的复杂性，因为需要维护每个节点的 leftCount。
    }
}
```
