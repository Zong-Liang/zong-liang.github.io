---
title: 230. 二叉搜索树中第K小的元素
date: 2024-08-17 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉搜索树]
tags: [二叉搜索树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232310093.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个二叉搜索树的根节点 `root`，和一个整数 `k`，请你设计一个算法查找其中第 `k` 小的元素（从 1 开始计数）。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)

- **输入:** `root = [3,1,4,null,2]`, `k = 1`
- **输出:** 1

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)

- **输入:** `root = [5,3,6,2,4,null,null,1]`, `k = 3`
- **输出:** 3

**提示:**

- 树中的节点数为 `n`。
- `1 <= k <= n <= 10^4`
- `0 <= Node.val <= 10^4`

**进阶：** 如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 `k` 小的值，你将如何优化算法？

## 题解

### 解法一：中序遍历（迭代法）

**思路：**

二叉搜索树（BST）的一个重要性质是：**中序遍历（左 -> 根 -> 右）的结果是严格递增的有序序列**。

因此，要在 BST 中找第 $k$ 小的元素，我们只需要对树进行中序遍历，并记录已经访问过的节点数量。当我们访问到第 $k$ 个节点时，它的值就是答案。

我们可以使用 **栈（Stack）** 来模拟递归的中序遍历过程，这样可以在找到目标后立即停止，无需遍历整棵树。

1.  **初始化**：创建一个栈，用于存储节点。
2.  **入栈（一直向左）**：从根节点开始，将当前节点及其所有左子节点依次入栈。
3.  **出栈（访问节点）**：弹出栈顶元素，这就是当前遍历到的“最小”节点。

    - 计数器 $k$ 减 1。
    - 如果 $k == 0$，说明当前节点就是第 $k$ 小的元素，直接返回其值。

4.  **转向右子树**：将当前指针指向弹出节点的右子节点，继续循环。

**复杂度分析：**

- **时间复杂度：** $O(H + k)$。其中 $H$ 是树的高度。在最坏情况下（树退化为链表）为 $O(N)$，但在平均情况下，我们不需要遍历完整个树，只需遍历到第 $k$ 个节点。
- **空间复杂度：** $O(H)$。栈的大小取决于树的高度。

**代码片段：**

```java
public int kthSmallest(TreeNode root, int k) {
    Deque<TreeNode> stack = new ArrayDeque<>();
    while (root != null || !stack.isEmpty()) {
        // 1. 一路向左，入栈
        while (root != null) {
            stack.push(root);
            root = root.left;
        }

        // 2. 出栈，访问
        root = stack.pop();
        k--;
        if (k == 0) {
            return root.val;
        }

        // 3. 转向右子树
        root = root.right;
    }
    return -1;
}
```

### 解法二：预统计子树节点数（进阶优化）

**思路：**

题目进阶部分提到：如果 BST 频繁修改（插入/删除）且频繁查找第 $k$ 小的值，该如何优化？

如果是上述 $O(N)$ 或 $O(k)$ 的解法，每次查询都要重新遍历，效率较低。我们可以通过**空间换时间**的方式，在节点中维护额外信息。

1.  **节点定义改造**：在 `TreeNode` 中增加一个字段 `size`，记录**以该节点为根的子树中的节点总数**。
2.  **查找逻辑**：利用 `size` 可以实现类似二分查找的效果（时间复杂度 $O(H)$）。

    - 获取当前节点左子树的节点数 `leftSize`。
    - **情况 A**：如果 `k == leftSize + 1`，说明当前节点正好是第 $k$ 小的，直接返回。
    - **情况 B**：如果 `k <= leftSize`，说明第 $k$ 小的元素在左子树中，递归向左查找。
    - **情况 C**：如果 `k > leftSize + 1`，说明第 $k$ 小的元素在右子树中。此时在右子树中它不再是第 $k$ 小，而是第 `k - (leftSize + 1)` 小，递归向右查找。

3.  **维护成本**：虽然查找变快了，但在插入和删除节点时，需要更新沿途所有祖先节点的 `size` 字段，这会增加写操作的开销，但复杂度仍为 $O(H)$。

**复杂度分析：**

- **时间复杂度：** $O(H)$。对于平衡二叉树（AVL 或 红黑树），$H = \log N$，查询效率极大提升。
- **空间复杂度：** $O(H)$。递归栈深度。

**代码片段（逻辑演示）：**

```java
// 假设 TreeNode 类有一个 int size 字段
public int kthSmallest(TreeNode root, int k) {
    TreeNode curr = root;
    while (curr != null) {
        int leftSize = (curr.left != null) ? curr.left.size : 0;

        if (k == leftSize + 1) {
            return curr.val;
        } else if (k <= leftSize) {
            curr = curr.left;
        } else {
            k = k - (leftSize + 1); // 减去左子树和根节点的数量
            curr = curr.right;
        }
    }
    return -1;
}
```

### 完整代码

这里提供**解法一（迭代法）**的完整可运行代码，这是在 LeetCode 现有接口下最通用的标准解法。

```java
import java.util.*;

// 二叉树节点定义
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

public class Main {

    // 核心算法实现：迭代法中序遍历
    public static int kthSmallest(TreeNode root, int k) {
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode curr = root;

        while (curr != null || !stack.isEmpty()) {
            // 步骤 1: 将当前节点及左子树沿途入栈
            while (curr != null) {
                stack.push(curr);
                curr = curr.left;
            }

            // 步骤 2: 弹出栈顶节点（当前子树最左/最小）
            curr = stack.pop();
            k--; // 找到一个小的，计数减一

            // 如果 k 减到 0，说明当前弹出的就是第 k 小
            if (k == 0) {
                return curr.val;
            }

            // 步骤 3: 转向右子树
            curr = curr.right;
        }
        return -1; // 理论上不会走到这里
    }

    // 辅助方法：构建二叉树（层序遍历数组转树）
    public static TreeNode buildTree(Integer[] arr) {
        if (arr.length == 0) return null;
        TreeNode root = new TreeNode(arr[0]);
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        int i = 1;
        while (i < arr.length) {
            TreeNode t = q.poll();
            if (i < arr.length && arr[i] != null) {
                t.left = new TreeNode(arr[i]);
                q.add(t.left);
            }
            i++;
            if (i < arr.length && arr[i] != null) {
                t.right = new TreeNode(arr[i]);
                q.add(t.right);
            }
            i++;
        }
        return root;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        // 输入: root = [3,1,4,null,2], k = 1
        Integer[] nums1 = {3, 1, 4, null, 2};
        TreeNode root1 = buildTree(nums1);
        int k1 = 1;

        System.out.println("示例 1 输入: root = [3,1,4,null,2], k = 1");
        System.out.println("示例 1 输出: " + kthSmallest(root1, k1)); // 预期 1
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        // 输入: root = [5,3,6,2,4,null,null,1], k = 3
        Integer[] nums2 = {5, 3, 6, 2, 4, null, null, 1};
        TreeNode root2 = buildTree(nums2);
        int k2 = 3;

        System.out.println("示例 2 输入: root = [5,3,6,2,4,null,null,1], k = 3");
        System.out.println("示例 2 输出: " + kthSmallest(root2, k2)); // 预期 3
    }
}
```
