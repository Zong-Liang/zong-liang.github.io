---
title: 98. 验证二叉搜索树
date: 2024-08-20 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉搜索树]
tags: [二叉搜索树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232336323.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个二叉树的根节点 `root`，判断其是否是一个 **有效** 的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **严格小于** 当前节点的数。
- 节点的右子树只包含 **严格大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)

- **输入:** `root = [2,1,3]`
- **输出:** `true`

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)

- **输入:** `root = [5,1,4,null,null,3,6]`
- **输出:** `false`
- **解释:** 根节点的值是 5，但是右子节点的值是 4。

**提示:**

- 树中节点数目范围在 `[1, 10^4]` 内
- `-2^31 <= Node.val <= 2^31 - 1`

## 题解

### 解法一：中序遍历（递归/迭代）

**思路：**

这是验证二叉搜索树（BST）最直观的方法。二叉搜索树的一个重要性质是：**二叉搜索树的中序遍历（左 -> 根 -> 右）结果一定是一个严格升序的序列**。

我们可以利用这个性质：

1.  对树进行中序遍历。
2.  记录遍历过程中 **前一个节点 (`pre`)** 的值。
3.  在遍历当前节点时，检查 **当前节点值** 是否 **严格大于** **前一个节点值**。
4.  如果任何时候不满足 `root.val > pre.val`，则说明不是有效的 BST，返回 `false`。
5.  遍历结束如果没有发现问题，返回 `true`。

**注意**：由于节点值可能是 `Integer.MIN_VALUE`，为了避免初始值的比较逻辑出错，我们可以使用一个 `long` 类型的变量来存储 `pre`，或者使用一个 `TreeNode` 引用来记录 `pre` 节点。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是二叉树的节点数。我们需要遍历每一个节点。
- **空间复杂度：** $O(height)$，也就是递归栈的深度。

**代码片段：**

```java
long pre = Long.MIN_VALUE; // 使用 long 避免 int 边界问题

public boolean isValidBST(TreeNode root) {
    if (root == null) {
        return true;
    }
    // 1. 访问左子树
    if (!isValidBST(root.left)) {
        return false;
    }
    // 2. 访问当前节点：如果当前节点小于等于前一个节点，则非法
    if (root.val <= pre) {
        return false;
    }
    pre = root.val;
    // 3. 访问右子树
    return isValidBST(root.right);
}
```

### 解法二：递归 + 区间范围（定义法）

**思路：**

根据 BST 的定义，对于树中的任意节点 `root`，它的值必须严格大于左子树所有节点的值，且严格小于右子树所有节点的值。

我们可以设计一个辅助函数 `isValid(root, lower, upper)`，表示以 `root` 为根的子树，其所有节点的值必须在 `(lower, upper)` 开区间内。

1.  **初始调用**：`isValid(root, -∞, +∞)`。
2.  **递归逻辑**：

    - 如果 `root` 为空，返回 `true`。
    - 如果 `root.val` 不在 `(lower, upper)` 范围内（即 `val <= lower` 或 `val >= upper`），返回 `false`。
    - 递归验证左子树：左子树的上界变为当前节点值，即 `isValid(root.left, lower, root.val)`。
    - 递归验证右子树：右子树的下界变为当前节点值，即 `isValid(root.right, root.val, upper)`。

**注意**：同样为了防止整数溢出（例如节点值为 `Integer.MAX_VALUE`），边界值应使用 `Long` 类型。

**复杂度分析：**

- **时间复杂度：** $O(n)$。
- **空间复杂度：** $O(height)$。

**代码片段：**

```java
public boolean isValidBST(TreeNode root) {
    return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);
}

public boolean validate(TreeNode node, long lower, long upper) {
    if (node == null) {
        return true;
    }
    // 当前节点必须在 (lower, upper) 之间
    if (node.val <= lower || node.val >= upper) {
        return false;
    }
    // 递归检查左右子树，同时更新上下界
    return validate(node.left, lower, node.val) && validate(node.right, node.val, upper);
}
```

### 完整代码

```java
import java.util.ArrayList;
import java.util.List;

public class Main {

    // Definition for a binary tree node.
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode() {}
        TreeNode(int val) { this.val = val; }
        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    // 核心算法实现：解法一（中序遍历，推荐，代码结构清晰）
    // 使用全局变量记录前一个节点的值
    static long preValue = Long.MIN_VALUE;

    public static boolean isValidBST(TreeNode root) {
        // 每次调用前重置全局变量（防止多组测试用例干扰）
        preValue = Long.MIN_VALUE;
        return inorder(root);
    }

    private static boolean inorder(TreeNode node) {
        if (node == null) {
            return true;
        }

        // 1. 递归遍历左子树
        if (!inorder(node.left)) {
            return false;
        }

        // 2. 处理当前节点
        // 如果当前节点值 <= 前一个节点值，说明不是升序，不合法
        if (node.val <= preValue) {
            return false;
        }
        preValue = node.val;

        // 3. 递归遍历右子树
        return inorder(node.right);
    }

    // 核心算法实现：解法二（区间范围递归）
    public static boolean isValidBSTRange(TreeNode root) {
        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    private static boolean validate(TreeNode node, long min, long max) {
        if (node == null) return true;

        if (node.val <= min || node.val >= max) {
            return false;
        }

        return validate(node.left, min, node.val)
            && validate(node.right, node.val, max);
    }


    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        // 输入: root = [2,1,3]
        TreeNode root1 = new TreeNode(2);
        root1.left = new TreeNode(1);
        root1.right = new TreeNode(3);

        System.out.println("示例 1 输入: [2,1,3]");
        System.out.println("输出 (中序法): " + isValidBST(root1)); // 预期: true
        System.out.println("输出 (区间法): " + isValidBSTRange(root1));
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        // 输入: root = [5,1,4,null,null,3,6]
        // 结构:   5
        //       /   \
        //      1     4
        //           / \
        //          3   6
        // 解释: 根节点是 5，但右子树中有 4 (4 < 5)，不合法。
        TreeNode root2 = new TreeNode(5);
        root2.left = new TreeNode(1);
        root2.right = new TreeNode(4);
        root2.right.left = new TreeNode(3);
        root2.right.right = new TreeNode(6);

        System.out.println("示例 2 输入: [5,1,4,null,null,3,6]");
        System.out.println("输出 (中序法): " + isValidBST(root2)); // 预期: false
        System.out.println("输出 (区间法): " + isValidBSTRange(root2));
        System.out.println("-----------------------------");

        // --- 示例 3 测试 (边界值) ---
        // 输入: [Integer.MAX_VALUE]
        TreeNode root3 = new TreeNode(Integer.MAX_VALUE);
        System.out.println("示例 3 输入: [2147483647]");
        System.out.println("输出 (中序法): " + isValidBST(root3)); // 预期: true
        System.out.println("输出 (区间法): " + isValidBSTRange(root3));
    }
}
```
