---
title: 98-验证二叉搜索树
date: 2024-08-20 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉搜索树]
tags: [二叉搜索树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232336323.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


### 题目：98. 验证二叉搜索树

给你一个二叉树的根节点 `root`，判断其是否是一个 **有效** 的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **严格小于** 当前节点的数。
- 节点的右子树只包含 **严格大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

---

**示例 1:**
![示例1图片](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)

- **输入:** `root = [2,1,3]`
- **输出:** `true`

**示例 2:**
![示例2图片](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)

- **输入:** `root = [5,1,4,null,null,3,6]`
- **输出:** `false`
- **解释:** 根节点的值是 5，但是右子节点的值是 4。

---

**提示:**

- 树中节点数目范围在 `[1, 10^4]` 内
- `-2^31 <= Node.val <= 2^31 - 1`

---

### Java 8 解答 (赛码网格式)

**算法思路 1：(递归 - 范围检查)**
一个常见的误区是只检查 `node.left.val < node.val` 和 `node.right.val > node.val`。这是不够的，因为必须保证左子树的 **所有** 节点都小于当前节点，右子树的 **所有** 节点都大于当前节点。

一个正确的递归方法是，在递归时传递当前子树所有节点必须满足的有效范围 `(min, max)`。

1.  **递归函数:** 定义 `isValid(node, min, max)`。
2.  **递归基:** 如果 `node` 为 `null`，它是一个有效的 BST，返回 `true`。
3.  **检查当前节点:**
    - 检查 `node.val` 是否在 `(min, max)` 范围内。如果不在，返回 `false`。
4.  **递归检查子树:**
    - 对左子树，递归调用 `isValid(node.left, min, node.val)`。新的上界是当前节点的值。
    - 对右子树，递归调用 `isValid(node.right, node.val, max)`。新的下界是当前节点的值。
    - 只有当左右子树都有效时，才返回 `true`。

---

**算法思路 2：(中序遍历)**
二叉搜索树的一个关键性质是，它的 **中序遍历** 结果是一个严格递增的序列。我们可以利用这个性质来验证。

1.  对二叉树进行中序遍历。
2.  在遍历过程中，将节点值存入一个列表。
3.  遍历结束后，检查这个列表是否是严格递增的。

或者，我们可以在中序遍历的同时进行检查，而不需要额外的列表存储。我们只需要一个变量 `prev` 来记录前一个访问的节点值。在访问当前节点时，将其值与 `prev` 比较，如果 `node.val <= prev`，则说明不满足递增性，该树不是 BST。

下面的代码使用了更简洁的中序遍历方法。

```java
import java.util.Stack;

/**
 * 二叉树节点的定义
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val) { this.val = val; }
}

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    // 使用一个变量来记录中序遍历中的前一个节点值
    // 使用 Long 类型来处理 Integer.MIN_VALUE 的边界情况
    private long prev = Long.MIN_VALUE;

    /**
     * 判断一个二叉树是否是有效的二叉搜索树 (递归中序遍历)
     */
    public boolean isValidBST_recursive(TreeNode root) {
        if (root == null) {
            return true;
        }
        // 1. 检查左子树
        if (!isValidBST_recursive(root.left)) {
            return false;
        }
        // 2. 检查当前节点
        if (root.val <= prev) {
            return false;
        }
        prev = root.val;
        // 3. 检查右子树
        return isValidBST_recursive(root.right);
    }

    /**
     * 判断一个二叉树是否是有效的二叉搜索树 (迭代中序遍历) - 这是更常用的实现
     */
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        Stack<TreeNode> stack = new Stack<>();
        long inorder = Long.MIN_VALUE;

        while (!stack.isEmpty() || root != null) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            // 如果当前节点值小于或等于前一个中序遍历的值，则不是BST
            if (root.val <= inorder) {
                return false;
            }
            inorder = root.val;
            root = root.right;
        }
        return true;
    }


    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        TreeNode root1 = new TreeNode(2);
        root1.left = new TreeNode(1);
        root1.right = new TreeNode(3);
        System.out.println("输入: root = [2,1,3]");
        boolean result1 = solution.isValidBST(root1);
        System.out.println("输出: " + result1); // 预期输出: true
        System.out.println();

        System.out.println("--- 示例 2 ---");
        solution.prev = Long.MIN_VALUE; // 重置 prev 以便再次使用递归方法 (如果选择的话)
        TreeNode root2 = new TreeNode(5);
        root2.left = new TreeNode(1);
        root2.right = new TreeNode(4);
        root2.right.left = new TreeNode(3);
        root2.right.right = new TreeNode(6);
        System.out.println("输入: root = [5,1,4,null,null,3,6]");
        boolean result2 = solution.isValidBST(root2);
        System.out.println("输出: " + result2); // 预期输出: false
    }
}
```
