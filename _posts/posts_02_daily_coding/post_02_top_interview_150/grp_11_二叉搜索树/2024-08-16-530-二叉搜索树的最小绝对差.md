---
title: 530. 二叉搜索树的最小绝对差
date: 2024-08-16 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉搜索树]
tags: [二叉搜索树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232244806.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个二叉搜索树的根节点 `root`，返回 **树中任意两不同节点值之间的最小差值**。

差值是一个正数，其数值等于两值之差的绝对值。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg)

- **输入:** `root = [4,2,6,1,3]`
- **输出:** 1

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg)

- **输入:** `root = [1,0,48,null,null,12,49]`
- **输出:** 1

**提示:**

- 树中节点的数目范围是 `[2, 10^4]`
- `0 <= Node.val <= 10^5`

**注意：** 本题与 783. 二叉搜索树节点间的最小距离 相同。

## 题解

### 解法一：中序遍历（递归）

**思路：**

二叉搜索树（BST）的一个重要特性是：**二叉搜索树的中序遍历得到的是一个升序序列**。

题目要求计算任意两不同节点值之间的最小差值。在一个有序数组中，最小的差值一定出现在 **相邻** 的两个元素之间。

因此，我们不需要将所有节点存储下来并排序，只需要在 **中序遍历** 的过程中，比较 **当前节点值** 和 **上一个遍历到的节点值 (`prev`)** 的差值，并持续更新全局最小值即可。

1.  **初始化**：

    - `minDiff`：记录最小差值，初始设为 `Integer.MAX_VALUE`。
    - `prev`：记录中序遍历中上一个访问的节点值，初始为 `null`。

2.  **递归流程**：

    - 递归遍历左子树。
    - **处理当前节点**：如果 `prev` 不为空，计算 `root.val - prev`，并尝试更新 `minDiff`。然后更新 `prev = root.val`。
    - 递归遍历右子树。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 为二叉树的节点数。我们需要遍历每一个节点。
- **空间复杂度：** $O(height)$，其中 $height$ 为二叉树的高度。主要消耗递归栈的空间，平均情况为 $O(\log n)$，最坏情况（链状）为 $O(n)$。

**代码片段：**

```java
int minDiff = Integer.MAX_VALUE;
Integer prev = null;

public int getMinimumDifference(TreeNode root) {
    dfs(root);
    return minDiff;
}

private void dfs(TreeNode node) {
    if (node == null) return;

    // 左
    dfs(node.left);

    // 中（处理逻辑）
    if (prev != null) {
        minDiff = Math.min(minDiff, node.val - prev);
    }
    prev = node.val;

    // 右
    dfs(node.right);
}
```

### 解法二：中序遍历（迭代/栈）

**思路：**

逻辑与递归法完全一致，只是使用 **栈** 来显式模拟递归过程。这在树深度非常深导致递归爆栈时很有用。

**复杂度分析：**

- **时间复杂度：** $O(n)$。
- **空间复杂度：** $O(height)$，栈中存储的节点数量。

**代码片段：**

```java
public int getMinimumDifference(TreeNode root) {
    int minDiff = Integer.MAX_VALUE;
    Integer prev = null;
    Deque<TreeNode> stack = new ArrayDeque<>();
    TreeNode cur = root;

    while (cur != null || !stack.isEmpty()) {
        // 一路向左
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        // 弹出栈顶
        cur = stack.pop();

        // 处理逻辑
        if (prev != null) {
            minDiff = Math.min(minDiff, cur.val - prev);
        }
        prev = cur.val;

        // 转向右子树
        cur = cur.right;
    }
    return minDiff;
}
```

### 完整代码

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class Main {

    // Definition for a binary tree node.
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode() {}
        TreeNode(int val) { this.val = val; }
        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    // 全局变量用于递归解法
    static int minDiff;
    static Integer prev;

    // 核心算法实现：解法一（递归中序遍历，推荐）
    public static int getMinimumDifference(TreeNode root) {
        minDiff = Integer.MAX_VALUE;
        prev = null;
        inorder(root);
        return minDiff;
    }

    private static void inorder(TreeNode node) {
        if (node == null) {
            return;
        }

        // 1. 递归左子树
        inorder(node.left);

        // 2. 处理当前节点
        if (prev != null) {
            // 计算差值并更新最小值
            minDiff = Math.min(minDiff, node.val - prev);
        }
        // 更新 prev 为当前节点值
        prev = node.val;

        // 3. 递归右子树
        inorder(node.right);
    }

    // 备选算法：解法二（迭代法）
    public static int getMinimumDifferenceIterative(TreeNode root) {
        int result = Integer.MAX_VALUE;
        Integer pre = null;
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode cur = root;

        while (cur != null || !stack.isEmpty()) {
            while (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.pop();

            if (pre != null) {
                result = Math.min(result, cur.val - pre);
            }
            pre = cur.val;

            cur = cur.right;
        }
        return result;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        // 输入: root = [4,2,6,1,3]
        TreeNode root1 = new TreeNode(4);
        root1.left = new TreeNode(2);
        root1.right = new TreeNode(6);
        root1.left.left = new TreeNode(1);
        root1.left.right = new TreeNode(3);

        System.out.println("示例 1 输入: [4,2,6,1,3]");
        System.out.println("示例 1 输出: " + getMinimumDifference(root1)); // 预期: 1 (2-1=1 或 3-2=1 等)
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        // 输入: root = [1,0,48,null,null,12,49]
        TreeNode root2 = new TreeNode(1);
        root2.left = new TreeNode(0);
        root2.right = new TreeNode(48);
        root2.right.left = new TreeNode(12);
        root2.right.right = new TreeNode(49);

        System.out.println("示例 2 输入: [1,0,48,null,null,12,49]");
        System.out.println("示例 2 输出: " + getMinimumDifference(root2)); // 预期: 1 (1-0=1 或 49-48=1)
        System.out.println("-----------------------------");

        // --- 示例 3 测试 (迭代法) ---
        // 输入: root = [236, 104, 701, null, 227, null, 911]
        TreeNode root3 = new TreeNode(236);
        root3.left = new TreeNode(104);
        root3.right = new TreeNode(701);
        root3.left.right = new TreeNode(227);
        root3.right.right = new TreeNode(911);

        System.out.println("示例 3 (迭代法) 输入: [236, 104, 701, null, 227, null, 911]");
        // 排序后: 104, 227, 236, 701, 911
        // 差值: 123, 9, 465, 210 -> 最小 9
        System.out.println("示例 3 输出: " + getMinimumDifferenceIterative(root3)); // 预期: 9
    }
}
```
