---
title: 530. 二叉搜索树的最小绝对差
date: 2024-08-16 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉搜索树]
tags: [二叉搜索树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232244806.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


## 题目：530. 二叉搜索树的最小绝对差

给你一个二叉搜索树的根节点 `root`，返回 **树中任意两不同节点值之间的最小差值**。

差值是一个正数，其数值等于两值之差的绝对值。



**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg)

- **输入:** `root = [4,2,6,1,3]`
- **输出:** 1

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg)

- **输入:** `root = [1,0,48,null,null,12,49]`
- **输出:** 1


**提示:**

- 树中节点的数目范围是 `[2, 10^4]`
- `0 <= Node.val <= 10^5`

**注意：** 本题与 783. 二叉搜索树节点间的最小距离 相同。


## Java 代码

**算法思路：(中序遍历)**

这道题的关键在于利用 **二叉搜索树 (BST)** 的一个重要性质：**中序遍历** 会得到一个升序的节点序列。

在升序序列中，任意两个节点之间的最小差值必然出现在 **相邻** 的两个节点之间。因此，问题就转化为了：

1.  对 BST 进行中序遍历。
2.  在遍历过程中，维护一个 `prev` 变量来记录前一个节点的值。
3.  每访问一个新节点 `current`，就计算 `current.val - prev.val`，并用这个差值来更新全局的最小差值 `minDiff`。
4.  然后，更新 `prev` 为 `current.val`，继续遍历。

通过这种方式，我们只需要一次遍历就可以找到答案。

```java
/**
 * 二叉树节点的定义
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
}


public class Main {

    // prev 用于记录中序遍历中前一个节点的值
    private Integer prev = null;
    // minDiff 用于记录全局的最小差值
    private int minDiff = Integer.MAX_VALUE;

    /**
     * 计算 BST 中任意两不同节点值之间的最小差值。
     * @param root BST 的根节点
     * @return 最小绝对差
     */
    public int getMinimumDifference(TreeNode root) {
        // 通过中序遍历来解决
        inorderTraversal(root);
        return minDiff;
    }

    /**
     * 递归实现中序遍历
     */
    private void inorderTraversal(TreeNode node) {
        if (node == null) {
            return;
        }

        // 1. 遍历左子树
        inorderTraversal(node.left);

        // 2. 处理当前节点
        if (prev != null) {
            minDiff = Math.min(minDiff, node.val - prev);
        }
        prev = node.val;

        // 3. 遍历右子树
        inorderTraversal(node.right);
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        TreeNode root1 = new TreeNode(4);
        root1.left = new TreeNode(2);
        root1.right = new TreeNode(6);
        root1.left.left = new TreeNode(1);
        root1.left.right = new TreeNode(3);
        System.out.println("输入: root = [4,2,6,1,3]");
        int result1 = solution.getMinimumDifference(root1);
        System.out.println("输出: " + result1); // 预期输出: 1
        System.out.println();

        // --- 为示例 2 重置实例变量 ---
        solution = new Main();

        System.out.println("--- 示例 2 ---");
        TreeNode root2 = new TreeNode(1);
        root2.left = new TreeNode(0);
        root2.right = new TreeNode(48);
        root2.right.left = new TreeNode(12);
        root2.right.right = new TreeNode(49);
        System.out.println("输入: root = [1,0,48,null,null,12,49]");
        int result2 = solution.getMinimumDifference(root2);
        System.out.println("输出: " + result2); // 预期输出: 1
    }
}
```
