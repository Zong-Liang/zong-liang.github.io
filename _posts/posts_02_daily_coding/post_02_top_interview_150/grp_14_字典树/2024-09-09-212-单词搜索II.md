---
title: 212. 单词搜索II
date: 2024-09-09 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 字典树]
tags: [字典树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233112841.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个 `m x n` 二维字符网格 `board` 和一个单词（字符串）列表 `words`，返回所有二维网格上的单词。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)

- **输入:** `board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]]`, `words = ["oath","pea","eat","rain"]`
- **输出:** `["eat","oath"]`

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2020/11/07/search2.jpg)

- **输入:** `board = [["a","b"],["c","d"]]`, `words = ["abcb"]`
- **输出:** `[]`

**提示:**

- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 12`
- `board[i][j]` 是一个小写英文字母
- `1 <= words.length <= 3 * 10^4`
- `1 <= words[i].length <= 10`
- `words[i]` 由小写英文字母组成
- `words` 中的所有字符串互不相同

## 题解

### 解法：回溯算法 + 字典树 (Trie)

**思路：**

这道题是 "单词搜索"（Word Search）的进阶版。如果对列表中的每个单词都分别在网格中进行一次 DFS 搜索，时间复杂度会非常高，因为单词列表可能很长，且许多单词可能有公共前缀。

为了优化搜索过程，我们可以使用 **字典树 (Trie/Prefix Tree)**。

1.  **构建 Trie**：首先将 `words` 列表中的所有单词插入到 Trie 中。

    - 优化点：在 Trie 的节点中存储完整的单词（`word` 字段），而不是仅标记 `isEnd`。这样当我们在网格中搜索到该节点时，可以直接获取对应的单词，而不需要从根节点重新构建字符串。

2.  **全局搜索**：遍历网格的每一个单元格 `(i, j)`，如果该单元格的字符存在于 Trie 的根节点的子节点中，则从该位置开始进行 DFS。
3.  **DFS (回溯)**：

    - **状态**：当前坐标 `(i, j)` 和当前所在的 Trie 节点 `node`。
    - **剪枝**：如果当前字符匹配上了 Trie 节点的一个子节点，移动到该子节点。
    - **收集结果**：如果当前 Trie 节点包含一个单词（`node.word != null`），说明我们在网格中找到了一个完整的单词。将其加入结果集，并将 `node.word` 置为 `null`（防止同一个单词被重复添加）。
    - **标记访问**：为了防止在当前路径中重复使用单元格，将当前单元格的字符临时修改为特殊字符（如 `#`）。
    - **递归**：向上下左右四个方向继续递归搜索。
    - **回溯**：递归返回后，将单元格字符还原。

**复杂度分析：**

- **时间复杂度：** $O(M \times N \times 4^L)$。其中 $M, N$ 是网格的宽和高，$L$ 是单词的最大长度。虽然理论上最坏情况是指数级，但由于 Trie 的剪枝作用，实际运行速度非常快。构建 Trie 的时间为 $O(K)$, $K$ 为所有单词字符总数。
- **空间复杂度：** $O(K)$。主要用于存储 Trie。递归栈的深度最大为 $L$。

**代码片段：**

```java
class Solution {
    class TrieNode {
        String word;
        TrieNode[] children = new TrieNode[26];
    }

    public List<String> findWords(char[][] board, String[] words) {
        // 1. 构建 Trie
        TrieNode root = new TrieNode();
        for (String w : words) {
            TrieNode node = root;
            for (char c : w.toCharArray()) {
                int idx = c - 'a';
                if (node.children[idx] == null) node.children[idx] = new TrieNode();
                node = node.children[idx];
            }
            node.word = w; // 在叶子节点存储完整单词
        }

        List<String> res = new ArrayList<>();
        // 2. 遍历网格
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                dfs(board, i, j, root, res);
            }
        }
        return res;
    }

    private void dfs(char[][] board, int i, int j, TrieNode node, List<String> res) {
        // 边界检查或已访问检查
        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] == '#') return;

        char c = board[i][j];
        int idx = c - 'a';

        // 如果 Trie 中没有该路径，剪枝
        if (node.children[idx] == null) return;

        node = node.children[idx];
        // 找到单词
        if (node.word != null) {
            res.add(node.word);
            node.word = null; // 去重关键：找到后置空，防止同一单词多次添加
        }

        // 标记已访问
        board[i][j] = '#';

        // 递归四个方向
        dfs(board, i + 1, j, node, res);
        dfs(board, i - 1, j, node, res);
        dfs(board, i, j + 1, node, res);
        dfs(board, i, j - 1, node, res);

        // 回溯：还原字符
        board[i][j] = c;
    }
}
```

### 完整代码

```java
import java.util.ArrayList;
import java.util.List;

public class Main {

    static class Solution {
        // 定义 Trie 节点
        class TrieNode {
            String word; // 存储完整单词，标志单词结束
            TrieNode[] children = new TrieNode[26];
        }

        // 构建 Trie
        private TrieNode buildTrie(String[] words) {
            TrieNode root = new TrieNode();
            for (String w : words) {
                TrieNode node = root;
                for (char c : w.toCharArray()) {
                    int idx = c - 'a';
                    if (node.children[idx] == null) {
                        node.children[idx] = new TrieNode();
                    }
                    node = node.children[idx];
                }
                node.word = w; // 在结尾处保存单词
            }
            return root;
        }

        public List<String> findWords(char[][] board, String[] words) {
            List<String> res = new ArrayList<>();
            TrieNode root = buildTrie(words);

            for (int i = 0; i < board.length; i++) {
                for (int j = 0; j < board[0].length; j++) {
                    // 从每个格子尝试开始搜索
                    dfs(board, i, j, root, res);
                }
            }
            return res;
        }

        private void dfs(char[][] board, int i, int j, TrieNode node, List<String> res) {
            // 边界检查：越界或当前格子已在路径中被使用('#')
            if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] == '#') {
                return;
            }

            char c = board[i][j];
            int idx = c - 'a';

            // 如果当前字符不在 Trie 的当前节点子节点中，说明路径不匹配，剪枝
            if (node.children[idx] == null) {
                return;
            }

            // 移动到子节点
            node = node.children[idx];

            // 检查是否找到单词
            if (node.word != null) {
                res.add(node.word);
                // 关键操作：找到单词后将 Trie 中的引用置空，防止后续重复搜索到该单词
                node.word = null;
            }

            // 标记当前格子已访问
            board[i][j] = '#';

            // 向四个方向递归
            dfs(board, i + 1, j, node, res);
            dfs(board, i - 1, j, node, res);
            dfs(board, i, j + 1, node, res);
            dfs(board, i, j - 1, node, res);

            // 回溯：恢复当前格子的字符
            board[i][j] = c;
        }
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // --- 示例 1 测试 ---
        char[][] board1 = {
            {'o', 'a', 'a', 'n'},
            {'e', 't', 'a', 'e'},
            {'i', 'h', 'k', 'r'},
            {'i', 'f', 'l', 'v'}
        };
        String[] words1 = {"oath", "pea", "eat", "rain"};

        System.out.println("示例 1 输出: " + solution.findWords(board1, words1));
        // 预期: [oath, eat] (顺序可能不同)
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        char[][] board2 = {
            {'a', 'b'},
            {'c', 'd'}
        };
        String[] words2 = {"abcb"};

        System.out.println("示例 2 输出: " + solution.findWords(board2, words2));
        // 预期: []
        System.out.println("-----------------------------");

        // --- 示例 3 测试 (相同前缀) ---
        char[][] board3 = {
            {'a', 'p', 'p'},
            {'p', 'l', 'e'}
        };
        String[] words3 = {"app", "apple"};
        System.out.println("示例 3 输出: " + solution.findWords(board3, words3));
        // 预期: [app, apple]
    }
}
```
