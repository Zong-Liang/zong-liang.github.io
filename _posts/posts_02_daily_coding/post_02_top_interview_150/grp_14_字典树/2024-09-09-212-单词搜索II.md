---
title: 212. 单词搜索II
date: 2024-09-09 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 字典树]
tags: [字典树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233112841.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：212. 单词搜索 II

给定一个 `m x n` 二维字符网格 `board` 和一个单词（字符串）列表 `words`，返回所有二维网格上的单词。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)

- **输入:** `board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]]`, `words = ["oath","pea","eat","rain"]`
- **输出:** `["eat","oath"]`

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2020/11/07/search2.jpg)

- **输入:** `board = [["a","b"],["c","d"]]`, `words = ["abcb"]`
- **输出:** `[]`

**提示:**

- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 12`
- `board[i][j]` 是一个小写英文字母
- `1 <= words.length <= 3 * 10^4`
- `1 <= words[i].length <= 10`
- `words[i]` 由小写英文字母组成
- `words` 中的所有字符串互不相同

## Java 代码

**算法思路：(前缀树/Trie + 深度优先搜索 DFS)**

如果对 `words` 列表中的每个单词都执行一次“单词搜索 I”的算法，会导致大量的重复计算和超时。一个高效的解决方案是结合使用 **前缀树** 和 **回溯法**。

1.  **构建前缀树 (Trie):**
    - 将 `words` 列表中的所有单词插入到一个前缀树中。
    - 在前缀树的每个节点中，我们可以额外存储一个 `word` 字段。当一个单词的最后一个字符被插入时，我们将该单词字符串存入对应节点的 `word` 字段。
2.  **DFS 搜索:**
    - 遍历 `board` 上的每一个单元格，以每个单元格为起点，进行深度优先搜索。
    - DFS 函数 `dfs(row, col, parentNode)` 会接收当前坐标和其在前缀树中对应的父节点。
    - 在 DFS 内部：
      a. 首先进行边界检查和状态检查。
      b. 获取当前字符，并在 `parentNode` 的子节点中查找是否存在匹配的节点 `currentNode`。如果不存在，说明以此路径开头的单词都不在 `words` 列表中，可以直接剪枝返回。
      c. **找到单词:** 如果 `currentNode.word` 不为 null，说明我们从起点到当前位置的路径构成了一个完整的单词。将其加入结果集，并为了避免重复添加，将 `currentNode.word` 设为 `null`。
      d. **回溯:** 标记当前单元格为已访问（例如，修改字符），然后向四个方向递归调用 DFS，传入 `currentNode` 作为新的父节点。
      e. 在递归返回后，恢复当前单元格的状态（取消标记）。

通过这种方式，我们可以在一次 DFS 遍历中，同时查找所有共享相同前缀的单词，极大地提高了效率。

```java
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * 前缀树节点定义
 */
class TrieNode {
    TrieNode[] children = new TrieNode[26];
    String word = null;
}


public class Main {

    public List<String> findWords(char[][] board, String[] words) {
        // 使用 Set 避免重复添加结果
        Set<String> resultSet = new HashSet<>();
        if (board == null || board.length == 0 || words == null || words.length == 0) {
            return new ArrayList<>(resultSet);
        }

        // 1. 构建前缀树
        TrieNode root = new TrieNode();
        for (String word : words) {
            TrieNode node = root;
            for (char c : word.toCharArray()) {
                if (node.children[c - 'a'] == null) {
                    node.children[c - 'a'] = new TrieNode();
                }
                node = node.children[c - 'a'];
            }
            node.word = word;
        }

        // 2. 遍历 board，进行 DFS 搜索
        int m = board.length;
        int n = board[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dfs(board, i, j, root, resultSet);
            }
        }

        return new ArrayList<>(resultSet);
    }

    private void dfs(char[][] board, int row, int col, TrieNode parentNode, Set<String> resultSet) {
        // 边界检查和剪枝
        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) {
            return;
        }
        char c = board[row][col];
        // 如果当前格子已被访问，或者在前缀树中没有对应路径，则返回
        if (c == '#' || parentNode.children[c - 'a'] == null) {
            return;
        }

        TrieNode currentNode = parentNode.children[c - 'a'];

        // 找到了一个单词
        if (currentNode.word != null) {
            resultSet.add(currentNode.word);
            currentNode.word = null; // 避免重复添加
        }

        // --- 回溯过程 ---
        board[row][col] = '#'; // 标记为已访问

        // 向四个方向递归
        dfs(board, row + 1, col, currentNode, resultSet);
        dfs(board, row - 1, col, currentNode, resultSet);
        dfs(board, row, col + 1, currentNode, resultSet);
        dfs(board, row, col - 1, currentNode, resultSet);

        board[row][col] = c; // 恢复状态
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        char[][] board1 = {{'o','a','a','n'},{'e','t','a','e'},{'i','h','k','r'},{'i','f','l','v'}};
        String[] words1 = {"oath","pea","eat","rain"};
        System.out.println("输入: board = [...], words = [\"oath\",\"pea\",\"eat\",\"rain\"]");
        List<String> result1 = solution.findWords(board1, words1);
        System.out.println("输出: " + result1); // 预期输出: ["eat", "oath"]
        System.out.println();

        System.out.println("--- 示例 2 ---");
        char[][] board2 = {{'a','b'},{'c','d'}};
        String[] words2 = {"abcb"};
        System.out.println("输入: board = [['a','b'],['c','d']], words = [\"abcb\"]");
        List<String> result2 = solution.findWords(board2, words2);
        System.out.println("输出: " + result2); // 预期输出: []
    }
}
```
