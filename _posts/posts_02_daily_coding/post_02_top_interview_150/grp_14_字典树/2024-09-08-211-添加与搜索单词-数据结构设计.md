---
title: 211. 添加与搜索单词-数据结构设计
date: 2024-09-08 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 字典树]
tags: [字典树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233004158.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：211. 添加与搜索单词 - 数据结构设计

请你设计一个数据结构，支持 **添加新单词** 和 **查找字符串是否与任何先前添加的字符串匹配**。

实现词典类 `WordDictionary`：

- `WordDictionary()` 初始化词典对象
- `void addWord(word)` 将 `word` 添加到数据结构中，之后可以对它进行匹配
- `bool search(word)` 如果数据结构中存在字符串与 `word` 匹配，则返回 `true`；否则，返回 `false`。`word` 中可能包含一些 `'.'`，每个 `.` 都可以表示任何一个字母。

**示例:**

- **输入**
  `["WordDictionary","addWord","addWord","addWord","search","search","search","search"]`
  `[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]`
- **输出**
  `[null,null,null,null,false,true,true,true]`
- **解释**
  ```
  WordDictionary wordDictionary = new WordDictionary();
  wordDictionary.addWord("bad");
  wordDictionary.addWord("dad");
  wordDictionary.addWord("mad");
  wordDictionary.search("pad"); // 返回 False
  wordDictionary.search("bad"); // 返回 True
  wordDictionary.search(".ad"); // 返回 True
  wordDictionary.search("b.."); // 返回 True
  ```

**提示:**

- `1 <= word.length <= 25`
- `addWord` 中的 `word` 由小写英文字母组成
- `search` 中的 `word` 由 `'.'` 或小写英文字母组成
- 最多调用 `10^4` 次 `addWord` 和 `search`

## Java 代码

**算法思路：(前缀树/Trie)**

这个问题非常适合使用 **前缀树 (Trie)** 数据结构来解决，特别是由于 `search` 操作中包含了通配符 `.`。

1.  **数据结构:**
    - 我们定义一个 `TrieNode` 类，它包含一个指向 26 个子节点的数组（代表 'a' 到 'z'）和一个布尔标记 `isEndOfWord`，用于表示当前节点是否是一个完整单词的结尾。
2.  **`addWord(word)`:**
    - 这个操作是标准的前缀树插入。我们从根节点开始，遍历 `word` 中的每个字符。对于每个字符，我们移动到对应的子节点。如果子节点不存在，就创建一个新的。
    - 当遍历完整个 `word` 后，我们将最后一个节点的 `isEndOfWord` 标记设置为 `true`。
3.  **`search(word)`:**
    - 这是本题的核心。我们需要一个递归的辅助函数来实现带通配符的搜索，例如 `searchHelper(node, word, index)`。
    - **递归基:** 如果 `index` 到达了 `word` 的末尾，我们只需检查当前 `node` 的 `isEndOfWord` 标记是否为 `true`。
    - **处理当前字符:**
      - 如果 `word.charAt(index)` 是一个普通字母，我们就沿着对应的子节点路径继续递归搜索。如果路径不存在，则匹配失败。
      - 如果 `word.charAt(index)` 是通配符 `.`，我们需要 **遍历当前节点的所有非空子节点**，并对每一个子节点递归调用搜索函数。只要有 **任何一个** 分支的搜索成功，就返回 `true`。如果所有分支都失败了，才返回 `false`。

```java
/**
 * 前缀树节点定义
 */
class TrieNode {
    TrieNode[] children;
    boolean isEndOfWord;

    public TrieNode() {
        children = new TrieNode[26];
        isEndOfWord = false;
    }
}

/**
 * LeetCode 的类名是 WordDictionary。
 * 我们可以将逻辑放在 Main 类中并创建一个实例来测试。
 */
class WordDictionary {
    private TrieNode root;

    public WordDictionary() {
        root = new TrieNode();
    }

    public void addWord(String word) {
        TrieNode current = root;
        for (char c : word.toCharArray()) {
            if (current.children[c - 'a'] == null) {
                current.children[c - 'a'] = new TrieNode();
            }
            current = current.children[c - 'a'];
        }
        current.isEndOfWord = true;
    }

    public boolean search(String word) {
        return searchHelper(root, word, 0);
    }

    private boolean searchHelper(TrieNode node, String word, int index) {
        // 递归终止条件
        if (index == word.length()) {
            return node.isEndOfWord;
        }

        char c = word.charAt(index);

        if (c == '.') {
            // 如果是通配符，遍历所有可能的子节点
            for (TrieNode child : node.children) {
                if (child != null && searchHelper(child, word, index + 1)) {
                    return true;
                }
            }
            return false;
        } else {
            // 如果是普通字母，沿着特定路径搜索
            TrieNode child = node.children[c - 'a'];
            if (child == null) {
                return false;
            }
            return searchHelper(child, word, index + 1);
        }
    }
}


public class Main {
    public static void main(String[] args) {
        System.out.println("--- 示例 ---");

        WordDictionary wordDictionary = new WordDictionary();
        System.out.print("[null");

        wordDictionary.addWord("bad");
        System.out.print(", null");

        wordDictionary.addWord("dad");
        System.out.print(", null");

        wordDictionary.addWord("mad");
        System.out.print(", null");

        boolean res1 = wordDictionary.search("pad");
        System.out.print(", " + res1); // false

        boolean res2 = wordDictionary.search("bad");
        System.out.print(", " + res2); // true

        boolean res3 = wordDictionary.search(".ad");
        System.out.print(", " + res3); // true

        boolean res4 = wordDictionary.search("b..");
        System.out.print(", " + res4); // true

        System.out.println("]");
    }
}
```
