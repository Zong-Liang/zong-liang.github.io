---
title: 211. 添加与搜索单词-数据结构设计
date: 2024-09-08 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 字典树]
tags: [字典树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233004158.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

请你设计一个数据结构，支持 **添加新单词** 和 **查找字符串是否与任何先前添加的字符串匹配**。

实现词典类 `WordDictionary`：

- `WordDictionary()` 初始化词典对象
- `void addWord(word)` 将 `word` 添加到数据结构中，之后可以对它进行匹配
- `bool search(word)` 如果数据结构中存在字符串与 `word` 匹配，则返回 `true`；否则，返回 `false`。`word` 中可能包含一些 `'.'`，每个 `.` 都可以表示任何一个字母。

**示例:**

- **输入**

  `["WordDictionary","addWord","addWord","addWord","search","search","search","search"]`

  `[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]`

- **输出**

  `[null,null,null,null,false,true,true,true]`

- **解释**

  ```
  WordDictionary wordDictionary = new WordDictionary();
  wordDictionary.addWord("bad");
  wordDictionary.addWord("dad");
  wordDictionary.addWord("mad");
  wordDictionary.search("pad"); // 返回 False
  wordDictionary.search("bad"); // 返回 True
  wordDictionary.search(".ad"); // 返回 True
  wordDictionary.search("b.."); // 返回 True
  ```

**提示:**

- `1 <= word.length <= 25`
- `addWord` 中的 `word` 由小写英文字母组成
- `search` 中的 `word` 由 `'.'` 或小写英文字母组成
- 最多调用 `10^4` 次 `addWord` 和 `search`

## 题解

### 解法：字典树 (Trie) + 深度优先搜索 (DFS)

**思路：**

这道题是 **Trie (前缀树)** 的典型应用变体。

1.  **添加单词 (`addWord`)**：这部分与普通的 Trie 完全相同。我们构建一颗树，将单词的每个字符作为路径节点插入，并在单词末尾标记 `isEnd = true`。
2.  **查找单词 (`search`)**：

    - 如果单词中只包含普通字母，直接在 Trie 中按照路径向下查找即可。
    - 如果单词中包含 `.`，这代表通配符。当遇到 `.` 时，我们需要尝试当前节点的所有 **非空子节点**。只要其中任何一条路径能匹配剩余的字符串，就返回 `true`。
    - 这种“尝试所有可能性”的逻辑，非常适合使用 **递归 (DFS)** 来实现。

**算法流程：**

1.  定义 `TrieNode` 类，包含 `children` 数组（大小 26）和 `isEnd` 布尔标记。
2.  `addWord`：从根节点开始遍历，不存在子节点就创建，最后标记结束。
3.  `search`：调用辅助递归函数 `dfs(index, node)`。

    - **终止条件**：如果 `index == word.length()`，说明单词匹配完毕，返回 `node.isEnd`。
    - **普通字符**：获取字符索引 `i = ch - 'a'`。如果 `node.children[i]` 为空，返回 `false`；否则递归调用 `dfs(index + 1, node.children[i])`。
    - **通配符 `.`**：遍历 `node.children` 的所有 26 个位置。如果某个位置不为空，尝试递归调用 `dfs(index + 1, child)`。如果任意一个递归返回 `true`，则直接返回 `true`。
    - 如果所有路径都走不通，返回 `false`。

**复杂度分析：**

- **时间复杂度：**

  - `addWord`：$O(L)$，其中 $L$ 是单词长度。
  - `search`：最坏情况下为 $O(26^L)$。这是当单词全为 `.` 时，需要遍历整棵树的所有分支。但由于题目限制 $L \le 25$，且实际字典树比较稀疏，效率通常是可以接受的。

- **空间复杂度：** $O(N \times L)$，其中 $N$ 是插入的单词数量，$L$ 是平均长度。这是 Trie 存储所有单词所需的空间。

**代码片段：**

```java
class WordDictionary {
    private class TrieNode {
        TrieNode[] children = new TrieNode[26];
        boolean isEnd = false;
    }

    private TrieNode root;

    public WordDictionary() {
        root = new TrieNode();
    }

    public void addWord(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (node.children[idx] == null) {
                node.children[idx] = new TrieNode();
            }
            node = node.children[idx];
        }
        node.isEnd = true;
    }

    public boolean search(String word) {
        return dfs(word, 0, root);
    }

    private boolean dfs(String word, int index, TrieNode node) {
        if (index == word.length()) {
            return node.isEnd;
        }

        char c = word.charAt(index);
        if (c == '.') {
            // 通配符：尝试所有可能的子节点
            for (int i = 0; i < 26; i++) {
                if (node.children[i] != null) {
                    if (dfs(word, index + 1, node.children[i])) {
                        return true;
                    }
                }
            }
            return false;
        } else {
            // 普通字符：精确匹配
            int idx = c - 'a';
            if (node.children[idx] == null) {
                return false;
            }
            return dfs(word, index + 1, node.children[idx]);
        }
    }
}
```

### 完整代码

```java
public class Main {

    // 核心算法实现
    static class WordDictionary {

        // 内部节点类
        private class TrieNode {
            TrieNode[] children;
            boolean isEnd;

            public TrieNode() {
                children = new TrieNode[26];
                isEnd = false;
            }
        }

        private TrieNode root;

        public WordDictionary() {
            root = new TrieNode();
        }

        public void addWord(String word) {
            TrieNode node = root;
            for (int i = 0; i < word.length(); i++) {
                char c = word.charAt(i);
                int index = c - 'a';
                if (node.children[index] == null) {
                    node.children[index] = new TrieNode();
                }
                node = node.children[index];
            }
            node.isEnd = true;
        }

        public boolean search(String word) {
            return dfs(word, 0, root);
        }

        // 深度优先搜索处理通配符
        private boolean dfs(String word, int index, TrieNode node) {
            // 递归终止条件：单词遍历完成
            if (index == word.length()) {
                return node.isEnd;
            }

            char c = word.charAt(index);

            if (c == '.') {
                // 如果是 '.'，遍历所有存在的子节点
                for (int i = 0; i < 26; i++) {
                    if (node.children[i] != null) {
                        // 只要有一条路走得通，就返回 true
                        if (dfs(word, index + 1, node.children[i])) {
                            return true;
                        }
                    }
                }
                // 所有路都走不通
                return false;
            } else {
                // 如果是普通字母，查找特定子节点
                int i = c - 'a';
                if (node.children[i] == null) {
                    return false;
                }
                return dfs(word, index + 1, node.children[i]);
            }
        }
    }

    public static void main(String[] args) {
        // --- 示例测试 ---
        WordDictionary wordDictionary = new WordDictionary();

        System.out.println("addWord(\"bad\")");
        wordDictionary.addWord("bad");

        System.out.println("addWord(\"dad\")");
        wordDictionary.addWord("dad");

        System.out.println("addWord(\"mad\")");
        wordDictionary.addWord("mad");

        System.out.println("search(\"pad\") -> " + wordDictionary.search("pad")); // 预期: false
        System.out.println("search(\"bad\") -> " + wordDictionary.search("bad")); // 预期: true
        System.out.println("search(\".ad\") -> " + wordDictionary.search(".ad")); // 预期: true
        System.out.println("search(\"b..\") -> " + wordDictionary.search("b..")); // 预期: true

        System.out.println("-----------------------------");

        // --- 额外测试 ---
        // 测试前缀匹配问题（Trie 中有单词，但搜索长度不符）
        System.out.println("addWord(\"apple\")");
        wordDictionary.addWord("apple");
        System.out.println("search(\"app\") -> " + wordDictionary.search("app"));   // 预期: false (Trie中有apple，但app没标记结束)
        System.out.println("search(\"apple\") -> " + wordDictionary.search("apple")); // 预期: true
        System.out.println("search(\".....\") -> " + wordDictionary.search(".....")); // 预期: true
    }
}
```
