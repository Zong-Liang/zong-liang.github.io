---
title: 208. 实现Trie(前缀树)
date: 2024-09-06 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 字典树]
tags: [字典树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232931038.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

**Trie**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word`。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false`。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix`，返回 `true`；否则，返回 `false`。

**示例：**

- **输入**

  `["Trie", "insert", "search", "search", "startsWith", "insert", "search"]`

  `[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]`

- **输出**

  `[null, null, true, false, true, null, true]`

- **解释**

  ```
  Trie trie = new Trie();
  trie.insert("apple");
  trie.search("apple");   // 返回 True
  trie.search("app");     // 返回 False
  trie.startsWith("app"); // 返回 True
  trie.insert("app");
  trie.search("app");     // 返回 True
  ```

**提示:**

- `1 <= word.length, prefix.length <= 2000`
- `word` 和 `prefix` 仅由小写英文字母组成
- `insert`、`search` 和 `startsWith` 调用次数 **总计** 不超过 `3 * 10^4` 次

## 题解

### 解法：数组实现字典树 (Standard Trie)

**思路：**

Trie（前缀树）是一种树形数据结构，用于高效地存储和检索字符串。它的核心思想是利用字符串的**公共前缀**来减少查询时间，最大限度地减少无谓的字符串比较。

1.  **节点设计 (`TrieNode`)**：

    - 每个节点包含一个大小为 26 的数组 `children`（假设只包含小写字母），用于存储指向子节点的引用。`children[i]` 不为空表示存在字符 `'a' + i` 的路径。
    - 每个节点包含一个布尔值 `isEnd`，表示该节点是否是一个单词的**结尾**。

2.  **初始化 (`Trie`)**：

    - 初始化一个根节点 `root`，根节点不存储字符，仅作为树的入口。

3.  **插入 (`insert`)**：

    - 从 `root` 开始，遍历字符串的每个字符。
    - 如果当前字符对应的子节点不存在，则创建一个新节点。
    - 将指针移动到子节点，继续处理下一个字符。
    - 遍历结束后，将当前节点的 `isEnd` 标记为 `true`。

4.  **查找单词 (`search`)**：

    - 从 `root` 开始，遍历字符串。
    - 如果某个字符对应的子节点不存在，说明单词不存在，返回 `false`。
    - 遍历结束后，检查当前节点的 `isEnd` 标志。只有当 `isEnd` 为 `true` 时，才说明这是一个完整的单词。

5.  **查找前缀 (`startsWith`)**：

    - 逻辑与 `search` 几乎相同。
    - 唯一的区别是，遍历结束后，无论 `isEnd` 是 `true` 还是 `false`，只要能顺利走完路径，就说明前缀存在，直接返回 `true`。

**复杂度分析：**

- **时间复杂度：**

  - `insert`：$O(L)$，其中 $L$ 是插入字符串的长度。
  - `search`：$O(L)$，其中 $L$ 是查询字符串的长度。
  - `startsWith`：$O(L)$，其中 $L$ 是前缀的长度。

- **空间复杂度：** $O(N \times \Sigma)$，其中 $N$ 是所有插入字符串的字符总数，$\Sigma$ 是字符集的大小（这里是 26）。最坏情况下，如果所有单词都没有公共前缀，所有字符都会占用一个节点空间。

**代码片段：**

```java
class Trie {
    // 内部类：Trie 节点
    private class TrieNode {
        private TrieNode[] children;
        private boolean isEnd;

        public TrieNode() {
            children = new TrieNode[26];
            isEnd = false;
        }
    }

    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            int index = c - 'a';
            if (node.children[index] == null) {
                node.children[index] = new TrieNode();
            }
            node = node.children[index];
        }
        node.isEnd = true;
    }

    public boolean search(String word) {
        TrieNode node = searchPrefix(word);
        return node != null && node.isEnd;
    }

    public boolean startsWith(String prefix) {
        TrieNode node = searchPrefix(prefix);
        return node != null;
    }

    // 辅助函数：查找前缀对应的最后一个节点
    private TrieNode searchPrefix(String prefix) {
        TrieNode node = root;
        for (char c : prefix.toCharArray()) {
            int index = c - 'a';
            if (node.children[index] == null) {
                return null;
            }
            node = node.children[index];
        }
        return node;
    }
}
```

### 完整代码

```java
public class Main {

    // 定义 Trie 类
    static class Trie {

        // 定义节点结构
        private class TrieNode {
            // 指向子节点的数组，索引 0-25 代表 a-z
            private TrieNode[] children;
            // 标记该节点是否为某个单词的结束字符
            private boolean isEnd;

            public TrieNode() {
                children = new TrieNode[26];
                isEnd = false;
            }
        }

        private TrieNode root;

        // 初始化前缀树对象
        public Trie() {
            root = new TrieNode();
        }

        // 向前缀树中插入字符串 word
        public void insert(String word) {
            TrieNode node = root;
            for (int i = 0; i < word.length(); i++) {
                char c = word.charAt(i);
                int index = c - 'a';
                // 如果对应子节点为空，新建节点
                if (node.children[index] == null) {
                    node.children[index] = new TrieNode();
                }
                // 指针下移
                node = node.children[index];
            }
            // 单词结束，标记 isEnd
            node.isEnd = true;
        }

        // 查找字符串 word 是否在 trie 中
        public boolean search(String word) {
            TrieNode node = searchPrefix(word);
            // 节点存在且标记为单词结尾，才算找到
            return node != null && node.isEnd;
        }

        // 查找是否有单词以 prefix 为前缀
        public boolean startsWith(String prefix) {
            TrieNode node = searchPrefix(prefix);
            // 只要节点存在，就说明有这个前缀
            return node != null;
        }

        // 辅助方法：沿路径查找，返回最后一个节点，如果路径断开返回 null
        private TrieNode searchPrefix(String prefix) {
            TrieNode node = root;
            for (int i = 0; i < prefix.length(); i++) {
                char c = prefix.charAt(i);
                int index = c - 'a';
                if (node.children[index] == null) {
                    return null;
                }
                node = node.children[index];
            }
            return node;
        }
    }

    public static void main(String[] args) {
        // --- 示例测试 ---
        Trie trie = new Trie();

        System.out.println("Insert \"apple\"");
        trie.insert("apple");

        System.out.println("Search \"apple\": " + trie.search("apple"));   // 预期: true
        System.out.println("Search \"app\": " + trie.search("app"));       // 预期: false (只作为前缀存在，未作为完整单词插入)

        System.out.println("StartsWith \"app\": " + trie.startsWith("app")); // 预期: true

        System.out.println("Insert \"app\"");
        trie.insert("app");

        System.out.println("Search \"app\": " + trie.search("app"));       // 预期: true

        System.out.println("-----------------------------");
        System.out.println("Search \"banana\": " + trie.search("banana")); // 预期: false
        trie.insert("banana");
        System.out.println("Search \"banana\": " + trie.search("banana")); // 预期: true
        System.out.println("StartsWith \"ban\": " + trie.startsWith("ban")); // 预期: true
    }
}
```
