---
title: 208. 实现Trie(前缀树)
date: 2024-09-06 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 字典树]
tags: [字典树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232931038.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：208. 实现 Trie (前缀树)

**Trie**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word`。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false`。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix`，返回 `true`；否则，返回 `false`。

**示例：**

- **输入**
  `["Trie", "insert", "search", "search", "startsWith", "insert", "search"]`
  `[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]`
- **输出**
  `[null, null, true, false, true, null, true]`
- **解释**
  ```
  Trie trie = new Trie();
  trie.insert("apple");
  trie.search("apple");   // 返回 True
  trie.search("app");     // 返回 False
  trie.startsWith("app"); // 返回 True
  trie.insert("app");
  trie.search("app");     // 返回 True
  ```

**提示:**

- `1 <= word.length, prefix.length <= 2000`
- `word` 和 `prefix` 仅由小写英文字母组成
- `insert`、`search` 和 `startsWith` 调用次数 **总计** 不超过 `3 * 10^4` 次

## Java 代码

**算法思路：**

前缀树的核心思想是利用字符串的公共前缀来减少存储和查询开销。

1.  **节点设计 (`TrieNode`):**
    - 每个节点代表一个字符前缀。
    - `children`: 一个大小为 26 的 `TrieNode` 数组，`children[0]` 对应 'a'，`children[1]` 对应 'b'，以此类推。如果某个 `children[i]` 不为 `null`，表示存在以该字符为后续的路径。
    - `isEndOfWord`: 一个布尔标记，用于指示当前节点是否是一个完整单词的结尾。这对于区分 "app" 和 "apple" 这样的情况至关重要。
2.  **`insert(word)`:**
    - 从根节点开始，遍历 `word` 的每个字符。
    - 对于字符 `c`，计算其在 `children` 数组中的索引 `c - 'a'`。
    - 如果 `children[c - 'a']` 为 `null`，则创建一个新的 `TrieNode`。
    - 将当前指针移动到该子节点。
    - 遍历结束后，将最后一个节点的 `isEndOfWord` 设为 `true`。
3.  **`search(word)`:**
    - 与 `insert` 类似地遍历 `word`。
    - 如果在遍历过程中遇到任何一个 `children[c - 'a']` 为 `null`，说明 `word` 不存在，返回 `false`。
    - 遍历结束后，**必须检查** 最后一个节点的 `isEndOfWord` 是否为 `true`。如果不是，说明 `word` 只是一个前缀，而不是一个完整的、被插入过的单词。
4.  **`startsWith(prefix)`:**
    - 与 `search` 非常相似，但有一个关键区别。
    - 遍历 `prefix`，如果在中途路径中断，返回 `false`。
    - 如果成功遍历完整个 `prefix`，**直接返回 `true`**，因为我们不需要关心它是否是一个完整单词的结尾。

```java
/**
 * 前缀树节点定义
 */
class TrieNode {
    TrieNode[] children;
    boolean isEndOfWord;

    public TrieNode() {
        children = new TrieNode[26];
        isEndOfWord = false;
    }
}

/**
 * LeetCode 的类名是 Trie。
 * 我们可以将逻辑放在 Main 类中并创建一个实例来测试。
 */
class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode current = root;
        for (char c : word.toCharArray()) {
            int index = c - 'a';
            if (current.children[index] == null) {
                current.children[index] = new TrieNode();
            }
            current = current.children[index];
        }
        current.isEndOfWord = true;
    }

    public boolean search(String word) {
        TrieNode node = searchPrefix(word);
        return node != null && node.isEndOfWord;
    }

    public boolean startsWith(String prefix) {
        TrieNode node = searchPrefix(prefix);
        return node != null;
    }

    // 辅助函数，用于查找一个单词或前缀的最后一个节点
    private TrieNode searchPrefix(String word) {
        TrieNode current = root;
        for (char c : word.toCharArray()) {
            int index = c - 'a';
            if (current.children[index] == null) {
                return null;
            }
            current = current.children[index];
        }
        return current;
    }
}


public class Main {
    public static void main(String[] args) {
        System.out.println("--- 示例 ---");

        Trie trie = new Trie();
        System.out.print("[null");

        trie.insert("apple");
        System.out.print(", null");

        boolean res1 = trie.search("apple");
        System.out.print(", " + res1); // true

        boolean res2 = trie.search("app");
        System.out.print(", " + res2); // false

        boolean res3 = trie.startsWith("app");
        System.out.print(", " + res3); // true

        trie.insert("app");
        System.out.print(", null");

        boolean res4 = trie.search("app");
        System.out.print(", " + res4); // true

        System.out.println("]");
    }
}
```
