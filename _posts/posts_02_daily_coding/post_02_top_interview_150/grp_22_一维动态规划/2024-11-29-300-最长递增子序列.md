---
title: 300. 最长递增子序列
date: 2024-11-29 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 一维动态规划]
tags: [一维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235926575.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个整数数组 `nums`，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1:**

- **输入:** `nums = [10,9,2,5,3,7,101,18]`
- **输出:** 4
- **解释:** 最长递增子序列是 `[2,3,7,101]`，因此长度为 4。

**示例 2:**

- **输入:** `nums = [0,1,0,3,2,3]`
- **输出:** 4

**示例 3:**

- **输入:** `nums = [7,7,7,7,7,7,7]`
- **输出:** 1

**提示:**

- `1 <= nums.length <= 2500`
- `-10^4 <= nums[i] <= 10^4`

**进阶:**

- 你能将算法的时间复杂度降低到 O(n log(n)) 吗？

## 题解

### 解法一：动态规划 (Dynamic Programming)

**思路：**

这是最基础的解法。我们定义 `dp[i]` 为 **以 `nums[i]` 结尾的最长严格递增子序列的长度**。

1.  **状态定义**：`dp[i]` 表示以第 `i` 个数字结尾的最长上升子序列长度。
2.  **状态转移**：对于每个位置 `i`，我们遍历它前面的所有位置 `j` ($0 \le j < i$)。

    - 如果 `nums[i] > nums[j]`，说明 `nums[i]` 可以接在 `nums[j]` 后面形成更长的子序列。
    - 此时更新 `dp[i] = max(dp[i], dp[j] + 1)`。

3.  **初始化**：每个元素自身至少可以构成一个长度为 1 的子序列，所以 `dp` 数组默认全部初始化为 1。
4.  **结果**：`dp` 数组中的最大值即为所求。

**复杂度分析：**

- **时间复杂度：** $O(n^2)$，使用了双层循环。
- **空间复杂度：** $O(n)$，需要一个 `dp` 数组存储状态。

**代码片段：**

```java
public int lengthOfLIS_DP(int[] nums) {
    if (nums.length == 0) return 0;
    int[] dp = new int[nums.length];
    // 初始化每个位置至少为 1
    Arrays.fill(dp, 1);
    int maxAns = 1;

    for (int i = 1; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            // 只有当前面的数比当前数小，才能接在后面
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        maxAns = Math.max(maxAns, dp[i]);
    }
    return maxAns;
}
```

### 解法二：贪心 + 二分查找 (Greedy + Binary Search) —— 进阶解法

**思路：**

为了达到 $O(n \log n)$ 的复杂度，我们需要一种更高效的方法来构建子序列。核心思想是：**如果我们要让上升子序列尽可能长，那么我们需要让序列上升得尽可能慢**。也就是说，对于同长度的上升子序列，末尾的元素越小越好，这样后面才有更大的空间接纳更多的元素。

1.  维护一个数组 `tails`（或者叫 `d`），其中 `tails[k]` 存储的是 **长度为 `k+1` 的最长上升子序列的最小末尾元素**。

    - 例如，如果长度为 2 的递增子序列有 `[1, 5]` 和 `[2, 3]`，我们选择 `3` 存入 `tails[1]`，因为 3 比 5 小，后面更有可能接上别的数（比如 4）。

2.  遍历 `nums` 中的每个元素 `num`：

    - 如果 `num` 大于 `tails` 中的最后一个元素，说明 `num` 可以接在当前最长的子序列后面，构成更长的子序列。将 `num` 追加到 `tails` 末尾。
    - 如果 `num` 小于或等于 `tails` 的最后一个元素，说明 `num` 不能延长最长子序列，但它可以 **更新** 之前某个长度的子序列结尾，使其变得更小（更有潜力）。我们在 `tails` 中找到 **第一个大于等于 `num`** 的元素，并将其替换为 `num`。

3.  由于 `tails` 数组始终保持严格递增（这也是贪心策略的结果），我们可以使用 **二分查找** 来寻找替换位置。

**复杂度分析：**

- **时间复杂度：** $O(n \log n)$，遍历数组耗时 $O(n)$，内部二分查找耗时 $O(\log n)$。
- **空间复杂度：** $O(n)$，需要维护 `tails` 数组，最坏情况下长度为 $n$。

**代码片段：**

```java
public int lengthOfLIS_BS(int[] nums) {
    // tails[i] 表示长度为 i+1 的最长递增子序列的末尾最小值
    int[] tails = new int[nums.length];
    int len = 0; // 当前 tails 数组的有效长度

    for (int num : nums) {
        int i = 0, j = len;
        // 二分查找：找到第一个 >= num 的位置
        while (i < j) {
            int m = (i + j) / 2;
            if (tails[m] < num) {
                i = m + 1;
            } else {
                j = m;
            }
        }

        // 如果没有找到 >= num 的元素（即 num 比 tails 所有元素都大），i 会等于 len
        // 此时直接追加
        // 否则，用 num 替换掉 tails[i]，让该长度的子序列结尾更小
        tails[i] = num;
        if (len == j) {
            len++;
        }
    }
    return len;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 解法一：动态规划 O(n^2)
    public static int lengthOfLIS_DP(int[] nums) {
        if (nums.length == 0) return 0;
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        int maxAns = 1;

        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxAns = Math.max(maxAns, dp[i]);
        }
        return maxAns;
    }

    // 解法二：贪心 + 二分查找 O(n log n)
    public static int lengthOfLIS_BS(int[] nums) {
        if (nums.length == 0) return 0;

        // tails[i] 存储的是长度为 i+1 的上升子序列的最小结尾元素
        int[] tails = new int[nums.length];
        int res = 0; // 当前最长序列的长度

        for (int num : nums) {
            int i = 0, j = res;
            // 二分查找：在 tails[0...res-1] 中找到第一个 >= num 的数
            while (i < j) {
                int m = (i + j) / 2;
                if (tails[m] < num) {
                    i = m + 1;
                } else {
                    j = m;
                }
            }

            // 将 num 放入 tails[i]
            // 情况1：num 比所有数都大 (i == res)，扩充序列长度
            // 情况2：num 替换掉某个较大的结尾，使序列"潜力"更大
            tails[i] = num;
            if (res == j) {
                res++;
            }
        }
        return res;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1 = {10, 9, 2, 5, 3, 7, 101, 18};
        System.out.println("示例 1 输入: " + Arrays.toString(nums1));
        System.out.println("DP 解法输出: " + lengthOfLIS_DP(nums1));
        System.out.println("二分优化解法输出: " + lengthOfLIS_BS(nums1));
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums2 = {0, 1, 0, 3, 2, 3};
        System.out.println("示例 2 输入: " + Arrays.toString(nums2));
        System.out.println("DP 解法输出: " + lengthOfLIS_DP(nums2));
        System.out.println("二分优化解法输出: " + lengthOfLIS_BS(nums2));
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        int[] nums3 = {7, 7, 7, 7, 7, 7, 7};
        System.out.println("示例 3 输入: " + Arrays.toString(nums3));
        System.out.println("DP 解法输出: " + lengthOfLIS_DP(nums3));
        System.out.println("二分优化解法输出: " + lengthOfLIS_BS(nums3));
    }
}
```
