---
title: 300. 最长递增子序列
date: 2024-11-29 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 一维动态规划]
tags: [一维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235926575.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：300. 最长递增子序列

给你一个整数数组 `nums`，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1:**

- **输入:** `nums = [10,9,2,5,3,7,101,18]`
- **输出:** 4
- **解释:** 最长递增子序列是 `[2,3,7,101]`，因此长度为 4。

**示例 2:**

- **输入:** `nums = [0,1,0,3,2,3]`
- **输出:** 4

**示例 3:**

- **输入:** `nums = [7,7,7,7,7,7,7]`
- **输出:** 1

**提示:**

- `1 <= nums.length <= 2500`
- `-10^4 <= nums[i] <= 10^4`

**进阶:**

- 你能将算法的时间复杂度降低到 O(n log(n)) 吗？

## Java 代码

**算法思路：(O(n log n) - 贪心 + 二分查找)**

为了满足进阶要求，我们不使用传统的 O(n^2) 动态规划，而是采用一种更优化的方法。

我们维护一个名为 `tails` 的数组，其中 `tails[i]` 存储的是所有长度为 `i+1` 的递增子序列中，末尾元素的最小值。这个 `tails` 数组本身一定是递增的。

遍历 `nums` 数组中的每一个数字 `num`：

1.  如果 `num` 大于 `tails` 数组中所有元素，这意味着我们可以将 `num` 接在最长的那个子序列后面，形成一个更长的子序列。我们将 `num` 添加到 `tails` 的末尾，并增加最长子序列的长度。
2.  如果 `num` 不大于 `tails` 数组中所有元素，我们就在 `tails` 数组中通过 **二分查找** 找到第一个大于或等于 `num` 的元素 `tails[i]`，并用 `num` 替换它。这表示我们找到了一个长度为 `i+1` 的、但结尾更小（更有潜力）的递增子序列。

遍历结束后，`tails` 数组的长度就是最长递增子序列的长度。

```java
import java.util.Arrays;


public class Main {

    /**
     * 找到最长严格递增子序列的长度。
     * 时间复杂度 O(n log n)。
     *
     * @param nums 整数数组。
     * @return 最长递增子序列的长度。
     */
    public static int lengthOfLIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        // tails[i] 存储长度为 i+1 的所有递增子序列中末尾元素的最小值
        int[] tails = new int[nums.length];
        // size 表示 tails 数组的有效长度，也即最长递增子序列的当前长度
        int size = 0;

        for (int num : nums) {
            // 使用二分查找在 tails[0...size-1] 中找到 num 的位置
            int i = 0, j = size;
            while (i < j) {
                int m = i + (j - i) / 2;
                if (tails[m] < num) {
                    i = m + 1;
                } else {
                    j = m;
                }
            }

            // 将 num 放在找到的位置上
            // 如果 num 大于所有 tails 中的元素，i 会等于 size，相当于在末尾添加
            // 否则，它会替换掉第一个大于或等于它的元素
            tails[i] = num;

            // 如果 i 等于 size，说明 num 被添加到了 tails 的末尾，
            // 意味着最长子序列的长度增加了 1
            if (i == size) {
                size++;
            }
        }
        return size;
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[] nums1 = {10, 9, 2, 5, 3, 7, 101, 18};
        System.out.println("输入: nums = " + Arrays.toString(nums1));
        int result1 = lengthOfLIS(nums1);
        System.out.println("输出: " + result1); // 预期输出: 4
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[] nums2 = {0, 1, 0, 3, 2, 3};
        System.out.println("输入: nums = " + Arrays.toString(nums2));
        int result2 = lengthOfLIS(nums2);
        System.out.println("输出: " + result2); // 预期输出: 4
        System.out.println();

        System.out.println("--- 示例 3 ---");
        int[] nums3 = {7, 7, 7, 7, 7, 7, 7};
        System.out.println("输入: nums = " + Arrays.toString(nums3));
        int result3 = lengthOfLIS(nums3);
        System.out.println("输出: " + result3); // 预期输出: 1
    }
}
```
