---
title: 139. 单词拆分
date: 2024-11-24 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 一维动态规划]
tags: [一维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235753616.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：** 不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1:**

- **输入:** `s = "leetcode", wordDict = ["leet", "code"]`
- **输出:** `true`
- **解释:** 返回 `true` 因为 `"leetcode"` 可以由 `"leet"` 和 `"code"` 拼接而成。

**示例 2:**

- **输入:** `s = "applepenapple", wordDict = ["apple", "pen"]`
- **输出:** `true`
- **解释:** 返回 `true` 因为 `"applepenapple"` 可以由 `"apple" "pen" "apple"` 拼接而成。注意，你可以重复使用字典中的单词。

**示例 3:**

- **输入:** `s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]`
- **输出:** `false`

**提示:**

- `1 <= s.length <= 300`
- `1 <= wordDict.length <= 1000`
- `1 <= wordDict[i].length <= 20`
- `s` 和 `wordDict[i]` 仅由小写英文字母组成
- `wordDict` 中的所有字符串 **互不相同**

## 题解

### 解法：动态规划 (Dynamic Programming)

**思路：**

这是一个典型的动态规划问题。我们可以将大问题（整个字符串能否拆分）分解为小问题（字符串的前缀能否拆分）。

我们定义一个布尔数组 `dp`，其中 `dp[i]` 表示字符串 `s` 的前 `i` 个字符（即 `s[0..i-1]`）是否都能被字典中的单词拆分。

1.  **状态定义**：

    `dp[i]`：布尔值，表示长度为 `i` 的前缀子串 `s[0...i-1]` 是否可以成功拆分。

2.  **初始状态**：

    `dp[0] = true`。表示空字符串可以被“拆分”（这是一个逻辑上的基准，方便计算）。

3.  **状态转移**：

    对于每一个长度 `i`（从 1 到 `n`），我们需要检查是否存在一个分割点 `j`（`0 <= j < i`），满足以下两个条件：

    1.  `dp[j]` 为 `true`：意味着前半部分 `s[0...j-1]` 已经被成功拆分了。
    2.  `s[j...i-1]` 在字典中：意味着后半部分正好是一个有效的单词。

    如果同时满足这两个条件，那么 `dp[i]` 就为 `true`，并且可以停止检查当前的 `i`，继续计算下一个长度。

    转移方程：

    $$dp[i] = \exists j \in [0, i-1], (dp[j] \land s.substring(j, i) \in wordDict)$$

**优化：**

为了快速判断子串是否存在于字典中，我们需要将 `wordDict` 列表转换为 **哈希集合 (HashSet)**，将查找复杂度从 $O(M)$ 降低到 $O(1)$（实际上取决于字符串哈希和长度，约为 $O(L)$）。

**复杂度分析：**

- **时间复杂度：** $O(n^2)$，其中 $n$ 是字符串 `s` 的长度。我们需要两层循环，外层遍历长度 $i$，内层遍历分割点 $j$。虽然 `substring` 和哈希查找也需要时间，但总体上被认为是 $O(n^2)$ 级别的。
- **空间复杂度：** $O(n)$，需要一个长度为 $n+1$ 的 `dp` 数组。

**代码片段：**

```java
public boolean wordBreak(String s, List<String> wordDict) {
    Set<String> wordSet = new HashSet<>(wordDict);
    int n = s.length();
    boolean[] dp = new boolean[n + 1];
    dp[0] = true; // 空串

    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            // 如果前 j 个字符能拆分，且 j 到 i 的子串存在于字典中
            if (dp[j] && wordSet.contains(s.substring(j, i))) {
                dp[i] = true;
                break; // 只要找到一种拆分方式即可，跳出内层循环
            }
        }
    }
    return dp[n];
}
```

### 完整代码

```java
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class Main {

    /**
     * 139. 单词拆分 - 动态规划解法
     */
    public static boolean wordBreak(String s, List<String> wordDict) {
        // 1. 将 List 转换为 Set，利用哈希表将查找复杂度降为 O(1)
        Set<String> wordSet = new HashSet<>(wordDict);

        int n = s.length();
        // dp[i] 表示 s 的前 i 个字符是否可以被拆分
        boolean[] dp = new boolean[n + 1];

        // 2. 初始化：空字符串默认可以拆分
        dp[0] = true;

        // 3. 遍历所有可能的字符串长度 i (从 1 到 n)
        for (int i = 1; i <= n; i++) {
            // 4. 遍历分割点 j (从 0 到 i-1)
            // 将 s[0...i-1] 分割为 s[0...j-1] 和 s[j...i-1]
            for (int j = 0; j < i; j++) {
                // 判断条件：
                // 1. 前 j 个字符必须能被拆分 (dp[j] == true)
                // 2. 后面的子串 s.substring(j, i) 必须存在于字典中
                if (dp[j] && wordSet.contains(s.substring(j, i))) {
                    dp[i] = true;
                    // 如果找到了一个有效的切分点，当前长度 i 就通过了，
                    // 无需继续尝试其他切分点，直接 break
                    break;
                }
            }
        }

        // 返回 s 的前 n 个字符（即整个字符串）是否可拆分
        return dp[n];
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        String s1 = "leetcode";
        List<String> wordDict1 = Arrays.asList("leet", "code");
        System.out.println("示例 1 输入: s = \"" + s1 + "\", wordDict = " + wordDict1);
        System.out.println("示例 1 输出: " + wordBreak(s1, wordDict1));
        // 解释: dp[4] ("leet") = true, dp[8] = dp[4] && contains("code") = true
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        String s2 = "applepenapple";
        List<String> wordDict2 = Arrays.asList("apple", "pen");
        System.out.println("示例 2 输入: s = \"" + s2 + "\", wordDict = " + wordDict2);
        System.out.println("示例 2 输出: " + wordBreak(s2, wordDict2));
        // 解释: 单词可以重复使用
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        String s3 = "catsandog";
        List<String> wordDict3 = Arrays.asList("cats", "dog", "sand", "and", "cat");
        System.out.println("示例 3 输入: s = \"" + s3 + "\", wordDict = " + wordDict3);
        System.out.println("示例 3 输出: " + wordBreak(s3, wordDict3));
        // 解释: 无法拼出 "og"
        System.out.println("-----------------------------");
    }
}
```
