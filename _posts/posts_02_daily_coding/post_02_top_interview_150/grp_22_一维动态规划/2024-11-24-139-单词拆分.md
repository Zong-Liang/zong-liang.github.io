---
title: 139. 单词拆分
date: 2024-11-24 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 一维动态规划]
tags: [一维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235753616.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：139. 单词拆分

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：** 不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1:**

- **输入:** `s = "leetcode", wordDict = ["leet", "code"]`
- **输出:** `true`
- **解释:** 返回 `true` 因为 `"leetcode"` 可以由 `"leet"` 和 `"code"` 拼接而成。

**示例 2:**

- **输入:** `s = "applepenapple", wordDict = ["apple", "pen"]`
- **输出:** `true`
- **解释:** 返回 `true` 因为 `"applepenapple"` 可以由 `"apple" "pen" "apple"` 拼接而成。注意，你可以重复使用字典中的单词。

**示例 3:**

- **输入:** `s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]`
- **输出:** `false`

**提示:**

- `1 <= s.length <= 300`
- `1 <= wordDict.length <= 1000`
- `1 <= wordDict[i].length <= 20`
- `s` 和 `wordDict[i]` 仅由小写英文字母组成
- `wordDict` 中的所有字符串 **互不相同**

## Java 代码

**算法思路：**

这是一个经典的动态规划问题。我们可以创建一个布尔数组 `dp`，其中 `dp[i]` 表示字符串 `s` 的前 `i` 个字符（即 `s.substring(0, i)`）是否可以被成功拆分。

- **状态定义:** `dp[i]` 表示 `s` 中长度为 `i` 的前缀子串能否被 `wordDict` 中的单词拼接而成。
- **状态转移方程:** 要计算 `dp[i]`，我们需要遍历所有可能的分割点 `j` (从 `0` 到 `i-1`)。如果 `dp[j]` 为 `true`（表示 `s` 的前 `j` 个字符可以被拆分），并且 `s` 从 `j` 到 `i` 的子串 `s.substring(j, i)` 存在于字典中，那么 `dp[i]` 就为 `true`。
- **初始化:** `dp[0]` 应为 `true`，因为它代表一个空字符串，可以被看作是有效的拆分。

为了快速查询字典，我们先将 `wordDict` 列表转换为一个哈希集合（`HashSet`）。

```java
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;


public class Main {

    /**
     * 判断字符串 s 是否可以被字典中的单词拼接而成。
     *
     * @param s        目标字符串。
     * @param wordDict 字典单词列表。
     * @return 如果可以拼接则返回 true，否则返回 false。
     */
    public static boolean wordBreak(String s, List<String> wordDict) {
        // 将 List 转换为 Set 以获得 O(1) 的平均查找时间
        Set<String> wordSet = new HashSet<>(wordDict);
        int n = s.length();

        // dp[i] 表示 s 的前 i 个字符是否可以被拆分
        boolean[] dp = new boolean[n + 1];

        // 初始化：空字符串总是可以被“拆分”
        dp[0] = true;

        // 遍历字符串的所有可能长度
        for (int i = 1; i <= n; i++) {
            // 遍历所有可能的分割点 j
            for (int j = 0; j < i; j++) {
                // 如果 s[0..j-1] 可以被拆分，并且 s[j..i-1] 是一个字典词
                if (dp[j] && wordSet.contains(s.substring(j, i))) {
                    // 那么 s[0..i-1] 就可以被拆分
                    dp[i] = true;
                    // 只要找到一种拆分方式，就可以跳出内层循环
                    break;
                }
            }
        }

        // 返回整个字符串 s 是否可以被拆分
        return dp[n];
    }


    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        String s1 = "leetcode";
        List<String> wordDict1 = Arrays.asList("leet", "code");
        System.out.println("输入: s = \"" + s1 + "\", wordDict = " + wordDict1.toString());
        boolean result1 = wordBreak(s1, wordDict1);
        System.out.println("输出: " + result1); // 预期输出: true
        System.out.println();

        System.out.println("--- 示例 2 ---");
        String s2 = "applepenapple";
        List<String> wordDict2 = Arrays.asList("apple", "pen");
        System.out.println("输入: s = \"" + s2 + "\", wordDict = " + wordDict2.toString());
        boolean result2 = wordBreak(s2, wordDict2);
        System.out.println("输出: " + result2); // 预期输出: true
        System.out.println();

        System.out.println("--- 示例 3 ---");
        String s3 = "catsandog";
        List<String> wordDict3 = Arrays.asList("cats", "dog", "sand", "and", "cat");
        System.out.println("输入: s = \"" + s3 + "\", wordDict = " + wordDict3.toString());
        boolean result3 = wordBreak(s3, wordDict3);
        System.out.println("输出: " + result3); // 预期输出: false
    }
}
```
