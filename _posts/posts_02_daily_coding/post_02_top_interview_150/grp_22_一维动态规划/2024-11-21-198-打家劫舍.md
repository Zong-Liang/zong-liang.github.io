---
title: 198. 打家劫舍
date: 2024-11-21 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 一维动态规划]
tags: [一维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235729047.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：198. 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置** 的情况下，一夜之内能够偷窃到的最高金额。

**示例 1:**

- **输入:** `[1,2,3,1]`
- **输出:** 4
- **解释:** 偷窃 1 号房屋 (金额 = 1)，然后偷窃 3 号房屋 (金额 = 3)。
  偷窃到的最高金额 = 1 + 3 = 4。

**示例 2:**

- **输入:** `[2,7,9,3,1]`
- **输出:** 12
- **解释:** 偷窃 1 号房屋 (金额 = 2)，偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
  偷窃到的最高金额 = 2 + 9 + 1 = 12。

**提示:**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

## 题解

**算法思路：**

这是一个典型的动态规划问题。当我们遍历到第 `i` 间房屋时，我们有两种选择：

1.  **偷窃第 `i` 间房屋**：那么我们就不能偷窃第 `i-1` 间房屋。此时的最大金额是 “到第 `i-2` 间房屋为止能偷到的最大金额” 加上 “第 `i` 间房屋的金额”。
2.  **不偷窃第 `i` 间房屋**：那么此时的最大金额就是 “到第 `i-1` 间房屋为止能偷到的最大金额”。

我们可以用两个变量来迭代地解决这个问题，从而将空间复杂度优化到 O(1)：

- `robbed_prev`: 表示偷窃了前一间房屋能获得的最大金额。
- `skipped_prev`: 表示没偷窃前一间房屋能获得的最大金额。

遍历数组，在每一步更新这两个变量即可。

```java
import java.util.Arrays;


public class Main {

    /**
     * 计算不触动警报装置的情况下，能偷窃到的最高金额。
     *
     * @param nums 代表每个房屋存放金额的数组。
     * @return 能够偷窃到的最高金额。
     */
    public static int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        // `include` 表示到当前房子为止，并且偷了当前房子的最大收益
        // `exclude` 表示到当前房子为止，并且没偷当前房子的最大收益
        int include = 0;
        int exclude = 0;

        for (int num : nums) {
            // 临时保存上一个 `include` 的值，因为它在计算 `newExclude` 时需要
            int prevInclude = include;

            // 如果偷当前房子，那么上一个房子必须不能偷。
            // 所以收益是 `exclude` (没偷上一个房子的最大收益) + 当前房子的金额
            include = exclude + num;

            // 如果不偷当前房子，那么上一个房子可偷可不偷，取二者最大值即可
            exclude = Math.max(prevInclude, exclude);
        }

        // 遍历结束后，比较偷最后一个房子和不偷最后一个房子的最大值
        return Math.max(include, exclude);
    }


    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[] nums1 = {1, 2, 3, 1};
        System.out.println("输入: " + Arrays.toString(nums1));
        int result1 = rob(nums1);
        System.out.println("输出: " + result1); // 预期输出: 4
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[] nums2 = {2, 7, 9, 3, 1};
        System.out.println("输入: " + Arrays.toString(nums2));
        int result2 = rob(nums2);
        System.out.println("输出: " + result2); // 预期输出: 12
        System.out.println();
    }
}
```
