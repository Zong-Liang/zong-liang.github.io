---
title: 198. 打家劫舍
date: 2024-11-21 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 一维动态规划]
tags: [一维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235729047.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置** 的情况下，一夜之内能够偷窃到的最高金额。

**示例 1:**

- **输入:** `[1,2,3,1]`
- **输出:** 4
- **解释:** 偷窃 1 号房屋 (金额 = 1)，然后偷窃 3 号房屋 (金额 = 3)。

  偷窃到的最高金额 = 1 + 3 = 4。

**示例 2:**

- **输入:** `[2,7,9,3,1]`
- **输出:** 12
- **解释:** 偷窃 1 号房屋 (金额 = 2)，偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。

  偷窃到的最高金额 = 2 + 9 + 1 = 12。

**提示:**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

## 题解

### 解法：动态规划 (Dynamic Programming)

**思路：**

这是一个典型的动态规划问题。对于第 `i` 间房屋，我们有两种选择：

1.  **偷窃第 `i` 间房屋**：那么我们就不能偷窃第 `i-1` 间房屋，此时的总金额为“前 `i-2` 间房屋的最高金额”加上“第 `i` 间房屋的金额”。即 `dp[i-2] + nums[i]`。
2.  **不偷窃第 `i` 间房屋**：那么我们可以保持前 `i-1` 间房屋的最高金额。即 `dp[i-1]`。

我们要在这两种选择中取最大值。状态转移方程为：

$$dp[i] = \max(dp[i-1], dp[i-2] + nums[i])$$

为了优化空间复杂度，我们不需要维护整个 `dp` 数组，只需要维护两个变量来记录“前两个状态”的最大值即可（滚动数组思想）。

**复杂度分析：**

- **时间复杂度：** $O(n)$，需要遍历一次数组。
- **空间复杂度：** $O(1)$，只需要常数个变量来存储中间状态。

**代码片段：**

```java
public int rob(int[] nums) {
    if (nums == null || nums.length == 0) return 0;

    // prevMax 代表 dp[i-2]，currMax 代表 dp[i-1]
    int prevMax = 0;
    int currMax = 0;

    for (int num : nums) {
        int temp = Math.max(currMax, prevMax + num);
        prevMax = currMax;
        currMax = temp;
    }
    return currMax;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    /**
     * 198. 打家劫舍 - 动态规划 (空间优化版)
     */
    public static int rob(int[] nums) {
        // 边界条件处理
        if (nums == null || nums.length == 0) {
            return 0;
        }

        // 定义两个变量，分别记录前两步的最优解
        // first: 代表 dp[i-2]，即上上家偷完后的最大值
        // second: 代表 dp[i-1]，即上家偷完后的最大值
        int first = 0;
        int second = 0;

        for (int num : nums) {
            // 状态转移方程: dp[i] = max(dp[i-1], dp[i-2] + nums[i])
            // 当前的最大值 = max(不偷这家(保持上家最大), 偷这家(上上家最大 + 当前金额))
            int temp = Math.max(second, first + num);

            // 滚动更新
            first = second;
            second = temp;
        }

        // 循环结束时，second 存储的就是 dp[n-1]，即最终结果
        return second;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1 = {1, 2, 3, 1};
        System.out.println("示例 1 输入: " + Arrays.toString(nums1));
        System.out.println("示例 1 输出: " + rob(nums1));
        // 解释: 1 + 3 = 4
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums2 = {2, 7, 9, 3, 1};
        System.out.println("示例 2 输入: " + Arrays.toString(nums2));
        System.out.println("示例 2 输出: " + rob(nums2));
        // 解释: 2 + 9 + 1 = 12
        System.out.println("-----------------------------");

        // --- 额外示例 (全 0 或单元素) ---
        int[] nums3 = {0};
        System.out.println("示例 3 输入: " + Arrays.toString(nums3));
        System.out.println("示例 3 输出: " + rob(nums3));

        int[] nums4 = {100};
        System.out.println("示例 4 输入: " + Arrays.toString(nums4));
        System.out.println("示例 4 输出: " + rob(nums4));
    }
}
```
