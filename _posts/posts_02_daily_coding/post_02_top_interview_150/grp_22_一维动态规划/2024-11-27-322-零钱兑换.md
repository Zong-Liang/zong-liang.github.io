---
title: 322. 零钱兑换
date: 2024-11-27 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 一维动态规划]
tags: [一维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235848862.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个整数数组 `coins`，表示不同面额的硬币；以及一个整数 `amount`，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数**。如果没有任何一种硬币组合能组成总金额，返回 `-1`。

你可以认为每种硬币的数量是无限的。

**示例 1:**

- **输入:** `coins = [1, 2, 5]`, `amount = 11`
- **输出:** 3
- **解释:** `11 = 5 + 5 + 1`

**示例 2:**

- **输入:** `coins = [2]`, `amount = 3`
- **输出:** -1

**示例 3:**

- **输入:** `coins = [1]`, `amount = 0`
- **输出:** 0

**提示:**

- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 2^31 - 1`
- `0 <= amount <= 10^4`

## 题解

### 解法：动态规划 (Dynamic Programming)

**思路：**

这个问题是典型的**完全背包问题**（Unbounded Knapsack Problem）的变种。我们需要凑出总金额 `amount`，且希望使用的硬币数量最少。

我们可以定义一个 DP 数组 `dp`，其中 `dp[i]` 表示凑成金额 `i` 所需的**最少硬币个数**。

1.  **状态定义**：

    `dp[i]`：凑齐总金额 `i` 需要的最少硬币数。

2.  **状态转移方程**：

    对于金额 `i`，我们可以尝试遍历每一枚硬币 `coin`。如果我们选用了这枚硬币，那么当前的最少硬币数应该是“凑齐金额 `i - coin` 的最少硬币数”加上“这一枚硬币”。

    $$dp[i] = \min(dp[i], dp[i - coin] + 1)$$

    前提是 `i - coin >= 0` 且 `dp[i - coin]` 是由解的（即可达到的）。

3.  **初始化**：

    - `dp[0] = 0`：凑齐金额 0 不需要任何硬币。
    - `dp[1...amount]`：初始化为一个不可能达到的最大值（例如 `amount + 1`），以便后续取 `min` 时能更新为较小的值。

4.  **最终结果**：

    - 如果 `dp[amount]` 仍然是初始化时的最大值，说明无法凑出该金额，返回 -1。
    - 否则返回 `dp[amount]`。

**复杂度分析：**

- **时间复杂度：** $O(S \cdot n)$，其中 $S$ 是金额 `amount`，$n$ 是硬币面额数。我们需要计算 $S$ 个状态，每个状态需要遍历 $n$ 枚硬币。
- **空间复杂度：** $O(S)$，需要一个长度为 `amount + 1` 的数组来存储状态。

**代码片段：**

```java
public int coinChange(int[] coins, int amount) {
    int max = amount + 1;
    int[] dp = new int[amount + 1];
    // 初始化 dp 数组为最大值
    Arrays.fill(dp, max);
    dp[0] = 0;

    for (int i = 1; i <= amount; i++) {
        for (int coin : coins) {
            // 如果当前硬币面额小于等于当前金额，尝试更新
            if (coin <= i) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    // 如果 dp[amount] 仍为 max，说明无法凑成
    return dp[amount] > amount ? -1 : dp[amount];
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    /**
     * 322. 零钱兑换 - 动态规划解法
     */
    public static int coinChange(int[] coins, int amount) {
        // 定义一个比最大可能硬币数稍大的值，用于初始化
        // 因为面额最小为1，硬币数最多为 amount，所以 amount + 1 相当于无穷大
        int max = amount + 1;

        // dp[i] 表示凑成金额 i 所需的最少硬币数
        int[] dp = new int[amount + 1];

        // 初始化数组，除了 dp[0] 外都设为不可达
        Arrays.fill(dp, max);
        dp[0] = 0;

        // 外层循环遍历所有金额，从 1 到 amount
        for (int i = 1; i <= amount; i++) {
            // 内层循环遍历所有硬币
            for (int coin : coins) {
                // 如果当前金额足以容纳这枚硬币
                if (coin <= i) {
                    // 状态转移：当前金额的最少硬币数 = min(现有方案, 使用这枚硬币后的方案)
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }

        // 检查结果是否被更新过
        return dp[amount] > amount ? -1 : dp[amount];
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] coins1 = {1, 2, 5};
        int amount1 = 11;
        System.out.println("示例 1 输入: coins = " + Arrays.toString(coins1) + ", amount = " + amount1);
        System.out.println("示例 1 输出: " + coinChange(coins1, amount1));
        // 解释: 5 + 5 + 1 = 11，共 3 枚
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] coins2 = {2};
        int amount2 = 3;
        System.out.println("示例 2 输入: coins = " + Arrays.toString(coins2) + ", amount = " + amount2);
        System.out.println("示例 2 输出: " + coinChange(coins2, amount2));
        // 解释: 无法用 2 凑出 3
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        int[] coins3 = {1};
        int amount3 = 0;
        System.out.println("示例 3 输入: coins = " + Arrays.toString(coins3) + ", amount = " + amount3);
        System.out.println("示例 3 输出: " + coinChange(coins3, amount3));
        // 解释: 金额 0 需要 0 枚硬币
        System.out.println("-----------------------------");

        // --- 额外示例 ---
        int[] coins4 = {186, 419, 83, 408};
        int amount4 = 6249;
        // 这是一个比较大的 amount，用于测试性能和正确性
        System.out.println("额外示例 输入: coins = " + Arrays.toString(coins4) + ", amount = " + amount4);
        System.out.println("额外示例 输出: " + coinChange(coins4, amount4));
    }
}
```
