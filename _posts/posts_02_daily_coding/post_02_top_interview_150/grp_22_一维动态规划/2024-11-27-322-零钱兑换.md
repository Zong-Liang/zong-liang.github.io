---
title: 322-零钱兑换
date: 2024-11-27 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 一维动态规划]
tags: [一维动态规划]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235848862.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


### 题目：322. 零钱兑换

给你一个整数数组 `coins`，表示不同面额的硬币；以及一个整数 `amount`，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数**。如果没有任何一种硬币组合能组成总金额，返回 `-1`。

你可以认为每种硬币的数量是无限的。

---

**示例 1:**

- **输入:** `coins = [1, 2, 5]`, `amount = 11`
- **输出:** 3
- **解释:** `11 = 5 + 5 + 1`

**示例 2:**

- **输入:** `coins = [2]`, `amount = 3`
- **输出:** -1

**示例 3:**

- **输入:** `coins = [1]`, `amount = 0`
- **输出:** 0

---

**提示:**

- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 2^31 - 1`
- `0 <= amount <= 10^4`

---

### Java 8 解答 (赛码网格式)

**算法思路：**
这是一个典型的动态规划问题。我们可以创建一个数组 `dp`，其中 `dp[i]` 表示凑成金额 `i` 所需的最少硬币数量。

- **状态定义:** `dp[i]` 是凑成金额 `i` 所需的最少硬币数。
- **状态转移方程:** 对于金额 `i`，我们可以尝试使用 `coins` 数组中的每一种硬币 `c`。如果我们使用了一个硬币 `c`，那么问题就变成了凑成金额 `i - c` 所需的最少硬币数，即 `dp[i - c]`。所以，`dp[i]` 就是所有 `dp[i - c] + 1` 中的最小值。
  `dp[i] = min(dp[i], dp[i - coin] + 1)`
- **初始化:**
  - `dp` 数组的大小为 `amount + 1`。
  - `dp[0]` 初始化为 0，因为凑成金额 0 不需要任何硬币。
  - 将 `dp` 数组的其他所有元素初始化为一个特殊值（例如 `amount + 1`），表示当前金额无法凑成。

最后，`dp[amount]` 就是我们要求的答案。如果它的值仍是我们初始化的特殊值，则说明无法凑成该金额。

```java
import java.util.Arrays;

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    /**
     * 计算凑成总金额所需的最少的硬币个数。
     *
     * @param coins  不同面额的硬币数组。
     * @param amount 总金额。
     * @return 最少的硬币个数，如果无法凑成则返回 -1。
     */
    public static int coinChange(int[] coins, int amount) {
        // dp[i] 表示凑成金额 i 所需的最少硬币数
        int[] dp = new int[amount + 1];

        // 初始化 dp 数组为一个不可能的值 (amount + 1)
        // 因为硬币面额至少为1，所以最多需要 amount 个硬币
        Arrays.fill(dp, amount + 1);

        // 基础情况：凑成金额 0 需要 0 个硬币
        dp[0] = 0;

        // 遍历从 1 到 amount 的所有金额
        for (int i = 1; i <= amount; i++) {
            // 遍历所有可用的硬币面额
            for (int coin : coins) {
                // 如果当前金额 i 大于等于硬币面额
                if (i >= coin) {
                    // 状态转移方程
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }

        // 如果 dp[amount] 的值没有被更新过，说明无法凑成该金额
        return dp[amount] > amount ? -1 : dp[amount];
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[] coins1 = {1, 2, 5};
        int amount1 = 11;
        System.out.println("输入: coins = " + Arrays.toString(coins1) + ", amount = " + amount1);
        int result1 = coinChange(coins1, amount1);
        System.out.println("输出: " + result1); // 预期输出: 3
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[] coins2 = {2};
        int amount2 = 3;
        System.out.println("输入: coins = " + Arrays.toString(coins2) + ", amount = " + amount2);
        int result2 = coinChange(coins2, amount2);
        System.out.println("输出: " + result2); // 预期输出: -1
        System.out.println();

        System.out.println("--- 示例 3 ---");
        int[] coins3 = {1};
        int amount3 = 0;
        System.out.println("输入: coins = " + Arrays.toString(coins3) + ", amount = " + amount3);
        int result3 = coinChange(coins3, amount3);
        System.out.println("输出: " + result3); // 预期输出: 0
    }
}
```
