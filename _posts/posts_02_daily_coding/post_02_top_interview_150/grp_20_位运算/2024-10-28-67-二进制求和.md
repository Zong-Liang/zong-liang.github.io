---
title: 67-二进制求和
date: 2024-10-28 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 位运算]
tags: [位运算]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234910446.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

好的，这是从图片中整理出的题目描述和解答代码。

### 题目：67. 二进制求和

给你两个二进制字符串 `a` 和 `b`，以二进制字符串的形式返回它们的和。

---

**示例 1:**

- **输入:** `a = "11"`, `b = "1"`
- **输出:** `"100"`

**示例 2:**

- **输入:** `a = "1010"`, `b = "1011"`
- **输出:** `"10101"`

---

**提示:**

- `1 <= a.length, b.length <= 10^4`
- `a` 和 `b` 仅由字符 `'0'` 或 `'1'` 组成
- 字符串如果不是 `"0"`，就不含前导零

---

### Java 8 解答 (赛码网格式)

**算法思路：(模拟加法)**
这个问题的核心是模拟手动的二进制加法过程。

1.  从两个字符串的末尾（最低位）开始遍历。
2.  使用一个 `carry` 变量来记录进位。
3.  在每一步中，计算当前位的和：`sum = a[i] + b[j] + carry`。
4.  当前位的结果是 `sum % 2`。
5.  新的进位是 `sum / 2`。
6.  将每一步计算出的结果位添加到结果字符串的前面。
7.  循环直到两个字符串都遍历完毕并且没有进位。

由于字符串可能非常长，不能直接转换为整数类型进行计算，所以必须使用模拟法。

```java
/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    /**
     * 以二进制字符串的形式返回两个二进制字符串的和。
     *
     * @param a 二进制字符串 a
     * @param b 二进制字符串 b
     * @return 它们的和
     */
    public static String addBinary(String a, String b) {
        StringBuilder result = new StringBuilder();

        // i 和 j 是分别指向 a 和 b 末尾的指针
        int i = a.length() - 1;
        int j = b.length() - 1;

        // carry 用于存储进位
        int carry = 0;

        // 循环直到两个字符串都遍历完，并且没有进位
        while (i >= 0 || j >= 0 || carry > 0) {
            int sum = carry;

            // 如果 a 还有位，则加上
            if (i >= 0) {
                // '0' 的 ASCII 码是 48, '1' 是 49
                // char - '0' 可以将字符 '0'或'1' 转换为整数 0或1
                sum += a.charAt(i) - '0';
                i--;
            }

            // 如果 b 还有位，则加上
            if (j >= 0) {
                sum += b.charAt(j) - '0';
                j--;
            }

            // 将当前位的结果添加到结果字符串
            result.append(sum % 2);

            // 更新进位
            carry = sum / 2;
        }

        // 因为我们是从低位向高位添加的，所以需要反转字符串
        return result.reverse().toString();
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        String a1 = "11", b1 = "1";
        System.out.println("输入: a = \"" + a1 + "\", b = \"" + b1 + "\"");
        String result1 = addBinary(a1, b1);
        System.out.println("输出: \"" + result1 + "\""); // 预期输出: "100"
        System.out.println();

        System.out.println("--- 示例 2 ---");
        String a2 = "1010", b2 = "1011";
        System.out.println("输入: a = \"" + a2 + "\", b = \"" + b2 + "\"");
        String result2 = addBinary(a2, b2);
        System.out.println("输出: \"" + result2 + "\""); // 预期输出: "10101"
        System.out.println();
    }
}
```
