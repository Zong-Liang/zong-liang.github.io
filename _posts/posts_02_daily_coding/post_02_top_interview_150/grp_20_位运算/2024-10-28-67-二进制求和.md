---
title: 67. 二进制求和
date: 2024-10-28 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 位运算]
tags: [位运算]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234910446.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你两个二进制字符串 `a` 和 `b`，以二进制字符串的形式返回它们的和。

**示例 1:**

- **输入:** `a = "11"`, `b = "1"`
- **输出:** `"100"`

**示例 2:**

- **输入:** `a = "1010"`, `b = "1011"`
- **输出:** `"10101"`

**提示:**

- `1 <= a.length, b.length <= 10^4`
- `a` 和 `b` 仅由字符 `'0'` 或 `'1'` 组成
- 字符串如果不是 `"0"`，就不含前导零

## 题解

### 解法：模拟竖式加法 (Simulation)

**思路：**

这道题其实就是模拟我们在小学数学中学习的“竖式加法”，只不过这里是**二进制**（逢二进一），而不是十进制。

由于输入的字符串长度可能非常长（达到 $10^4$），直接将其转换为整型（int 或 long）会发生**溢出**，因此必须使用字符串逐位处理。

1.  **双指针法**：定义两个指针 `i` 和 `j` 分别指向字符串 `a` 和 `b` 的**末尾**（最低位）。
2.  **进位处理**：维护一个变量 `carry` 表示进位，初始为 0。
3.  **循环相加**：

    - 只要两个指针没有越界，或者 `carry` 不为 0，就继续循环。
    - 获取当前位的数字：如果指针未越界，取字符转换为数字；如果越界，则视为 0。
    - 计算当前位的和：`sum = num1 + num2 + carry`。
    - 计算新进位：`carry = sum / 2`。
    - 计算当前位的结果：`result = sum % 2`，拼接到结果字符串中。

4.  **结果反转**：因为我们是从后往前计算的，拼接到 `StringBuilder` 后得到的是逆序结果，最后需要反转一次。

**复杂度分析：**

- **时间复杂度：** $O(N)$，其中 $N = \max(|a|, |b|)$。我们需要遍历两个字符串中较长的那个。
- **空间复杂度：** $O(N)$，需要一个 `StringBuilder` 来存储结果，长度最多为 $N + 1$。

**代码片段：**

```java
public String addBinary(String a, String b) {
    StringBuilder ans = new StringBuilder();
    int i = a.length() - 1;
    int j = b.length() - 1;
    int carry = 0;

    // 从后往前遍历，直到两个字符串都遍历完且没有剩余进位
    while (i >= 0 || j >= 0 || carry != 0) {
        int sum = carry;

        // 如果 a 还没遍历完，加上 a 当前位的值
        if (i >= 0) {
            sum += a.charAt(i) - '0'; // 字符转整数
            i--;
        }

        // 如果 b 还没遍历完，加上 b 当前位的值
        if (j >= 0) {
            sum += b.charAt(j) - '0';
            j--;
        }

        // 本位的结果是 sum % 2，拼接到字符串
        ans.append(sum % 2);
        // 新的进位是 sum / 2
        carry = sum / 2;
    }

    // 因为是从低位算到高位 append 的，所以需要反转
    return ans.reverse().toString();
}
```

### 完整代码

```java
public class Main {

    /**
     * 67. 二进制求和 - 模拟竖式加法
     */
    public static String addBinary(String a, String b) {
        StringBuilder sb = new StringBuilder();
        // 指针指向字符串末尾
        int i = a.length() - 1;
        int j = b.length() - 1;
        int carry = 0; // 进位

        // 循环条件：只要还没遍历完，或者还有进位，就继续
        while (i >= 0 || j >= 0 || carry != 0) {
            int sum = carry;

            // 获取 a 的当前位
            if (i >= 0) {
                sum += a.charAt(i) - '0';
                i--;
            }

            // 获取 b 的当前位
            if (j >= 0) {
                sum += b.charAt(j) - '0';
                j--;
            }

            // sum 的可能值为 0, 1, 2, 3
            // 拼接余数 (0或1)
            sb.append(sum % 2);
            // 计算进位 (0或1)
            carry = sum / 2;
        }

        // 翻转并转换为字符串
        return sb.reverse().toString();
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        String a1 = "11";
        String b1 = "1";
        System.out.println("示例 1 输入: a = \"" + a1 + "\", b = \"" + b1 + "\"");
        System.out.println("示例 1 输出: \"" + addBinary(a1, b1) + "\"");
        // 解释: 11(3) + 1(1) = 100(4)
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        String a2 = "1010";
        String b2 = "1011";
        System.out.println("示例 2 输入: a = \"" + a2 + "\", b = \"" + b2 + "\"");
        System.out.println("示例 2 输出: \"" + addBinary(a2, b2) + "\"");
        // 解释: 10 + 11 = 21 (10101)
        System.out.println("-----------------------------");

        // --- 边界测试：进位溢出 ---
        String a3 = "111";
        String b3 = "1";
        System.out.println("边界测试 输入: a = \"" + a3 + "\", b = \"" + b3 + "\"");
        System.out.println("边界测试 输出: \"" + addBinary(a3, b3) + "\"");
        // 预期: 1000
    }
}
```
