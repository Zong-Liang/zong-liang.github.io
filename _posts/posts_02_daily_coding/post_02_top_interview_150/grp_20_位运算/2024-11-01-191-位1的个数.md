---
title: 191-位1的个数
date: 2024-11-01 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 位运算]
tags: [位运算]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235041712.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


### 题目：191. 位 1 的个数

给定一个正整数 `n`，编写一个函数，获取一个正整数的二进制形式并返回其二进制表达式中 **设置位** 的个数（也被称为**汉明重量**）。

---

**示例 1:**

- **输入:** `n = 11`
- **输出:** 3
- **解释:** 输入的二进制串 `1011` 中，共有 3 个设置位。

**示例 2:**

- **输入:** `n = 128`
- **输出:** 1
- **解释:** 输入的二进制串 `10000000` 中，共有 1 个设置位。

**示例 3:**

- **输入:** `n = 2147483645` (即 `2^31 - 3`)
- **输出:** 30
- **解释:** 输入的二进制串 `11111111111111111111111111111101` 中，共有 30 个设置位。

---

**提示:**

- `1 <= n <= 2^31 - 1`

**进阶:**

- 如果多次调用这个函数，你将如何优化你的算法？

---

### Java 8 解答 (赛码网格式)

**算法思路：(位运算)**
这是一个高效计算汉明重量的经典技巧。

我们利用一个巧妙的位运算 `n & (n - 1)`。这个操作的效果是：将 `n` 的二进制表示中**最右边的那个 `1` 变成 `0`**。

例如，`n = 12`（二进制 `1100`）：

- `n - 1` 是 `11`（二进制 `1011`）
- `n & (n - 1)` 等于 `1100 & 1011`，结果是 `1000`（十进制 8）。

我们可以重复这个操作，每次操作都会消除一个 `1`，直到 `n` 变为 0。我们计算这个操作执行了多少次，就是 `n` 中 `1` 的个数。这个方法的循环次数等于 `n` 中 `1` 的个数，通常比遍历 32 位要快。

```java
/**
 * 赛码网要求的标准类名是 Main
 * 注意：LeetCode 上的函数签名是 public int hammingWeight(int n)，
 * 在赛码网模式下，我们将其放入一个可调用的静态方法中。
 */
public class Main {

    /**
     * 计算一个正整数的二进制表达式中 '1' 的个数（汉明重量）。
     *
     * @param n 一个正整数。
     * @return 二进制中 '1' 的个数。
     */
    public static int hammingWeight(int n) {
        int count = 0;
        while (n != 0) {
            // 这个操作会把 n 的二进制表示中最右边的 1 变成 0
            n = n & (n - 1);
            count++;
        }
        return count;
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int n1 = 11;
        System.out.println("输入: n = " + n1);
        int result1 = hammingWeight(n1);
        System.out.println("输出: " + result1); // 预期输出: 3
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int n2 = 128;
        System.out.println("输入: n = " + n2);
        int result2 = hammingWeight(n2);
        System.out.println("输出: " + result2); // 预期输出: 1
        System.out.println();

        System.out.println("--- 示例 3 ---");
        int n3 = 2147483645;
        System.out.println("输入: n = " + n3);
        int result3 = hammingWeight(n3);
        System.out.println("输出: " + result3); // 预期输出: 30
        System.out.println();

        // 进阶问题的讨论：
        // 如果函数被多次调用，可以预计算一个查找表（Lookup Table）。
        // 例如，创建一个大小为 256 的表，存储 0 到 255 每个数字的汉明重量。
        // 然后对于一个 32 位整数，可以将其分为 4 个 8 位的块，
        // 分别查表后将结果相加，这样可以减少计算量。
        // 例如：hammingWeight(n) = table[n & 0xff] + table[(n >> 8) & 0xff] + ...
    }
}
```
