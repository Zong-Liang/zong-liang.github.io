---
title: 191. 位1的个数
date: 2024-11-01 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 位运算]
tags: [位运算]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235041712.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个正整数 `n`，编写一个函数，获取一个正整数的二进制形式并返回其二进制表达式中 **设置位** 的个数（也被称为**汉明重量**）。

**示例 1:**

- **输入:** `n = 11`
- **输出:** 3
- **解释:** 输入的二进制串 `1011` 中，共有 3 个设置位。

**示例 2:**

- **输入:** `n = 128`
- **输出:** 1
- **解释:** 输入的二进制串 `10000000` 中，共有 1 个设置位。

**示例 3:**

- **输入:** `n = 2147483645` (即 `2^31 - 3`)
- **输出:** 30
- **解释:** 输入的二进制串 `11111111111111111111111111111101` 中，共有 30 个设置位。

**提示:**

- `1 <= n <= 2^31 - 1`

**进阶:**

- 如果多次调用这个函数，你将如何优化你的算法？

## 题解

### 解法一：位运算 - Brian Kernighan 算法

**思路：**

最直观的方法是循环 32 次检查每一位。但有一个更巧妙的技巧，称为 **Brian Kernighan 算法**。

该算法的核心在于利用 `n & (n - 1)` 的性质。

- **原理**：表达式 `n & (n - 1)` 的运算结果，会将 `n` 的二进制表示中 **最低位的那个 1 变成 0**，而其他高位保持不变。
- **流程**：

  1.  初始化计数器 `count = 0`。
  2.  只要 `n` 不等于 0，就执行 `n = n & (n - 1)`，这意味着消除掉了一个 1。
  3.  每次消除后，计数器 `count + 1`。
  4.  重复直到 `n` 变为 0。

相比于逐位检查（固定 32 次循环），这个算法的循环次数仅等于 `n` 中 1 的个数，因此在 1 较稀疏的情况下效率更高。

**复杂度分析：**

- **时间复杂度：** $O(k)$，其中 $k$ 是 `n` 中 1 的个数。最坏情况下为 $O(\log n)$（即 32 次）。
- **空间复杂度：** $O(1)$，只需要常数空间。

**代码片段：**

```java
public int hammingWeight(int n) {
    int count = 0;
    while (n != 0) {
        // 消除最低位的 1
        n = n & (n - 1);
        count++;
    }
    return count;
}
```

### 解法二：进阶解法 - 查表法 (Table Lookup)

**思路：**

针对进阶问题：**“如果多次调用这个函数，你将如何优化你的算法？”**

如果需要处理海量数据，我们可以使用**空间换时间**的策略。

1.  **预计算**：一个 32 位整数可以拆分为 4 个 8 位的字节。8 位二进制数的范围是 0-255。我们可以预先计算出 0 到 255 之间每个数字包含的 1 的个数，并存储在一个大小为 256 的数组（缓存表）中。
2.  **查表**：当调用函数时，利用位掩码和移位操作，将 32 位整数分为 4 段，分别去查表，然后将结果相加。

这种方法将计算过程转化为内存访问，消除了循环。

**复杂度分析：**

- **时间复杂度：** $O(1)$，无论输入是什么，固定进行 4 次数组访问和加法运算。
- **空间复杂度：** $O(1)$，需要一个大小为 256 的辅助数组，相对于内存来说微不足道。

**代码片段：**

```java
// 静态缓存表
private static final int[] CACHE = new int[256];

// 静态代码块初始化
static {
    for (int i = 0; i < 256; i++) {
        // 利用之前的算法预计算小范围数据的 bitCount
        int count = 0;
        int num = i;
        while (num != 0) {
            num &= (num - 1);
            count++;
        }
        CACHE[i] = count;
    }
}

public int hammingWeightOptimized(int n) {
    // 将 32 位拆分为 4 个 8 位，分别查表求和
    return CACHE[n & 0xff] +
           CACHE[(n >>> 8) & 0xff] +
           CACHE[(n >>> 16) & 0xff] +
           CACHE[(n >>> 24) & 0xff];
}
```

### 完整代码

```java
public class Main {

    // --- 解法一：Brian Kernighan 算法 ---
    public static int hammingWeight(int n) {
        int count = 0;
        while (n != 0) {
            n &= (n - 1); // 抹去最低位的 1
            count++;
        }
        return count;
    }

    // --- 解法二：查表法 (进阶优化) ---
    private static final int[] CACHE = new int[256];

    static {
        for (int i = 0; i < 256; i++) {
            int count = 0;
            int temp = i;
            while (temp != 0) {
                temp &= (temp - 1);
                count++;
            }
            CACHE[i] = count;
        }
    }

    public static int hammingWeightOptimized(int n) {
        // 0xff 是 11111111，用于截取低 8 位
        // >>> 是无符号右移
        return CACHE[n & 0xff] +
               CACHE[(n >>> 8) & 0xff] +
               CACHE[(n >>> 16) & 0xff] +
               CACHE[(n >>> 24) & 0xff];
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int n1 = 11; // 二进制 1011
        System.out.println("示例 1 输入: " + n1 + " (二进制: " + Integer.toBinaryString(n1) + ")");
        System.out.println("示例 1 输出: " + hammingWeight(n1));
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int n2 = 128; // 二进制 10000000
        System.out.println("示例 2 输入: " + n2 + " (二进制: " + Integer.toBinaryString(n2) + ")");
        System.out.println("示例 2 输出: " + hammingWeight(n2));
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        int n3 = 2147483645; // 2^31 - 3
        System.out.println("示例 3 输入: " + n3 + " (二进制: " + Integer.toBinaryString(n3) + ")");
        // 测试优化解法
        System.out.println("示例 3 输出 (查表法): " + hammingWeightOptimized(n3));

        // 验证一致性
        assert hammingWeight(n3) == hammingWeightOptimized(n3);
    }
}
```
