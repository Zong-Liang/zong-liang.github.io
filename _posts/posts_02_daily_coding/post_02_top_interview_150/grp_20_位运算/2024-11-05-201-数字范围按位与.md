---
title: 201. 数字范围按位与
date: 2024-11-05 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 位运算]
tags: [位运算]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235203605.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你两个整数 `left` 和 `right`，表示区间 `[left, right]`，返回此区间内所有数字 **按位与** 的结果（包含 `left`、`right` 端点）。

**示例 1:**

- **输入:** `left = 5`, `right = 7`
- **输出:** 4
- **解释:**

  - 5 (二进制: 101)
  - 6 (二进制: 110)
  - 7 (二进制: 111)
  - 101 & 110 & 111 = 100 (十进制: 4)

**示例 2:**

- **输入:** `left = 0`, `right = 0`
- **输出:** 0

**示例 3:**

- **输入:** `left = 1`, `right = 2147483647`
- **输出:** 0

**提示:**

- `0 <= left <= right <= 2^31 - 1`

## 题解

### 解法一：位移法 (Shift Right)

**思路：**

题目要求计算区间 `[left, right]` 内所有数字的按位与。

我们观察二进制数的规律：

- `left` = 5 (`101`)
- `right` = 7 (`111`)
- 结果 = 4 (`100`)

- `left` = 9 (`1001`)
- `right` = 12 (`1100`)
- 结果 = 8 (`1000`)

我们可以发现一个核心规律：**结果实际上是 `left` 和 `right` 的二进制“公共前缀”，后面补上 0**。

因为对于区间内连续的整数，右侧的低位（非公共前缀部分）在从 `left` 增加到 `right` 的过程中，一定会发生 0 和 1 的翻转。只要某一位出现过 0，那么按位与的结果在该位就必定是 0。只有高位一直保持不变的部分（公共前缀）才能保留下来。

因此，算法步骤如下：

1.  将 `left` 和 `right` 同时向右移位（`>>`），直到它们相等。这一步是为了消除不相同的低位。
2.  记录移位的次数 `shift`。
3.  将此时相等的这个公共前缀向左移位（`<<`）`shift` 次，即补上 0，得到最终结果。

**复杂度分析：**

- **时间复杂度：** $O(\log N)$。$N$ 为整数的最大位数（本题为 32），循环次数不会超过 32 次。
- **空间复杂度：** $O(1)$。

**代码片段：**

```java
public int rangeBitwiseAnd(int left, int right) {
    int shift = 0;
    // 寻找公共前缀
    while (left < right) {
        left >>= 1;
        right >>= 1;
        shift++;
    }
    return left << shift;
}
```

### 解法二：Brian Kernighan 算法 (去除最右侧的 1)

**思路：**

这是另一种更巧妙的方法。我们知道 `n & (n-1)` 的作用是将整数 `n` 二进制表示中**最右边的 1 变成 0**。

在这个题目中，只要 `right > left`，就说明 `right` 和 `left` 并不相等，意味着它们还包含“非公共前缀”的部分。我们可以不断地对 `right` 执行 `right = right & (right - 1)`，抹去最右边的 1，直到 `right` 小于或等于 `left` 为止。

此时的 `right` 就是我们要找的公共前缀补零后的结果。

**复杂度分析：**

- **时间复杂度：** $O(\log N)$。虽然也是对数级，但在数字稀疏的情况下，循环次数比解法一更少。
- **空间复杂度：** $O(1)$。

**代码片段：**

```java
public int rangeBitwiseAnd(int left, int right) {
    while (left < right) {
        // 抹去 right 最右边的 1
        right = right & (right - 1);
    }
    return right;
}
```

### 完整代码

```java
public class Main {

    /**
     * 方法一：位移法
     * 寻找 left 和 right 的公共前缀
     */
    public static int rangeBitwiseAndShift(int left, int right) {
        int shift = 0;
        // 当 left != right 时，说明还有低位不同，继续右移
        while (left < right) {
            left >>= 1;
            right >>= 1;
            shift++;
        }
        // 将公共前缀左移回原来的位置
        return left << shift;
    }

    /**
     * 方法二：Brian Kernighan 算法
     * 不断抹去 right 最右边的 1，直到 right <= left
     */
    public static int rangeBitwiseAndBK(int left, int right) {
        while (left < right) {
            // 这一步会抹去 right 二进制中最右边的 1
            right = right & (right - 1);
        }
        return right;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int left1 = 5, right1 = 7;
        System.out.println("示例 1 输入: left = " + left1 + ", right = " + right1);
        System.out.println("示例 1 输出 (位移法): " + rangeBitwiseAndShift(left1, right1));
        System.out.println("示例 1 输出 (BK算法): " + rangeBitwiseAndBK(left1, right1));
        // 解释: 101, 110, 111 -> 公共前缀 1xx -> 100 (4)
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int left2 = 0, right2 = 0;
        System.out.println("示例 2 输入: left = " + left2 + ", right = " + right2);
        System.out.println("示例 2 输出: " + rangeBitwiseAndBK(left2, right2));
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        int left3 = 1, right3 = 2147483647;
        System.out.println("示例 3 输入: left = " + left3 + ", right = " + right3);
        System.out.println("示例 3 输出: " + rangeBitwiseAndBK(left3, right3));
        // 解释: 范围跨度极大，公共前缀为 0
        System.out.println("-----------------------------");

        // --- 额外示例 ---
        int left4 = 9, right4 = 12; // 1001 到 1100
        System.out.println("额外示例 输入: left = " + left4 + ", right = " + right4);
        System.out.println("额外示例 输出: " + rangeBitwiseAndBK(left4, right4));
        // 解释: 1001 & 1010 & 1011 & 1100 -> 公共前缀 1xxx -> 1000 (8)
    }
}
```
