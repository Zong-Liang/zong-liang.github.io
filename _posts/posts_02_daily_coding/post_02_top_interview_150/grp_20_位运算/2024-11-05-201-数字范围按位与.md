---
title: 201. 数字范围按位与
date: 2024-11-05 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 位运算]
tags: [位运算]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235203605.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：201. 数字范围按位与

给你两个整数 `left` 和 `right`，表示区间 `[left, right]`，返回此区间内所有数字 **按位与** 的结果（包含 `left`、`right` 端点）。

**示例 1:**

- **输入:** `left = 5`, `right = 7`
- **输出:** 4
- **解释:**
  - 5 (二进制: 101)
  - 6 (二进制: 110)
  - 7 (二进制: 111)
  - 101 & 110 & 111 = 100 (十进制: 4)

**示例 2:**

- **输入:** `left = 0`, `right = 0`
- **输出:** 0

**示例 3:**

- **输入:** `left = 1`, `right = 2147483647`
- **输出:** 0

**提示:**

- `0 <= left <= right <= 2^31 - 1`

## 题解

**算法思路：(位运算 - 寻找公共前缀)**

直接遍历范围内的所有数字并执行“与”操作会超时。我们可以观察到，一个数字范围 `[left, right]` 内所有数字的按位与结果，实际上是 `left` 和 `right` 这两个数的二进制表示的 **公共前缀**。

例如，对于 `[5, 7]`，二进制表示为：

- 5: `101`
- 6: `110`
- 7: `111`

它们的公共前缀是 `1xx`。在公共前缀之后的所有位，由于 `left` 和 `right` 不同，这个范围内必然会经历至少一次从 `...0111...` 到 `...1000...` 的进位，导致这些位上至少出现一次 `0`。因此，按位与的结果会将这些位全部置为 `0`。

我们的目标就是找到这个公共前缀。一个巧妙的方法是不断地将 `right` 的最右边的 `1` 置为 `0`，直到 `right` 小于或等于 `left`。这个过程最终会削掉所有非公共前缀的部分，剩下的 `right` 值就是最终的答案。

```java
public class Main {

    /**
     * 返回区间 [left, right] 内所有数字按位与的结果。
     *
     * @param left  区间左端点
     * @param right 区间右端点
     * @return 按位与的结果
     */
    public static int rangeBitwiseAnd(int left, int right) {
        // 当 right > left 时，不断地通过 right = right & (right - 1)
        // 这个操作会把 right 的二进制表示中最右边的 1 给置为 0
        // 直到 right <= left，此时的 right 就是 [left, right] 范围内所有数字的公共前缀
        while (right > left) {
            right = right & (right - 1);
        }
        return right;
    }


    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int left1 = 5, right1 = 7;
        System.out.println("输入: left = " + left1 + ", right = " + right1);
        int result1 = rangeBitwiseAnd(left1, right1);
        System.out.println("输出: " + result1); // 预期输出: 4
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int left2 = 0, right2 = 0;
        System.out.println("输入: left = " + left2 + ", right = " + right2);
        int result2 = rangeBitwiseAnd(left2, right2);
        System.out.println("输出: " + result2); // 预期输出: 0
        System.out.println();

        System.out.println("--- 示例 3 ---");
        int left3 = 1, right3 = 2147483647;
        System.out.println("输入: left = " + left3 + ", right = " + right3);
        int result3 = rangeBitwiseAnd(left3, right3);
        System.out.println("输出: " + result3); // 预期输出: 0
    }
}
```
