---
title: 190. 颠倒二进制位
date: 2024-10-29 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 位运算]
tags: [位运算]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234938538.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

颠倒给定的 32 位有符号整数的二进制位。

**示例 1:**

- **输入:** `n = 43261596`
- **输出:** `964176192`
- **解释:**

  | 整数      | 二进制                             |
  | :-------- | :--------------------------------- |
  | 43261596  | `00000010100101000001111010011100` |
  | 964176192 | `00111001011110000010100101000000` |

**示例 2:**

- **输入:** `n = 2147483644`
- **输出:** `1073741822`
- **解释:**

  | 整数       | 二进制                             |
  | :--------- | :--------------------------------- |
  | 2147483644 | `01111111111111111111111111111100` |
  | 1073741822 | `00111111111111111111111111111110` |

**提示:**

- `0 <= n <= 2^31 - 2`
- `n` 为偶数
- (注意：在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。)

**进阶:**

- 如果多次调用这个函数，你将如何优化你的算法？

## 题解

### 解法一：逐位颠倒 (Bit Manipulation - Iteration)

**思路：**

这是最基础的解法。由于题目要求颠倒 32 位整数的二进制位，我们可以通过循环处理每一位。

1.  初始化结果变量 `res = 0`。
2.  循环 32 次（对应 32 位整数）：

    - 将 `res` 向左移动一位，为空出的最低位腾出位置。
    - 取出 `n` 的最低位（通过 `n & 1`）。
    - 将取出的这一位加到 `res` 的最低位（通过 `|` 或 `+`）。
    - 将 `n` 向右移动一位（`n >>> 1`，使用无符号右移），以便下一次处理下一位。

**复杂度分析：**

- **时间复杂度：** $O(1)$，虽然有循环，但循环次数固定为 32 次，与输入大小无关，可视为常数时间。
- **空间复杂度：** $O(1)$，只使用了常数个变量。

**代码片段：**

```java
public int reverseBits(int n) {
    int res = 0;
    for (int i = 0; i < 32; i++) {
        // 1. 将结果左移，为新加入的位腾出空间
        // 2. 将 n 的最低位加到 res 的最低位
        res = (res << 1) | (n & 1);
        // 3. n 右移，处理下一位
        n >>= 1;
    }
    return res;
}
```

### 解法二：进阶解法 - 分治合并 (Divide and Conquer) / 字节缓存 (Byte Cache)

**思路：**

针对题目进阶要求：**“如果多次调用这个函数，你将如何优化？”**

如果函数被频繁调用，每次都循环 32 次可能不够高效。我们可以采用**以空间换时间**的策略。

1.  **位操作分治法**：

    不使用循环，而是通过位掩码（Mask）和移位操作，并行交换相邻的 1 位、2 位、4 位、8 位、16 位。

    例如：先交换每相邻 1 位 `(n & 0x55555555) << 1 | (n >>> 1) & 0x55555555`，再交换每相邻 2 位... 直到交换高低 16 位。

2.  **字节表缓存法（针对多次调用的推荐优化）**：

    - 一个 32 位整数由 4 个 8 位的字节（Byte）组成。
    - 我们可以预先计算 0-255（即 8 位二进制）所有数字的颠倒结果，存入一个大小为 256 的数组中作为缓存。
    - 当函数被调用时，将 32 位整数拆分为 4 个字节，分别查表得到颠倒后的字节，然后将这 4 个颠倒后的字节拼回到正确的位置（原来的第 1 个字节放到最后，第 4 个字节放到最前）。
    - 这种方法在大量调用时，只需进行 4 次查表和位运算，去除了循环开销。

> **关键点：** 将 32 次位操作缩减为 4 次查表 + 移位组合操作。

**复杂度分析：**

- **时间复杂度：** $O(1)$，仅需 4 次查表和位运算。
- **空间复杂度：** $O(1)$，需要一个大小为 256 的整型数组存储缓存，空间固定且很小。

**代码片段：**

```java
// 缓存数组
private static final int[] cache = new int[256];

// 静态代码块初始化缓存
static {
    for (int i = 0; i < 256; i++) {
        cache[i] = reverseByte(i);
    }
}

// 辅助函数：颠倒 8 位整数
private static int reverseByte(int b) {
    int res = 0;
    // 8 bit 翻转
    for (int i = 0; i < 8; i++) {
        res = (res << 1) | (b & 1);
        b >>= 1;
    }
    return res;
}

public int reverseBitsOptimized(int n) {
    // 将 n 分割成 4 个字节，分别查表并移位到对应位置
    // 注意：Java 中 byte 是有符号的，这里使用 mask (0xff) 确保按无符号处理
    int b0 = n & 0xff;
    int b1 = (n >>> 8) & 0xff;
    int b2 = (n >>> 16) & 0xff;
    int b3 = (n >>> 24) & 0xff;

    // b0 原本在最低位，翻转后应在最高位 (<< 24)
    // b3 原本在最高位，翻转后应在最低位 (不需要移位)
    return (cache[b0] << 24) | (cache[b1] << 16) | (cache[b2] << 8) | cache[b3];
}
```

### 完整代码

```java
public class Main {

    // --- 解法一：常规循环 ---
    // you need treat n as an unsigned value
    public static int reverseBits(int n) {
        int res = 0;
        for (int i = 0; i < 32; i++) {
            res = (res << 1) | (n & 1);
            n >>= 1;
        }
        return res;
    }

    // --- 解法二：进阶优化（字节缓存法） ---
    private static final int[] cache = new int[256];

    static {
        // 预计算 0-255 的翻转结果
        for (int i = 0; i < 256; i++) {
            cache[i] = reverseByteHelper(i);
        }
    }

    private static int reverseByteHelper(int b) {
        int res = 0;
        for (int i = 0; i < 8; i++) {
            res = (res << 1) | (b & 1);
            b >>= 1;
        }
        return res;
    }

    public static int reverseBitsOptimized(int n) {
        // 利用缓存表，每次只处理 8 位
        return (cache[n & 0xff] << 24) |
               (cache[(n >>> 8) & 0xff] << 16) |
               (cache[(n >>> 16) & 0xff] << 8) |
               cache[(n >>> 24) & 0xff];
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        // Java 中字面量如果是十进制，很难直接表示无符号的大数，
        // 我们可以使用二进制字符串解析或直接使用十六进制
        int n1 = 43261596;

        System.out.println("示例 1 输入: " + n1);
        System.out.println("输入二进制: " + String.format("%32s", Integer.toBinaryString(n1)).replace(' ', '0'));

        int res1 = reverseBits(n1);
        System.out.println("示例 1 输出: " + res1);
        System.out.println("输出二进制: " + String.format("%32s", Integer.toBinaryString(res1)).replace(' ', '0'));
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        // 2147483644 的二进制是 0111...1100 (接近 Integer.MAX_VALUE)
        int n2 = 2147483644;

        System.out.println("示例 2 输入: " + n2);
        System.out.println("输入二进制: " + String.format("%32s", Integer.toBinaryString(n2)).replace(' ', '0'));

        int res2 = reverseBitsOptimized(n2);
        System.out.println("示例 2 输出 (优化解法): " + res2);
        System.out.println("输出二进制: " + String.format("%32s", Integer.toBinaryString(res2)).replace(' ', '0'));

        // 验证优化解法与普通解法结果一致性
        assert reverseBits(n2) == reverseBitsOptimized(n2);
    }
}
```
