---
title: 190-颠倒二进制位
date: 2024-10-29 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 位运算]
tags: [位运算]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234938538.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

好的，这是从图片中整理出的题目描述和解答代码。

### 题目：190. 颠倒二进制位

颠倒给定的 32 位有符号整数的二进制位。

---

**示例 1:**

- **输入:** `n = 43261596`
- **输出:** `964176192`
- **解释:**
  | 整数 | 二进制 |
  | :--- | :--- |
  | 43261596 | `00000010100101000001111010011100` |
  | 964176192 | `00111001011110000010100101000000` |

**示例 2:**

- **输入:** `n = 2147483644`
- **输出:** `1073741822`
- **解释:**
  | 整数 | 二进制 |
  | :--- | :--- |
  | 2147483644 | `01111111111111111111111111111100` |
  | 1073741822 | `00111111111111111111111111111110` |

---

**提示:**

- `0 <= n <= 2^31 - 2`
- `n` 为偶数
- (注意：在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。)

**进阶:**

- 如果多次调用这个函数，你将如何优化你的算法？

---

### Java 8 解答 (赛码网格式)

**算法思路：(位运算)**
我们可以通过迭代 32 次来构建颠倒后的整数。

1.  初始化结果 `result = 0`。
2.  循环 32 次，代表 32 个二进制位。
3.  在每次循环中：
    a. 将 `result` 左移一位 (`result << 1`)，为即将到来的新位腾出空间。
    b. 取出 `n` 的最低位（`n & 1`）。
    c. 将这个最低位加到 `result` 上（通过或运算 `|`）。
    d. 将 `n` 右移一位 (`n >>= 1`)，以便在下一次循环中处理下一个位。

经过 32 次循环，`n` 的所有位都会被依次取出并以相反的顺序放入 `result` 中。

```java
/**
 * 赛码网要求的标准类名是 Main
 * 注意：LeetCode 上的函数签名是 public int reverseBits(int n)，
 * 在赛码网模式下，我们将其放入一个可调用的静态方法中。
 */
public class Main {

    /**
     * 颠倒给定的 32 位有符号整数的二进制位。
     *
     * @param n 要颠倒的整数。
     * @return 颠倒后的整数。
     */
    public static int reverseBits(int n) {
        int result = 0;
        // 循环 32 次，处理 32 个位
        for (int i = 0; i < 32; i++) {
            // 1. 将 result 左移一位，为新位腾出空间
            result <<= 1;

            // 2. 取出 n 的最低位
            int lsb = n & 1;

            // 3. 将 n 的最低位设置到 result 的最低位
            result |= lsb;

            // 4. 将 n 右移一位，准备处理下一个位
            n >>= 1;
        }
        return result;
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int n1 = 43261596;
        System.out.println("输入: n = " + n1);
        int result1 = reverseBits(n1);
        System.out.println("输出: " + result1); // 预期输出: 964176192
        System.out.println();

        System.out.println("--- 示例 2 ---");
        // 注意：Java 中 2147483644 是一个正数，但如果作为无符号数处理，
        // LeetCode 的 Python 环境可能会把它当成一个负数。
        // 但这里的位操作逻辑对有符号和无符号数是通用的。
        int n2 = -2147483644; // Leetcode 中这个测试用例常写作 FFFFFFFC (无符号)
        n2 = 2147483644; // 按题目给的十进制
        System.out.println("输入: n = " + n2);
        int result2 = reverseBits(n2);
        System.out.println("输出: " + result2); // 预期输出: 1073741822
        System.out.println();

        // 进阶问题的讨论：
        // 如果函数被多次调用，可以预计算一个查找表（Lookup Table）。
        // 比如，创建一个大小为 256 的表，存储 0 到 255 每个 8 位字节颠倒后的结果。
        // 对于一个 32 位整数，可以将其分为 4 个 8 位的字节，
        // 分别查表得到颠倒后的字节，再通过位移和或运算拼接成最终结果。
        // 这样可以将 32 次循环操作减少为几次查表和位运算。
    }
}
```
