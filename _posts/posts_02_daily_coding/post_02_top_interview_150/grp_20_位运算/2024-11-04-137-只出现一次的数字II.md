---
title: 137. 只出现一次的数字II
date: 2024-11-04 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 位运算]
tags: [位运算]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235141146.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个整数数组 `nums`，除某个元素仅出现 **一次** 外，其余每个元素都恰好出现 **三次**。请你找出并返回那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。

**示例 1:**

- **输入:** `nums = [2,2,3,2]`
- **输出:** 3

**示例 2:**

- **输入:** `nums = [0,1,0,1,0,1,99]`
- **输出:** 99

**提示:**

- `1 <= nums.length <= 3 * 10^4`
- `-2^31 <= nums[i] <= 2^31 - 1`
- `nums` 中，除某个元素仅出现 **一次** 外，其余每个元素都恰好出现 **三次**

## 题解

### 解法一：逐位统计 (Bitwise Counting)

**思路：**

我们可以把数组中所有数字的二进制表示的每一位进行相加。

对于整数的第 `i` 位，如果数组中所有数字在该位上的 1 的总个数：

- 如果是 3 的倍数，说明那个只出现一次的数字在该位上是 0。
- 如果不是 3 的倍数（余数为 1），说明那个只出现一次的数字在该位上是 1。

这是因为其他数字都出现了 3 次，它们在任何一位上的和必然是 3 的倍数（$3 \times 0 = 0$ 或 $3 \times 1 = 3$）。只有那个唯一的数字会破坏这个平衡。

我们只需要遍历 32 个二进制位（int 类型），统计每一位上 1 的个数对 3 取模，然后还原出结果。

**复杂度分析：**

- **时间复杂度：** $O(n)$，我们需要遍历 32 次数组，总操作次数为 $32 \times n$，即线性复杂度。
- **空间复杂度：** $O(1)$，只需要常数个变量。

**代码片段：**

```java
public int singleNumber(int[] nums) {
    int ans = 0;
    // 遍历 int 的 32 位
    for (int i = 0; i < 32; i++) {
        int total = 0;
        // 统计所有数字在第 i 位上的值之和
        for (int num : nums) {
            total += (num >> i) & 1;
        }
        // 如果 total 不是 3 的倍数，说明目标数字在该位是 1
        if (total % 3 != 0) {
            ans |= (1 << i);
        }
    }
    return ans;
}
```

### 解法二：数字电路设计 / 有限状态自动机 (Digital Logic Design)

**思路：**

这是一种更高级且代码更简洁的解法。我们可以把每个二进制位看作一个状态机。

对于任意一位，它可能出现的 1 的次数模 3 的结果只有三种状态：0、1、2。

我们需要两个比特位（变量）来表示这三种状态：

- `00`：表示该位 1 出现了 0 次（或 3 的倍数次）。
- `01`：表示该位 1 出现了 1 次。
- `10`：表示该位 1 出现了 2 次。

定义两个变量 `ones` 和 `twos`：

- `ones`：记录二进制位上 1 出现 1 次的掩码。
- `twos`：记录二进制位上 1 出现 2 次的掩码。

**状态转移逻辑：**

当我们在处理一个新的数字 `num` 时：

1.  **更新 `ones`**：

    `ones = (ones ^ num) & ~twos`

    _解释：如果 `num` 的某一位是 1，且 `twos` 该位是 0，那么 `ones` 该位翻转；如果 `twos` 该位已经是 1（说明之前出现了两次），则 `ones` 强制为 0（因为 2+1=3，归零）。_

2.  **更新 `twos`**：

    `twos = (twos ^ num) & ~ones`

    _解释：如果 `num` 的某一位是 1，且 `ones` 该位是 0（注意使用的是更新后的 `ones`，即意味着变成了 1 次，或者本来是 1 次变成了 0 次），逻辑同上。_

最终，只出现一次的数字会保留在 `ones` 中（因为它的每一位都只出现了 1 次）。

**复杂度分析：**

- **时间复杂度：** $O(n)$，只需要遍历一次数组。
- **空间复杂度：** $O(1)$，仅需两个变量。

**代码片段：**

```java
public int singleNumberOptimized(int[] nums) {
    int ones = 0, twos = 0;
    for (int num : nums) {
        ones = (ones ^ num) & ~twos;
        twos = (twos ^ num) & ~ones;
    }
    return ones;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    /**
     * 解法：数字电路设计 (最优化解法)
     * 时间复杂度 O(N), 空间复杂度 O(1)
     */
    public static int singleNumber(int[] nums) {
        int ones = 0, twos = 0;
        for (int num : nums) {
            // ones 记录所有位上出现次数为 1 的位
            // 如果 twos 对应位已经是 1，说明加上这个 num 后变成了 3 次，ones 需要归零
            ones = (ones ^ num) & ~twos;

            // twos 记录所有位上出现次数为 2 的位
            // 使用更新后的 ones 来辅助判断
            twos = (twos ^ num) & ~ones;
        }
        return ones;
    }

    /**
     * 解法备份：逐位统计 (更容易理解的解法)
     */
    public static int singleNumberBitCounting(int[] nums) {
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            int count = 0;
            for (int num : nums) {
                // 检查第 i 位是否为 1
                if (((num >> i) & 1) == 1) {
                    count++;
                }
            }
            // 如果 count % 3 != 0，说明目标数字在该位是 1
            if (count % 3 != 0) {
                ans |= (1 << i);
            }
        }
        return ans;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1 = {2, 2, 3, 2};
        System.out.println("示例 1 输入: " + Arrays.toString(nums1));
        System.out.println("示例 1 输出: " + singleNumber(nums1));
        // 解释: 2 出现了 3 次，3 出现了 1 次。
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums2 = {0, 1, 0, 1, 0, 1, 99};
        System.out.println("示例 2 输入: " + Arrays.toString(nums2));
        System.out.println("示例 2 输出: " + singleNumber(nums2));
        // 解释: 99 出现了 1 次。
        System.out.println("-----------------------------");

        // --- 示例 3 (负数测试) ---
        int[] nums3 = {-2, -2, 1, 1, -3, 1, -3, -3, -4, -2};
        // -2(4次? 不对，题目保证是3次), 构造一个合法的输入
        // -2 x 3, 1 x 3, -3 x 3, -4 x 1
        int[] numsValid = {-2, -2, -2, 1, 1, 1, -3, -3, -3, -4};
        System.out.println("示例 3 输入: " + Arrays.toString(numsValid));
        System.out.println("示例 3 输出 (优化解法): " + singleNumber(numsValid));
        System.out.println("示例 3 输出 (逐位统计): " + singleNumberBitCounting(numsValid));
        // 解释: -4 只出现一次。
    }
}
```
