---
title: 2. 两数相加
date: 2024-06-23 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 链表]
tags: [链表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230401628.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

### 题目

**描述：**

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1:**

![示例1图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

- **输入:** `l1 = [2,4,3]`, `l2 = [5,6,4]`
- **输出:** `[7,0,8]`
- **解释:** `342 + 465 = 807`.

**示例 2:**

- **输入:** `l1 = [0]`, `l2 = [0]`
- **输出:** `[0]`

**示例 3:**

- **输入:** `l1 = [9,9,9,9,9,9,9]`, `l2 = [9,9,9,9]`
- **输出:** `[8,9,9,9,0,0,0,1]`

**提示:**

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

## 题解

### 解法：模拟法（数学进位）

**思路：**

由于链表中的数字已经是**逆序**存储的（即链表头节点是个位，第二个节点是十位...），这与我们平常笔算加法的顺序（从低位到高位）完全一致。因此，我们只需要从头到尾遍历两个链表，逐位计算即可。

1.  **虚拟头节点**：创建一个 `dummy` 节点（哑节点）作为结果链表的伪头部，这样可以简化对结果链表首节点的处理。
2.  **变量维护**：

    - `carry`：记录进位值（初始为 0）。
    - `curr`：指向当前结果链表的末尾。

3.  **遍历逻辑**：

    - 只要 `l1` 或 `l2` 还有节点未遍历，或者 `carry` 不为 0（例如最后一位相加产生了进位），就继续循环。
    - 取出当前节点的值：如果链表已经遍历完，则对应位的值视为 `0`。
    - 计算和：`sum = x + y + carry`。
    - 更新进位：`carry = sum / 10`。
    - 创建新节点：`curr.next = new ListNode(sum % 10)`，并将 `curr` 后移。
    - 移动输入链表指针：如果 `l1` 或 `l2` 不为空，则指向下一个节点。

**复杂度分析：**

- **时间复杂度：** $O(\max(m, n))$，其中 $m$ 和 $n$ 分别是两个链表的长度。我们要遍历两个链表，最长遍历次数取决于较长的那个链表。
- **空间复杂度：** $O(1)$。返回值是答案必须的空间，我们只需要常数级别的额外空间（指针和变量）来维持运算。

**代码片段：**

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummyHead = new ListNode(0);
    ListNode curr = dummyHead;
    int carry = 0;

    while (l1 != null || l2 != null || carry != 0) {
        int x = (l1 != null) ? l1.val : 0;
        int y = (l2 != null) ? l2.val : 0;

        int sum = x + y + carry;
        carry = sum / 10;

        curr.next = new ListNode(sum % 10);
        curr = curr.next;

        if (l1 != null) l1 = l1.next;
        if (l2 != null) l2 = l2.next;
    }

    return dummyHead.next;
}
```

### 完整代码

```java
public class Main {

    // 定义链表节点结构
    public static class ListNode {
        int val;
        ListNode next;
        ListNode() {}
        ListNode(int val) { this.val = val; }
        ListNode(int val, ListNode next) { this.val = val; this.next = next; }
    }

    // 核心算法实现
    public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // 创建一个哑节点作为结果链表的头，简化操作
        ListNode dummyHead = new ListNode(0);
        ListNode curr = dummyHead;
        int carry = 0;

        // 只要还有节点未处理，或者还有进位，就继续循环
        while (l1 != null || l2 != null || carry != 0) {
            // 获取当前位的值，如果链表已经空了，用 0 代替
            int val1 = (l1 != null) ? l1.val : 0;
            int val2 = (l2 != null) ? l2.val : 0;

            // 计算当前位的和以及新的进位
            int sum = val1 + val2 + carry;
            carry = sum / 10;

            // 创建新节点存储当前位的结果（个位数）
            curr.next = new ListNode(sum % 10);
            curr = curr.next;

            // 移动指针
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }

        return dummyHead.next;
    }

    // 辅助方法：使用数组创建链表
    public static ListNode createList(int[] arr) {
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        for (int val : arr) {
            curr.next = new ListNode(val);
            curr = curr.next;
        }
        return dummy.next;
    }

    // 辅助方法：打印链表
    public static void printList(ListNode head) {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        while (head != null) {
            sb.append(head.val);
            if (head.next != null) sb.append(", ");
            head = head.next;
        }
        sb.append("]");
        System.out.println(sb.toString());
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int[] arr1 = {2, 4, 3};
        int[] arr2 = {5, 6, 4};
        ListNode l1 = createList(arr1);
        ListNode l2 = createList(arr2);

        System.out.println("示例 1 输入:");
        System.out.print("l1 = "); printList(l1);
        System.out.print("l2 = "); printList(l2);

        ListNode res1 = addTwoNumbers(l1, l2);
        System.out.print("示例 1 输出: ");
        printList(res1); // 预期: [7, 0, 8]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        int[] arr3 = {0};
        int[] arr4 = {0};
        ListNode l3 = createList(arr3);
        ListNode l4 = createList(arr4);

        System.out.println("示例 2 输入:");
        System.out.print("l1 = "); printList(l3);
        System.out.print("l2 = "); printList(l4);

        ListNode res2 = addTwoNumbers(l3, l4);
        System.out.print("示例 2 输出: ");
        printList(res2); // 预期: [0]
        System.out.println("-----------------------------");

        // --- 示例 3 测试 ---
        int[] arr5 = {9, 9, 9, 9, 9, 9, 9};
        int[] arr6 = {9, 9, 9, 9};
        ListNode l5 = createList(arr5);
        ListNode l6 = createList(arr6);

        System.out.println("示例 3 输入:");
        System.out.print("l1 = "); printList(l5);
        System.out.print("l2 = "); printList(l6);

        ListNode res3 = addTwoNumbers(l5, l6);
        System.out.print("示例 3 输出: ");
        printList(res3); // 预期: [8, 9, 9, 9, 0, 0, 0, 1]
    }
}
```
