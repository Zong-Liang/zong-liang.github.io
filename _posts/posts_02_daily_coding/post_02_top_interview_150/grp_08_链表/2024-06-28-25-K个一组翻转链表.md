---
title: 25-K个一组翻转链表
date: 2024-06-28 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 链表]
tags: [链表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230706037.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

好的，这是从图片中整理出的题目描述和解答代码。

### 题目：25. K 个一组翻转链表

给你链表的头节点 `head`，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

- `k` 是一个正整数，它的值小于或等于链表的长度。
- 如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

---

**示例 1:**
![示例1图片](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

- **输入:** `head = [1,2,3,4,5]`, `k = 2`
- **输出:** `[2,1,4,3,5]`

**示例 2:**
![示例2图片](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

- **输入:** `head = [1,2,3,4,5]`, `k = 3`
- **输出:** `[3,2,1,4,5]`

---

**提示:**

- 链表中的节点数目为 `n`
- `1 <= k <= n <= 5000`
- `0 <= Node.val <= 1000`

**进阶：** 你可以设计一个只用 `O(1)` 额外内存空间的算法解决此问题吗？

---

### Java 8 解答 (赛码网格式)

**算法思路：(递归)**
这个问题可以通过递归优雅地解决，并且能够满足 O(1) 额外空间复杂度的要求（不考虑递归栈空间）。

1.  **分组:**
    - 首先，我们需要确定当前 `head` 后面是否有足够的 `k` 个节点来进行翻转。我们可以遍历 `k` 步，如果中途遇到 `null`，说明剩余节点不足 `k` 个，直接返回 `head`，不做任何翻转。
2.  **翻转当前组:**
    - 如果确定有足够的节点，我们就翻转从 `head` 开始的这 `k` 个节点。我们可以使用标准的迭代法翻转链表。
3.  **连接下一组:**
    - 在翻转当前组后，原来的 `head` 节点会变成这一组的 **尾节点**。
    - 我们需要将这个新的尾节点连接到 **下一组** 翻转后的 **头节点** 上。
    - 下一组的翻转结果可以通过递归调用 `reverseKGroup(next_group_head, k)` 来获得。
4.  **返回新头节点:**
    - 当前组翻转后的新头节点（即原始组的第 `k` 个节点）就是本次递归调用需要返回的结果。

```java
/**
 * 链表节点的定义
 */
class ListNode {
    int val;
    ListNode next;
    ListNode(int val) { this.val = val; }
}

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    /**
     * 每 k 个节点一组进行翻转。
     */
    public static ListNode reverseKGroup(ListNode head, int k) {
        // 1. 检查是否有足够的节点进行翻转
        ListNode current = head;
        for (int i = 0; i < k; i++) {
            if (current == null) {
                // 剩余节点不足 k 个，直接返回
                return head;
            }
            current = current.next;
        }

        // 2. 翻转当前 k 个节点
        ListNode prev = null;
        ListNode curr = head;
        ListNode nextTemp = null;
        for (int i = 0; i < k; i++) {
            nextTemp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextTemp;
        }

        // 3. 递归处理剩余部分，并连接
        if (curr != null) {
            // head 在翻转后是当前组的尾节点
            head.next = reverseKGroup(curr, k);
        }

        // 4. prev 是当前组翻转后的新头节点
        return prev;
    }

    // --- 辅助函数，用于测试 ---
    public static ListNode createLinkedList(int[] arr) {
        if (arr == null || arr.length == 0) return null;
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        for (int val : arr) {
            current.next = new ListNode(val);
            current = current.next;
        }
        return dummy.next;
    }

    public static void printLinkedList(ListNode head) {
        if (head == null) {
            System.out.println("[]");
            return;
        }
        StringBuilder sb = new StringBuilder("[");
        ListNode current = head;
        while (current != null) {
            sb.append(current.val);
            if (current.next != null) sb.append(",");
            current = current.next;
        }
        sb.append("]");
        System.out.println(sb.toString());
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        ListNode head1 = createLinkedList(new int[]{1, 2, 3, 4, 5});
        int k1 = 2;
        System.out.print("输入: head = [1,2,3,4,5], k = " + k1 + "\n");
        ListNode result1 = reverseKGroup(head1, k1);
        System.out.print("输出: ");
        printLinkedList(result1); // 预期输出: [2,1,4,3,5]
        System.out.println();

        System.out.println("--- 示例 2 ---");
        ListNode head2 = createLinkedList(new int[]{1, 2, 3, 4, 5});
        int k2 = 3;
        System.out.print("输入: head = [1,2,3,4,5], k = " + k2 + "\n");
        ListNode result2 = reverseKGroup(head2, k2);
        System.out.print("输出: ");
        printLinkedList(result2); // 预期输出: [3,2,1,4,5]
    }
}
```
