---
title: 25. K个一组翻转链表
date: 2024-06-28 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 链表]
tags: [链表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230706037.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你链表的头节点 `head`，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

- `k` 是一个正整数，它的值小于或等于链表的长度。
- 如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

- **输入:** `head = [1,2,3,4,5]`, `k = 2`
- **输出:** `[2,1,4,3,5]`

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

- **输入:** `head = [1,2,3,4,5]`, `k = 3`
- **输出:** `[3,2,1,4,5]`

**提示:**

- 链表中的节点数目为 `n`
- `1 <= k <= n <= 5000`
- `0 <= Node.val <= 1000`

**进阶：** 你可以设计一个只用 `O(1)` 额外内存空间的算法解决此问题吗？

## 题解

### 解法一：递归法（常规解法）

**思路：**

递归法的逻辑非常清晰，符合“分而治之”的思想。

1.  **检查长度**：首先寻找当前链表部分的第 `k+1` 个节点（即下一组的头节点）。
2.  **终止条件**：如果在找到 `k` 个节点之前链表就结束了（节点数少于 `k`），说明剩余部分不需要反转，直接返回当前的 `head`。
3.  **递归调用**：如果找到了 $k$ 个节点，记录下第 $k+1$ 个节点（记为 `next_group`）。对 `next_group` 进行递归调用，假设它能正确返回后面所有组反转好后的头节点。
4.  **反转当前组**：将当前的 $k$ 个节点进行反转。
5.  **连接**：反转后，原来的 `head` 变成了当前组的尾部，将其 `next` 指向递归返回的结果。
6.  **返回**：返回当前组反转后的新头节点（即原来的第 $k$ 个节点）。

**复杂度分析：**

- **时间复杂度：** $O(N)$。每个节点会被访问常数次。
- **空间复杂度：** $O(N/k)$。主要消耗在递归调用栈上。虽然不是 $O(1)$，但逻辑最易理解。

**代码片段：**

```java
public ListNode reverseKGroup(ListNode head, int k) {
    ListNode cursor = head;
    int count = 0;
    // 1. 找到第 k+1 个节点
    while (cursor != null && count < k) {
        cursor = cursor.next;
        count++;
    }

    // 2. 如果凑够了 k 个节点
    if (count == k) {
        // 3. 递归解决剩下的链表，并获得结果
        // cursor 目前指向下一组的开头
        ListNode reversedRest = reverseKGroup(cursor, k);

        // 4. 反转前 k 个节点（这里需要一个局部的反转逻辑，或者复用标准反转）
        // 简单起见，这里可以用迭代方式反转 head 到 cursor 之间的节点
        // 但为了配合递归结构，通常写个辅助函数或者直接在这里处理
        while (count > 0) {
            ListNode next = head.next;
            head.next = reversedRest; // head 变成尾巴，指向后面已反转的部分
            reversedRest = head;      // reversedRest 向前移动，变成当前新的头
            head = next;
            count--;
        }
        return reversedRest;
    }

    // 节点不足 k 个，不反转，直接返回
    return head;
}
```

### 解法二：迭代法（模拟 - 进阶 O(1) 空间）

**思路：**

为了满足 $O(1)$ 的空间复杂度，我们需要消除递归栈，使用迭代的方式进行分组反转。

1.  **引入哨兵节点**：创建一个 `dummy` 节点指向 `head`，方便处理头节点变化的情况。
2.  **双指针定位**：使用 `pre` 指针指向每一组待反转区域的前一个节点，使用 `end` 指针来寻找当前组的结尾。
3.  **循环处理**：

    - 将 `end` 向后移动 `k` 步。如果途中遇到 `null`，说明剩余节点不足 `k` 个，直接退出循环。
    - 记录下一组的开头 `nextGroup = end.next`。
    - **断开连接**：将 `end.next` 置为 `null`，使当前 $k$ 个节点形成一个独立的链表。
    - **局部反转**：调用标准的链表反转函数，反转从 `pre.next`（记为 `start`）开始的链表。
    - **重新连接**：

      - 将 `pre.next` 指向反转后的新头节点（即原来的 `end`）。
      - 将 `start.next`（现在是尾节点）指向 `nextGroup`。

    - **移动指针**：将 `pre` 和 `end` 重置到 `start` 的位置，准备下一轮循环。

**复杂度分析：**

- **时间复杂度：** $O(N)$。我们需要遍历链表来定位 `end`，然后反转链表，总体每个节点被访问常数次。
- **空间复杂度：** $O(1)$。只使用了有限的几个指针变量，没有递归栈开销。

**代码片段：**

```java
public ListNode reverseKGroup(ListNode head, int k) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;

    ListNode pre = dummy;
    ListNode end = dummy;

    while (end.next != null) {
        // 1. end 指针向后移动 k 步
        for (int i = 0; i < k && end != null; i++) {
            end = end.next;
        }
        // 如果不足 k 个，跳出
        if (end == null) break;

        // 2. 记录断点
        ListNode start = pre.next;
        ListNode nextGroup = end.next;
        end.next = null; // 断开，方便反转

        // 3. 反转子链表，pre 连接新头
        pre.next = reverse(start);

        // 4. 接上后面的链表
        start.next = nextGroup;

        // 5. 移动指针，准备下一轮
        pre = start;
        end = pre;
    }
    return dummy.next;
}

// 辅助函数：标准链表反转
private ListNode reverse(ListNode head) {
    ListNode pre = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode next = curr.next;
        curr.next = pre;
        pre = curr;
        curr = next;
    }
    return pre;
}
```

### 完整代码

```java
import java.util.*;

// 链表节点定义
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

public class Main {

    // 核心算法实现（迭代法 - O(1) 空间）
    public static ListNode reverseKGroup(ListNode head, int k) {
        if (head == null || k == 1) {
            return head;
        }

        // 虚拟头节点
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        // pre 指向待反转区域的前一个节点
        ListNode pre = dummy;
        // end 指向待反转区域的最后一个节点
        ListNode end = dummy;

        while (end.next != null) {
            // 1. 尝试向后移动 k 步，找到当前组的尾部
            for (int i = 0; i < k && end != null; i++) {
                end = end.next;
            }
            // 如果不足 k 个，说明到了最后，不需要反转，直接退出
            if (end == null) break;

            // 2. 记录关键位置
            ListNode start = pre.next;      // 当前组的头部
            ListNode nextGroup = end.next;  // 下一组的头部

            // 3. 断开链表，形成独立子链表以便反转
            end.next = null;

            // 4. 反转该组，并将 pre 指向反转后的新头（即原来的 end）
            pre.next = reverse(start);

            // 5. 此时 start 变成了该组的尾部，将其连接到下一组
            start.next = nextGroup;

            // 6. 更新指针，准备处理下一组
            // 此时 start 在逻辑上已经是当前组的最后一个节点了，所以 pre 和 end 都移到这里
            pre = start;
            end = pre;
        }

        return dummy.next;
    }

    // 辅助方法：反转一个独立的链表，返回新的头节点
    private static ListNode reverse(ListNode head) {
        ListNode pre = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode next = curr.next;
            curr.next = pre;
            pre = curr;
            curr = next;
        }
        return pre;
    }

    // 辅助方法：打印链表
    public static void printList(ListNode head) {
        System.out.print("[");
        ListNode curr = head;
        while (curr != null) {
            System.out.print(curr.val);
            if (curr.next != null) {
                System.out.print(", ");
            }
            curr = curr.next;
        }
        System.out.println("]");
    }

    // 辅助方法：构建链表
    public static ListNode buildList(int[] vals) {
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        for (int val : vals) {
            curr.next = new ListNode(val);
            curr = curr.next;
        }
        return dummy.next;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int[] vals1 = {1, 2, 3, 4, 5};
        int k1 = 2;
        ListNode head1 = buildList(vals1);

        System.out.println("示例 1 输入: head = " + Arrays.toString(vals1) + ", k = " + k1);
        ListNode res1 = reverseKGroup(head1, k1);
        System.out.print("示例 1 输出: ");
        printList(res1);
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        int[] vals2 = {1, 2, 3, 4, 5};
        int k2 = 3;
        ListNode head2 = buildList(vals2);

        System.out.println("示例 2 输入: head = " + Arrays.toString(vals2) + ", k = " + k2);
        ListNode res2 = reverseKGroup(head2, k2);
        System.out.print("示例 2 输出: ");
        printList(res2);
    }
}
```
