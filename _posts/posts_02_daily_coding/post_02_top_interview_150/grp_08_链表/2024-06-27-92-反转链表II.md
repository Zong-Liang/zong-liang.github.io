---
title: 92. 反转链表II
date: 2024-06-27 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 链表]
tags: [链表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230629847.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你单链表的头指针 `head` 和两个整数 `left` 和 `right`，其中 `left <= right`。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表**。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)

- **输入:** `head = [1,2,3,4,5]`, `left = 2`, `right = 4`
- **输出:** `[1,4,3,2,5]`

**示例 2:**

- **输入:** `head = [5]`, `left = 1`, `right = 1`
- **输出:** `[5]`

**提示:**

- 链表中节点数目为 `n`
- `1 <= n <= 500`
- `-500 <= Node.val <= 500`
- `1 <= left <= right <= n`

**进阶：** 你可以使用一趟扫描完成反转吗？

## 题解

### 解法一：截断-反转-拼接（常规解法）

**思路：**

最直观的思路是将需要反转的链表部分“切”出来，单独调用标准的“反转链表”函数（即力扣第 206 题的逻辑），反转完成后，再将其拼接回原链表中。

1.  **定位**：找到 `left` 前一个节点（记为 `pre`）和 `right` 节点（记为 `rightNode`）。
2.  **切断**：记录 `rightNode` 的后继节点 `succ`，切断 `pre` 和 `rightNode` 的连接，形成一个独立的子链表。
3.  **反转**：调用反转函数，将子链表反转。
4.  **拼接**：将 `pre` 指向反转后的新头节点，将反转后的新尾节点指向 `succ`。
5.  **虚拟头节点**：为了处理 `left = 1` 的情况（即头节点也参与反转），使用 `dummy` 节点指向 `head`。

**复杂度分析：**

- **时间复杂度：** $O(N)$。虽然我们只遍历了链表，但寻找切分点和反转子链表在最坏情况下会遍历两次相关区域。
- **空间复杂度：** $O(1)$。只使用了几个指针变量。

**代码片段：**

```java
public ListNode reverseBetween(ListNode head, int left, int right) {
    ListNode dummy = new ListNode(-1);
    dummy.next = head;

    ListNode pre = dummy;
    // 1. 走到 left 的前一个节点
    for (int i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    // 2. 走到 right 节点
    ListNode rightNode = pre;
    for (int i = 0; i < right - left + 1; i++) {
        rightNode = rightNode.next;
    }

    // 3. 切断链表
    ListNode leftNode = pre.next;
    ListNode succ = rightNode.next;

    pre.next = null;
    rightNode.next = null;

    // 4. 反转子链表
    reverseLinkedList(leftNode);

    // 5. 拼接回来
    pre.next = rightNode;
    leftNode.next = succ;

    return dummy.next;
}

// 辅函数：反转链表
private void reverseLinkedList(ListNode head) {
    ListNode pre = null;
    ListNode cur = head;
    while (cur != null) {
        ListNode next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
}
```

### 解法二：头插法（进阶：一次扫描）

**思路：**

为了满足“一次扫描”的要求，我们不能先断开再反转。我们可以在遍历到 `left` 位置后，利用 **“头插法”** 的思想，将后续的节点依次移动到 `left` 位置的前面。

1.  **初始化**：设置 `dummy` 节点指向 `head`，`pre` 指针移动到 `left - 1` 的位置。
2.  **定位当前节点**：`cur` 指向 `pre.next`（即当前子链表的第一个节点，它在反转后会变成子链表的最后一个节点）。
3.  **穿针引线（循环操作）**：

    在 `left` 到 `right` 的区间内，重复以下操作：

    - 取出 `cur` 后面的节点 `next`。
    - 将 `next` 从 `cur` 后面摘除（`cur.next = next.next`）。
    - 将 `next` 插入到 `pre` 的后面（即子链表的最前面）。
    - 更新 `pre.next` 指向新的头 `next`。

4.  **结果**：随着循环进行，`cur` 会不断向后移动（逻辑位置上），而后面的元素会被不断插到 `pre` 之后，从而实现局部反转。

**示意图逻辑：**

假设 `1 -> 2 -> 3 -> 4 -> 5`，`left=2`, `right=4`。

- `pre` 指向 1，`cur` 指向 2。
- **第一轮**：将 3 插到 1 后面。链表变为 `1 -> 3 -> 2 -> 4 -> 5`。
- **第二轮**：将 4 插到 1 后面。链表变为 `1 -> 4 -> 3 -> 2 -> 5`。
- 结束。

**复杂度分析：**

- **时间复杂度：** $O(N)$。只需要遍历一次链表至 `right` 位置。
- **空间复杂度：** $O(1)$。原地修改，不需要额外空间。

**代码片段：**

```java
public ListNode reverseBetween(ListNode head, int left, int right) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;

    ListNode pre = dummy;
    // 1. 移动 pre 到 left-1 的位置
    for (int i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    // cur 指向子链表的第一个节点（即 left 位置的节点）
    ListNode cur = pre.next;

    // 2. 开始穿针引线
    for (int i = 0; i < right - left; i++) {
        ListNode next = cur.next;
        cur.next = next.next;   // 把 next 摘出来
        next.next = pre.next;   // 把 next 插到 pre 后面
        pre.next = next;        // 更新 pre 的 next 指针
    }

    return dummy.next;
}
```

### 完整代码

```java
import java.util.*;

// 链表节点定义
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

public class Main {

    // 核心算法实现（头插法 - 一次扫描）
    public static ListNode reverseBetween(ListNode head, int left, int right) {
        // 设置虚拟头节点，避免处理 left=1 的特殊逻辑
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode pre = dummy;
        // 1. 将 pre 移动到 left 的前一个位置
        for (int i = 0; i < left - 1; i++) {
            pre = pre.next;
        }

        // cur 指向当前需要反转区间的第一个节点
        // 这个节点在反转完成后，会变成区间的最后一个节点
        ListNode cur = pre.next;

        // 2. 遍历并执行“头插法”
        // 只需要执行 right - left 次，因为 cur 本身不需要动，是它后面的节点在动
        for (int i = 0; i < right - left; i++) {
            ListNode next = cur.next;   // 暂存 cur 后面的那个节点

            cur.next = next.next;       // 步骤A：跳过 next，cur 指向 next 的下下个
            next.next = pre.next;       // 步骤B：next 指向当前的区间头
            pre.next = next;            // 步骤C：pre 指向 next（next 变成了新的区间头）
        }

        return dummy.next;
    }

    // 辅助方法：打印链表
    public static void printList(ListNode head) {
        ListNode curr = head;
        System.out.print("[");
        while (curr != null) {
            System.out.print(curr.val);
            if (curr.next != null) {
                System.out.print(", ");
            }
            curr = curr.next;
        }
        System.out.println("]");
    }

    // 辅助方法：构建链表
    public static ListNode buildList(int[] vals) {
        ListNode dummy = new ListNode(0);
        ListNode cur = dummy;
        for (int val : vals) {
            cur.next = new ListNode(val);
            cur = cur.next;
        }
        return dummy.next;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int[] input1 = {1, 2, 3, 4, 5};
        ListNode head1 = buildList(input1);
        int left1 = 2, right1 = 4;

        System.out.println("示例 1 输入: head = " + Arrays.toString(input1) + ", left = " + left1 + ", right = " + right1);
        ListNode res1 = reverseBetween(head1, left1, right1);
        System.out.print("示例 1 输出: ");
        printList(res1);
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        int[] input2 = {5};
        ListNode head2 = buildList(input2);
        int left2 = 1, right2 = 1;

        System.out.println("示例 2 输入: head = " + Arrays.toString(input2) + ", left = " + left2 + ", right = " + right2);
        ListNode res2 = reverseBetween(head2, left2, right2);
        System.out.print("示例 2 输出: ");
        printList(res2);
    }
}
```
