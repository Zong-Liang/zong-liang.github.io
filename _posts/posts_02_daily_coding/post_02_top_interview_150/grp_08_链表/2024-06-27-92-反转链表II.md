---
title: 92. 反转链表II
date: 2024-06-27 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 链表]
tags: [链表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230629847.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：92. 反转链表 II

给你单链表的头指针 `head` 和两个整数 `left` 和 `right`，其中 `left <= right`。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表**。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)

- **输入:** `head = [1,2,3,4,5]`, `left = 2`, `right = 4`
- **输出:** `[1,4,3,2,5]`

**示例 2:**

- **输入:** `head = [5]`, `left = 1`, `right = 1`
- **输出:** `[5]`

**提示:**

- 链表中节点数目为 `n`
- `1 <= n <= 500`
- `-500 <= Node.val <= 500`
- `1 <= left <= right <= n`

**进阶：** 你可以使用一趟扫描完成反转吗？

## Java 代码

**算法思路：(迭代 / 一趟扫描)**

为了在一趟扫描中完成指定区间的反转，我们需要精确定位到反转区域的前一个节点和反转区域的第一个节点。

1.  **虚拟头节点:** 创建一个虚拟头节点 `dummy`，并使其 `next` 指向 `head`。这可以统一处理 `left = 1`（即从头节点开始反转）的边界情况。
2.  **定位:**
    - 创建一个指针 `pre`，初始指向 `dummy`。
    - 向前移动 `pre` 指针 `left - 1` 步，使其指向 **反转区域的前一个节点**。
    - 此时，`pre.next` 就是反转区域的 **第一个节点**，我们用一个指针 `curr` 指向它。
3.  **头插法反转:**
    - 我们将在 `pre` 节点之后，对从 `left` 到 `right` 的 `right - left` 个节点进行反转。
    - 一个巧妙的方法是“头插法”。在循环中，我们依次将 `curr` 后面的节点 `next` 取出，并将其插入到 `pre` 的后面。
    - 循环 `right - left` 次。在每次循环中：
      a. `next = curr.next` (定位到要移动的节点)
      b. `curr.next = next.next` (让 `curr` 跳过 `next`)
      c. `next.next = pre.next` (将 `next` 插入到 `pre` 后面)
      d. `pre.next = next` (完成插入)
4.  **返回结果:**
    - 整个过程结束后，`dummy.next` 就是最终链表的头节点。

```java
/**
 * 链表节点的定义
 */
class ListNode {
    int val;
    ListNode next;
    ListNode(int val) { this.val = val; }
}


public class Main {

    /**
     * 反转从位置 left 到位置 right 的链表节点。
     */
    public static ListNode reverseBetween(ListNode head, int left, int right) {
        // 创建虚拟头节点
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        // 1. 定位到 left 节点的前一个节点 pre
        ListNode pre = dummy;
        for (int i = 0; i < left - 1; i++) {
            pre = pre.next;
        }

        // 2. 定位到 left 节点 curr
        ListNode curr = pre.next;
        ListNode next;

        // 3. 使用头插法进行反转
        for (int i = 0; i < right - left; i++) {
            next = curr.next;
            curr.next = next.next;
            next.next = pre.next;
            pre.next = next;
        }

        return dummy.next;
    }

    // --- 辅助函数，用于测试 ---
    public static ListNode createLinkedList(int[] arr) {
        if (arr == null || arr.length == 0) return null;
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        for (int val : arr) {
            current.next = new ListNode(val);
            current = current.next;
        }
        return dummy.next;
    }

    public static void printLinkedList(ListNode head) {
        if (head == null) {
            System.out.println("[]");
            return;
        }
        StringBuilder sb = new StringBuilder("[");
        ListNode current = head;
        while (current != null) {
            sb.append(current.val);
            if (current.next != null) sb.append(",");
            current = current.next;
        }
        sb.append("]");
        System.out.println(sb.toString());
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        ListNode head1 = createLinkedList(new int[]{1, 2, 3, 4, 5});
        int left1 = 2, right1 = 4;
        System.out.print("输入: head = [1,2,3,4,5], left = " + left1 + ", right = " + right1 + "\n");
        ListNode result1 = reverseBetween(head1, left1, right1);
        System.out.print("输出: ");
        printLinkedList(result1); // 预期输出: [1,4,3,2,5]
        System.out.println();

        System.out.println("--- 示例 2 ---");
        ListNode head2 = createLinkedList(new int[]{5});
        int left2 = 1, right2 = 1;
        System.out.print("输入: head = [5], left = " + left2 + ", right = " + right2 + "\n");
        ListNode result2 = reverseBetween(head2, left2, right2);
        System.out.print("输出: ");
        printLinkedList(result2); // 预期输出: [5]
    }
}
```
