---
title: 82. 删除排序链表中的重复元素II
date: 2024-07-02 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 链表]
tags: [链表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230843620.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个已排序的链表的头 `head`，删除原始链表中所有重复数字的节点，只留下不同的数字。返回 **已排序的链表**。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg)

- **输入:** `head = [1,2,3,3,4,4,5]`
- **输出:** `[1,2,5]`

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg)

- **输入:** `head = [1,1,1,2,3]`
- **输出:** `[2,3]`

**提示:**

- 链表中节点数目在范围 `[0, 300]` 内
- `-100 <= Node.val <= 100`
- 题目数据保证链表已经按 **升序** 排列

## 题解

### 解法：迭代法（一次遍历 + 哑节点）

**思路：**

由于链表是 **有序** 的，重复的元素一定在链表中相邻。我们需要删除所有重复的节点，这意味着如果 `current` 节点和 `current.next` 节点值相同，那么这一组值相同的节点都不能保留。

1.  **哨兵节点 (Dummy Node)**：

    因为头节点 `head` 本身也可能重复（例如 `[1, 1, 2]`），为了避免处理头节点被删除的特殊情况，我们需要创建一个指向 `head` 的哨兵节点 `dummy`。

2.  **指针维护**：

    我们使用一个指针 `cur` 指向当前**确定不重复**的节点（初始为 `dummy`）。

3.  **遍历逻辑**：

    每次检查 `cur` 后面的两个节点（`cur.next` 和 `cur.next.next`）：

    - 如果这两个节点的值 **相等**，说明发现了重复序列。

      - 记录下这个重复的值 `x`。
      - 使用一个内部循环，不断将 `cur.next` 指向 `cur.next.next`，直到 `cur.next` 的值不等于 `x` 为止。
      - 注意：此时**不要**移动 `cur` 指针，因为新的 `cur.next` 可能仍然是另一组重复值的开头。

    - 如果这两个节点的值 **不等**，说明 `cur.next` 是唯一的。

      - 将 `cur` 向后移动一位 (`cur = cur.next`)。

4.  **终止条件**：
    当 `cur.next` 为空或者 `cur.next.next` 为空时，说明后面没有足够的节点来构成重复对，遍历结束。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是链表的长度。虽然有嵌套循环，但每个节点最多被访问两次，因此总体是线性的。
- **空间复杂度：** $O(1)$。只使用了常数个额外的指针变量。

**代码片段：**

```java
public ListNode deleteDuplicates(ListNode head) {
    if (head == null) return null;

    ListNode dummy = new ListNode(0, head);
    ListNode cur = dummy;

    while (cur.next != null && cur.next.next != null) {
        if (cur.next.val == cur.next.next.val) {
            int x = cur.next.val;
            // 跳过所有值等于 x 的节点
            while (cur.next != null && cur.next.val == x) {
                cur.next = cur.next.next;
            }
        } else {
            // 如果不重复，cur 指针后移
            cur = cur.next;
        }
    }

    return dummy.next;
}
```

### 完整代码

```java
public class Main {

    // Definition for singly-linked list.
    public static class ListNode {
        int val;
        ListNode next;
        ListNode() {}
        ListNode(int val) { this.val = val; }
        ListNode(int val, ListNode next) { this.val = val; this.next = next; }
    }

    // 核心算法实现
    public static ListNode deleteDuplicates(ListNode head) {
        if (head == null) {
            return null;
        }

        // 创建哑节点，指向 head，方便处理头节点就是重复的情况
        ListNode dummy = new ListNode(0, head);
        ListNode cur = dummy;

        // 只要后面还有至少两个节点，就需要判断它们是否相同
        while (cur.next != null && cur.next.next != null) {
            if (cur.next.val == cur.next.next.val) {
                int x = cur.next.val;
                // 发现重复，开始删除操作
                // 只要 cur.next 不为空且值等于 x，就将其跳过
                while (cur.next != null && cur.next.val == x) {
                    cur.next = cur.next.next;
                }
                // 注意：这里 cur 不移动，因为新的 cur.next 可能还是重复节点
            } else {
                // 如果后两个节点值不相等，说明 cur.next 是安全的（不重复）
                cur = cur.next;
            }
        }

        return dummy.next;
    }

    // --- 辅助方法：数组转链表 ---
    public static ListNode createList(int[] arr) {
        ListNode dummy = new ListNode(-1);
        ListNode cur = dummy;
        for (int val : arr) {
            cur.next = new ListNode(val);
            cur = cur.next;
        }
        return dummy.next;
    }

    // --- 辅助方法：打印链表 ---
    public static void printList(ListNode head) {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        ListNode cur = head;
        while (cur != null) {
            sb.append(cur.val);
            if (cur.next != null) {
                sb.append(", ");
            }
            cur = cur.next;
        }
        sb.append("]");
        System.out.println(sb.toString());
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int[] arr1 = {1, 2, 3, 3, 4, 4, 5};
        ListNode head1 = createList(arr1);
        System.out.println("示例 1 输入:");
        printList(head1);

        ListNode res1 = deleteDuplicates(head1);

        System.out.println("示例 1 输出:");
        printList(res1); // 预期: [1, 2, 5]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        int[] arr2 = {1, 1, 1, 2, 3};
        ListNode head2 = createList(arr2);
        System.out.println("示例 2 输入:");
        printList(head2);

        ListNode res2 = deleteDuplicates(head2);

        System.out.println("示例 2 输出:");
        printList(res2); // 预期: [2, 3]
        System.out.println("-----------------------------");

        // --- 示例 3 测试 (全部重复) ---
        int[] arr3 = {1, 1};
        ListNode head3 = createList(arr3);
        System.out.println("示例 3 输入:");
        printList(head3);

        ListNode res3 = deleteDuplicates(head3);

        System.out.println("示例 3 输出:");
        printList(res3); // 预期: []
    }
}
```
