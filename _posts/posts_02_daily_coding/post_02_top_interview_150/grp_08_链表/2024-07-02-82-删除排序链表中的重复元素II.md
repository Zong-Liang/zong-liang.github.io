---
title: 82-删除排序链表中的重复元素II
date: 2024-07-02 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 链表]
tags: [链表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230843620.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


### 题目：82. 删除排序链表中的重复元素 II

给定一个已排序的链表的头 `head`，删除原始链表中所有重复数字的节点，只留下不同的数字。返回 **已排序的链表**。

---

**示例 1:**
![示例1图片](https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg)

- **输入:** `head = [1,2,3,3,4,4,5]`
- **输出:** `[1,2,5]`

**示例 2:**
![示例2图片](https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg)

- **输入:** `head = [1,1,1,2,3]`
- **输出:** `[2,3]`

---

**提示:**

- 链表中节点数目在范围 `[0, 300]` 内
- `-100 <= Node.val <= 100`
- 题目数据保证链表已经按 **升序** 排列

---

### Java 8 解答 (赛码网格式)

**算法思路：(迭代 / 虚拟头节点)**
这个问题的关键在于，当发现重复节点时，我们需要将 **所有** 重复的节点都删除，而不仅仅是保留一个。因为头节点也可能被删除，所以使用一个 **虚拟头节点 (dummy head)** 会让代码逻辑更简洁。

1.  **初始化:**
    - 创建一个虚拟头节点 `dummy`，并使其 `next` 指向原始的头节点 `head`。
    - 创建一个 `current` 指针，初始指向 `dummy`。`current` 将作为新链表的尾指针。
2.  **遍历链表:**
    - 使用一个循环，只要 `current.next` (即 potential next node) 和 `current.next.next` (即 potential duplicate) 都存在，就进行检查。
3.  **检查重复:**
    - **如果 `current.next.val == current.next.next.val`:**
      - 这表示我们遇到了一个重复的数值。
      - 记录下这个重复值 `duplicateVal`。
      - 进入一个内部循环，不断地将 `current.next` 向后移动，直到 `current.next` 为空或者其值不再是 `duplicateVal`。这样就跳过了所有重复的节点。
    - **如果不重复:**
      - 说明 `current.next` 是一个应该被保留的唯一节点。
      - 我们只需将 `current` 指针向后移动一位即可：`current = current.next`。
4.  **返回结果:**
    - 循环结束后，`dummy.next` 就是处理完毕的链表的头节点。

```java
/**
 * 链表节点的定义
 */
class ListNode {
    int val;
    ListNode next;
    ListNode(int val) { this.val = val; }
}

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    /**
     * 删除排序链表中所有重复数字的节点。
     */
    public static ListNode deleteDuplicates(ListNode head) {
        // 处理空链表或单节点链表
        if (head == null || head.next == null) {
            return head;
        }

        // 创建虚拟头节点，以简化对头节点的处理
        ListNode dummy = new ListNode(0); // 虚拟头节点的值可以任意
        dummy.next = head;

        ListNode current = dummy;

        while (current.next != null && current.next.next != null) {
            // 检查是否存在重复节点
            if (current.next.val == current.next.next.val) {
                int duplicateVal = current.next.val;
                // 持续删除所有值等于 duplicateVal 的节点
                while (current.next != null && current.next.val == duplicateVal) {
                    current.next = current.next.next;
                }
            } else {
                // 如果没有重复，则移动 current 指针
                current = current.next;
            }
        }

        return dummy.next;
    }

    // --- 辅助函数，用于测试 ---
    public static ListNode createLinkedList(int[] arr) {
        if (arr == null || arr.length == 0) return null;
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        for (int val : arr) {
            current.next = new ListNode(val);
            current = current.next;
        }
        return dummy.next;
    }

    public static void printLinkedList(ListNode head) {
        if (head == null) {
            System.out.println("[]");
            return;
        }
        StringBuilder sb = new StringBuilder("[");
        ListNode current = head;
        while (current != null) {
            sb.append(current.val);
            if (current.next != null) sb.append(",");
            current = current.next;
        }
        sb.append("]");
        System.out.println(sb.toString());
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        ListNode head1 = createLinkedList(new int[]{1, 2, 3, 3, 4, 4, 5});
        System.out.print("输入: head = [1,2,3,3,4,4,5]\n");
        ListNode result1 = deleteDuplicates(head1);
        System.out.print("输出: ");
        printLinkedList(result1); // 预期输出: [1,2,5]
        System.out.println();

        System.out.println("--- 示例 2 ---");
        ListNode head2 = createLinkedList(new int[]{1, 1, 1, 2, 3});
        System.out.print("输入: head = [1,1,1,2,3]\n");
        ListNode result2 = deleteDuplicates(head2);
        System.out.print("输出: ");
        printLinkedList(result2); // 预期输出: [2,3]
    }
}
```
