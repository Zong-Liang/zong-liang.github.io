---
title: 141. 环形链表
date: 2024-06-22 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 链表]
tags: [链表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230333464.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：141. 环形链表

给你一个链表的头节点 `head`，判断链表中是否有环。

如果链表中存在某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递**。仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 `true`。否则，返回 `false`。

**示例 1:**

![示例1图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

- **输入:** `head = [3,2,0,-4]`, `pos = 1`
- **输出:** `true`
- **解释:** 链表中有一个环，其尾部连接到第二个节点。

**示例 2:**

![示例2图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

- **输入:** `head = [1,2]`, `pos = 0`
- **输出:** `true`
- **解释:** 链表中有一个环，其尾部连接到第一个节点。

**示例 3:**

![示例3图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

- **输入:** `head = [1]`, `pos = -1`
- **输出:** `false`
- **解释:** 链表中没有环。

**提示:**

- 链表中节点的数目范围是 `[0, 10^4]`
- `-10^5 <= Node.val <= 10^5`
- `pos` 为 `-1` 或者链表中的一个 **有效索引**。

**进阶：** 你能用 `O(1)`（即，常量）内存解决此问题吗？

## Java 代码

**算法思路：(快慢指针 / Floyd 判环算法)**

为了满足 `O(1)` 空间复杂度的进阶要求，我们不能使用哈希表来记录访问过的节点。此时，**快慢指针** 是解决这个问题的标准且优雅的方法。

1.  **初始化指针:** 创建两个指针，`slow` 和 `fast`，都从头节点 `head` 开始。
2.  **移动指针:**
    - `slow` 指针每次向前移动一步。
    - `fast` 指针每次向前移动两步。
3.  **判断相遇:**
    - **如果链表中没有环**，`fast` 指针（或 `fast.next`）最终会先到达链表的末尾，变为 `null`。
    - **如果链表中存在环**，`fast` 指针会进入环并开始“兜圈子”，而 `slow` 指针稍后也会进入环。由于 `fast` 比 `slow` 跑得快，它最终必然会在环中的某个节点追上 `slow`，即两个指针指向同一个节点。
4.  **循环条件:** 我们的循环应该在 `fast` 和 `fast.next` 都不为 `null` 的情况下持续进行。一旦循环结束（因为 `fast` 遇到 `null`），就说明没有环。如果在循环内部发现 `slow == fast`，就说明存在环。

```java
/**
 * 链表节点的定义
 */
class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}


public class Main {

    /**
     * 判断链表中是否有环。
     */
    public static boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }

        ListNode slow = head;
        ListNode fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            // 如果快慢指针相遇，说明存在环
            if (slow == fast) {
                return true;
            }
        }

        // 如果 fast 指针到达末尾，说明没有环
        return false;
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        // 构建带环链表: 3 -> 2 -> 0 -> -4 -> 2
        ListNode head1 = new ListNode(3);
        ListNode node2 = new ListNode(2);
        ListNode node0 = new ListNode(0);
        ListNode node_4 = new ListNode(-4);
        head1.next = node2;
        node2.next = node0;
        node0.next = node_4;
        node_4.next = node2; // 形成环
        System.out.println("输入: head = [3,2,0,-4], pos = 1");
        boolean result1 = hasCycle(head1);
        System.out.println("输出: " + result1); // 预期输出: true
        System.out.println();

        System.out.println("--- 示例 2 ---");
        // 构建带环链表: 1 -> 2 -> 1
        ListNode head2 = new ListNode(1);
        ListNode node2_2 = new ListNode(2);
        head2.next = node2_2;
        node2_2.next = head2; // 形成环
        System.out.println("输入: head = [1,2], pos = 0");
        boolean result2 = hasCycle(head2);
        System.out.println("输出: " + result2); // 预期输出: true
        System.out.println();

        System.out.println("--- 示例 3 ---");
        ListNode head3 = new ListNode(1);
        System.out.println("输入: head = [1], pos = -1");
        boolean result3 = hasCycle(head3);
        System.out.println("输出: " + result3); // 预期输出: false
    }
}
```
