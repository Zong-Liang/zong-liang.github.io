---
title: 141. 环形链表
date: 2024-06-22 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 链表]
tags: [链表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230333464.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个链表的头节点 `head`，判断链表中是否有环。

如果链表中存在某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递**。仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 `true`。否则，返回 `false`。

**示例 1:**

![示例1图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

- **输入:** `head = [3,2,0,-4]`, `pos = 1`
- **输出:** `true`
- **解释:** 链表中有一个环，其尾部连接到第二个节点。

**示例 2:**

![示例2图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

- **输入:** `head = [1,2]`, `pos = 0`
- **输出:** `true`
- **解释:** 链表中有一个环，其尾部连接到第一个节点。

**示例 3:**

![示例3图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

- **输入:** `head = [1]`, `pos = -1`
- **输出:** `false`
- **解释:** 链表中没有环。

**提示:**

- 链表中节点的数目范围是 `[0, 10^4]`
- `-10^5 <= Node.val <= 10^5`
- `pos` 为 `-1` 或者链表中的一个 **有效索引**。

**进阶：** 你能用 `O(1)`（即，常量）内存解决此问题吗？

## 题解

### 解法一：哈希表

**思路：**

我们可以通过检查一个节点此前是否被访问过来判断链表是否包含环。

最简单的方法是使用哈希表（`HashSet`）来存储所有已经访问过的节点。

1.  遍历链表中的每个节点。
2.  每次遍历到一个节点时，判断该节点是否已经在哈希表中：

    - 如果存在，说明我们再次回到了该节点，链表中有环，返回 `true`。
    - 如果不存在，将该节点加入哈希表，继续遍历。

3.  如果遍历结束（遇到 `null`），说明链表没有环，返回 `false`。

**复杂度分析：**

- **时间复杂度：** $O(N)$，其中 $N$ 是链表中的节点数。我们最多访问每个节点一次。
- **空间复杂度：** $O(N)$，最坏情况下我们需要将链表中的所有节点都添加到哈希表中。

**代码片段：**

```java
public boolean hasCycle(ListNode head) {
    Set<ListNode> seen = new HashSet<>();
    while (head != null) {
        if (!seen.add(head)) {
            // 如果 add 返回 false，说明元素已存在
            return true;
        }
        head = head.next;
    }
    return false;
}
```

### 解法二：快慢指针（Floyd 判圈算法）- 进阶解法

**思路：**

这是一个经典算法，通常称为“龟兔赛跑”算法。我们可以利用两个指针来解决这个问题，而不需要额外的存储空间。

1.  **定义指针**：定义两个指针，`slow`（慢指针）和 `fast`（快指针）。初始时都指向链表头部 `head`。
2.  **移动策略**：

    - `slow` 指针每次向后移动 **1** 步。
    - `fast` 指针每次向后移动 **2** 步。

3.  **判断逻辑**：

    - 如果链表中不存在环，`fast` 指针最终会遇到 `null`（到达链表尾部），此时返回 `false`。
    - 如果链表中存在环，`fast` 指针就像在环形跑道上跑步一样，由于它比 `slow` 跑得快，最终一定会在环内“追上” `slow` 指针（即 `fast == slow`）。一旦相遇，返回 `true`。

**复杂度分析：**

- **时间复杂度：** $O(N)$。

  - 当链表中不存在环时，快指针走完链表，时间复杂度为 $O(N)$。
  - 当链表中存在环时，快慢指针进入环后，快指针每轮追赶慢指针 1 步，最终会在有限步数内相遇。

- **空间复杂度：** $O(1)$。我们只使用了两个指针变量，满足进阶要求。

**代码片段：**

```java
public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) {
        return false;
    }

    ListNode slow = head;
    ListNode fast = head.next;

    while (slow != fast) {
        // 如果快指针走到了尽头，说明没有环
        if (fast == null || fast.next == null) {
            return false;
        }
        slow = slow.next;
        fast = fast.next.next;
    }

    return true;
}
// 或者另一种写法，初始都指向 head
public boolean hasCycleAlternative(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) {
            return true;
        }
    }
    return false;
}
```

### 完整代码

```java
import java.util.*;

// 链表节点定义
class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
        val = x;
        next = null;
    }
}

public class Main {

    // 核心算法实现（快慢指针法 O(1) 空间）
    public static boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }

        ListNode slow = head;
        ListNode fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;       // 慢指针走一步
            fast = fast.next.next;  // 快指针走两步

            // 如果相遇，说明有环
            if (slow == fast) {
                return true;
            }
        }

        // 如果循环结束，说明 fast 走到了 null，没有环
        return false;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        // 构造链表: 3 -> 2 -> 0 -> -4 -> (回到 index 1，即节点 2)
        ListNode n1 = new ListNode(3);
        ListNode n2 = new ListNode(2);
        ListNode n3 = new ListNode(0);
        ListNode n4 = new ListNode(-4);

        n1.next = n2;
        n2.next = n3;
        n3.next = n4;
        n4.next = n2; // 制造环：尾部 -4 指向索引 1 的节点 2

        System.out.println("示例 1 输入: head = [3,2,0,-4], pos = 1");
        System.out.println("示例 1 输出: " + hasCycle(n1)); // 预期 true
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        // 构造链表: 1 -> 2 -> (回到 index 0，即节点 1)
        ListNode m1 = new ListNode(1);
        ListNode m2 = new ListNode(2);

        m1.next = m2;
        m2.next = m1; // 制造环

        System.out.println("示例 2 输入: head = [1,2], pos = 0");
        System.out.println("示例 2 输出: " + hasCycle(m1)); // 预期 true
        System.out.println("-----------------------------");

        // --- 示例 3 测试 ---
        // 构造链表: 1 -> null
        ListNode k1 = new ListNode(1);

        System.out.println("示例 3 输入: head = [1], pos = -1");
        System.out.println("示例 3 输出: " + hasCycle(k1)); // 预期 false
    }
}
```
