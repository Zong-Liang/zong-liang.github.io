---
title: 61. 旋转链表
date: 2024-07-03 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 链表]
tags: [链表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230926161.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：61. 旋转链表

给你一个链表的头节点 `head`，旋转链表，将链表每个节点向右移动 `k` 个位置。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)

- **输入:** `head = [1,2,3,4,5]`, `k = 2`
- **输出:** `[4,5,1,2,3]`

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg)

- **输入:** `head = [0,1,2]`, `k = 4`
- **输出:** `[2,0,1]`

**提示:**

- 链表中节点的数目在范围 `[0, 500]` 内
- `-100 <= Node.val <= 100`
- `0 <= k <= 2 * 10^9`

## Java 代码

**算法思路：(闭合成环)**

一个直观且高效的解法是将链表 **闭合成环**，然后找到新的断开点。

1.  **处理边界情况:** 如果链表为空、只有一个节点或者 `k` 为 0，则无需旋转，直接返回原头节点。
2.  **计算长度并成环:**
    - 遍历整个链表，计算其长度 `length`。
    - 在遍历到最后一个节点时，将其 `next` 指针指向原始的头节点 `head`，形成一个环。
3.  **计算有效位移:**
    - 由于 `k` 可能非常大，而每旋转 `length` 次链表就会回到原位，所以实际需要移动的步数是 `k % length`。
    - 我们需要找到新的头节点，它位于旧头节点向左移动 `k % length` 个位置，或者说，位于旧尾节点向右移动 `length - (k % length)` 个位置。
4.  **找到断开点:**
    - 从原始头节点开始，向前移动 `length - (k % length) - 1` 步，到达新的尾节点。
    - 新的头节点就是这个新尾节点的下一个节点。
5.  **断开环并返回:**
    - 将新尾节点的 `next` 指针设为 `null`，断开环。
    - 返回新的头节点。

```java
/**
 * 链表节点的定义
 */
class ListNode {
    int val;
    ListNode next;
    ListNode(int val) { this.val = val; }
}


public class Main {

    /**
     * 旋转链表，将链表每个节点向右移动 k 个位置。
     */
    public static ListNode rotateRight(ListNode head, int k) {
        // 1. 处理边界情况
        if (head == null || head.next == null || k == 0) {
            return head;
        }

        // 2. 计算长度并成环
        int length = 1;
        ListNode tail = head;
        while (tail.next != null) {
            tail = tail.next;
            length++;
        }
        tail.next = head; // 形成环

        // 3. 计算有效位移
        int effectiveK = k % length;
        int stepsToNewHead = length - effectiveK;

        // 4. 找到新的尾节点和头节点
        ListNode newTail = tail; // 从旧的尾节点开始
        for (int i = 0; i < stepsToNewHead; i++) {
            newTail = newTail.next;
        }
        ListNode newHead = newTail.next;

        // 5. 断开环
        newTail.next = null;

        return newHead;
    }

    // 辅助函数，用于测试
    public static ListNode createLinkedList(int[] arr) {
        if (arr == null || arr.length == 0) return null;
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        for (int val : arr) {
            current.next = new ListNode(val);
            current = current.next;
        }
        return dummy.next;
    }

    public static void printLinkedList(ListNode head) {
        if (head == null) {
            System.out.println("[]");
            return;
        }
        StringBuilder sb = new StringBuilder("[");
        ListNode current = head;
        while (current != null) {
            sb.append(current.val);
            if (current.next != null) sb.append(",");
            current = current.next;
        }
        sb.append("]");
        System.out.println(sb.toString());
    }


    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        ListNode head1 = createLinkedList(new int[]{1, 2, 3, 4, 5});
        int k1 = 2;
        System.out.print("输入: head = [1,2,3,4,5], k = " + k1 + "\n");
        ListNode result1 = rotateRight(head1, k1);
        System.out.print("输出: ");
        printLinkedList(result1); // 预期输出: [4,5,1,2,3]
        System.out.println();

        System.out.println("--- 示例 2 ---");
        ListNode head2 = createLinkedList(new int[]{0, 1, 2});
        int k2 = 4;
        System.out.print("输入: head = [0,1,2], k = " + k2 + "\n");
        ListNode result2 = rotateRight(head2, k2);
        System.out.print("输出: ");
        printLinkedList(result2); // 预期输出: [2,0,1]
    }
}
```
