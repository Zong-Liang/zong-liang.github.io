---
title: 61. 旋转链表
date: 2024-07-03 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 链表]
tags: [链表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230926161.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个链表的头节点 `head`，旋转链表，将链表每个节点向右移动 `k` 个位置。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)

- **输入:** `head = [1,2,3,4,5]`, `k = 2`
- **输出:** `[4,5,1,2,3]`

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg)

- **输入:** `head = [0,1,2]`, `k = 4`
- **输出:** `[2,0,1]`

**提示:**

- 链表中节点的数目在范围 `[0, 500]` 内
- `-100 <= Node.val <= 100`
- `0 <= k <= 2 * 10^9`

## 题解

### 解法：闭合为环再断开

**思路：**

将链表向右旋转 `k` 个位置，实际上是将链表的**倒数** `k` 个节点移到链表的头部。

我们可以采用“闭合为环”的策略来优雅地解决这个问题：

1.  **求长度与找尾节点**：首先遍历整个链表，求出链表的长度 `n`，并找到链表的尾节点（`old_tail`）。
2.  **处理 k**：由于 `k` 可能大于链表长度 `n`，我们需要计算有效旋转次数 `k = k % n`。如果 `k == 0`，说明不需要旋转，直接返回原链表。
3.  **闭合成环**：将尾节点的 `next` 指向头节点（`old_tail.next = head`），此时链表变成了一个环。
4.  **寻找新断点**：

    - 向右旋转 `k` 步，相当于新链表的尾节点（`new_tail`）在原链表尾节点的前面 `k` 个位置，或者是从原链表尾节点开始向后走 `n - k` 步的位置。
    - 我们让 `old_tail` 再移动 `n - k` 次，到达新的尾节点位置。

5.  **断开环**：

    - 记录新头节点 `new_head = new_tail.next`。
    - 断开环 `new_tail.next = null`。

6.  **返回**：返回 `new_head`。

**复杂度分析：**

- **时间复杂度：** $O(n)$。我们需要遍历一次链表计算长度，然后再移动指针找到新的断点，总共移动步数不超过 $2n$。
- **空间复杂度：** $O(1)$。只使用了常数个额外的指针变量。

**代码片段：**

```java
public ListNode rotateRight(ListNode head, int k) {
    // 1. 边界条件处理：链表为空、只有一个节点或 k=0
    if (head == null || head.next == null || k == 0) {
        return head;
    }

    // 2. 计算链表长度 n，并找到尾节点
    ListNode iter = head;
    int n = 1;
    while (iter.next != null) {
        iter = iter.next;
        n++;
    }

    // iter 现在指向旧的尾节点 (old_tail)

    // 3. 计算有效移动步数
    int add = n - k % n;
    // 如果 k 是 n 的倍数，无需旋转
    if (add == n) {
        return head;
    }

    // 4. 将链表闭合成环
    iter.next = head;

    // 5. 寻找新的尾节点：从旧尾节点向后移动 n - k % n 步
    while (add-- > 0) {
        iter = iter.next;
    }

    // 6. 断开环并确定新头节点
    ListNode ret = iter.next;
    iter.next = null;

    return ret;
}
```

### 完整代码

```java
public class Main {

    // 定义链表节点
    public static class ListNode {
        int val;
        ListNode next;
        ListNode() {}
        ListNode(int val) { this.val = val; }
        ListNode(int val, ListNode next) { this.val = val; this.next = next; }
    }

    // 核心算法实现
    public static ListNode rotateRight(ListNode head, int k) {
        // 1. 处理特殊情况：链表为空、单节点、或 k=0
        if (head == null || head.next == null || k == 0) {
            return head;
        }

        // 2. 统计链表长度，同时让指针停在最后一个节点
        ListNode iter = head;
        int n = 1;
        while (iter.next != null) {
            iter = iter.next;
            n++;
        }

        // 此时 iter 是旧的尾节点

        // 3. 计算实际需要移动的步数
        // 如果 k 大于 n，取模；如果取模后为 0，说明转回原样，直接返回
        int steps = n - k % n;
        if (steps == n) {
            return head;
        }

        // 4. 闭合成环
        iter.next = head;

        // 5. 移动到新的尾节点位置
        // 我们从旧尾节点(iter)开始走 steps 步
        while (steps-- > 0) {
            iter = iter.next;
        }

        // 6. 确定新头节点，并断开环
        ListNode newHead = iter.next;
        iter.next = null;

        return newHead;
    }

    // --- 辅助方法：数组转链表 ---
    public static ListNode createList(int[] arr) {
        if (arr.length == 0) return null;
        ListNode head = new ListNode(arr[0]);
        ListNode curr = head;
        for (int i = 1; i < arr.length; i++) {
            curr.next = new ListNode(arr[i]);
            curr = curr.next;
        }
        return head;
    }

    // --- 辅助方法：打印链表 ---
    public static void printList(ListNode head) {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        ListNode cur = head;
        while (cur != null) {
            sb.append(cur.val);
            if (cur.next != null) {
                sb.append(", ");
            }
            cur = cur.next;
        }
        sb.append("]");
        System.out.println(sb.toString());
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int[] arr1 = {1, 2, 3, 4, 5};
        int k1 = 2;
        ListNode head1 = createList(arr1);

        System.out.println("示例 1 输入:");
        System.out.print("head = "); printList(head1);
        System.out.println("k = " + k1);

        ListNode res1 = rotateRight(head1, k1);

        System.out.print("示例 1 输出: ");
        printList(res1); // 预期: [4, 5, 1, 2, 3]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        int[] arr2 = {0, 1, 2};
        int k2 = 4;
        ListNode head2 = createList(arr2);

        System.out.println("示例 2 输入:");
        System.out.print("head = "); printList(head2);
        System.out.println("k = " + k2);

        ListNode res2 = rotateRight(head2, k2);

        System.out.print("示例 2 输出: ");
        printList(res2); // 预期: [2, 0, 1]
        System.out.println("-----------------------------");

        // --- 示例 3 测试 (k 是长度倍数) ---
        int[] arr3 = {1, 2};
        int k3 = 2; // k % n == 0
        ListNode head3 = createList(arr3);

        System.out.println("示例 3 输入:");
        System.out.print("head = "); printList(head3);
        System.out.println("k = " + k3);

        ListNode res3 = rotateRight(head3, k3);

        System.out.print("示例 3 输出: ");
        printList(res3); // 预期: [1, 2]
    }
}
```
