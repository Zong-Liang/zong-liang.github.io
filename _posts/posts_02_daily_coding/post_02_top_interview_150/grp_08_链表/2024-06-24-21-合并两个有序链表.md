---
title: 21. 合并两个有序链表
date: 2024-06-24 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 链表]
tags: [链表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230433509.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：21. 合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

- **输入:** `l1 = [1,2,4]`, `l2 = [1,3,4]`
- **输出:** `[1,1,2,3,4,4]`

**示例 2:**

- **输入:** `l1 = []`, `l2 = []`
- **输出:** `[]`

**示例 3:**

- **输入:** `l1 = []`, `l2 = [0]`
- **输出:** `[0]`

**提示:**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列

## Java 代码

**算法思路：(迭代 / 虚拟头节点)**

这是一个经典的链表合并问题。我们可以通过迭代的方式，逐一比较两个链表的节点来构建新的合并链表。

1.  **初始化:**
    - 创建一个 **虚拟头节点 (dummy head)** `dummy`。这可以极大地简化代码，避免对头节点的特殊处理。
    - 创建一个指针 `current`，初始指向 `dummy`，用于构建新链表。
2.  **迭代合并:**
    - 当 `l1` 和 `l2` 都不为空时，进行循环：
      a. 比较 `l1.val` 和 `l2.val`。
      b. 将值较小的那个节点连接到 `current.next`。
      c. 将被选中的那个节点的指针向后移动一位。
      d. 将 `current` 指针也向后移动一位。
3.  **连接剩余部分:**
    - 循环结束后，`l1` 和 `l2` 中最多只有一个还不为空。
    - 将 `current.next` 指向这个不为空的链表，即可连接所有剩余的节点。
4.  **返回结果:**
    - 返回 `dummy.next`，它就是合并后链表的真正头节点。

```java
/**
 * 链表节点的定义
 */
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
}


public class Main {

    /**
     * 将两个升序链表合并为一个新的升序链表。
     */
    public static ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // 创建虚拟头节点
        ListNode dummy = new ListNode(-1);
        // 创建一个指针用于构建新链表
        ListNode current = dummy;

        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                current.next = l1;
                l1 = l1.next;
            } else {
                current.next = l2;
                l2 = l2.next;
            }
            current = current.next;
        }

        // 连接剩余的链表部分
        current.next = (l1 != null) ? l1 : l2;

        return dummy.next;
    }

    // --- 辅助函数，用于测试 ---
    public static ListNode createLinkedList(int[] arr) {
        if (arr == null || arr.length == 0) return null;
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        for (int val : arr) {
            current.next = new ListNode(val);
            current = current.next;
        }
        return dummy.next;
    }

    public static void printLinkedList(ListNode head) {
        if (head == null) {
            System.out.println("[]");
            return;
        }
        StringBuilder sb = new StringBuilder("[");
        ListNode current = head;
        while (current != null) {
            sb.append(current.val);
            if (current.next != null) sb.append(",");
            current = current.next;
        }
        sb.append("]");
        System.out.println(sb.toString());
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        ListNode l1 = createLinkedList(new int[]{1, 2, 4});
        ListNode l2 = createLinkedList(new int[]{1, 3, 4});
        System.out.print("输入: l1 = [1,2,4], l2 = [1,3,4]\n");
        ListNode result1 = mergeTwoLists(l1, l2);
        System.out.print("输出: ");
        printLinkedList(result1); // 预期输出: [1,1,2,3,4,4]
        System.out.println();

        System.out.println("--- 示例 2 ---");
        ListNode l3 = createLinkedList(new int[]{});
        ListNode l4 = createLinkedList(new int[]{});
        System.out.print("输入: l1 = [], l2 = []\n");
        ListNode result2 = mergeTwoLists(l3, l4);
        System.out.print("输出: ");
        printLinkedList(result2); // 预期输出: []
        System.out.println();

        System.out.println("--- 示例 3 ---");
        ListNode l5 = createLinkedList(new int[]{});
        ListNode l6 = createLinkedList(new int[]{0});
        System.out.print("输入: l1 = [], l2 = [0]\n");
        ListNode result3 = mergeTwoLists(l5, l6);
        System.out.print("输出: ");
        printLinkedList(result3); // 预期输出: [0]
    }
}
```
