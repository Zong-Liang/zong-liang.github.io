---
title: 21. 合并两个有序链表
date: 2024-06-24 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 链表]
tags: [链表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230433509.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

- **输入:** `l1 = [1,2,4]`, `l2 = [1,3,4]`
- **输出:** `[1,1,2,3,4,4]`

**示例 2:**

- **输入:** `l1 = []`, `l2 = []`
- **输出:** `[]`

**示例 3:**

- **输入:** `l1 = []`, `l2 = [0]`
- **输出:** `[0]`

**提示:**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列

## 题解

### 解法一：迭代法（虚拟头节点 + 双指针）

**思路：**

我们可以用迭代的方法来实现链表的合并。因为两个链表都是有序的，我们只需要同时遍历两个链表，比较它们的头节点，将较小的节点拼接到结果链表中即可。

1.  **虚拟头节点 (Dummy Node)**：为了简化对结果链表头部的处理（避免处理“头节点为空”或“确定谁是头节点”的边界情况），我们创建一个哨兵节点 `prehead`。
2.  **维护指针**：使用一个指针 `prev` 指向当前结果链表的末尾。
3.  **循环比较**：

    - 当 `l1` 和 `l2` 都不为空时，比较 `l1.val` 和 `l2.val`。
    - 如果 `l1.val` 较小，将 `prev.next` 指向 `l1`，并将 `l1` 向后移动。
    - 否则，将 `prev.next` 指向 `l2`，并将 `l2` 向后移动。
    - 每次操作后，`prev` 指针也向后移动一步。

4.  **处理剩余节点**：当循环结束时，其中一个链表可能还有剩余节点（因为两个链表长度可能不同）。由于链表是有序的，我们直接将 `prev.next` 指向剩余的那个非空链表即可。

**复杂度分析：**

- **时间复杂度：** $O(n + m)$，其中 $n$ 和 $m$ 分别为两个链表的长度。我们需要遍历两个链表的所有节点。
- **空间复杂度：** $O(1)$。我们只需要常数空间的指针变量，不需要申请新的节点空间（原地调整指针）。

**代码片段：**

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode prehead = new ListNode(-1);
    ListNode prev = prehead;

    while (l1 != null && l2 != null) {
        if (l1.val <= l2.val) {
            prev.next = l1;
            l1 = l1.next;
        } else {
            prev.next = l2;
            l2 = l2.next;
        }
        prev = prev.next;
    }

    // 合并后 l1 和 l2 最多只有一个还未被合并完，直接接在后面
    prev.next = (l1 == null) ? l2 : l1;

    return prehead.next;
}
```

### 解法二：递归法

**思路：**

利用递归的性质，我们可以将问题分解：

- 如果 `l1` 为空，返回 `l2`。
- 如果 `l2` 为空，返回 `l1`。
- 如果 `l1.val < l2.val`，那么 `l1` 应该是合并后链表的头节点，其 `next` 指向 **`l1.next` 和 `l2` 合并后的结果**。
- 否则，`l2` 是头节点，其 `next` 指向 **`l1` 和 `l2.next` 合并后的结果**。

**复杂度分析：**

- **时间复杂度：** $O(n + m)$。
- **空间复杂度：** $O(n + m)$。递归调用会消耗栈空间，栈的深度取决于链表的长度。

**代码片段：**

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if (l1 == null) return l2;
    if (l2 == null) return l1;

    if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
}
```

### 完整代码

```java
public class Main {

    // 定义链表节点
    public static class ListNode {
        int val;
        ListNode next;
        ListNode() {}
        ListNode(int val) { this.val = val; }
        ListNode(int val, ListNode next) { this.val = val; this.next = next; }
    }

    // 核心算法实现（迭代法，推荐）
    public static ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // 创建一个虚拟头节点
        ListNode prehead = new ListNode(-1);
        ListNode prev = prehead;

        // 当两个链表都不为空时，比较并拼接
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                prev.next = l1;
                l1 = l1.next;
            } else {
                prev.next = l2;
                l2 = l2.next;
            }
            prev = prev.next;
        }

        // 处理剩余部分：直接接上非空的那个链表
        prev.next = (l1 == null) ? l2 : l1;

        return prehead.next;
    }

    // 辅助方法：从数组创建链表
    public static ListNode createList(int[] arr) {
        ListNode dummy = new ListNode(-1);
        ListNode curr = dummy;
        for (int val : arr) {
            curr.next = new ListNode(val);
            curr = curr.next;
        }
        return dummy.next;
    }

    // 辅助方法：打印链表
    public static void printList(ListNode head) {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        while (head != null) {
            sb.append(head.val);
            if (head.next != null) sb.append(", ");
            head = head.next;
        }
        sb.append("]");
        System.out.println(sb.toString());
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int[] arr1 = {1, 2, 4};
        int[] arr2 = {1, 3, 4};
        ListNode l1 = createList(arr1);
        ListNode l2 = createList(arr2);

        System.out.println("示例 1 输入:");
        System.out.print("l1 = "); printList(l1);
        System.out.print("l2 = "); printList(l2);

        ListNode res1 = mergeTwoLists(l1, l2);
        System.out.print("示例 1 输出: ");
        printList(res1); // 预期: [1, 1, 2, 3, 4, 4]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 (双空) ---
        int[] arr3 = {};
        int[] arr4 = {};
        ListNode l3 = createList(arr3);
        ListNode l4 = createList(arr4);

        System.out.println("示例 2 输入:");
        System.out.print("l1 = "); printList(l3);
        System.out.print("l2 = "); printList(l4);

        ListNode res2 = mergeTwoLists(l3, l4);
        System.out.print("示例 2 输出: ");
        printList(res2); // 预期: []
        System.out.println("-----------------------------");

        // --- 示例 3 测试 (一空一非空) ---
        int[] arr5 = {};
        int[] arr6 = {0};
        ListNode l5 = createList(arr5);
        ListNode l6 = createList(arr6);

        System.out.println("示例 3 输入:");
        System.out.print("l1 = "); printList(l5);
        System.out.print("l2 = "); printList(l6);

        ListNode res3 = mergeTwoLists(l5, l6);
        System.out.print("示例 3 输出: ");
        printList(res3); // 预期: [0]
    }
}
```
