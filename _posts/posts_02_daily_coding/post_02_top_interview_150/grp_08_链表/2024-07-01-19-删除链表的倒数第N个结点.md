---
title: 19. 删除链表的倒数第N个结点
date: 2024-07-01 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 链表]
tags: [链表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230739103.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


## 题目：19. 删除链表的倒数第 N 个结点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。


**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

- **输入:** `head = [1,2,3,4,5]`, `n = 2`
- **输出:** `[1,2,3,5]`

**示例 2:**

- **输入:** `head = [1]`, `n = 1`
- **输出:** `[]`

**示例 3:**

- **输入:** `head = [1,2]`, `n = 1`
- **输出:** `[1]`


**提示:**

- 链表中结点的数目为 `sz`
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`

**进阶：** 你能尝试使用一趟扫描实现吗？


## Java 代码

**算法思路：(快慢指针 / 一趟扫描)**

为了实现只遍历一次就找到目标节点，我们可以使用经典的 **快慢指针** 技巧。

1.  **虚拟头节点:** 为了方便处理删除头节点这种边界情况（例如，删除一个只有一个节点的链表），我们创建一个虚拟头节点 `dummy`，并让 `dummy.next` 指向原始的 `head`。
2.  **初始化指针:** 创建两个指针，`fast` 和 `slow`，都初始指向 `dummy`。
3.  **拉开差距:** 首先，让 `fast` 指针向前移动 `n` 步。这样，`fast` 和 `slow` 之间就有了 `n` 个节点的差距。
4.  **同步移动:** 接下来，同时向前移动 `fast` 和 `slow` 指针，一步一个节点，直到 `fast` 的 `next` 指针为 `null`（即 `fast` 到达了链表的最后一个节点）。
5.  **定位删除:** 当 `fast` 到达链表末尾时，由于它们之间始终保持着 `n` 个节点的差距，`slow` 指针此时正好位于 **要被删除节点的前一个节点**。
6.  **执行删除:** 我们通过 `slow.next = slow.next.next;` 来跳过（即删除）目标节点。
7.  **返回结果:** 返回 `dummy.next`，它就是新链表的头节点。

```java
/**
 * 链表节点的定义
 */
class ListNode {
    int val;
    ListNode next;
    ListNode(int val) { this.val = val; }
}

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    /**
     * 删除链表的倒数第 n 个结点。
     */
    public static ListNode removeNthFromEnd(ListNode head, int n) {
        // 创建虚拟头节点以简化边界情况处理
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode fast = dummy;
        ListNode slow = dummy;

        // 1. fast 指针先向前移动 n 步
        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }

        // 2. fast 和 slow 指针同步移动，直到 fast 到达链表末尾
        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }

        // 3. 此时 slow 指向的是要删除节点的前一个节点
        // 执行删除操作
        slow.next = slow.next.next;

        return dummy.next;
    }

    // --- 辅助函数，用于测试 ---
    public static ListNode createLinkedList(int[] arr) {
        if (arr == null || arr.length == 0) return null;
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        for (int val : arr) {
            current.next = new ListNode(val);
            current = current.next;
        }
        return dummy.next;
    }

    public static void printLinkedList(ListNode head) {
        if (head == null) {
            System.out.println("[]");
            return;
        }
        StringBuilder sb = new StringBuilder("[");
        ListNode current = head;
        while (current != null) {
            sb.append(current.val);
            if (current.next != null) sb.append(",");
            current = current.next;
        }
        sb.append("]");
        System.out.println(sb.toString());
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        ListNode head1 = createLinkedList(new int[]{1, 2, 3, 4, 5});
        int n1 = 2;
        System.out.print("输入: head = [1,2,3,4,5], n = " + n1 + "\n");
        ListNode result1 = removeNthFromEnd(head1, n1);
        System.out.print("输出: ");
        printLinkedList(result1); // 预期输出: [1,2,3,5]
        System.out.println();

        System.out.println("--- 示例 2 ---");
        ListNode head2 = createLinkedList(new int[]{1});
        int n2 = 1;
        System.out.print("输入: head = [1], n = " + n2 + "\n");
        ListNode result2 = removeNthFromEnd(head2, n2);
        System.out.print("输出: ");
        printLinkedList(result2); // 预期输出: []
        System.out.println();

        System.out.println("--- 示例 3 ---");
        ListNode head3 = createLinkedList(new int[]{1, 2});
        int n3 = 1;
        System.out.print("输入: head = [1,2], n = " + n3 + "\n");
        ListNode result3 = removeNthFromEnd(head3, n3);
        System.out.print("输出: ");
        printLinkedList(result3); // 预期输出: [1]
    }
}
```
