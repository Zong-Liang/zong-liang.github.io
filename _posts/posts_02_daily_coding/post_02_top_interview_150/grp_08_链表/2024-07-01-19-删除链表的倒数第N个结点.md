---
title: 19. 删除链表的倒数第N个结点
date: 2024-07-01 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 链表]
tags: [链表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230739103.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

- **输入:** `head = [1,2,3,4,5]`, `n = 2`
- **输出:** `[1,2,3,5]`

**示例 2:**

- **输入:** `head = [1]`, `n = 1`
- **输出:** `[]`

**示例 3:**

- **输入:** `head = [1,2]`, `n = 1`
- **输出:** `[1]`

**提示:**

- 链表中结点的数目为 `sz`
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`

**进阶：** 你能尝试使用一趟扫描实现吗？

## 题解

### 解法一：计算链表长度（两次扫描）

**思路：**

最简单直接的方法是先遍历一遍链表，计算出链表的总长度 $L$。

要删除倒数第 $n$ 个节点，实际上就是删除正数第 $L - n + 1$ 个节点。

我们需要找到该节点的前一个节点（即第 $L - n$ 个节点），将其指向下下个节点即可。

1.  **添加哨兵节点**：为了能够方便地处理删除头节点的情况（例如链表只有 1 个节点，或者要删除的是头节点），我们在 `head` 前添加一个 `dummy` 节点。
2.  **第一次遍历**：计算链表长度 `length`。
3.  **第二次遍历**：从 `dummy` 开始，移动 `length - n` 步，到达待删除节点的前驱节点。
4.  **执行删除**：修改指针指向。

**复杂度分析：**

- **时间复杂度：** $O(L)$。我们需要遍历链表两次，第一次求长度，第二次定位。
- **空间复杂度：** $O(1)$。只使用了常数个指针。

**代码片段：**

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(0, head);
    int length = 0;
    ListNode cur = head;
    // 1. 计算长度
    while (cur != null) {
        length++;
        cur = cur.next;
    }

    // 2. 找到待删除节点的前一个节点
    ListNode pre = dummy;
    for (int i = 0; i < length - n; i++) {
        pre = pre.next;
    }

    // 3. 删除
    pre.next = pre.next.next;

    return dummy.next;
}
```

### 解法二：双指针法（进阶：一趟扫描）

**思路：**

我们可以利用双指针（快慢指针）保持固定的“距离”，从而只扫描一遍链表就找到倒数第 $n$ 个节点的前驱。

1.  **哨兵节点**：同样使用 `dummy` 节点指向 `head`，`fast` 和 `slow` 初始都指向 `dummy`。
2.  **构建间距**：让 `fast` 指针先向后移动 $n$ 步。此时，`fast` 和 `slow` 之间相隔 $n$ 个节点。
3.  **同步移动**：同时移动 `fast` 和 `slow`，直到 `fast` 指向链表的**最后一个节点**（即 `fast.next == null`）。

    - 为什么是这里停止？因为当 `fast` 到达末尾时，`slow` 正好位于倒数第 $n$ 个节点的**前一个位置**。

4.  **删除节点**：执行 `slow.next = slow.next.next`。

**示意图逻辑：**

假设链表 `1->2->3->4->5`，`n=2`。

- `fast` 先走 2 步到节点 2。
- `fast` 和 `slow` 同时走：

  - `slow` 在 dummy, `fast` 在 2。
  - `slow` 在 1, `fast` 在 3。
  - `slow` 在 2, `fast` 在 4。
  - `slow` 在 3, `fast` 在 5 (尾节点)。停止。

- 此时 `slow` 指向 3，也就是 4（倒数第 2 个）的前驱。删除 4。

**复杂度分析：**

- **时间复杂度：** $O(L)$。只遍历了一次链表。
- **空间复杂度：** $O(1)$。

**代码片段：**

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(0, head);
    ListNode slow = dummy;
    ListNode fast = dummy;

    // 1. 让 fast 先领先 n 步
    for (int i = 0; i < n; i++) {
        fast = fast.next;
    }

    // 2. 同时移动，直到 fast 到达末尾
    while (fast.next != null) {
        fast = fast.next;
        slow = slow.next;
    }

    // 3. 此时 slow 指向待删除节点的前一个节点
    slow.next = slow.next.next;

    return dummy.next;
}
```

### 完整代码

```java
import java.util.*;

// 链表节点定义
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

public class Main {

    // 核心算法实现（双指针法 - 一趟扫描）
    public static ListNode removeNthFromEnd(ListNode head, int n) {
        // 使用 dummy 节点处理删除头结点的边界情况
        ListNode dummy = new ListNode(0, head);
        ListNode slow = dummy;
        ListNode fast = dummy;

        // 1. 让 fast 先走 n 步
        // 题目保证 n 有效，所以 fast 不会 NPE
        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }

        // 2. 两个指针同时向后移动，直到 fast 到达最后一个节点
        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }

        // 此时 slow 正好停在倒数第 n 个节点的前一个位置
        // 3. 执行删除操作
        slow.next = slow.next.next;

        return dummy.next;
    }

    // 辅助方法：打印链表
    public static void printList(ListNode head) {
        System.out.print("[");
        ListNode curr = head;
        while (curr != null) {
            System.out.print(curr.val);
            if (curr.next != null) {
                System.out.print(", ");
            }
            curr = curr.next;
        }
        System.out.println("]");
    }

    // 辅助方法：构建链表
    public static ListNode buildList(int[] vals) {
        if (vals.length == 0) return null;
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        for (int val : vals) {
            curr.next = new ListNode(val);
            curr = curr.next;
        }
        return dummy.next;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int[] vals1 = {1, 2, 3, 4, 5};
        int n1 = 2;
        ListNode head1 = buildList(vals1);

        System.out.println("示例 1 输入: head = " + Arrays.toString(vals1) + ", n = " + n1);
        ListNode res1 = removeNthFromEnd(head1, n1);
        System.out.print("示例 1 输出: ");
        printList(res1);
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        int[] vals2 = {1};
        int n2 = 1;
        ListNode head2 = buildList(vals2);

        System.out.println("示例 2 输入: head = " + Arrays.toString(vals2) + ", n = " + n2);
        ListNode res2 = removeNthFromEnd(head2, n2);
        System.out.print("示例 2 输出: ");
        printList(res2);
        System.out.println("-----------------------------");

        // --- 示例 3 测试 ---
        int[] vals3 = {1, 2};
        int n3 = 1;
        ListNode head3 = buildList(vals3);

        System.out.println("示例 3 输入: head = " + Arrays.toString(vals3) + ", n = " + n3);
        ListNode res3 = removeNthFromEnd(head3, n3);
        System.out.print("示例 3 输出: ");
        printList(res3);
    }
}
```
