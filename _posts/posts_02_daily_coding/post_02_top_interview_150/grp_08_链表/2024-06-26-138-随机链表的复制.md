---
title: 138. 随机链表的复制
date: 2024-06-26 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 链表]
tags: [链表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230555654.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：138. 随机链表的复制

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random`，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **深拷贝**。深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点**。

返回复制链表的头节点。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2019/12/18/e1.png)

- **输入:** `head = [[7,null],[13,0],[11,4],[10,2],[1,0]]`
- **输出:** `[[7,null],[13,0],[11,4],[10,2],[1,0]]`

**示例 2:**

- **输入:** `head = [[1,1],[2,1]]`
- **输出:** `[[1,1],[2,1]]`

**提示:**

- `0 <= n <= 1000`
- `-10^4 <= Node.val <= 10^4`
- `Node.random` 为 `null` 或指向链表中的节点。

## Java 代码

**算法思路：(哈希表映射)**

复制带有 `random` 指针的链表，主要挑战在于如何处理 `random` 指针的指向。一个清晰的解法是使用 **哈希表** 来存储原始节点到新创建节点的映射关系。

1.  **第一次遍历 (复制节点):**
    - 创建一个哈希表 `map`，用于存储 `<原始节点, 复制节点>` 的映射。
    - 遍历原始链表，对于每个节点 `current`，创建一个新的节点 `newNode`，其 `val` 与 `current.val` 相同。
    - 将 `(current, newNode)` 存入 `map`。
2.  **第二次遍历 (连接指针):**
    - 再次遍历原始链表。
    - 对于每个原始节点 `current`：
      a. 从 `map` 中获取其对应的复制节点 `copiedNode`。
      b. 设置 `copiedNode` 的 `next` 指针：`copiedNode.next = map.get(current.next)`。
      c. 设置 `copiedNode` 的 `random` 指针：`copiedNode.random = map.get(current.random)`。
3.  **返回结果:**
    - `map.get(head)` 就是复制后链表的头节点。

这个方法需要两次遍历和 `O(n)` 的额外空间（用于哈希表）。

```java
import java.util.HashMap;
import java.util.Map;

/**
 * 随机链表节点的定义
 */
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}


public class Main {

    /**
     * 复制一个带有随机指针的链表。
     */
    public Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }

        // Map<原始节点, 复制节点>
        Map<Node, Node> map = new HashMap<>();

        // 1. 第一次遍历：复制所有节点
        Node current = head;
        while (current != null) {
            map.put(current, new Node(current.val));
            current = current.next;
        }

        // 2. 第二次遍历：连接 next 和 random 指针
        current = head;
        while (current != null) {
            Node copiedNode = map.get(current);
            copiedNode.next = map.get(current.next);
            copiedNode.random = map.get(current.random);
            current = current.next;
        }

        // 3. 返回复制链表的头节点
        return map.get(head);
    }

    /**
     * 主函数，包含测试用例。
     * 由于链表结构复杂，这里仅演示调用，不进行复杂的打印验证。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        Main solution = new Main();

        // --- 构建示例 1 的图 ---
        Node n7 = new Node(7);
        Node n13 = new Node(13);
        Node n11 = new Node(11);
        Node n10 = new Node(10);
        Node n1 = new Node(1);
        n7.next = n13;
        n13.next = n11;
        n11.next = n10;
        n10.next = n1;
        n13.random = n7;
        n11.random = n1;
        n10.random = n11;
        n1.random = n7;

        System.out.println("--- 示例 1 ---");
        System.out.println("输入: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]");
        Node clonedHead = solution.copyRandomList(n7);
        System.out.println("输出: (复制链表已生成，结构与输入相同)");
    }
}
```
