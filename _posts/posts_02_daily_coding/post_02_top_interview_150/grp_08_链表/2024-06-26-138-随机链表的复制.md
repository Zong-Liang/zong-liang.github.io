---
title: 138. 随机链表的复制
date: 2024-06-26 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 链表]
tags: [链表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230555654.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random`，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **深拷贝**。深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点**。

返回复制链表的头节点。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2019/12/18/e1.png)

- **输入:** `head = [[7,null],[13,0],[11,4],[10,2],[1,0]]`
- **输出:** `[[7,null],[13,0],[11,4],[10,2],[1,0]]`

**示例 2:**

- **输入:** `head = [[1,1],[2,1]]`
- **输出:** `[[1,1],[2,1]]`

**提示:**

- `0 <= n <= 1000`
- `-10^4 <= Node.val <= 10^4`
- `Node.random` 为 `null` 或指向链表中的节点。

## 题解

### 解法一：哈希表（Iterative with HashMap）

**思路：**

我们要对链表进行深拷贝，难点在于 `random` 指针可能指向链表中任意位置的节点（包括尚未创建的节点）。我们可以利用 **哈希表** 来建立“原节点”与“新节点”的一一映射关系。

算法分为两步：

1.  **第一轮遍历**：遍历原链表，为每个节点创建一个对应的新节点（只复制 `val`），并将 `<原节点, 新节点>` 的映射关系存入哈希表 `Map<Node, Node>` 中。
2.  **第二轮遍历**：再次遍历原链表，通过哈希表找到对应的“新节点”，并根据原节点的 `next` 和 `random` 指针，在哈希表中查找对应的目标新节点，从而设置新节点的 `next` 和 `random`。

**复杂度分析：**

- **时间复杂度：** $O(n)$。我们需要遍历链表两次。
- **空间复杂度：** $O(n)$。我们需要一个哈希表来存储 $n$ 个节点的映射关系。

**代码片段：**

```java
public Node copyRandomList(Node head) {
    if (head == null) return null;

    // Map: 原节点 -> 新节点
    Map<Node, Node> map = new HashMap<>();

    Node curr = head;
    // 1. 遍历原链表，创建新节点并建立映射
    while (curr != null) {
        map.put(curr, new Node(curr.val));
        curr = curr.next;
    }

    curr = head;
    // 2. 再次遍历，构建新节点的指针关系
    while (curr != null) {
        // map.get(curr) 是新节点
        // map.get(curr.next) 是新节点的 next 指向的对象
        map.get(curr).next = map.get(curr.next);
        map.get(curr).random = map.get(curr.random);
        curr = curr.next;
    }

    return map.get(head);
}
```

### 解法二：拼接 + 拆分（空间优化 O(1)）

**思路：**

如果我们不能使用额外的 $O(n)$ 空间（即不使用哈希表），可以通过修改原链表的结构来建立映射关系。

1.  **复制节点并拼接**：遍历链表，对于每个节点 `A`，创建一个新节点 `A'`，并将其插入到 `A` 和 `A.next` 之间。

    - 原链表：`A -> B -> C`
    - 拼接后：`A -> A' -> B -> B' -> C -> C'`

2.  **设置 random 指针**：遍历拼接后的链表。因为 `A'` 在 `A` 的后面，所以 `A'` 的 `random` 应该指向 `A.random` 的下一个节点（即 `A.random` 的复本）。

    - 逻辑：`node.next.random = node.random.next` (若 `node.random` 不为空)。

3.  **拆分链表**：将混合链表拆分成两个独立的链表：原链表和新链表。

    - 恢复原链表：`A.next = A.next.next`
    - 提取新链表：`A'.next = A'.next.next`

**复杂度分析：**

- **时间复杂度：** $O(n)$。
- **空间复杂度：** $O(1)$。除了返回结果所需的空间外，不需要额外的哈希表空间。

**代码片段：**

```java
public Node copyRandomList(Node head) {
    if (head == null) return null;

    // 1. 复制节点，交织在一起：A -> A' -> B -> B'
    Node curr = head;
    while (curr != null) {
        Node newNode = new Node(curr.val);
        newNode.next = curr.next;
        curr.next = newNode;
        curr = newNode.next;
    }

    // 2. 设置 random 指针
    curr = head;
    while (curr != null) {
        if (curr.random != null) {
            // curr.next 是新节点，curr.random.next 是 random 指向的新节点
            curr.next.random = curr.random.next;
        }
        curr = curr.next.next;
    }

    // 3. 拆分链表
    Node newHead = head.next;
    curr = head;
    Node temp = null;
    while (curr != null) {
        temp = curr.next; // temp 是新节点
        curr.next = temp.next; // 恢复原链表连接
        if (temp.next != null) {
            temp.next = temp.next.next; // 连接新链表
        }
        curr = curr.next;
    }

    return newHead;
}
```

### 完整代码

这里展示最通用且易于理解的 **哈希表解法** 的完整实现及测试代码。

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Main {

    // 定义节点结构（根据题目要求）
    static class Node {
        int val;
        Node next;
        Node random;

        public Node(int val) {
            this.val = val;
            this.next = null;
            this.random = null;
        }
    }

    // 核心算法实现：使用哈希表进行深拷贝
    public static Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }

        // Map: Key=原节点, Value=新节点
        Map<Node, Node> map = new HashMap<>();

        Node curr = head;
        // 第一遍遍历：创建新节点，存入 Map
        while (curr != null) {
            map.put(curr, new Node(curr.val));
            curr = curr.next;
        }

        curr = head;
        // 第二遍遍历：构建指针关系
        while (curr != null) {
            Node newNode = map.get(curr);
            // 设置 next
            newNode.next = map.get(curr.next);
            // 设置 random (如果 curr.random 是 null，map.get 也会返回 null，符合预期)
            newNode.random = map.get(curr.random);

            curr = curr.next;
        }

        return map.get(head);
    }

    // --- 辅助测试代码 ---

    // 辅助方法：打印链表结构用于验证 (格式: [val, randomVal])
    public static void printList(Node head) {
        Node curr = head;
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        while (curr != null) {
            String randomVal = (curr.random != null) ? String.valueOf(curr.random.val) : "null";
            sb.append("[").append(curr.val).append(", ").append(randomVal).append("]");
            if (curr.next != null) {
                sb.append(", ");
            }
            curr = curr.next;
        }
        sb.append("]");
        System.out.println(sb.toString());
    }

    public static void main(String[] args) {
        // --- 示例 1 构造 ---
        // 输入: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
        // 注意：输入里的第二个数字是 random 指向的索引，不是值
        Node n0 = new Node(7);
        Node n1 = new Node(13);
        Node n2 = new Node(11);
        Node n3 = new Node(10);
        Node n4 = new Node(1);

        // 连接 next
        n0.next = n1; n1.next = n2; n2.next = n3; n3.next = n4;
        // 连接 random
        n0.random = null;
        n1.random = n0; // index 0
        n2.random = n4; // index 4
        n3.random = n2; // index 2
        n4.random = n0; // index 0

        System.out.println("示例 1 原链表:");
        printList(n0);

        Node copiedList1 = copyRandomList(n0);

        System.out.println("示例 1 新链表:");
        printList(copiedList1);

        // 验证是否是深拷贝（修改原链表，新链表不应受影响）
        System.out.println("验证深拷贝: 修改原链表头节点值为 99");
        n0.val = 99;
        System.out.print("原链表: "); printList(n0);
        System.out.print("新链表: "); printList(copiedList1);
        System.out.println("-----------------------------");

        // --- 示例 2 构造 ---
        // 输入: head = [[1,1],[2,1]]
        Node a0 = new Node(1);
        Node a1 = new Node(2);
        a0.next = a1;
        a0.random = a1; // index 1
        a1.random = a1; // index 1

        System.out.println("示例 2 原链表:");
        printList(a0);
        Node copiedList2 = copyRandomList(a0);
        System.out.println("示例 2 新链表:");
        printList(copiedList2);
    }
}
```
