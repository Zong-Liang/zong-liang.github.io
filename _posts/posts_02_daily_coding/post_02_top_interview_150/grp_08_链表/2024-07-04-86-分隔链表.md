---
title: 86. 分隔链表
date: 2024-07-04 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 链表]
tags: [链表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231017221.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个链表的头节点 `head` 和一个特定值 `x`，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/01/04/partition.jpg)

- **输入:** `head = [1,4,3,2,5,2]`, `x = 3`
- **输出:** `[1,2,2,4,3,5]`

**示例 2:**

- **输入:** `head = [2,1]`, `x = 2`
- **输出:** `[1,2]`

**提示:**

- 链表中节点的数目在范围 `[0, 200]` 内
- `-100 <= Node.val <= 100`
- `-200 <= x <= 200`

## 题解

### 解法：双指针 + 哑节点（模拟法）

**思路：**

这个问题的核心是将链表分成两个独立的链表：一个存储所有小于 `x` 的节点（`small` 链表），另一个存储所有大于等于 `x` 的节点（`large` 链表）。由于题目要求**保留初始相对位置**，我们只需要遍历原链表，依次将节点尾插到对应的链表中即可。

为了方便处理头节点（比如不需要特判第一个节点是放入 `small` 还是 `large`），我们可以使用两个 **哑节点（Dummy Node）**：

1.  `smallHead`：作为存放小于 `x` 的节点的链表头。
2.  `largeHead`：作为存放大于等于 `x` 的节点的链表头。

**具体步骤：**

1.  初始化两个哑节点 `smallHead` 和 `largeHead`，并分别定义两个指针 `small` 和 `large` 指向它们。
2.  遍历原链表 `head`：

    - 如果当前节点值 `< x`，将其挂在 `small` 指针后面，并更新 `small` 指针。
    - 如果当前节点值 `>= x`，将其挂在 `large` 指针后面，并更新 `large` 指针。

3.  **连接两个链表**：将 `small` 链表的尾部（`small.next`）指向 `large` 链表的头部（`largeHead.next`）。
4.  **断开环**：非常重要的一步，遍历结束后，`large` 指针指向的节点可能原本后面还有节点（且是小于 `x` 的节点，已经被移走了）。如果不将 `large.next` 置为 `null`，链表可能会形成环。
5.  返回 `smallHead.next`。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是链表的长度。我们需要遍历整个链表一次。
- **空间复杂度：** $O(1)$。我们只使用了常数个额外的指针变量，直接复用了原链表的节点，没有申请新的节点空间。

**代码片段：**

```java
public ListNode partition(ListNode head, int x) {
    ListNode smallHead = new ListNode(0);
    ListNode small = smallHead;
    ListNode largeHead = new ListNode(0);
    ListNode large = largeHead;

    while (head != null) {
        if (head.val < x) {
            small.next = head;
            small = small.next;
        } else {
            large.next = head;
            large = large.next;
        }
        head = head.next;
    }

    // 连接两个部分
    large.next = null; // 关键：切断 large 链表末尾可能的后续连接，防止成环
    small.next = largeHead.next;

    return smallHead.next;
}
```

### 完整代码

```java
public class Main {

    // 定义链表节点
    public static class ListNode {
        int val;
        ListNode next;
        ListNode() {}
        ListNode(int val) { this.val = val; }
        ListNode(int val, ListNode next) { this.val = val; this.next = next; }
    }

    // 核心算法实现
    public static ListNode partition(ListNode head, int x) {
        // smallHead 用于存放小于 x 的节点
        ListNode smallHead = new ListNode(0);
        ListNode small = smallHead;

        // largeHead 用于存放大于等于 x 的节点
        ListNode largeHead = new ListNode(0);
        ListNode large = largeHead;

        // 遍历原链表
        while (head != null) {
            if (head.val < x) {
                small.next = head;
                small = small.next;
            } else {
                large.next = head;
                large = large.next;
            }
            head = head.next;
        }

        // 关键步骤：处理尾部
        // large 链表的最后一个节点可能还指向原链表中的某个节点，必须切断，否则会形成环
        large.next = null;

        // 将 small 链表的尾巴接到 large 链表的真实头部
        small.next = largeHead.next;

        return smallHead.next;
    }

    // --- 辅助方法：数组转链表 ---
    public static ListNode createList(int[] arr) {
        if (arr.length == 0) return null;
        ListNode head = new ListNode(arr[0]);
        ListNode curr = head;
        for (int i = 1; i < arr.length; i++) {
            curr.next = new ListNode(arr[i]);
            curr = curr.next;
        }
        return head;
    }

    // --- 辅助方法：打印链表 ---
    public static void printList(ListNode head) {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        ListNode curr = head;
        while (curr != null) {
            sb.append(curr.val);
            if (curr.next != null) {
                sb.append(", ");
            }
            curr = curr.next;
        }
        sb.append("]");
        System.out.println(sb.toString());
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int[] arr1 = {1, 4, 3, 2, 5, 2};
        int x1 = 3;
        ListNode head1 = createList(arr1);

        System.out.println("示例 1 输入:");
        System.out.print("head = "); printList(head1);
        System.out.println("x = " + x1);

        ListNode res1 = partition(head1, x1);

        System.out.print("示例 1 输出: ");
        printList(res1);
        // 预期: [1, 2, 2, 4, 3, 5] (小于3的 1,2,2 在前，保持相对顺序；4,3,5 在后)
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        int[] arr2 = {2, 1};
        int x2 = 2;
        ListNode head2 = createList(arr2);

        System.out.println("示例 2 输入:");
        System.out.print("head = "); printList(head2);
        System.out.println("x = " + x2);

        ListNode res2 = partition(head2, x2);

        System.out.print("示例 2 输出: ");
        printList(res2);
        // 预期: [1, 2]
    }
}
```
