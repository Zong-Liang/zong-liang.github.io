---
title: 86. 分隔链表
date: 2024-07-04 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 链表]
tags: [链表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231017221.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：86. 分隔链表

给你一个链表的头节点 `head` 和一个特定值 `x`，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/01/04/partition.jpg)

- **输入:** `head = [1,4,3,2,5,2]`, `x = 3`
- **输出:** `[1,2,2,4,3,5]`

**示例 2:**

- **输入:** `head = [2,1]`, `x = 2`
- **输出:** `[1,2]`

**提示:**

- 链表中节点的数目在范围 `[0, 200]` 内
- `-100 <= Node.val <= 100`
- `-200 <= x <= 200`

## Java 代码

**算法思路：(双指针 / 链表拼接)**

这个问题的关键在于要 **保持** 每个分区内部节点的原始相对顺序。一个清晰且高效的方法是创建两个新的虚拟链表：一个用于存放小于 `x` 的节点（`smaller` 链表），另一个用于存放大于或等于 `x` 的节点（`larger` 链表）。

1.  **初始化:**
    - 创建两个虚拟头节点 `smallerHead` 和 `largerHead`。
    - 创建两个指针 `smallerTail` 和 `largerTail`，分别指向这两个新链表的尾部。
2.  **遍历原链表:**
    - 遍历原始链表中的每一个节点 `current`。
    - 如果 `current.val < x`，则将 `current` 节点连接到 `smaller` 链表的尾部，并移动 `smallerTail` 指针。
    - 否则（`current.val >= x`），将 `current` 节点连接到 `larger` 链表的尾部，并移动 `largerTail` 指针。
3.  **拼接链表:**
    - 遍历结束后，我们得到了两个独立的、内部有序的链表。
    - 首先，将 `larger` 链表的末尾设置为 `null`，以防止形成环。
    - 然后，将 `smaller` 链表的尾部连接到 `larger` 链表的头部（`smallerTail.next = largerHead.next`）。
4.  **返回结果:**
    - 返回 `smallerHead.next`，这就是新形成的、已分隔链表的头节点。

````java
/**
 * 链表节点的定义
 */
class ListNode {
    int val;
    ListNode next;
    ListNode(int val) { this.val = val; }
}


public class Main {

    /**
     * 对链表进行分隔。
     */
    public static ListNode partition(ListNode head, int x) {
        // 创建两个虚拟头节点，用于构建两个新链表
        ListNode smallerHead = new ListNode(0);
        ListNode largerHead = new ListNode(0);

        // 创建两个尾指针
        ListNode smallerTail = smallerHead;
        ListNode largerTail = largerHead;

        ListNode current = head;

        // 遍历原始链表
        while (current != null) {
            if (current.val < x) {
                // 将节点添加到 "smaller" 链表
                smallerTail.next = current;
                smallerTail = smallerTail.next;
            } else {
                // 将节点添加到 "larger" 链表
                largerTail.next = current;
                largerTail = largerTail.next;
            }
            current = current.next;
        }

        // 重要：将 larger 链表的末尾设为 null
        largerTail.next = null;

        // 将 smaller 链表的尾部连接到 larger 链表的头部
        smallerTail.next = largerHead.next;

        // 返回新链表的头节点
        return smallerHead.next;
    }

    // --- 辅助函数，用于测试 ---
    public static ListNode createLinkedList(int[] arr) {
        if (arr == null || arr.length == 0) return null;
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        for (int val : arr) {
            current.next = new ListNode(val);
            current = current.next;
        }
        return dummy.next;
    }

    public static void printLinkedList(ListNode head) {
        if (head == null) {
            System.out.println("[]");
            return;
        }
        StringBuilder sb = new StringBuilder("[");
        ListNode current = head;
        while (current != null) {
            sb.append(current.val);
            if (current.next != null) sb.append(",");
            current = current.next;
        }
        sb.append("]");
        System.out.println(sb.toString());
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        ListNode head1 = createLinkedList(new int[]{1, 4, 3, 2, 5, 2});
        int x1 = 3;
        System.out.print("输入: head = [1,4,3,2,5,2], x = " + x1 + "\n");
        ListNode result1 = partition(head1, x1);
        System.out.print("输出: ");
        printLinkedList(result1); // 预期输出: [1,2,2,4,3,5]
        System.out.println();

        System.out.println("--- 示例 2 ---");
        ListNode head2 = createLinkedList(new int[]{2, 1});
        int x2 = 2;
        System.out.print("输入: head = [2,1], x = " + x2 + "\n");
        ListNode result2 = partition(head2, x2);
        System.out.print("输出: ");
        printLinkedList(result2); // 预期输出: [1,2]
    }
}```
````
