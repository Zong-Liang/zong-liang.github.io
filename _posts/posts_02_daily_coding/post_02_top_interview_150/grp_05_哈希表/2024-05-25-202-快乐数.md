---
title: 202. 快乐数
date: 2024-05-25 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 哈希表]
tags: [哈希表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121225442998.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：202. 快乐数

**描述：**

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为 1**，那么这个数就是快乐数。

如果 `n` 是快乐数就返回 `true` ；不是，则返回 `false` 。

**示例 1:**

- **输入:** `n = 19`
- **输出:** `true`
- **解释:**

  - 1² + 9² = 82
  - 8² + 2² = 68
  - 6² + 8² = 100
  - 1² + 0² + 0² = 1

**示例 2:**

- **输入:** `n = 2`
- **输出:** `false`

**提示:**

- `1 <= n <= 2^31 - 1`

## 题解

### 解法一：哈希集合检测循环

**思路：**

根据题目描述，一个数要么最终变为 1（快乐数），要么进入一个 **无限循环**。

核心在于检测这个“循环”。

我们可以使用一个哈希集合（`HashSet`）来存储每一次计算出来的结果：

1.  计算当前数字 `n` 的下一个数（各位平方和）。
2.  检查这个新数是否在集合中出现过：

    - 如果出现过，说明我们进入了循环，且永远不会到达 1，返回 `false`。
    - 如果没有出现过，将其加入集合，继续计算。

3.  如果计算结果变为 1，返回 `true`。

**为什么不会无限增大？**

对于 `int` 范围内的最大数（约 21 亿），其下一位数的最大可能值是非常小的（例如 $1,999,999,999$ 的下一位是 $1^2 + 9 \times 9^2 = 730$）。这意味着数字序列最终会落入一个很小的范围内（小于 1000）。在这个有限范围内，要么到达 1，要么重复之前的数字形成环。

**复杂度分析：**

- **时间复杂度：** $O(\log n)$。计算每一位的平方和需要对 $n$ 的位数进行遍历，即 $\log n$。由于链条长度有限（对于 int 范围的数，链条不会很长），总耗时可视为 $O(\log n)$。
- **空间复杂度：** $O(\log n)$。我们需要集合来存储链条中的数字。

**代码片段：**

```java
public boolean isHappy(int n) {
    Set<Integer> seen = new HashSet<>();
    while (n != 1 && !seen.contains(n)) {
        seen.add(n);
        n = getNext(n);
    }
    return n == 1;
}

// 辅助函数：计算各位平方和
private int getNext(int n) {
    int totalSum = 0;
    while (n > 0) {
        int d = n % 10;
        n = n / 10;
        totalSum += d * d;
    }
    return totalSum;
}
```

### 解法二：快慢指针法（Floyd 判圈算法）

**思路：**

我们可以将这个数字的变化过程看作是一个 **链表**。

- 如果是一个快乐数，链表最终会指向节点 `1`，且 `1` 的下一个节点还是 `1`（死循环于 1）。
- 如果不是快乐数，链表中会存在一个不包含 `1` 的环。

基于此，我们可以使用 **快慢指针** 来检测循环，这与“判断链表是否有环”的题目逻辑完全一致：

1.  定义 `slow` 指针每次走一步（计算一次平方和）。
2.  定义 `fast` 指针每次走两步（计算两次平方和）。
3.  如果 `fast` 最终变成了 1，说明是快乐数。
4.  如果 `fast` 追上了 `slow`（`fast == slow`）且不等于 1，说明进入了死循环，不是快乐数。

**复杂度分析：**

- **时间复杂度：** $O(\log n)$。
- **空间复杂度：** $O(1)$。不需要使用哈希集合存储历史数据，只需要两个指针变量。

**代码片段：**

```java
public boolean isHappy(int n) {
    int slow = n;
    int fast = getNext(n);

    // 当 fast 不等于 1 且 快慢指针没相遇时，继续跑
    while (fast != 1 && slow != fast) {
        slow = getNext(slow);
        fast = getNext(getNext(fast));
    }
    return fast == 1;
}

private int getNext(int n) {
    int totalSum = 0;
    while (n > 0) {
        int d = n % 10;
        n = n / 10;
        totalSum += d * d;
    }
    return totalSum;
}
```

### 完整代码

这里展示空间复杂度最优的 **快慢指针法**。

```java
import java.util.HashSet;
import java.util.Set;

public class Main {

    // 辅助函数：计算一个数各位数字的平方和
    private static int getNext(int n) {
        int totalSum = 0;
        while (n > 0) {
            int d = n % 10;
            n = n / 10;
            totalSum += d * d;
        }
        return totalSum;
    }

    // 核心算法实现：快慢指针法
    public static boolean isHappy(int n) {
        int slow = n;
        int fast = getNext(n); // fast 先走一步，或者初始时 slow=n, fast=n 然后用 do-while

        while (fast != 1 && slow != fast) {
            slow = getNext(slow);           // 慢指针走一步
            fast = getNext(getNext(fast));  // 快指针走两步
        }
        // 如果是因为 fast == 1 退出的循环，则是快乐数
        return fast == 1;
    }

    // 备选算法：哈希集合法 (方便理解)
    public static boolean isHappySet(int n) {
        Set<Integer> seen = new HashSet<>();
        while (n != 1 && !seen.contains(n)) {
            seen.add(n);
            n = getNext(n);
        }
        return n == 1;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int n1 = 19;
        System.out.println("示例 1 输入: n = " + n1);
        System.out.println("示例 1 输出: " + isHappy(n1));
        // 解释: 19 -> 82 -> 68 -> 100 -> 1
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int n2 = 2;
        System.out.println("示例 2 输入: n = " + n2);
        System.out.println("示例 2 输出: " + isHappy(n2));
        // 解释: 2 -> 4 -> 16 -> 37 -> 58 -> 89 -> 145 -> 42 -> 20 -> 4 ... (进入循环)
    }
}
```
