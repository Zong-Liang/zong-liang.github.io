---
title: 242. 有效的字母异位词
date: 2024-05-18 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 哈希表]
tags: [哈希表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121225314001.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。

**字母异位词** 是由相同字母按不同顺序排列形成的字符串。

**示例 1:**

- **输入:** `s = "anagram"`, `t = "nagaram"`
- **输出:** `true`

**示例 2:**

- **输入:** `s = "rat"`, `t = "car"`
- **输出:** `false`

**提示:**

- `1 <= s.length, t.length <= 5 * 10^4`
- `s` 和 `t` 仅包含小写字母

**进阶:** 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

## 题解

### 标准解法：哈希表（数组优化）

**思路：**

题目限定了字符串只包含**小写字母**。对于这种情况，我们可以使用一个长度为 26 的整数数组来代替哈希表，这样可以避免哈希计算的开销，提高效率。

1.  **长度检查**：首先判断 `s` 和 `t` 的长度是否相等，如果不等，直接返回 `false`。
2.  **计数**：

    - 创建一个长度为 26 的数组 `table`。
    - 遍历字符串 `s`，在对应位置增加计数。
    - 遍历字符串 `t`，在对应位置减少计数。
    - （优化：可以由一个循环同时处理 `s` 和 `t` 的加减，也可以分开处理）。

3.  **验证**：最后检查数组中的每个元素。如果有任何一个元素不为 0，说明 `s` 和 `t` 中该字符的数量不一致，返回 `false`。否则返回 `true`。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是字符串的长度。我们需要遍历字符串一次，以及遍历常数大小的数组（26）。
- **空间复杂度：** $O(1)$，无论字符串多长，我们需要辅助数组的大小固定为 26。

**代码片段：**

```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }
    int[] table = new int[26];
    // 统计字符频次
    for (int i = 0; i < s.length(); i++) {
        table[s.charAt(i) - 'a']++;
        table[t.charAt(i) - 'a']--;
    }
    // 检查是否有非零项
    for (int count : table) {
        if (count != 0) {
            return false;
        }
    }
    return true;
}
```

### 进阶解法：通用哈希表（Unicode 支持）

**思路：**

如果输入字符串包含 **Unicode** 字符（如中文、Emoji 等），字符集的范围会非常大（超过 10 万个字符），直接使用数组会造成巨大的空间浪费，且下标映射也变得复杂。此时应使用通用的 `HashMap`。

1.  **长度检查**：同上，长度不等直接返回 `false`。
2.  **构建哈希表**：

    - 遍历 `s`，将字符作为 `key`，出现次数作为 `value` 存入 `HashMap`。

3.  **抵消检查**：

    - 遍历 `t`，对于每个字符，将 Map 中对应的计数减 1。
    - 如果在 Map 中找不到该字符，或者计数减为负数，说明 `t` 中该字符比 `s` 多（或 `s` 没有），直接返回 `false`。

4.  **最终验证**：由于长度相等且中途没有返回 false，说明所有字符完美抵消，返回 `true`。

**复杂度分析：**

- **时间复杂度：** $O(n)$，哈希表的插入和查询平均时间复杂度为 $O(1)$。
- **空间复杂度：** $O(K)$，其中 $K$ 是字符集的大小（不同字符的个数）。最坏情况下 $K=n$。

**代码片段：**

```java
public boolean isAnagramUnicode(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }
    Map<Character, Integer> map = new HashMap<>();

    // 统计 s 的字符
    for (char c : s.toCharArray()) {
        map.put(c, map.getOrDefault(c, 0) + 1);
    }

    // 遍历 t 进行抵消
    for (char c : t.toCharArray()) {
        // 如果 s 中没有这个字符，或者计数已经归零，说明不匹配
        if (!map.containsKey(c) || map.get(c) == 0) {
            return false;
        }
        map.put(c, map.get(c) - 1);
    }

    return true;
}
```

### 完整代码

```java
import java.util.HashMap;
import java.util.Map;

public class Main {

    // 核心算法实现：数组优化版 (适用于仅小写字母)
    public static boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }
        int[] table = new int[26];
        for (int i = 0; i < s.length(); i++) {
            table[s.charAt(i) - 'a']++;
            table[t.charAt(i) - 'a']--;
        }
        for (int count : table) {
            if (count != 0) {
                return false;
            }
        }
        return true;
    }

    // 进阶算法实现：HashMap 版 (适用于 Unicode)
    public static boolean isAnagramUnicode(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }
        Map<Character, Integer> map = new HashMap<>();

        for (char c : s.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }

        for (char c : t.toCharArray()) {
            int count = map.getOrDefault(c, 0);
            if (count == 0) {
                return false;
            }
            map.put(c, count - 1);
        }

        return true;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        String s1 = "anagram";
        String t1 = "nagaram";
        System.out.println("示例 1 输入: s = \"" + s1 + "\", t = \"" + t1 + "\"");

        boolean result1 = isAnagram(s1, t1);
        System.out.println("示例 1 输出: " + result1);
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        String s2 = "rat";
        String t2 = "car";
        System.out.println("示例 2 输入: s = \"" + s2 + "\", t = \"" + t2 + "\"");

        boolean result2 = isAnagram(s2, t2);
        System.out.println("示例 2 输出: " + result2);
        System.out.println("-----------------------------");

        // --- 进阶示例 (Unicode) ---
        String s3 = "你好世界";
        String t3 = "世界你好";
        System.out.println("进阶示例 输入: s = \"" + s3 + "\", t = \"" + t3 + "\"");

        boolean result3 = isAnagramUnicode(s3, t3);
        System.out.println("进阶示例 输出: " + result3);
    }
}
```
