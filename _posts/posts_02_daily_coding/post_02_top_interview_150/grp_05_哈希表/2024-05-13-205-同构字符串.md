---
title: 205. 同构字符串
date: 2024-05-13 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 哈希表]
tags: [哈希表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121225107461.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定两个字符串 `s` 和 `t` ，判断它们是否是同构的。

如果 `s` 中的字符可以按某种映射关系替换得到 `t` ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

**示例 1:**

- **输入:** `s = "egg"`, `t = "add"`
- **输出:** `true`

**示例 2:**

- **输入:** `s = "foo"`, `t = "bar"`
- **输出:** `false`

**示例 3:**

- **输入:** `s = "paper"`, `t = "title"`
- **输出:** `true`

**提示:**

- `1 <= s.length <= 5 * 10^4`
- `t.length == s.length`
- `s` 和 `t` 由任意有效的 ASCII 字符组成

## 题解

### 解法：双向映射（字符索引法）

**思路：**

判断两个字符串是否同构，本质上是判断两个字符串中的字符是否满足 **一一对应（双射）** 的关系。

即：`s` 中的字符 `a` 映射到 `t` 中的 `x`，那么 `t` 中的 `x` 也必须唯一映射回 `s` 中的 `a`。

我们可以利用 **“上次出现的索引”** 来解决这个问题：

1.  如果 `s` 和 `t` 是同构的，那么对于当前遍历到的索引 `i`，`s.charAt(i)` 和 `t.charAt(i)` 在之前出现的位置必须相同。
2.  例如 `s = "egg", t = "add"`：

    - `i=0`: `e` 第一次出现，`a` 第一次出现。匹配。
    - `i=1`: `g` 第一次出现，`d` 第一次出现。匹配。
    - `i=2`: `g` 上次出现在下标 1，`d` 上次也出现在下标 1。匹配。

3.  如果 `s.charAt(i)` 上次出现的下标与 `t.charAt(i)` 上次出现的下标**不一致**，说明破坏了映射规则，返回 `false`。

为了实现这一点，我们可以使用两个整型数组（长度为 256，覆盖 ASCII 码）来记录每个字符**上一次出现的下标 + 1**（加 1 是为了区分数组默认值 0 和索引 0）。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是字符串的长度。只需要遍历一次字符串。
- **空间复杂度：** $O(\Sigma)$，其中 $\Sigma$ 是字符集的大小。题目提示由 ASCII 字符组成，因此需要常数级的空间（如 256）。

**代码片段：**

```java
public boolean isIsomorphic(String s, String t) {
    // 两个数组分别记录 s 和 t 中字符上一次出现的位置
    int[] mapS = new int[256];
    int[] mapT = new int[256];

    for (int i = 0; i < s.length(); i++) {
        char c1 = s.charAt(i);
        char c2 = t.charAt(i);

        // 如果两个字符上次出现的位置不一样，说明不是同构
        if (mapS[c1] != mapT[c2]) {
            return false;
        }

        // 更新当前字符最后出现的位置（存 i + 1 是为了避免默认值 0 的混淆）
        mapS[c1] = i + 1;
        mapT[c2] = i + 1;
    }
    return true;
}
```

### 完整代码

```java
public class Main {

    // 核心算法实现
    public static boolean isIsomorphic(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }

        // 使用数组模拟哈希表，ASCII 字符范围通常在 0-127 或 0-255
        int[] mapS = new int[256];
        int[] mapT = new int[256];

        for (int i = 0; i < s.length(); i++) {
            char c1 = s.charAt(i);
            char c2 = t.charAt(i);

            // 核心逻辑：比较当前两个字符上次出现的索引
            // 如果不相等，说明映射关系混乱（例如 s 中是新字符，t 中却是旧字符，或者反之）
            if (mapS[c1] != mapT[c2]) {
                return false;
            }

            // 记录当前索引 + 1
            // 为什么 +1？因为数组初始化默认是 0，如果直接存索引 0，
            // 无法区分"该字符从未出现过"和"该字符出现在索引0"这两种情况。
            mapS[c1] = i + 1;
            mapT[c2] = i + 1;
        }

        return true;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        String s1 = "egg";
        String t1 = "add";
        System.out.println("示例 1 输入: s = \"" + s1 + "\", t = \"" + t1 + "\"");
        System.out.println("示例 1 输出: " + isIsomorphic(s1, t1));
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        String s2 = "foo";
        String t2 = "bar";
        System.out.println("示例 2 输入: s = \"" + s2 + "\", t = \"" + t2 + "\"");
        System.out.println("示例 2 输出: " + isIsomorphic(s2, t2));
        // 解释: o -> a, o -> r，同一个字符映射到了不同的字符，False
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        String s3 = "paper";
        String t3 = "title";
        System.out.println("示例 3 输入: s = \"" + s3 + "\", t = \"" + t3 + "\"");
        System.out.println("示例 3 输出: " + isIsomorphic(s3, t3));
    }
}
```
