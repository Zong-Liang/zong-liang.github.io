---
title: 128. 最长连续序列
date: 2024-05-29 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 哈希表]
tags: [哈希表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121225545067.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

- **输入:** `nums = [100,4,200,1,3,2]`
- **输出:** 4
- **解释:** 最长数字连续序列是 `[1, 2, 3, 4]`。它的长度为 4。

**示例 2:**

- **输入:** `nums = [0,3,7,2,5,8,4,6,0,1]`
- **输出:** 9

**示例 3:**

- **输入:** `nums = [1,0,1,2]`
- **输出:** 3

**提示:**

- `0 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`

## 题解

### 解法一：排序后遍历

**思路：**

最符合直觉的解法是将数组进行排序。排序后，连续的数字在数组中是相邻的。我们只需要遍历一遍数组，检查当前元素是否等于前一个元素加 1。

1.  **特判**：如果数组为空，返回 0。
2.  **排序**：使用 `Arrays.sort` 对数组进行升序排序。
3.  **遍历**：

    - 如果当前数字等于前一个数字（重复值），直接跳过。
    - 如果当前数字等于前一个数字 + 1，说明序列连续，长度加 1。
    - 否则，说明序列中断，重新开始计数（重置长度为 1）。

4.  **记录最大值**：在遍历过程中持续更新最大长度。

**复杂度分析：**

- **时间复杂度：** $O(n \log n)$。虽然遍历只需要 $O(n)$，但排序不仅是瓶颈，而且不满足题目要求的 $O(n)$。
- **空间复杂度：** $O(\log n)$（取决于排序算法的递归栈深度）。

**代码片段：**

```java
public int longestConsecutive(int[] nums) {
    if (nums.length == 0) return 0;

    Arrays.sort(nums);

    int longest = 1;
    int currentStreak = 1;

    for (int i = 1; i < nums.length; i++) {
        if (nums[i] != nums[i-1]) {
            if (nums[i] == nums[i-1] + 1) {
                currentStreak += 1;
            } else {
                longest = Math.max(longest, currentStreak);
                currentStreak = 1;
            }
        }
    }

    return Math.max(longest, currentStreak);
}
```

### 解法二：哈希表（符合要求的 O(n) 解法）

**思路：**

为了达到 $O(n)$ 的时间复杂度，我们必须去除排序步骤。我们可以利用 **哈希表（HashSet）** 实现 $O(1)$ 的查找，从而快速判断一个数是否存在。

1.  **去重与存储**：将数组中的所有元素放入 `HashSet` 中，这样去除了重复元素，并允许我们在 $O(1)$ 时间内查询某个数是否存在。
2.  **寻找序列起点**：遍历集合中的每个元素 `x`。为了避免重复计算（例如对于序列 `1, 2, 3`，我们只希望从 `1` 开始计算，而不是从 `2` 或 `3` 重复算），我们只在 **`x - 1` 不在集合中** 时才开始计数。这意味着 `x` 是一个连续序列的起点。
3.  **向后延伸**：如果 `x` 是起点，则通过 `while` 循环不断检查 `x + 1`, `x + 2`, ... 是否存在于集合中，直到序列断开。
4.  **更新最大长度**：计算当前序列长度，并更新全局最大值。

**复杂度分析：**

- **时间复杂度：** $O(n)$。

  - 第一步构建哈希表需要 $O(n)$。
  - 第二步虽然有 `for` 循环嵌套 `while` 循环，但因为 `if (!numSet.contains(num - 1))` 的判断，`while` 循环体内的逻辑只会在序列的第一个数字处执行。这就保证了数组中的每个数字最多只会被访问两次（一次在 `for` 中，一次在 `while` 中）。因此总复杂度是线性的。

- **空间复杂度：** $O(n)$。需要使用哈希表存储数组元素。

**代码片段：**

```java
public int longestConsecutive(int[] nums) {
    Set<Integer> numSet = new HashSet<>();
    for (int num : nums) {
        numSet.add(num);
    }

    int longestStreak = 0;

    for (int num : numSet) {
        // 只有当 num 是序列的起点时（即 num-1 不存在），才开始向后寻找
        if (!numSet.contains(num - 1)) {
            int currentNum = num;
            int currentStreak = 1;

            while (numSet.contains(currentNum + 1)) {
                currentNum += 1;
                currentStreak += 1;
            }

            longestStreak = Math.max(longestStreak, currentStreak);
        }
    }

    return longestStreak;
}
```

### 完整代码

```java
import java.util.*;

public class Main {

    // 核心算法实现（哈希表法 O(n)）
    public static int longestConsecutive(int[] nums) {
        Set<Integer> numSet = new HashSet<>();
        // 1. 将所有数字加入 HashSet，实现去重和 O(1) 查询
        for (int num : nums) {
            numSet.add(num);
        }

        int longestStreak = 0;

        // 2. 遍历集合中的每个元素
        for (int num : numSet) {
            // 3. 剪枝：只有当当前数字是序列的“起点”时，才开始计数
            // 如果 num - 1 存在，说明 num 已经是某个序列的一部分，但不是起点，跳过
            if (!numSet.contains(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;

                // 4. 不断向后寻找 x+1, x+2...
                while (numSet.contains(currentNum + 1)) {
                    currentNum += 1;
                    currentStreak += 1;
                }

                longestStreak = Math.max(longestStreak, currentStreak);
            }
        }

        return longestStreak;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int[] nums1 = {100, 4, 200, 1, 3, 2};
        System.out.println("示例 1 输入: " + Arrays.toString(nums1));
        int result1 = longestConsecutive(nums1);
        System.out.println("示例 1 输出: " + result1); // 预期 4
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        int[] nums2 = {0, 3, 7, 2, 5, 8, 4, 6, 0, 1};
        System.out.println("示例 2 输入: " + Arrays.toString(nums2));
        int result2 = longestConsecutive(nums2);
        System.out.println("示例 2 输出: " + result2); // 预期 9
        System.out.println("-----------------------------");

        // --- 示例 3 测试 ---
        int[] nums3 = {1, 0, 1, 2};
        System.out.println("示例 3 输入: " + Arrays.toString(nums3));
        int result3 = longestConsecutive(nums3);
        System.out.println("示例 3 输出: " + result3); // 预期 3 (序列为 0, 1, 2)
    }
}
```
