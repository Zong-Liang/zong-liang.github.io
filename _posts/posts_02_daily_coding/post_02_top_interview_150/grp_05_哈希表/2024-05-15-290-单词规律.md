---
title: 290. 单词规律
date: 2024-05-15 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 哈希表]
tags: [哈希表]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121225206574.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一种规律 `pattern` 和一个字符串 `s` ，判断 `s` 是否遵循相同的规律。

这里的 **遵循** 指完全匹配，例如，`pattern` 里的每个字母和字符串 `s` 中的每个非空单词之间存在着双向连接的对应规律。具体来说：

- `pattern` 中的每个字母都 **恰好** 映射到 `s` 中的一个唯一单词。
- `s` 中的每个唯一单词都 **恰好** 映射到 `pattern` 中的一个字母。
- 没有两个字母映射到同一个单词，也没有两个单词映射到同一个字母。

**示例 1:**

- **输入:** `pattern = "abba"`, `s = "dog cat cat dog"`
- **输出:** `true`

**示例 2:**

- **输入:** `pattern = "abba"`, `s = "dog cat cat fish"`
- **输出:** `false`

**示例 3:**

- **输入:** `pattern = "aaaa"`, `s = "dog cat cat dog"`
- **输出:** `false`

**提示:**

- `1 <= pattern.length <= 300`
- `pattern` 只包含小写英文字母
- `1 <= s.length <= 3000`
- `s` 只包含小写英文字母和 `' '`
- `s` **不包含** 任何前导或尾随空格
- `s` 中每个单词都被 **单个空格** 分隔

## 题解

### 解法：双向哈希表（Bi-Map）

**思路：**

题目要求 `pattern` 中的字符与 `s` 中的单词之间建立 **一一对应（双射）** 的关系。这意味着：

1.  同一个字符必须映射到同一个单词。
2.  同一个单词必须映射到同一个字符。
3.  不同的字符不能映射到同一个单词（反之亦然）。

为了满足这种严格的双向绑定，我们可以使用 **两个哈希表**（或者一个哈希表 + 一个集合）：

- `charToWord`：记录字符到单词的映射关系（例如 `'a' -> "dog"`）。
- `wordToChar`：记录单词到字符的映射关系（例如 `"dog" -> 'a'`）。

**算法流程：**

1.  首先将字符串 `s` 按空格分割成单词数组 `words`。
2.  **前置判断**：如果 `pattern` 的长度与 `words` 的长度不一致，说明数量对不上，直接返回 `false`。
3.  遍历 `pattern` 和 `words`（使用索引 `i`）：

    - 取出当前字符 `c` = `pattern.charAt(i)` 和当前单词 `w` = `words[i]`。
    - **检查 `charToWord`**：如果 `c` 已经在表中，检查它映射的单词是否是 `w`。如果不相等，返回 `false`。
    - **检查 `wordToChar`**：如果 `w` 已经在表中，检查它映射的字符是否是 `c`。如果不相等，返回 `false`。
    - **建立映射**：如果两者都不在各自的表中，说明是一组新的对应关系，将它们分别存入两个哈希表。

4.  遍历结束且无冲突，返回 `true`。

**复杂度分析：**

- **时间复杂度：** $O(N + M)$，其中 $N$ 是 `pattern` 的长度，$M$ 是 `s` 的长度。`split` 操作消耗 $O(M)$，遍历消耗 $O(N)$。
- **空间复杂度：** $O(M)$，需要存储分割后的单词数组以及哈希表的空间。

**代码片段：**

```java
public boolean wordPattern(String pattern, String s) {
    String[] words = s.split(" ");

    // 数量不一致，绝对无法匹配
    if (pattern.length() != words.length) {
        return false;
    }

    Map<Character, String> charToWord = new HashMap<>();
    Map<String, Character> wordToChar = new HashMap<>();

    for (int i = 0; i < pattern.length(); i++) {
        char c = pattern.charAt(i);
        String w = words[i];

        // 检查 字符 -> 单词 的映射
        if (charToWord.containsKey(c)) {
            // 如果该字符之前映射的单词不是当前单词 w，失败
            if (!charToWord.get(c).equals(w)) {
                return false;
            }
        }
        // 检查 单词 -> 字符 的映射 (防止不同字符映射到同一个单词)
        else {
            // 如果该字符是新的，但单词 w 已经被别的字符用过了，失败
            if (wordToChar.containsKey(w)) {
                return false;
            }
            // 建立双向映射
            charToWord.put(c, w);
            wordToChar.put(w, c);
        }
    }
    return true;
}
```

### 完整代码

```java
import java.util.HashMap;
import java.util.Map;

public class Main {

    // 核心算法实现
    public static boolean wordPattern(String pattern, String s) {
        String[] words = s.split(" ");

        // 1. 长度校验
        if (pattern.length() != words.length) {
            return false;
        }

        // 2. 双向映射 Map
        Map<Character, String> charToWord = new HashMap<>();
        Map<String, Character> wordToChar = new HashMap<>();

        for (int i = 0; i < pattern.length(); i++) {
            char c = pattern.charAt(i);
            String w = words[i];

            // 情况 A: 字符 c 之前出现过
            if (charToWord.containsKey(c)) {
                // 必须保证对应的单词和之前的一样
                if (!charToWord.get(c).equals(w)) {
                    return false;
                }
            }
            // 情况 B: 字符 c 是第一次出现
            else {
                // 必须保证单词 w 也是第一次出现（不能被其他字符占用）
                if (wordToChar.containsKey(w)) {
                    return false;
                }

                // 建立映射
                charToWord.put(c, w);
                wordToChar.put(w, c);
            }
        }

        return true;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        String pattern1 = "abba";
        String s1 = "dog cat cat dog";
        System.out.println("示例 1 输入: pattern = \"" + pattern1 + "\", s = \"" + s1 + "\"");
        System.out.println("示例 1 输出: " + wordPattern(pattern1, s1)); // 预期: true
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        String pattern2 = "abba";
        String s2 = "dog cat cat fish";
        System.out.println("示例 2 输入: pattern = \"" + pattern2 + "\", s = \"" + s2 + "\"");
        System.out.println("示例 2 输出: " + wordPattern(pattern2, s2)); // 预期: false
        // 解释: 'a' 应该对应 "dog"，但最后一个对应了 "fish"
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        String pattern3 = "aaaa";
        String s3 = "dog cat cat dog";
        System.out.println("示例 3 输入: pattern = \"" + pattern3 + "\", s = \"" + s3 + "\"");
        System.out.println("示例 3 输出: " + wordPattern(pattern3, s3)); // 预期: false
        // 解释: 'a' 只能对应一个单词，不能同时对应 "dog" 和 "cat"

        System.out.println("-----------------------------");
        // --- 额外示例: 长度不匹配 ---
        String pattern4 = "aaa";
        String s4 = "aa aa aa aa";
        System.out.println("额外示例 输入: pattern = \"" + pattern4 + "\", s = \"" + s4 + "\"");
        System.out.println("额外示例 输出: " + wordPattern(pattern4, s4)); // 预期: false
    }
}
```
