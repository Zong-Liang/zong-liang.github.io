---
title: 102. 二叉树的层序遍历
date: 2024-08-11 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树层次遍历]
tags: [二叉树层次遍历]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232114053.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你二叉树的根节点 `root`，返回其节点值的 **层序遍历**。（即逐层地，从左到右访问所有节点）。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

- **输入:** `root = [3,9,20,null,null,15,7]`
- **输出:** `[[3],[9,20],[15,7]]`

**示例 2:**

- **输入:** `root = [1]`
- **输出:** `[[1]]`

**示例 3:**

- **输入:** `root = []`
- **输出:** `[]`

**提示:**

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000`

## 题解

### 解法一：广度优先搜索 (BFS) - 队列迭代

**思路：**

层序遍历的本质是 **广度优先搜索 (BFS)**。我们可以利用 **队列 (Queue)** 的先进先出特性来实现：

1.  **初始化**：创建一个队列，将根节点放入队列中。
2.  **循环处理**：当队列不为空时，进行循环。
3.  **分层控制**：在每一轮循环开始时，记录当前队列的大小 `size`。这个 `size` 恰好是当前这一层节点的数量。
4.  **遍历当前层**：使用一个 `for` 循环，执行 `size` 次出队操作：

    - 取出队头节点，将其值加入当前层的列表 `levelList`。
    - 如果该节点有左子节点，入队。
    - 如果该节点有右子节点，入队。

5.  **收集结果**：当前层遍历结束后，将 `levelList` 加入最终的结果集 `res`。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是二叉树的节点数。每个节点进队和出队各一次。
- **空间复杂度：** $O(n)$。队列中需要存储每一层的节点，最坏情况下（满二叉树的最底层）大约需要存储 $n/2$ 个节点。

**代码片段：**

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) return res;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        List<Integer> level = new ArrayList<>();
        int currentLevelSize = queue.size();

        for (int i = 0; i < currentLevelSize; i++) {
            TreeNode node = queue.poll();
            level.add(node.val);
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        res.add(level);
    }
    return res;
}
```

### 解法二：深度优先搜索 (DFS) - 递归

**思路：**

虽然 BFS 是层序遍历最直观的方法，但使用 DFS 同样可以达到目的。

我们在递归时，额外传递一个 `level` 参数（表示当前节点的深度）。

1.  当我们访问节点时，判断结果列表 `res` 的大小是否等于 `level`。

    - 如果 `res.size() == level`，说明我们第一次到达这一层，需要在 `res` 中新添加一个空列表。

2.  获取 `res` 中索引为 `level` 的列表，将当前节点值加入其中。
3.  递归处理左子节点（`level + 1`）和右子节点（`level + 1`）。

**复杂度分析：**

- **时间复杂度：** $O(n)$。
- **空间复杂度：** $O(h)$，即递归栈的高度。

**代码片段：**

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    dfs(root, 0, res);
    return res;
}

private void dfs(TreeNode node, int level, List<List<Integer>> res) {
    if (node == null) return;

    // 如果结果集的大小等于当前层级，说明该层还没有创建对应的列表
    if (res.size() == level) {
        res.add(new ArrayList<>());
    }

    // 将当前节点加入对应层的列表中
    res.get(level).add(node.val);

    // 递归处理子节点
    dfs(node.left, level + 1, res);
    dfs(node.right, level + 1, res);
}
```

### 完整代码

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class Main {

    // Definition for a binary tree node.
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode() {}
        TreeNode(int val) { this.val = val; }
        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    // 核心算法实现：解法一（BFS，最通用的层序遍历解法）
    public static List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            List<Integer> levelList = new ArrayList<>();
            // 获取当前层的节点数，固定循环次数
            int size = queue.size();

            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                levelList.add(node.val);

                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            // 将当前层的结果加入总结果集
            res.add(levelList);
        }

        return res;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        // 输入: root = [3,9,20,null,null,15,7]
        TreeNode root1 = new TreeNode(3);
        root1.left = new TreeNode(9);
        root1.right = new TreeNode(20);
        root1.right.left = new TreeNode(15);
        root1.right.right = new TreeNode(7);

        System.out.println("示例 1 输入: [3,9,20,null,null,15,7]");
        List<List<Integer>> res1 = levelOrder(root1);
        System.out.println("示例 1 输出: " + res1);
        // 预期: [[3], [9, 20], [15, 7]]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        // 输入: root = [1]
        TreeNode root2 = new TreeNode(1);
        System.out.println("示例 2 输入: [1]");
        List<List<Integer>> res2 = levelOrder(root2);
        System.out.println("示例 2 输出: " + res2);
        // 预期: [[1]]
        System.out.println("-----------------------------");

        // --- 示例 3 测试 ---
        // 输入: root = []
        TreeNode root3 = null;
        System.out.println("示例 3 输入: []");
        List<List<Integer>> res3 = levelOrder(root3);
        System.out.println("示例 3 输出: " + res3);
        // 预期: []
    }
}
```
