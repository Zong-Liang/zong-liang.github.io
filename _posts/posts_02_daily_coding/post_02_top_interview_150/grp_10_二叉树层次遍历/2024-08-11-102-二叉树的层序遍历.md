---
title: 102. 二叉树的层序遍历
date: 2024-08-11 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树层次遍历]
tags: [二叉树层次遍历]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232114053.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：102. 二叉树的层序遍历

给你二叉树的根节点 `root`，返回其节点值的 **层序遍历**。（即逐层地，从左到右访问所有节点）。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

- **输入:** `root = [3,9,20,null,null,15,7]`
- **输出:** `[[3],[9,20],[15,7]]`

**示例 2:**

- **输入:** `root = [1]`
- **输出:** `[[1]]`

**示例 3:**

- **输入:** `root = []`
- **输出:** `[]`

**提示:**

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000`

## 题解

**算法思路：(广度优先搜索 BFS)**

层序遍历是 **广度优先搜索 (BFS)** 的典型应用。我们可以使用一个 **队列** 来辅助实现。

1.  **初始化:**
    - 创建一个队列 `queue`，并将根节点 `root` 入队。
    - 创建一个列表 `result` 来存储最终的分层结果。
2.  **BFS 循环:**
    - 当队列不为空时，说明还有节点需要处理。
    - 在每一层的开始，我们首先记录下当前队列的大小 `levelSize`，这代表了当前层拥有的节点数。
    - 创建一个临时列表 `currentLevel` 来存储当前层所有节点的值。
    - 循环 `levelSize` 次，依次处理当前层的所有节点：
      a. 从队列中取出一个节点 `node`。
      b. 将 `node.val` 添加到 `currentLevel` 列表中。
      c. 如果 `node` 有左子节点，将其左子节点入队。
      d. 如果 `node` 有右子节点，将其右子节点入队。
    - 当内层循环结束后，`currentLevel` 就包含了当前层所有的节点值，将其加入 `result` 列表。
3.  重复此过程，直到队列为空。

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

/**
 * 二叉树节点的定义
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val) { this.val = val; }
}


public class Main {

    /**
     * 返回二叉树的层序遍历。
     */
    public static List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) {
            return result;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            // 当前层的节点数量
            int levelSize = queue.size();
            // 存储当前层节点值的列表
            List<Integer> currentLevel = new ArrayList<>();

            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();
                currentLevel.add(node.val);

                // 将下一层的节点入队
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            result.add(currentLevel);
        }

        return result;
    }


    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        TreeNode root1 = new TreeNode(3);
        root1.left = new TreeNode(9);
        root1.right = new TreeNode(20);
        root1.right.left = new TreeNode(15);
        root1.right.right = new TreeNode(7);
        System.out.println("输入: root = [3,9,20,null,null,15,7]");
        List<List<Integer>> result1 = levelOrder(root1);
        System.out.println("输出: " + result1); // 预期输出: [[3],[9,20],[15,7]]
        System.out.println();

        System.out.println("--- 示例 2 ---");
        TreeNode root2 = new TreeNode(1);
        System.out.println("输入: root = [1]");
        List<List<Integer>> result2 = levelOrder(root2);
        System.out.println("输出: " + result2); // 预期输出: [[1]]
        System.out.println();

        System.out.println("--- 示例 3 ---");
        TreeNode root3 = null;
        System.out.println("输入: root = []");
        List<List<Integer>> result3 = levelOrder(root3);
        System.out.println("输出: " + result3); // 预期输出: []
    }
}
```
