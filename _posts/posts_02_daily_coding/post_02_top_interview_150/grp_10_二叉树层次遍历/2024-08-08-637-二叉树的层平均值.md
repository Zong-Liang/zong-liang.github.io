---
title: 637. 二叉树的层平均值
date: 2024-08-08 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树层次遍历]
tags: [二叉树层次遍历]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232007369.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个非空二叉树的根节点 `root`，以数组的形式返回每一层节点的平均值。与实际答案相差 `10^-5` 以内的答案可以被接受。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg)

- **输入:** `root = [3,9,20,null,null,15,7]`
- **输出:** `[3.00000,14.50000,11.00000]`
- **解释:**

  第 0 层的平均值为 3，第 1 层的平均值为 14.5，第 2 层的平均值为 11。

  因此返回 `[3, 14.5, 11]`。

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg)

- **输入:** `root = [3,9,20,15,7]`
- **输出:** `[3.00000,14.50000,11.00000]`

**提示:**

- 树中节点数量在 `[1, 10^4]` 范围内
- `-2^31 <= Node.val <= 2^31 - 1`

## 题解

### 解法一：广度优先搜索 (BFS / 层序遍历)

**思路：**

要求计算每一层的平均值，最直接的方法就是进行 **层序遍历 (BFS)**。我们可以利用队列 (Queue) 来实现：

1.  初始化一个队列，将根节点加入队列。
2.  当队列不为空时，进行循环处理。在每一轮循环开始时，队列的大小 `size` 就代表了当前层拥有的节点数量。
3.  遍历这 `size` 个节点：

    - 将节点值累加到当前层的 `sum` 中。**注意**：为了防止累加和溢出 32 位整数范围，并且为了后续计算小数平均值，`sum` 应该使用 `double` 类型。
    - 将当前节点的左右子节点（如果不为空）加入队列，作为下一层的节点。

4.  当前层遍历结束后，计算 `sum / size`，并将结果添加到返回列表中。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是二叉树的节点数。我们需要遍历每个节点一次。
- **空间复杂度：** $O(m)$，其中 $m$ 是树的最大宽度（最底层的节点数）。在最坏情况下（满二叉树），队列中需要存储大约 $n/2$ 个节点。

**代码片段：**

```java
public List<Double> averageOfLevels(TreeNode root) {
    List<Double> averages = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        double sum = 0;
        int size = queue.size();

        // 遍历当前层的所有节点
        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            sum += node.val;

            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
        // 计算平均值
        averages.add(sum / size);
    }
    return averages;
}
```

### 解法二：深度优先搜索 (DFS)

**思路：**

虽然 BFS 更符合直觉，但我们也可以使用 DFS。我们需要维护两个列表：

- `counts`：存储每一层的节点数量。
- `sums`：存储每一层的节点数值之和。

我们在递归遍历树时，携带一个 `depth` 参数（代表当前深度）。

1.  当我们访问深度为 `i` 的节点时，将该节点的值加到 `sums[i]` 中，并将 `counts[i]` 加 1。
2.  如果当前深度 `i` 还没有在列表中创建对应的项，说明这是第一次到达该深度，需要初始化。
3.  遍历结束后，循环这两个列表，计算每一层的平均值。

**复杂度分析：**

- **时间复杂度：** $O(n)$。
- **空间复杂度：** $O(h)$，其中 $h$ 是树的高度。需要存储每一层的和与计数，以及递归调用栈的空间。

**代码片段：**

```java
public List<Double> averageOfLevels(TreeNode root) {
    List<Double> sums = new ArrayList<>();
    List<Integer> counts = new ArrayList<>();
    dfs(root, 0, sums, counts);

    List<Double> averages = new ArrayList<>();
    for (int i = 0; i < sums.size(); i++) {
        averages.add(sums.get(i) / counts.get(i));
    }
    return averages;
}

private void dfs(TreeNode node, int level, List<Double> sums, List<Integer> counts) {
    if (node == null) return;

    // 如果是第一次到达该层，初始化
    if (level < sums.size()) {
        sums.set(level, sums.get(level) + node.val);
        counts.set(level, counts.get(level) + 1);
    } else {
        sums.add((double) node.val);
        counts.add(1);
    }

    dfs(node.left, level + 1, sums, counts);
    dfs(node.right, level + 1, sums, counts);
}
```

### 完整代码

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class Main {

    // Definition for a binary tree node.
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode() {}
        TreeNode(int val) { this.val = val; }
        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    // 核心算法实现：解法一（BFS 层序遍历，最推荐）
    public static List<Double> averageOfLevels(TreeNode root) {
        List<Double> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            // 当前层的节点数量
            int size = queue.size();
            // 使用 double 防止整数溢出，并用于计算小数平均值
            double sum = 0;

            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                sum += node.val;

                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }

            // 计算当前层的平均值
            res.add(sum / size);
        }

        return res;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        // 输入: root = [3,9,20,null,null,15,7]
        TreeNode root1 = new TreeNode(3);
        root1.left = new TreeNode(9);
        root1.right = new TreeNode(20);
        root1.right.left = new TreeNode(15);
        root1.right.right = new TreeNode(7);

        System.out.println("示例 1 输入: [3,9,20,null,null,15,7]");
        List<Double> res1 = averageOfLevels(root1);
        System.out.println("示例 1 输出: " + res1); // 预期: [3.0, 14.5, 11.0]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        // 输入: root = [3,9,20,15,7]
        TreeNode root2 = new TreeNode(3);
        root2.left = new TreeNode(9);
        root2.right = new TreeNode(20);
        root2.left.left = new TreeNode(15);
        root2.left.right = new TreeNode(7);

        System.out.println("示例 2 输入: [3,9,20,15,7]");
        List<Double> res2 = averageOfLevels(root2);
        System.out.println("示例 2 输出: " + res2); // 预期: [3.0, 14.5, 11.0] (注意层级结构不同，但平均值计算相同)
        System.out.println("-----------------------------");

        // --- 示例 3 测试 (单节点) ---
        TreeNode root3 = new TreeNode(2147483647);
        TreeNode root3Right = new TreeNode(2147483647);
        root3.right = root3Right;
        System.out.println("示例 3 输入: [MaxInt, null, MaxInt] (测试溢出)");
        List<Double> res3 = averageOfLevels(root3);
        System.out.println("示例 3 输出: " + res3); // 预期: [2.147483647E9, 2.147483647E9]
    }
}
```
