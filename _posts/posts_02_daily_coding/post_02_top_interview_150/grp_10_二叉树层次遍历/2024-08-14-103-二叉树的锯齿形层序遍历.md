---
title: 103-二叉树的锯齿形层序遍历
date: 2024-08-14 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树层次遍历]
tags: [二叉树层次遍历]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232140807.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

好的，这是从图片中整理出的题目描述和解答代码。

### 题目：103. 二叉树的锯齿形层序遍历

给你二叉树的根节点 `root`，返回其节点值的 **锯齿形层序遍历**。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

---

**示例 1:**
![示例1图片](https://assets.leetcode.com/uploads/2021/02/19/tree_zigzag.jpg)

- **输入:** `root = [3,9,20,null,null,15,7]`
- **输出:** `[[3],[20,9],[15,7]]`

**示例 2:**

- **输入:** `root = [1]`
- **输出:** `[[1]]`

**示例 3:**

- **输入:** `root = []`
- **输出:** `[]`

---

**提示:**

- 树中节点数目在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`

---

### Java 8 解答 (赛码网格式)

**算法思路：(广度优先搜索 BFS)**
这个问题是标准层序遍历的一个变体。我们可以使用 **广度优先搜索 (BFS)**，并借助一个队列来实现。

1.  **BFS 初始化:**
    - 创建一个队列 `queue` 并将根节点 `root` 加入。
    - 创建一个布尔变量 `leftToRight`，初始为 `true`，用于指示当前层的遍历方向。
2.  **BFS 循环:**
    - 当队列不为空时，我们逐层处理节点。
    - 在每一层的开始，获取当前层的节点数 `levelSize`，并创建一个 `LinkedList` 来存储当前层的节点值（使用 `LinkedList` 是因为它支持在头部或尾部高效地添加元素）。
    - 循环 `levelSize` 次，处理当前层的所有节点：
      a. 从队列中取出一个节点 `node`。
      b. 根据 `leftToRight` 的值，决定是将 `node.val` **添加** 到 `LinkedList` 的 **尾部**（从左到右）还是 **头部**（从右到左）。
      c. 将 `node` 的非空子节点（左、右）加入队列，为下一层的遍历做准备。
    - 处理完一层后，将该层的 `LinkedList` 加入最终的结果列表，并 **反转** `leftToRight` 标志位。

通过这种方式，我们可以在标准的层序遍历框架上，通过改变添加元素到子列表的方式，轻松实现锯齿形遍历。

```java
import java.util.*;

/**
 * 二叉树节点的定义
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val) { this.val = val; }
}

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    /**
     * 返回二叉树节点值的锯齿形层序遍历。
     */
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) {
            return result;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        boolean leftToRight = true;

        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            // 使用 LinkedList 可以在头部或尾部高效添加元素
            LinkedList<Integer> currentLevel = new LinkedList<>();

            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();

                if (leftToRight) {
                    currentLevel.addLast(node.val); // 从左到右，添加到末尾
                } else {
                    currentLevel.addFirst(node.val); // 从右到左，添加到头部
                }

                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }

            result.add(currentLevel);
            leftToRight = !leftToRight; // 反转下一层的方向
        }

        return result;
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        TreeNode root1 = new TreeNode(3);
        root1.left = new TreeNode(9);
        root1.right = new TreeNode(20);
        root1.right.left = new TreeNode(15);
        root1.right.right = new TreeNode(7);
        System.out.println("输入: root = [3,9,20,null,null,15,7]");
        List<List<Integer>> result1 = solution.zigzagLevelOrder(root1);
        System.out.println("输出: " + result1); // 预期输出: [[3],[20,9],[15,7]]
        System.out.println();

        System.out.println("--- 示例 2 ---");
        TreeNode root2 = new TreeNode(1);
        System.out.println("输入: root = [1]");
        List<List<Integer>> result2 = solution.zigzagLevelOrder(root2);
        System.out.println("输出: " + result2); // 预期输出: [[1]]
        System.out.println();

        System.out.println("--- 示例 3 ---");
        TreeNode root3 = null;
        System.out.println("输入: root = []");
        List<List<Integer>> result3 = solution.zigzagLevelOrder(root3);
        System.out.println("输出: " + result3); // 预期输出: []
    }
}
```
