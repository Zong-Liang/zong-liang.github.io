---
title: 103. 二叉树的锯齿形层序遍历
date: 2024-08-14 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树层次遍历]
tags: [二叉树层次遍历]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232140807.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你二叉树的根节点 `root`，返回其节点值的 **锯齿形层序遍历**。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

- **输入:** `root = [3,9,20,null,null,15,7]`
- **输出:** `[[3],[20,9],[15,7]]`

**示例 2:**

- **输入:** `root = [1]`
- **输出:** `[[1]]`

**示例 3:**

- **输入:** `root = []`
- **输出:** `[]`

**提示:**

- 树中节点数目在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`

## 题解

### 解法一：广度优先搜索 (BFS) + 双端队列

**思路：**

这道题是标准的“二叉树层序遍历”的变种。普通的层序遍历是从左向右依次添加节点。而“锯齿形”遍历要求我们在每一层切换添加的顺序：

1.  第一层：从左往右。
2.  第二层：从右往左。
3.  第三层：从左往右。

    ...以此类推。

我们可以使用 **BFS**（借助队列）来遍历树的每一层。为了实现交替顺序，我们在收集每一层的节点值时，可以使用一个 **双端队列 (Deque/LinkedList)**：

- 如果当前是从左往右（`leftToRight` 为 `true`）：将新元素添加到链表的 **尾部** (`addLast`)。
- 如果当前是从右往左（`leftToRight` 为 `false`）：将新元素添加到链表的 **头部** (`addFirst`)。

每遍历完一层，将 `leftToRight` 的布尔值取反。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是二叉树的节点数。每个节点进队出队各一次，且链表的头尾插入操作均为 $O(1)$。
- **空间复杂度：** $O(n)$。需要队列存储节点，最坏情况下（满二叉树最底层）队列大小约为 $n/2$。

**代码片段：**

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) return res;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    boolean isOrderLeft = true; // 标记当前层是否从左往右

    while (!queue.isEmpty()) {
        // 使用 LinkedList 作为双端队列，方便头部插入
        LinkedList<Integer> levelList = new LinkedList<>();
        int size = queue.size();

        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();

            if (isOrderLeft) {
                // 从左往右：添加到末尾
                levelList.addLast(node.val);
            } else {
                // 从右往左：添加到开头
                levelList.addFirst(node.val);
            }

            // 下一层的节点依然是从左到右入队
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        res.add(levelList);
        // 切换方向
        isOrderLeft = !isOrderLeft;
    }
    return res;
}
```

### 解法二：深度优先搜索 (DFS)

**思路：**

我们也可以使用 DFS 递归遍历。递归时带上 `level`（层级）参数。

1.  如果结果集 `res` 的大小等于 `level`，说明需要为该层创建一个新的列表。
2.  获取当前层的列表。
3.  根据 `level` 的奇偶性决定插入顺序：

    - 偶数层（0, 2, ...）：从左往右，即 `add` 到列表末尾。
    - 奇数层（1, 3, ...）：从右往左，即 `add(0, val)` 插入到列表头部。

**复杂度分析：**

- **时间复杂度：** $O(n)$。
- **空间复杂度：** $O(h)$，递归栈的高度。

**代码片段：**

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    dfs(root, 0, res);
    return res;
}

private void dfs(TreeNode node, int level, List<List<Integer>> res) {
    if (node == null) return;

    if (res.size() == level) {
        res.add(new LinkedList<>());
    }

    // 根据层数决定插入位置
    if (level % 2 == 0) {
        res.get(level).add(node.val); // 偶数层：尾插
    } else {
        res.get(level).add(0, node.val); // 奇数层：头插
    }

    dfs(node.left, level + 1, res);
    dfs(node.right, level + 1, res);
}
```

### 完整代码

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class Main {

    // Definition for a binary tree node.
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode() {}
        TreeNode(int val) { this.val = val; }
        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    // 核心算法实现：解法一（BFS + 双端队列，推荐解法）
    public static List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        boolean isOrderLeft = true; // true: 左->右, false: 右->左

        while (!queue.isEmpty()) {
            // 使用 LinkedList 既实现了 List 接口，又支持 Deque 操作 (addFirst/addLast)
            LinkedList<Integer> levelList = new LinkedList<>();
            int size = queue.size();

            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();

                // 核心逻辑：根据方向决定放入结果列表的头部还是尾部
                if (isOrderLeft) {
                    levelList.addLast(node.val);
                } else {
                    levelList.addFirst(node.val);
                }

                // 子节点的入队顺序始终保持：先左后右
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }

            // 将当前层加入结果集
            res.add(levelList);
            // 每一层遍历完，反转方向
            isOrderLeft = !isOrderLeft;
        }

        return res;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        // 输入: root = [3,9,20,null,null,15,7]
        // 结构:
        //      3
        //     / \
        //    9  20
        //      /  \
        //     15   7
        TreeNode root1 = new TreeNode(3);
        root1.left = new TreeNode(9);
        root1.right = new TreeNode(20);
        root1.right.left = new TreeNode(15);
        root1.right.right = new TreeNode(7);

        System.out.println("示例 1 输入: [3,9,20,null,null,15,7]");
        List<List<Integer>> res1 = zigzagLevelOrder(root1);
        System.out.println("示例 1 输出: " + res1);
        // 预期: [[3], [20, 9], [15, 7]]
        // L0(左->右): [3]
        // L1(右->左): [20, 9]
        // L2(左->右): [15, 7]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        // 输入: root = [1]
        TreeNode root2 = new TreeNode(1);
        System.out.println("示例 2 输入: [1]");
        List<List<Integer>> res2 = zigzagLevelOrder(root2);
        System.out.println("示例 2 输出: " + res2);
        // 预期: [[1]]
        System.out.println("-----------------------------");

        // --- 示例 3 测试 ---
        // 输入: root = []
        TreeNode root3 = null;
        System.out.println("示例 3 输入: []");
        List<List<Integer>> res3 = zigzagLevelOrder(root3);
        System.out.println("示例 3 输出: " + res3);
        // 预期: []
    }
}
```
