---
title: 199. 二叉树的右视图
date: 2024-08-06 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树层次遍历]
tags: [二叉树层次遍历]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231938878.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2024/11/24/tmpd5jn43fs-1.png)

- **输入:** `root = [1,2,3,null,5,null,4]`
- **输出:** `[1,3,4]`

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2024/11/24/tmpkpe40xeh-1.png)

- **输入:** `root = [1,2,3,4,null,null,null,5]`
- **输出:** `[1,3,4,5]`

**示例 3:**

- **输入:** `root = [1,null,3]`
- **输出:** `[1,3]`

**示例 4:**

- **输入:** `root = []`
- **输出:** `[]`

**提示:**

- 二叉树的节点个数的范围是 `[0,100]`
- `-100 <= Node.val <= 100`

## 题解

### 解法一：广度优先搜索 (BFS / 层序遍历)

**思路：**

二叉树的右视图，实际上就是**二叉树每一层最右边的那个节点**。

我们可以利用 **层序遍历 (BFS)** 来解决这个问题：

1.  创建一个队列 `queue`，初始将根节点入队。
2.  当队列不为空时，开始遍历当前层的节点：

    - 获取当前队列的大小 `size`（代表当前层的节点数量）。
    - 循环 `size` 次，依次取出队头节点。
    - **关键点**：在循环过程中，如果当前节点的索引是该层的最后一个（即 `i == size - 1`），说明它是该层最右边的节点，将其值加入结果列表。
    - 将当前节点的左、右子节点（如果存在）分别加入队列。

3.  循环结束后，结果列表中存储的就是每一层最右侧的节点值。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是二叉树的节点数。我们需要遍历每个节点一次。
- **空间复杂度：** $O(n)$。最坏情况下（满二叉树），队列需要存储 $n/2$ 个节点（即最底层的节点数）。

**代码片段：**

```java
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root == null) return res;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        int size = queue.size();
        // 遍历当前层
        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            // 如果是当前层的最后一个节点，将其加入结果集
            if (i == size - 1) {
                res.add(node.val);
            }
            // 将子节点入队
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
    }
    return res;
}
```

### 解法二：深度优先搜索 (DFS)

**思路：**

我们要找每一层的最右侧节点，可以通过修改 DFS 的遍历顺序来实现。

通常的前序遍历是 `根 -> 左 -> 右`。如果我们改为 **`根 -> 右 -> 左`** 的顺序进行遍历，那么对于每一层来说，我们最先访问到的节点一定是最右边的那个节点。

1.  维护一个结果列表 `res`。
2.  递归函数携带当前节点的 `depth`（深度，从 0 开始）。
3.  **核心判断**：如果 `当前深度 == res.size()`，说明我们第一次到达这一层。因为我们是先访问右子树的，所以这“第一次”遇到的节点一定是该层最右边的节点。将其加入 `res`。
4.  先递归右子树，再递归左子树。

**复杂度分析：**

- **时间复杂度：** $O(n)$。
- **空间复杂度：** $O(height)$，递归栈的深度。

**代码片段：**

```java
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    dfs(root, 0, res);
    return res;
}

private void dfs(TreeNode node, int depth, List<Integer> res) {
    if (node == null) return;

    // 如果当前深度等于结果集的大小，说明是第一次访问该深度
    // 也就是该深度最右侧的节点
    if (depth == res.size()) {
        res.add(node.val);
    }

    // 注意：先递归右子树，再递归左子树
    dfs(node.right, depth + 1, res);
    dfs(node.left, depth + 1, res);
}
```

### 完整代码

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class Main {

    // Definition for a binary tree node.
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode() {}
        TreeNode(int val) { this.val = val; }
        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    // 核心算法实现：解法一（BFS 层序遍历，最符合直觉）
    public static List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int size = queue.size();
            // 遍历当前层的所有节点
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();

                // 如果是当前层的最后一个节点，说明它是从右侧看得到的那个
                if (i == size - 1) {
                    res.add(node.val);
                }

                // 标准的 BFS 入队逻辑
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
        }
        return res;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        // 输入: root = [1,2,3,null,5,null,4]
        TreeNode root1 = new TreeNode(1);
        root1.left = new TreeNode(2);
        root1.right = new TreeNode(3);
        root1.left.right = new TreeNode(5);
        root1.right.right = new TreeNode(4);

        System.out.println("示例 1 输入: [1,2,3,null,5,null,4]");
        List<Integer> res1 = rightSideView(root1);
        System.out.println("示例 1 输出: " + res1); // 预期: [1, 3, 4]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        // 输入: root = [1,2,3,4,null,null,null,5]
        TreeNode root2 = new TreeNode(1);
        root2.left = new TreeNode(2);
        root2.right = new TreeNode(3);
        root2.left.left = new TreeNode(4);
        root2.left.left.left = new TreeNode(5); // 注意 5 在第 4 层，右边没有遮挡

        System.out.println("示例 2 输入: [1,2,3,4,null,null,null,5]");
        List<Integer> res2 = rightSideView(root2);
        System.out.println("示例 2 输出: " + res2); // 预期: [1, 3, 4, 5]
        System.out.println("-----------------------------");

        // --- 示例 3 测试 ---
        // 输入: root = [1,null,3]
        TreeNode root3 = new TreeNode(1);
        root3.right = new TreeNode(3);

        System.out.println("示例 3 输入: [1,null,3]");
        List<Integer> res3 = rightSideView(root3);
        System.out.println("示例 3 输出: " + res3); // 预期: [1, 3]
        System.out.println("-----------------------------");

        // --- 示例 4 测试 ---
        // 输入: root = []
        TreeNode root4 = null;
        System.out.println("示例 4 输入: []");
        List<Integer> res4 = rightSideView(root4);
        System.out.println("示例 4 输出: " + res4); // 预期: []
    }
}
```
