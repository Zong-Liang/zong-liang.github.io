---
title: 74. 搜索二维矩阵
date: 2024-10-08 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二分查找]
tags: [二分查找]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234417054.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：74. 搜索二维矩阵

给你一个满足下列两条属性的 `m x n` 整数矩阵：

- 每行中的整数从左到右按非严格递增顺序排列。
- 每行的第一个整数大于前一行的最后一个整数。

给你一个整数 `target`，如果 `target` 在矩阵中，返回 `true`；否则，返回 `false`。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)

- **输入:** `matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]]`, `target = 3`
- **输出:** `true`

**示例 2:**

![示例2图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg)

- **输入:** `matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]]`, `target = 13`
- **输出:** `false`

**提示:**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 100`
- `-10^4 <= matrix[i][j], target <= 10^4`

## Java 代码

**算法思路：(两次二分查找)**

这个矩阵有一个非常重要的特性：如果将它按行展开，会得到一个完整的有序数组。我们可以利用这个特性来进行高效的搜索。

1.  **第一次二分查找（定位行）：**
    - 首先，对矩阵的第一列进行二分查找，目的是找到 `target` 可能存在的那一行。
    - 我们要找的是最后一行，其第一个元素小于或等于 `target`。
2.  **第二次二分查找（定位列）：**
    - 在定位到的那一行中，再进行一次标准的二分查找，看是否存在 `target`。

这种方法的总时间复杂度是 `O(log m + log n)`，满足题目要求。

````java
import java.util.Arrays;


public class Main {

    /**
     * 在一个特殊的 m x n 矩阵中搜索一个值。
     *
     * @param matrix 满足特定排序属性的矩阵
     * @param target 要搜索的目标值
     * @return 如果目标值存在则返回 true，否则返回 false
     */
    public static boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }

        int rows = matrix.length;
        int cols = matrix[0].length;

        // 第一次二分查找：定位目标行
        int top = 0, bottom = rows - 1;
        int targetRow = -1;
        while (top <= bottom) {
            int mid = top + (bottom - top) / 2;
            if (matrix[mid][0] <= target) {
                targetRow = mid;
                top = mid + 1;
            } else {
                bottom = mid - 1;
            }
        }

        // 如果没有找到合适的行（例如 target 比第一行的第一个元素还小）
        if (targetRow == -1) {
            return false;
        }

        // 第二次二分查找：在目标行中查找 target
        int left = 0, right = cols - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (matrix[targetRow][mid] == target) {
                return true;
            } else if (matrix[targetRow][mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return false;
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[][] matrix1 = {
            {1, 3, 5, 7},
            {10, 11, 16, 20},
            {23, 30, 34, 60}
        };
        int target1 = 3;
        System.out.println("输入: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = " + target1);
        boolean result1 = searchMatrix(matrix1, target1);
        System.out.println("输出: " + result1); // 预期输出: true
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[][] matrix2 = {
            {1, 3, 5, 7},
            {10, 11, 16, 20},
            {23, 30, 34, 60}
        };
        int target2 = 13;
        System.out.println("输入: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = " + target2);
        boolean result2 = searchMatrix(matrix2, target2);
        System.out.println("输出: " + result2); // 预期输出: false
        System.out.println();
    }
}```
````
