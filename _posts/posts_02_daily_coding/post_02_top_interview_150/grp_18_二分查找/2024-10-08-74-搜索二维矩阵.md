---
title: 74. 搜索二维矩阵
date: 2024-10-08 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二分查找]
tags: [二分查找]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234417054.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个满足下列两条属性的 `m x n` 整数矩阵：

- 每行中的整数从左到右按非严格递增顺序排列。
- 每行的第一个整数大于前一行的最后一个整数。

给你一个整数 `target`，如果 `target` 在矩阵中，返回 `true`；否则，返回 `false`。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)

- **输入:** `matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]]`, `target = 3`
- **输出:** `true`

**示例 2:**

![示例2图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg)

- **输入:** `matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]]`, `target = 13`
- **输出:** `false`

**提示:**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 100`
- `-10^4 <= matrix[i][j], target <= 10^4`

## 题解

### 解法：一次二分查找 (Binary Search on Flattened Matrix)

**思路：**

题目中给出的两个性质：

1.  每行元素从左到右升序。
2.  每行的第一个元素大于上一行的最后一个元素。

这意味着，如果我们把每一行拼接在上一行的后面，整个矩阵就会变成一个**严格递增的 1D 数组**。

我们可以利用这一特性，直接在这个“虚拟”的一维数组上进行二分查找，而不需要真正地重组数组。

1.  **坐标映射**：

    假设矩阵有 $m$ 行 $n$ 列。对于虚拟一维数组中的索引 `idx`（范围 `0` 到 `m * n - 1`），它对应在二维矩阵中的坐标为：

    - 行号：`row = idx / n`
    - 列号：`col = idx % n`

2.  **二分查找**：

    - `left = 0`
    - `right = m * n - 1`
    - 每次取出 `mid`，计算出对应的矩阵坐标值 `matrix[mid / n][mid % n]`，与 `target` 进行比较。

**复杂度分析：**

- **时间复杂度：** $O(\log(mn))$，我们将二维矩阵视作长度为 $m \times n$ 的一维数组进行二分查找。
- **空间复杂度：** $O(1)$，不需要额外的空间存储数据，只是逻辑上的映射。

**代码片段：**

```java
public boolean searchMatrix(int[][] matrix, int target) {
    int m = matrix.length;
    int n = matrix[0].length;

    // 二分查找的左右边界
    int left = 0;
    int right = m * n - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        // 关键：将一维索引映射回二维坐标
        int midVal = matrix[mid / n][mid % n];

        if (midVal == target) {
            return true;
        } else if (midVal < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return false;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    /**
     * 搜索二维矩阵 - 视作一维有序数组处理
     */
    public static boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) {
            return false;
        }

        int m = matrix.length;
        int n = matrix[0].length;

        // 虚拟一维数组的范围
        int left = 0;
        int right = m * n - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            // 一维索引 -> 二维坐标映射
            // 行 = mid / 列数
            // 列 = mid % 列数
            int row = mid / n;
            int col = mid % n;
            int midVal = matrix[row][col];

            if (midVal == target) {
                return true;
            } else if (midVal < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return false;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[][] matrix1 = {
            {1, 3, 5, 7},
            {10, 11, 16, 20},
            {23, 30, 34, 60}
        };
        int target1 = 3;

        System.out.println("示例 1 输入:");
        System.out.println("matrix = " + Arrays.deepToString(matrix1));
        System.out.println("target = " + target1);

        boolean result1 = searchMatrix(matrix1, target1);
        System.out.println("示例 1 输出: " + result1);
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[][] matrix2 = {
            {1, 3, 5, 7},
            {10, 11, 16, 20},
            {23, 30, 34, 60}
        };
        int target2 = 13;

        System.out.println("示例 2 输入:");
        System.out.println("matrix = " + Arrays.deepToString(matrix2));
        System.out.println("target = " + target2);

        boolean result2 = searchMatrix(matrix2, target2);
        System.out.println("示例 2 输出: " + result2);
    }
}
```
