---
title: 153-寻找旋转排序数组中的最小值
date: 2024-10-16 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二分查找]
tags: [二分查找]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234630199.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


### 题目：153. 寻找旋转排序数组中的最小值

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

**注意**，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`。

给你一个元素值 **互不相同** 的数组 `nums`，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素**。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

---

**示例 1:**

- **输入:** `nums = [3,4,5,1,2]`
- **输出:** 1
- **解释:** 原数组为 `[1,2,3,4,5]` ，旋转 `3` 次得到输入数组。

**示例 2:**

- **输入:** `nums = [4,5,6,7,0,1,2]`
- **输出:** 0
- **解释:** 原数组为 `[0,1,2,4,5,6,7]` ，旋转 `4` 次得到输入数组。

**示例 3:**

- **输入:** `nums = [11,13,15,17]`
- **输出:** 11
- **解释:** 原数组为 `[11,13,15,17]` ，旋转 `4` 次得到输入数组。

---

**提示:**

- `n == nums.length`
- `1 <= n <= 5000`
- `-5000 <= nums[i] <= 5000`
- `nums` 中的所有整数 **互不相同**
- `nums` 原来是一个升序排序的数组，并进行了 `1` 至 `n` 次旋转

---

### Java 8 解答 (赛码网格式)

**算法思路：(二分查找)**
为了达到 `O(log n)` 的时间复杂度，我们需要使用二分查找。

这个旋转后的数组有一个关键特性：它被分成了两个有序的部分。最小值就是右边那个较小部分的第一个元素。我们的目标就是通过二分查找找到这个“旋转点”。

1.  **初始化指针:** 设置 `left` 和 `right` 指针，分别指向数组的开始和结尾。
2.  **二分循环:**
    - 计算中间点 `mid`。
    - **比较 `nums[mid]` 和 `nums[right]`**：
      - 如果 `nums[mid] < nums[right]`，说明从 `mid` 到 `right` 这个区间是单调递增的。因此，最小值一定在 `mid` 的左边（或者就是 `mid` 本身）。我们缩小范围，令 `right = mid`。
      - 如果 `nums[mid] > nums[right]`，说明 `mid` 在左边那个较大的有序部分，而旋转点（即最小值）一定在 `mid` 的右边。我们缩小范围，令 `left = mid + 1`。
3.  **循环终止:** 当 `left == right` 时，循环结束，此时指针指向的位置就是数组的最小元素。

**特殊情况:** 如果数组没有被旋转（或者旋转了 n 次），那么它本身就是有序的，第一个元素 `nums[0]` 就是最小值。我们的二分查找逻辑同样可以覆盖这种情况。

```java
import java.util.Arrays;

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    /**
     * 找出并返回旋转排序数组中的最小元素。
     *
     * @param nums 旋转后的排序数组
     * @return 数组中的最小元素
     */
    public static int findMin(int[] nums) {
        int left = 0;
        int right = nums.length - 1;

        // 循环直到左右指针相遇
        while (left < right) {
            int mid = left + (right - left) / 2;

            // 如果中间值小于右边界值，说明右半部分是有序的
            // 最小值在左半部分（或就是 mid）
            if (nums[mid] < nums[right]) {
                right = mid;
            } else {
                // 如果中间值大于右边界值，说明 mid 在左边较大的那段
                // 最小值（旋转点）在右半部分
                left = mid + 1;
            }
        }

        // 当 left == right 时，找到了最小值
        return nums[left];
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[] nums1 = {3, 4, 5, 1, 2};
        System.out.println("输入: nums = " + Arrays.toString(nums1));
        int result1 = findMin(nums1);
        System.out.println("输出: " + result1); // 预期输出: 1
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[] nums2 = {4, 5, 6, 7, 0, 1, 2};
        System.out.println("输入: nums = " + Arrays.toString(nums2));
        int result2 = findMin(nums2);
        System.out.println("输出: " + result2); // 预期输出: 0
        System.out.println();

        System.out.println("--- 示例 3 ---");
        int[] nums3 = {11, 13, 15, 17};
        System.out.println("输入: nums = " + Arrays.toString(nums3));
        int result3 = findMin(nums3);
        System.out.println("输出: " + result3); // 预期输出: 11
        System.out.println();
    }
}
```
