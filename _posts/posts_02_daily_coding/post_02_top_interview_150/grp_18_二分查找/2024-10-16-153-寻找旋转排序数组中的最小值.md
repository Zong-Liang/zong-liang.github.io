---
title: 153. 寻找旋转排序数组中的最小值
date: 2024-10-16 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二分查找]
tags: [二分查找]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234630199.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

**注意**，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`。

给你一个元素值 **互不相同** 的数组 `nums`，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素**。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1:**

- **输入:** `nums = [3,4,5,1,2]`
- **输出:** 1
- **解释:** 原数组为 `[1,2,3,4,5]` ，旋转 `3` 次得到输入数组。

**示例 2:**

- **输入:** `nums = [4,5,6,7,0,1,2]`
- **输出:** 0
- **解释:** 原数组为 `[0,1,2,4,5,6,7]` ，旋转 `4` 次得到输入数组。

**示例 3:**

- **输入:** `nums = [11,13,15,17]`
- **输出:** 11
- **解释:** 原数组为 `[11,13,15,17]` ，旋转 `4` 次得到输入数组。

**提示:**

- `n == nums.length`
- `1 <= n <= 5000`
- `-5000 <= nums[i] <= 5000`
- `nums` 中的所有整数 **互不相同**
- `nums` 原来是一个升序排序的数组，并进行了 `1` 至 `n` 次旋转

## 题解

### 解法：二分查找 (Binary Search)

**思路：**

这道题要求时间复杂度为 $O(\log n)$，因此我们考虑**二分查找**。

数组经过旋转后，会在某个位置断开，形成两段有序区间（或者在旋转 0 次/n 次时整体有序）。我们的目标是找到“断崖”点，即右半段的起始位置，该位置的元素就是最小值。

我们需要定义左右指针 `left` 和 `right`，并在循环中计算中间位置 `mid`。关键在于如何缩小搜索区间：

**将 `nums[mid]` 与区间右边界 `nums[right]` 进行比较：**

1.  **如果 `nums[mid] > nums[right]`**：

    - 这意味着 `mid` 处于左半段（数值较大的那一段），而最小值一定在 `mid` 的右侧。
    - 所以，我们忽略左半部分，更新 `left = mid + 1`。

2.  **如果 `nums[mid] < nums[right]`**：

    - 这意味着 `mid` 到 `right` 这一段是单调递增的，说明 `mid` 可能就是最小值，或者最小值在 `mid` 的左侧。
    - 所以，我们忽略右半部分，更新 `right = mid`（注意不能是 `mid - 1`，因为 `mid` 自身可能是最小值）。

3.  **循环结束条件**：

    - 当 `left == right` 时，搜索区间收缩为一个点，该点即为全局最小值。

**为什么比较 `right` 而不是 `left`？**

因为数组可能未旋转（完全有序）。如果比较 `nums[mid] > nums[left]`，无法区分是“左侧有序”还是“数组整体有序且最小值在最左侧”。而比较 `nums[right]` 可以明确判断出旋转点所在的区间。

**复杂度分析：**

- **时间复杂度：** $O(\log n)$，每次循环搜索区间减半。
- **空间复杂度：** $O(1)$，只使用了常数个变量。

**代码片段：**

```java
public int findMin(int[] nums) {
    int left = 0;
    int right = nums.length - 1;

    // 循环直到 left == right
    while (left < right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] > nums[right]) {
            // 最小值在右边
            left = mid + 1;
        } else {
            // 最小值在左边或者就是 mid
            right = mid;
        }
    }
    return nums[left];
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    /**
     * 寻找旋转排序数组中的最小值
     */
    public static int findMin(int[] nums) {
        // 边界条件处理
        if (nums == null || nums.length == 0) {
            throw new IllegalArgumentException("Array must not be empty");
        }

        int left = 0;
        int right = nums.length - 1;

        // 二分查找
        while (left < right) {
            int mid = left + (right - left) / 2;

            // 将中间值与右边界值比较
            if (nums[mid] > nums[right]) {
                // 情况 1: 中间值大于右边界值 (例如 [3, 4, 5, 1, 2], mid=5, right=2)
                // 说明 mid 左侧是升序的，最小值肯定在 mid 右侧的"断崖"之后
                left = mid + 1;
            } else {
                // 情况 2: 中间值小于等于右边界值 (例如 [5, 1, 2, 3, 4], mid=2, right=4)
                // 说明 mid 到 right 是升序的，最小值要么是 mid，要么在 mid 左侧
                right = mid;
            }
        }

        // 结束时 left == right，指向最小值
        return nums[left];
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1 = {3, 4, 5, 1, 2};
        System.out.println("示例 1 输入: " + Arrays.toString(nums1));
        System.out.println("示例 1 输出: " + findMin(nums1));
        // 解释: 最小值为 1
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums2 = {4, 5, 6, 7, 0, 1, 2};
        System.out.println("示例 2 输入: " + Arrays.toString(nums2));
        System.out.println("示例 2 输出: " + findMin(nums2));
        // 解释: 最小值为 0
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        int[] nums3 = {11, 13, 15, 17};
        System.out.println("示例 3 输入: " + Arrays.toString(nums3));
        System.out.println("示例 3 输出: " + findMin(nums3));
        // 解释: 原数组未旋转或旋转n次，最小值为 11
        System.out.println("-----------------------------");

        // --- 额外示例 ---
        int[] nums4 = {2, 1};
        System.out.println("额外示例 输入: " + Arrays.toString(nums4));
        System.out.println("额外示例 输出: " + findMin(nums4));
        // 解释: 最小值为 1
    }
}
```
