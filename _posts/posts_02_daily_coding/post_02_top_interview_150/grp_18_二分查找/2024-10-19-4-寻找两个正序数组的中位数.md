---
title: 4. 寻找两个正序数组的中位数
date: 2024-10-19 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二分查找]
tags: [二分查找]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234657976.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：4. 寻找两个正序数组的中位数

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数**。

算法的时间复杂度应该为 `O(log (m+n))`。

**示例 1:**

- **输入:** `nums1 = [1,3]`, `nums2 = [2]`
- **输出:** `2.00000`
- **解释:** 合并数组 = `[1,2,3]`，中位数 2

**示例 2:**

- **输入:** `nums1 = [1,2]`, `nums2 = [3,4]`
- **输出:** `2.50000`
- **解释:** 合并数组 = `[1,2,3,4]`，中位数 `(2 + 3) / 2 = 2.5`

**提示:**

- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- `-10^6 <= nums1[i], nums2[i] <= 10^6`

## Java 代码

**算法思路：(二分查找)**

为了达到 `O(log(m+n))` 的时间复杂度，我们不能简单地合并两个数组。这个问题的核心是在不合并数组的情况下，找到一个“分割线”，将两个数组划分为“左半部分”和“右半部分”，使得：

1.  左半部分所有元素的最大值小于等于右半部分所有元素的最小值。
2.  左半部分的元素数量等于（或多于一个）右半部分的元素数量。

这个分割线可以通过在较短的数组上进行 **二分查找** 来找到。

1.  对较短的数组 `nums1` 进行二分查找，确定其分割点 `partitionX`。
2.  根据中位数的定义，`nums2` 的分割点 `partitionY` 也就随之确定了，以保证左右两部分元素总数平衡。
3.  检查分割是否满足 `max(左半部分) <= min(右半部分)` 的条件。
    - 如果不满足，根据比较结果调整 `nums1` 上的二分查找范围。
    - 如果满足，我们就找到了中位数。根据总元素个数的奇偶性，计算中位数的值。

这个方法将问题转化为了在一个有序数组中寻找一个特定位置，因此时间复杂度为对数级别。

```java
import java.util.Arrays;


public class Main {

    /**
     * 找出并返回这两个正序数组的中位数。
     *
     * @param nums1 第一个正序数组
     * @param nums2 第二个正序数组
     * @return 中位数
     */
    public static double findMedianSortedArrays(int[] nums1, int[] nums2) {
        // 确保 nums1 是较短的数组，以优化二分查找
        if (nums1.length > nums2.length) {
            return findMedianSortedArrays(nums2, nums1);
        }

        int x = nums1.length;
        int y = nums2.length;
        int low = 0;
        int high = x;

        while (low <= high) {
            // 在 nums1 中进行二分查找，确定分割点
            int partitionX = (low + high) / 2;
            // 根据中位数定义，计算出 nums2 的分割点
            int partitionY = (x + y + 1) / 2 - partitionX;

            // 获取分割线两侧的四个关键值
            // maxLeftX 是 nums1 左半部分的最大值
            int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];
            // minRightX 是 nums1 右半部分的最小值
            int minRightX = (partitionX == x) ? Integer.MAX_VALUE : nums1[partitionX];

            // maxLeftY 是 nums2 左半部分的最大值
            int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];
            // minRightY 是 nums2 右半部分的最小值
            int minRightY = (partitionY == y) ? Integer.MAX_VALUE : nums2[partitionY];

            // 检查分割是否正确
            if (maxLeftX <= minRightY && maxLeftY <= minRightX) {
                // 如果总长度是偶数
                if ((x + y) % 2 == 0) {
                    return ((double) Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;
                } else { // 如果总长度是奇数
                    return (double) Math.max(maxLeftX, maxLeftY);
                }
            } else if (maxLeftX > minRightY) {
                // partitionX 太大了，需要向左移动
                high = partitionX - 1;
            } else {
                // partitionX 太小了，需要向右移动
                low = partitionX + 1;
            }
        }

        // 理论上不会执行到这里，因为总能找到解
        throw new IllegalArgumentException("Input arrays are not sorted.");
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[] nums1_1 = {1, 3};
        int[] nums2_1 = {2};
        System.out.println("输入: nums1 = " + Arrays.toString(nums1_1) + ", nums2 = " + Arrays.toString(nums2_1));
        double result1 = findMedianSortedArrays(nums1_1, nums2_1);
        System.out.printf("输出: %.5f\n\n", result1); // 预期输出: 2.00000

        System.out.println("--- 示例 2 ---");
        int[] nums1_2 = {1, 2};
        int[] nums2_2 = {3, 4};
        System.out.println("输入: nums1 = " + Arrays.toString(nums1_2) + ", nums2 = " + Arrays.toString(nums2_2));
        double result2 = findMedianSortedArrays(nums1_2, nums2_2);
        System.out.printf("输出: %.5f\n", result2); // 预期输出: 2.50000
    }
}
```
