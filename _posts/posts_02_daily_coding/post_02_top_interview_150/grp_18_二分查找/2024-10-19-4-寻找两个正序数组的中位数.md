---
title: 4. 寻找两个正序数组的中位数
date: 2024-10-19 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二分查找]
tags: [二分查找]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234657976.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数**。

算法的时间复杂度应该为 `O(log (m+n))`。

**示例 1:**

- **输入:** `nums1 = [1,3]`, `nums2 = [2]`
- **输出:** `2.00000`
- **解释:** 合并数组 = `[1,2,3]`，中位数 2

**示例 2:**

- **输入:** `nums1 = [1,2]`, `nums2 = [3,4]`
- **输出:** `2.50000`
- **解释:** 合并数组 = `[1,2,3,4]`，中位数 `(2 + 3) / 2 = 2.5`

**提示:**

- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- `-10^6 <= nums1[i], nums2[i] <= 10^6`

## 题解

### 解法：二分查找与划分数组 (Binary Search / Partitioning)

**思路：**

要在两个有序数组中找到中位数，且要求时间复杂度为 $O(\log (m+n))$，这提示我们需要使用**二分查找**，而不是合并两个数组（后者是 $O(m+n)$）。

我们可以将问题转化为：**将两个数组分别切一刀，使得左半部分的所有元素都不大于右半部分的所有元素，且左半部分元素的总数量等于右半部分（或者多一个）。**

假设 `nums1` 长度为 `m`，`nums2` 长度为 `n`。为了减少二分查找的次数，我们总是在**长度较短**的那个数组上进行二分查找（假设是 `nums1`）。

1.  **定义分割线**：

    - 我们在 `nums1` 中切在位置 `i`（`0 <= i <= m`），在 `nums2` 中切在位置 `j`。
    - 左半部分包含：`nums1[0 .. i-1]` 和 `nums2[0 .. j-1]`。
    - 右半部分包含：`nums1[i .. m-1]` 和 `nums2[j .. n-1]`。
    - 为了保证左右元素数量平衡，我们需要满足：$i + j = \lfloor \frac{m + n + 1}{2} \rfloor$。这意味着只要确定了 `i`，`j` 就自动确定了。

2.  **交叉条件**：

    要使左半部分全部小于等于右半部分，必须满足：

    - `nums1[i-1] <= nums2[j]` （`nums1` 左边最大 $\le$ `nums2` 右边最小）
    - `nums2[j-1] <= nums1[i]` （`nums2` 左边最大 $\le$ `nums1` 右边最小）

3.  **二分搜索逻辑**：

    - 在 `nums1` 的区间 `[0, m]` 上进行二分。
    - 如果 `nums1[i-1] > nums2[j]`，说明 `nums1` 的左边太大了，分割线 `i` 需要左移。
    - 如果 `nums2[j-1] > nums1[i]`，说明 `nums1` 的右边太小了（或者说 `nums2` 的左边太大了），分割线 `i` 需要右移。
    - 找到满足条件的 `i` 后，根据总长度的奇偶性计算中位数：

      - **奇数**：中位数是左半部分的最大值（即 $\max(nums1[i-1], nums2[j-1])$）。
      - **偶数**：中位数是（左半部分最大值 + 右半部分最小值）/ 2。

4.  **边界处理**：

    - 当 `i=0` 或 `i=m`，或者 `j=0` 或 `j=n` 时，意味着分割线在数组的最左侧或最右侧。我们可以使用无穷小（`MIN_VALUE`）或无穷大（`MAX_VALUE`）来处理越界情况，避免复杂的 if-else 判断。

**复杂度分析：**

- **时间复杂度：** $O(\log(\min(m, n)))$，我们只在较短的数组上进行二分查找。
- **空间复杂度：** $O(1)$，只使用了常数个变量存储分割线位置和临界值。

**代码片段：**

```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    // 保证 nums1 是较短的数组，以优化时间复杂度
    if (nums1.length > nums2.length) {
        return findMedianSortedArrays(nums2, nums1);
    }

    int m = nums1.length;
    int n = nums2.length;
    int left = 0, right = m;

    // median1: 左半部分的最大值
    // median2: 右半部分的最小值
    int median1 = 0, median2 = 0;

    while (left <= right) {
        // i 是 nums1 的分割线，j 是 nums2 的分割线
        int i = (left + right) / 2;
        int j = (m + n + 1) / 2 - i;

        // 处理边界值：如果分割线在最左/最右，用无穷值代替
        int nums1_im1 = (i == 0 ? Integer.MIN_VALUE : nums1[i - 1]);
        int nums1_i   = (i == m ? Integer.MAX_VALUE : nums1[i]);
        int nums2_jm1 = (j == 0 ? Integer.MIN_VALUE : nums2[j - 1]);
        int nums2_j   = (j == n ? Integer.MAX_VALUE : nums2[j]);

        if (nums1_im1 <= nums2_j) {
            // 左半部分满足条件，记录可能的解
            median1 = Math.max(nums1_im1, nums2_jm1);
            median2 = Math.min(nums1_i, nums2_j);
            left = i + 1; // 尝试向右找，看是否有更合适的（其实这里二分逻辑稍有不同，一般找到即可停止，但为了逻辑统一可配合下方判断）
            // 更标准的写法是：
            // if (nums1_im1 <= nums2_j && nums2_jm1 <= nums1_i) { 找到答案 break; }
            // else if (nums1_im1 > nums2_j) { right = i - 1; }
            // else { left = i + 1; }
        } else {
            right = i - 1;
        }
    }

    // 上面的循环稍微简化了逻辑，这里提供一个更严谨的二分查找写法（见完整代码）
    // 下面仅为示意返回值逻辑
    return (m + n) % 2 == 0 ? (median1 + median2) / 2.0 : median1;
}
```

### 完整代码

以下是经过严格边界处理和优化的完整代码实现：

```java
import java.util.Arrays;

public class Main {

    /**
     * 寻找两个正序数组的中位数 - O(log(min(m,n))) 解法
     */
    public static double findMedianSortedArrays(int[] nums1, int[] nums2) {
        // 1. 确保 nums1 的长度小于等于 nums2 的长度
        // 这样我们只需要在较短的数组上进行二分查找，效率更高
        if (nums1.length > nums2.length) {
            return findMedianSortedArrays(nums2, nums1);
        }

        int m = nums1.length;
        int n = nums2.length;

        // totalLeft 表示合并后左半部分需要的元素个数
        // 技巧：(m + n + 1) / 2 可以同时处理总和为奇数和偶数的情况
        // 如果 m+n 是奇数，左半部分比右半部分多 1 个，中位数就是左半部分最大值
        // 如果 m+n 是偶数，左右相等，中位数是 (左大 + 右小) / 2
        int totalLeft = (m + n + 1) / 2;

        // 2. 在 nums1 上进行二分查找
        int left = 0;
        int right = m;

        while (left <= right) {
            // i 表示 nums1 的分割线（即 nums1 左半部分有多少个元素）
            int i = left + (right - left) / 2;
            // j 表示 nums2 的分割线（即 nums2 左半部分有多少个元素）
            int j = totalLeft - i;

            // 获取分割线两侧的四个关键数值
            // nums1LeftMax: nums1 分割线左边的值 (nums1[i-1])
            // nums1RightMin: nums1 分割线右边的值 (nums1[i])
            // nums2LeftMax: nums2 分割线左边的值 (nums2[j-1])
            // nums2RightMin: nums2 分割线右边的值 (nums2[j])

            // 处理边界：如果分割线切在最左边，左值设为最小值；切在最右边，右值设为最大值
            int nums1LeftMax = (i == 0) ? Integer.MIN_VALUE : nums1[i - 1];
            int nums1RightMin = (i == m) ? Integer.MAX_VALUE : nums1[i];
            int nums2LeftMax = (j == 0) ? Integer.MIN_VALUE : nums2[j - 1];
            int nums2RightMin = (j == n) ? Integer.MAX_VALUE : nums2[j];

            // 3. 检查分割是否合理
            // 交叉比较：nums1的左边 <= nums2的右边 && nums2的左边 <= nums1的右边
            if (nums1LeftMax <= nums2RightMin && nums2LeftMax <= nums1RightMin) {
                // 找到了合适的分割线

                // 如果总长度是奇数，中位数就是左半部分的最大值
                if ((m + n) % 2 == 1) {
                    return Math.max(nums1LeftMax, nums2LeftMax);
                }
                // 如果总长度是偶数，中位数是 (左半部最大值 + 右半部最小值) / 2
                else {
                    return (Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin)) / 2.0;
                }
            }
            else if (nums1LeftMax > nums2RightMin) {
                // nums1 左边的数太大了，说明分割线 i 需要左移
                right = i - 1;
            }
            else {
                // nums2 左边的数太大了（即 nums1 右边的数太小了），说明分割线 i 需要右移
                left = i + 1;
            }
        }

        return 0.0;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1_ex1 = {1, 3};
        int[] nums2_ex1 = {2};
        System.out.println("示例 1 输入: nums1 = " + Arrays.toString(nums1_ex1) + ", nums2 = " + Arrays.toString(nums2_ex1));
        System.out.println("示例 1 输出: " + findMedianSortedArrays(nums1_ex1, nums2_ex1));
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums1_ex2 = {1, 2};
        int[] nums2_ex2 = {3, 4};
        System.out.println("示例 2 输入: nums1 = " + Arrays.toString(nums1_ex2) + ", nums2 = " + Arrays.toString(nums2_ex2));
        System.out.println("示例 2 输出: " + findMedianSortedArrays(nums1_ex2, nums2_ex2));
        System.out.println("-----------------------------");

        // --- 示例 3 (空数组情况) ---
        int[] nums1_ex3 = {};
        int[] nums2_ex3 = {1};
        System.out.println("示例 3 输入: nums1 = " + Arrays.toString(nums1_ex3) + ", nums2 = " + Arrays.toString(nums2_ex3));
        System.out.println("示例 3 输出: " + findMedianSortedArrays(nums1_ex3, nums2_ex3));
    }
}
```
