---
title: 162. 寻找峰值
date: 2024-10-10 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二分查找]
tags: [二分查找]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234440111.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：162. 寻找峰值

**峰值元素**是指其值严格大于左右相邻值的元素。

给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞`。

你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。

**示例 1:**

- **输入:** `nums = [1,2,3,1]`
- **输出:** 2
- **解释:** 3 是峰值元素，你的函数应该返回其索引 2。

**示例 2:**

- **输入:** `nums = [1,2,1,3,5,6,4]`
- **输出:** 1 或 5
- **解释:** 你的函数可以返回索引 1，其峰值元素为 2；
  或者返回索引 5，其峰值元素为 6。

**提示:**

- `1 <= nums.length <= 1000`
- `-2^31 <= nums[i] <= 2^31 - 1`
- 对于所有有效的 `i` 都有 `nums[i] != nums[i + 1]`

## Java 代码

**算法思路：(二分查找)**

`O(log n)` 的时间复杂度要求提示我们使用二分查找。我们可以利用数组中元素的坡度来确定峰值的位置。

1.  **初始化指针:** 设置 `left` 和 `right` 指针，分别指向数组的开始和结尾。
2.  **比较中间值:** 在二分查找的每一步，我们取中间元素 `nums[mid]`，并将其与它的右邻居 `nums[mid + 1]` 进行比较。
    - **如果 `nums[mid] < nums[mid + 1]`:** 这说明我们正处于一个“上坡”路段，峰值一定在 `mid` 的右侧。因此，我们可以安全地舍弃左半部分，将搜索范围缩小到 `[mid + 1, right]`。
    - **如果 `nums[mid] > nums[mid + 1]`:** 这说明我们正处于一个“下坡”路段，峰值可能就是 `mid` 本身，或者在 `mid` 的左侧。因此，我们可以安全地舍弃右半部分，将搜索范围缩小到 `[left, mid]`。
3.  **循环终止:** 当 `left` 和 `right` 指针相遇时，循环结束。此时指针指向的位置就是一个峰值。

由于题目保证了 `nums[i] != nums[i+1]`，我们不需要处理 `nums[mid] == nums[mid + 1]` 的情况。

```java
import java.util.Arrays;


public class Main {

    /**
     * 找到峰值元素并返回其索引。
     *
     * @param nums 整数数组
     * @return 任何一个峰值的索引
     */
    public static int findPeakElement(int[] nums) {
        int left = 0;
        int right = nums.length - 1;

        // 循环直到左右指针相遇
        while (left < right) {
            int mid = left + (right - left) / 2;

            // 如果 mid 元素小于其右边的元素，说明处于上坡
            // 峰值一定在右边
            if (nums[mid] < nums[mid + 1]) {
                left = mid + 1;
            } else { // 否则，处于下坡，峰值在左边或就是 mid 本身
                right = mid;
            }
        }

        // 当 left == right 时，找到了一个峰值
        return left;
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[] nums1 = {1, 2, 3, 1};
        System.out.println("输入: nums = " + Arrays.toString(nums1));
        int result1 = findPeakElement(nums1);
        System.out.println("输出: " + result1); // 预期输出: 2
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[] nums2 = {1, 2, 1, 3, 5, 6, 4};
        System.out.println("输入: nums = " + Arrays.toString(nums2));
        int result2 = findPeakElement(nums2);
        // 验证输出是否是 1 或 5
        System.out.println("输出: " + result2); // 预期输出: 1 或 5
        if (result2 == 1 || result2 == 5) {
            System.out.println("结果正确！");
        } else {
            System.out.println("结果错误！");
        }
        System.out.println();
    }
}
```
