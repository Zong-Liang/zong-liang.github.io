---
title: 162. 寻找峰值
date: 2024-10-10 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二分查找]
tags: [二分查找]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234440111.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

**峰值元素**是指其值严格大于左右相邻值的元素。

给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞`。

你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。

**示例 1:**

- **输入:** `nums = [1,2,3,1]`
- **输出:** 2
- **解释:** 3 是峰值元素，你的函数应该返回其索引 2。

**示例 2:**

- **输入:** `nums = [1,2,1,3,5,6,4]`
- **输出:** 1 或 5
- **解释:** 你的函数可以返回索引 1，其峰值元素为 2；或者返回索引 5，其峰值元素为 6。

**提示:**

- `1 <= nums.length <= 1000`
- `-2^31 <= nums[i] <= 2^31 - 1`
- 对于所有有效的 `i` 都有 `nums[i] != nums[i + 1]`

## 题解

### 解法：二分查找 (Binary Search)

**思路：**

题目要求时间复杂度为 $O(\log n)$，这强烈暗示我们需要使用**二分查找**。虽然数组整体不是有序的，但我们可以利用“峰值”的性质来确定搜索方向。

我们可以将数组看作连绵起伏的山脉。我们随机取一个位置 `mid`：

1.  **上坡（Uphill）**：如果 `nums[mid] < nums[mid + 1]`，说明 `mid` 处于一个**上坡**阶段。因为题目约定了数组右边界是 $-\infty$，所以从 `mid + 1` 向右走，必然会遇到一个峰值（或者一直在上升直到末尾，末尾本身就是峰值）。因此，我们可以大胆地抛弃左半部分，让 `left = mid + 1`。
2.  **下坡（Downhill）**：如果 `nums[mid] > nums[mid + 1]`，说明 `mid` 处于一个**下坡**阶段（或者 `mid` 本身就是峰值）。同理，因为左边界是 $-\infty$，在 `mid` 的左侧（包含 `mid`）必然存在一个峰值。因此，我们抛弃右半部分，让 `right = mid`。

通过不断缩小区间，最终 `left` 和 `right` 会相遇，该位置就是峰值。

**关键点：** 为什么可以二分？因为题目保证了相邻元素不相等，且两端为负无穷，只要沿着“上坡”的方向走，或者在“下坡”时停留在高处，最终一定能找到一个局部最高点。

**复杂度分析：**

- **时间复杂度：** $O(\log n)$，每次比较都将搜索区间减半。
- **空间复杂度：** $O(1)$，仅使用了常数个变量。

**代码片段：**

```java
public int findPeakElement(int[] nums) {
    int left = 0;
    int right = nums.length - 1;

    // 使用 left < right 作为循环条件
    // 这样当循环结束时，left == right，即为峰值位置
    while (left < right) {
        int mid = left + (right - left) / 2;

        // 比较 mid 和 mid + 1
        if (nums[mid] < nums[mid + 1]) {
            // 处于上坡，峰值肯定在右边，且 mid 肯定不是峰值
            left = mid + 1;
        } else {
            // 处于下坡，峰值在左边或者就是 mid
            right = mid;
        }
    }
    return left;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    /**
     * 寻找峰值 - 二分查找
     */
    public static int findPeakElement(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }

        int left = 0;
        int right = nums.length - 1;

        while (left < right) {
            // 计算中间位置
            int mid = left + (right - left) / 2;

            // 比较当前值与右邻居的值
            // 注意：mid 计算方式保证了 mid 总是偏左，所以 mid + 1 不会越界
            if (nums[mid] < nums[mid + 1]) {
                // 如果 nums[mid] < nums[mid+1]，说明处于"上坡"
                // 峰值一定在 mid 的右侧，且 mid 不可能是峰值
                left = mid + 1;
            } else {
                // 如果 nums[mid] > nums[mid+1]，说明处于"下坡"
                // 峰值可能是 mid 自己，或者是 mid 左侧的某元素
                right = mid;
            }
        }

        // 循环结束时 left == right，这就是峰值的位置
        return left;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1 = {1, 2, 3, 1};
        System.out.println("示例 1 输入: " + Arrays.toString(nums1));
        int result1 = findPeakElement(nums1);
        System.out.println("示例 1 输出: " + result1);
        // 解释: 3 是峰值，索引为 2
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums2 = {1, 2, 1, 3, 5, 6, 4};
        System.out.println("示例 2 输入: " + Arrays.toString(nums2));
        int result2 = findPeakElement(nums2);
        System.out.println("示例 2 输出: " + result2);
        // 解释: 可以返回 1 (值为2) 或 5 (值为6)
        System.out.println("-----------------------------");

        // --- 示例 3 (单调递增) ---
        int[] nums3 = {1, 2, 3, 4, 5};
        System.out.println("示例 3 输入: " + Arrays.toString(nums3));
        System.out.println("示例 3 输出: " + findPeakElement(nums3));
        // 解释: 峰值在末尾，索引 4
        System.out.println("-----------------------------");

        // --- 示例 4 (单调递减) ---
        int[] nums4 = {5, 4, 3, 2, 1};
        System.out.println("示例 4 输入: " + Arrays.toString(nums4));
        System.out.println("示例 4 输出: " + findPeakElement(nums4));
        // 解释: 峰值在开头，索引 0
    }
}
```
