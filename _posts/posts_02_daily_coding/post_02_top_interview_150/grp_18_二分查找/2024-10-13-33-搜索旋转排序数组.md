---
title: 33. 搜索旋转排序数组
date: 2024-10-13 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二分查找]
tags: [二分查找]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234515923.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

整数数组 `nums` 按升序排列，数组中的值 **互不相同**。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **向左旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如，`[0,1,2,4,5,6,7]` 下标 `3` 上向左旋转后可能变为 `[4,5,6,7,0,1,2]`。

给你 **旋转后** 的数组 `nums` 和一个整数 `target`，如果 `nums` 中存在这个目标值 `target`，则返回它的下标，否则返回 `-1`。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1:**

- **输入:** `nums = [4,5,6,7,0,1,2]`, `target = 0`
- **输出:** 4

**示例 2:**

- **输入:** `nums = [4,5,6,7,0,1,2]`, `target = 3`
- **输出:** -1

**示例 3:**

- **输入:** `nums = [1]`, `target = 0`
- **输出:** -1

**提示:**

- `1 <= nums.length <= 5000`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 中的每个值都 **独一无二**
- 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
- `-10^4 <= target <= 10^4`

## 题解

### 解法：二分查找 (Binary Search)

**思路：**

这道题要求时间复杂度为 $O(\log n)$，因此必须使用**二分查找**。虽然数组被旋转了，不再是全局有序，但它具有一个重要性质：**将数组从中间分开，至少有一半是有序的**。

我们可以利用这个性质来决定搜索方向：

1.  初始化 `left` 和 `right` 指针。
2.  在循环中计算 `mid`，如果 `nums[mid] == target`，直接返回。
3.  判断哪一部分是有序的：

    - **如果 `nums[left] <= nums[mid]`**：说明左半部分 `[left, mid]` 是有序的。

      - 检查 `target` 是否在左半部分范围内（即 `nums[left] <= target < nums[mid]`）。
      - 如果是，则向左搜索 (`right = mid - 1`)。
      - 否则，目标值只能在右半部分，向右搜索 (`left = mid + 1`)。

    - **否则（`nums[left] > nums[mid]`）**：说明左半部分包含旋转点，因此右半部分 `[mid, right]` 必然是有序的。

      - 检查 `target` 是否在右半部分范围内（即 `nums[mid] < target <= nums[right]`）。
      - 如果是，则向右搜索 (`left = mid + 1`)。
      - 否则，目标值只能在左半部分，向左搜索 (`right = mid - 1`)。

**复杂度分析：**

- **时间复杂度：** $O(\log n)$，每次迭代都会将搜索范围减半，符合二分查找的特性。
- **空间复杂度：** $O(1)$，仅使用了常数级变量。

**代码片段：**

```java
public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            return mid;
        }

        // 判断哪一半是有序的
        if (nums[left] <= nums[mid]) {
            // 左半部分有序
            // 检查 target 是否在左半部分范围内
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            // 右半部分有序
            // 检查 target 是否在右半部分范围内
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return -1;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    /**
     * 搜索旋转排序数组
     */
    public static int search(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return -1;
        }

        int left = 0;
        int right = nums.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] == target) {
                return mid;
            }

            // 判断哪边有序
            // 注意：当 left == mid 时，条件 nums[left] <= nums[mid] 成立，逻辑依然正确
            if (nums[left] <= nums[mid]) {
                // Case 1: 左半边 [left, mid] 是有序的
                // 检查 target 是否落在左半边的范围内
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1; // 目标在左边
                } else {
                    left = mid + 1;  // 目标在右边
                }
            } else {
                // Case 2: 右半边 [mid, right] 是有序的
                // 检查 target 是否落在右半边的范围内
                if (nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;  // 目标在右边
                } else {
                    right = mid - 1; // 目标在左边
                }
            }
        }

        return -1;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1 = {4, 5, 6, 7, 0, 1, 2};
        int target1 = 0;
        System.out.println("示例 1 输入: nums = " + Arrays.toString(nums1) + ", target = " + target1);
        System.out.println("示例 1 输出: " + search(nums1, target1));
        // 解释: 0 位于下标 4
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums2 = {4, 5, 6, 7, 0, 1, 2};
        int target2 = 3;
        System.out.println("示例 2 输入: nums = " + Arrays.toString(nums2) + ", target = " + target2);
        System.out.println("示例 2 输出: " + search(nums2, target2));
        // 解释: 3 不在数组中，返回 -1
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        int[] nums3 = {1};
        int target3 = 0;
        System.out.println("示例 3 输入: nums = " + Arrays.toString(nums3) + ", target = " + target3);
        System.out.println("示例 3 输出: " + search(nums3, target3));
        // 解释: 0 不在数组中
        System.out.println("-----------------------------");

        // --- 额外示例 ---
        int[] nums4 = {3, 1};
        int target4 = 1;
        System.out.println("额外示例 输入: nums = " + Arrays.toString(nums4) + ", target = " + target4);
        System.out.println("额外示例 输出: " + search(nums4, target4));
        // 预期输出: 1
    }
}
```
