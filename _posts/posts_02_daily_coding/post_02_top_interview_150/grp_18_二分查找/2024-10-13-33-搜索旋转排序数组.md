---
title: 33. 搜索旋转排序数组
date: 2024-10-13 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二分查找]
tags: [二分查找]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234515923.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：33. 搜索旋转排序数组

整数数组 `nums` 按升序排列，数组中的值 **互不相同**。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **向左旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如，`[0,1,2,4,5,6,7]` 下标 `3` 上向左旋转后可能变为 `[4,5,6,7,0,1,2]`。

给你 **旋转后** 的数组 `nums` 和一个整数 `target`，如果 `nums` 中存在这个目标值 `target`，则返回它的下标，否则返回 `-1`。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1:**

- **输入:** `nums = [4,5,6,7,0,1,2]`, `target = 0`
- **输出:** 4

**示例 2:**

- **输入:** `nums = [4,5,6,7,0,1,2]`, `target = 3`
- **输出:** -1

**示例 3:**

- **输入:** `nums = [1]`, `target = 0`
- **输出:** -1

**提示:**

- `1 <= nums.length <= 5000`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 中的每个值都 **独一无二**
- 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
- `-10^4 <= target <= 10^4`

## Java 代码

**算法思路：(二分查找)**

为了达到 `O(log n)` 的时间复杂度，我们必须使用二分查找。由于数组只是被旋转过，它仍然具有部分有序的特性。我们可以利用这个特性来修改二分查找的逻辑。

在标准的二分查找中，我们通过比较中间值 `nums[mid]` 和 `target` 来决定舍弃哪一半。在这里，数组被分成了两个有序的部分。因此，在每一步二分查找中，`[left, mid]` 和 `[mid, right]` 这两个区间中 **至少有一个是完全有序的**。

1.  计算中间点 `mid`。
2.  判断哪一半（左半部分 `[left, mid]` 或右半部分 `[mid, right]`）是有序的。
    - 如果 `nums[left] <= nums[mid]`，则左半部分是有序的。
    - 否则，右半部分是有序的。
3.  在确定了有序的那一半之后，我们检查 `target` 是否位于这个有序区间的范围内。
    - 如果是，我们就缩小搜索范围到这个有序的半区。
    - 如果不是，我们就去另一半（可能是无序的）半区继续寻找。
4.  重复这个过程，直到找到 `target` 或者 `left > right`。

```java
import java.util.Arrays;


public class Main {

    /**
     * 在旋转排序数组中搜索目标值。
     *
     * @param nums   旋转后的排序数组
     * @param target 目标值
     * @return 目标值的索引，如果不存在则返回 -1
     */
    public static int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] == target) {
                return mid;
            }

            // 判断左半部分 [left...mid] 是否有序
            if (nums[left] <= nums[mid]) {
                // 如果 target 在有序的左半部分范围内
                if (target >= nums[left] && target < nums[mid]) {
                    right = mid - 1;
                } else { // 否则，去右半部分查找
                    left = mid + 1;
                }
            } else { // 否则，右半部分 [mid...right] 是有序的
                // 如果 target 在有序的右半部分范围内
                if (target > nums[mid] && target <= nums[right]) {
                    left = mid + 1;
                } else { // 否则，去左半部分查找
                    right = mid - 1;
                }
            }
        }

        // 没有找到目标值
        return -1;
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[] nums1 = {4, 5, 6, 7, 0, 1, 2};
        int target1 = 0;
        System.out.println("输入: nums = " + Arrays.toString(nums1) + ", target = " + target1);
        int result1 = search(nums1, target1);
        System.out.println("输出: " + result1); // 预期输出: 4
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[] nums2 = {4, 5, 6, 7, 0, 1, 2};
        int target2 = 3;
        System.out.println("输入: nums = " + Arrays.toString(nums2) + ", target = " + target2);
        int result2 = search(nums2, target2);
        System.out.println("输出: " + result2); // 预期输出: -1
        System.out.println();

        System.out.println("--- 示例 3 ---");
        int[] nums3 = {1};
        int target3 = 0;
        System.out.println("输入: nums = " + Arrays.toString(nums3) + ", target = " + target3);
        int result3 = search(nums3, target3);
        System.out.println("输出: " + result3); // 预期输出: -1
        System.out.println();
    }
}
```
