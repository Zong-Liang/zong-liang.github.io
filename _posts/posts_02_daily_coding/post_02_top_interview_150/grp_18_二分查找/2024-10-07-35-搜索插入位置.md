---
title: 35. 搜索插入位置
date: 2024-10-07 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二分查找]
tags: [二分查找]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234258321.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

**示例 1:**

- **输入:** `nums = [1,3,5,6]`, `target = 5`
- **输出:** 2

**示例 2:**

- **输入:** `nums = [1,3,5,6]`, `target = 2`
- **输出:** 1

**示例 3:**

- **输入:** `nums = [1,3,5,6]`, `target = 7`
- **输出:** 4

**提示:**

- `1 <= nums.length <= 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 为 **无重复元素** 的 **升序** 排列数组
- `-10^4 <= target <= 10^4`

## 题解

### 解法：二分查找 (Binary Search)

**思路：**

题目要求在有序数组中查找目标值，且强制要求时间复杂度为 $O(\log n)$，这是典型的**二分查找**应用场景。

我们需要维护两个指针 `left` 和 `right`，分别指向查找区间的左右边界。在循环过程中：

1.  计算中间下标 `mid`。
2.  比较 `nums[mid]` 和 `target`：

    - 如果相等，直接返回 `mid`。
    - 如果 `nums[mid] < target`，说明目标值在右侧，更新 `left = mid + 1`。
    - 如果 `nums[mid] > target`，说明目标值在左侧，更新 `right = mid - 1`。

**关键点：当循环结束（未找到目标值）时，应该返回什么？**

当 `while (left <= right)` 结束时，`left` 指针所在的位置恰好是**第一个大于等于 target 的元素下标**，也就是目标值应当被插入的位置。

**复杂度分析：**

- **时间复杂度：** $O(\log n)$，每次迭代将搜索范围减半。
- **空间复杂度：** $O(1)$，仅使用常数个变量存储指针。

**代码片段：**

```java
public int searchInsert(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        // 防止 (left + right) 溢出
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    // 如果没找到，left 所在的位置即为插入位置
    return left;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    /**
     * 搜索插入位置 - 二分查找
     */
    public static int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                // 目标值在右半部分
                left = mid + 1;
            } else {
                // 目标值在左半部分
                right = mid - 1;
            }
        }

        // 循环结束时，left 指向第一个大于等于 target 的位置
        return left;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1 = {1, 3, 5, 6};
        int target1 = 5;
        System.out.println("示例 1 输入: nums = " + Arrays.toString(nums1) + ", target = " + target1);
        System.out.println("示例 1 输出: " + searchInsert(nums1, target1));
        // 解释: 5 存在于索引 2
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums2 = {1, 3, 5, 6};
        int target2 = 2;
        System.out.println("示例 2 输入: nums = " + Arrays.toString(nums2) + ", target = " + target2);
        System.out.println("示例 2 输出: " + searchInsert(nums2, target2));
        // 解释: 2 不存在，应插入在 1 和 3 之间，即索引 1
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        int[] nums3 = {1, 3, 5, 6};
        int target3 = 7;
        System.out.println("示例 3 输入: nums = " + Arrays.toString(nums3) + ", target = " + target3);
        System.out.println("示例 3 输出: " + searchInsert(nums3, target3));
        // 解释: 7 比所有元素都大，应插入在末尾，即索引 4
        System.out.println("-----------------------------");

        // --- 示例 4 (插入头部) ---
        int[] nums4 = {1, 3, 5, 6};
        int target4 = 0;
        System.out.println("示例 4 输入: nums = " + Arrays.toString(nums4) + ", target = " + target4);
        System.out.println("示例 4 输出: " + searchInsert(nums4, target4));
        // 解释: 0 比所有元素都小，应插入在头部，即索引 0
    }
}
```
