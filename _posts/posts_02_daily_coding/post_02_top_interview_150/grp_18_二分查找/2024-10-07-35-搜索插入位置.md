---
title: 35. 搜索插入位置
date: 2024-10-07 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二分查找]
tags: [二分查找]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234258321.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：35. 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

**示例 1:**

- **输入:** `nums = [1,3,5,6]`, `target = 5`
- **输出:** 2

**示例 2:**

- **输入:** `nums = [1,3,5,6]`, `target = 2`
- **输出:** 1

**示例 3:**

- **输入:** `nums = [1,3,5,6]`, `target = 7`
- **输出:** 4

**提示:**

- `1 <= nums.length <= 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 为 **无重复元素** 的 **升序** 排列数组
- `-10^4 <= target <= 10^4`

## 题解

**算法思路：(二分查找)**

`O(log n)` 的时间复杂度要求明确指向了使用 **二分查找** 算法。

这个问题的本质是寻找第一个 **大于或等于** `target` 的元素的索引。

1.  **初始化指针:** 设置 `left` 和 `right` 指针，分别指向数组的开始和结尾。
2.  **二分循环:**
    - 计算中间点 `mid`。
    - 如果 `nums[mid]` 小于 `target`，说明 `target` 的位置（或其插入位置）一定在 `mid` 的右侧，因此我们将搜索范围缩小到 `[mid + 1, right]`。
    - 如果 `nums[mid]` 大于或等于 `target`，说明 `mid` **可能** 就是我们要找的位置，或者正确的位置在 `mid` 的左侧。因此，我们将搜索范围缩小到 `[left, mid - 1]`，并记录下当前的 `mid` 作为一个潜在的答案。
3.  **循环终止:** 当 `left > right` 时，循环结束。
    - 如果在循环中没有找到等于 `target` 的值，最终 `left` 指针停留的位置就是 `target` 应该被插入的位置。

```java
import java.util.Arrays;


public class Main {

    /**
     * 在排序数组中查找目标值或其插入位置。
     *
     * @param nums   升序排列的无重复元素数组
     * @param target 目标值
     * @return 目标值的索引或其插入位置
     */
    public static int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        // 如果循环结束都没有找到 target，
        // 那么 left 指针的位置就是它应该被插入的位置。
        return left;
    }


    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[] nums1 = {1, 3, 5, 6};
        int target1 = 5;
        System.out.println("输入: nums = " + Arrays.toString(nums1) + ", target = " + target1);
        int result1 = searchInsert(nums1, target1);
        System.out.println("输出: " + result1); // 预期输出: 2
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[] nums2 = {1, 3, 5, 6};
        int target2 = 2;
        System.out.println("输入: nums = " + Arrays.toString(nums2) + ", target = " + target2);
        int result2 = searchInsert(nums2, target2);
        System.out.println("输出: " + result2); // 预期输出: 1
        System.out.println();

        System.out.println("--- 示例 3 ---");
        int[] nums3 = {1, 3, 5, 6};
        int target3 = 7;
        System.out.println("输入: nums = " + Arrays.toString(nums3) + ", target = " + target3);
        int result3 = searchInsert(nums3, target3);
        System.out.println("输出: " + result3); // 预期输出: 4
        System.out.println();
    }
}
```
