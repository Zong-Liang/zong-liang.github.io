---
title: 39. 组合总和
date: 2024-09-18 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 回溯]
tags: [回溯]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233343189.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target`，找出 `candidates` 中可以使数字和为目标数 `target` 的所有 **不同组合**，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取**。如果至少一个数字的被选数量不同，则两种组合是不同的。

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

**示例 1:**

- **输入:** `candidates = [2,3,6,7]`, `target = 7`
- **输出:** `[[2,2,3],[7]]`
- **解释:**

  2 和 3 可以形成一组候选，2 + 2 + 3 = 7。注意 2 可以使用多次。

  7 也是一个候选， 7 = 7。

  仅有这两种组合。

**示例 2:**

- **输入:** `candidates = [2,3,5]`, `target = 8`
- **输出:** `[[2,2,2,2],[2,3,3],[3,5]]`

**示例 3:**

- **输入:** `candidates = [2]`, `target = 1`
- **输出:** `[]`

**提示:**

- `1 <= candidates.length <= 30`
- `2 <= candidates[i] <= 40`
- `candidates` 的所有元素 **互不相同**
- `1 <= target <= 40`

## 题解

### 解法：回溯算法 + 剪枝 (Backtracking with Pruning)

**思路：**

这道题是典型的**回溯算法**应用场景。我们需要在候选数组中不断尝试选择数字，直到总和等于目标值。可以将其抽象为一棵决策树的遍历过程。

1.  **路径与选择**：

    - 路径：已经做出的选择（当前已选的数字列表）。
    - 选择列表：当前可以选的数字。因为题目允许数字重复使用，且要求组合不重复（即 `[2, 3]` 和 `[3, 2]` 视为同一个），所以我们在递归时，**下一次选择的起始位置应当从当前索引开始**，而不能回头选之前的数字。

2.  **结束条件**：

    - 如果当前总和等于 `target`（或剩余目标值为 0），说明找到了一组解，将其加入结果集。
    - 如果当前总和超过 `target`（或剩余目标值为负数），说明此路不通，直接返回（回溯）。

3.  **剪枝优化**：

    - 为了提高效率，我们可以先对 `candidates` 数组进行**排序**。
    - 在遍历选择列表时，如果发现 `当前数字 > 剩余目标值`，因为数组是有序的，后续的数字肯定更大，必然也不满足条件。此时可以直接 `break` 终止当前层的循环，而不需要继续尝试。

**复杂度分析：**

- **时间复杂度：** $O(S)$，其中 $S$ 为所有可行解的长度之和。最坏情况下（例如全是 1，target 很大），复杂度是指数级的 $O(n \cdot 2^n)$，但由于题目限制了 `target` 和 `candidates` 的大小，且有剪枝，实际运行很快。
- **空间复杂度：** $O(target)$，取决于递归的深度。最坏情况下需要递归 $target / \min(candidates)$ 层。

**代码片段：**

```java
public List<List<Integer>> combinationSum(int[] candidates, int target) {
    List<List<Integer>> res = new ArrayList<>();
    // 排序是为了后面剪枝
    Arrays.sort(candidates);
    backtrack(res, new ArrayList<>(), candidates, target, 0);
    return res;
}

private void backtrack(List<List<Integer>> res, List<Integer> path, int[] candidates, int target, int start) {
    // 终止条件：找到目标
    if (target == 0) {
        res.add(new ArrayList<>(path));
        return;
    }

    for (int i = start; i < candidates.length; i++) {
        // 剪枝：如果当前数字已经大于剩余 target，后面的数字更大，肯定不行
        if (target - candidates[i] < 0) {
            break;
        }

        // 做出选择
        path.add(candidates[i]);
        // 递归：注意这里传入的是 i，因为数字可以重复使用
        // 如果不允许重复，这里应传入 i + 1
        backtrack(res, path, candidates, target - candidates[i], i);
        // 撤销选择（回溯）
        path.remove(path.size() - 1);
    }
}
```

### 完整代码

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Main {

    // 核心解法
    public static List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        if (candidates == null || candidates.length == 0) {
            return res;
        }
        // 1. 排序，方便剪枝
        Arrays.sort(candidates);

        // 2. 进入回溯
        backtrack(res, new ArrayList<>(), candidates, target, 0);
        return res;
    }

    /**
     * 回溯函数
     * @param res 结果集
     * @param path 当前路径（已选的数字）
     * @param candidates 候选数组
     * @param remainingTarget 剩余需要凑出的目标值
     * @param start 当前搜索的起始下标（防止产生重复组合）
     */
    private static void backtrack(List<List<Integer>> res, List<Integer> path, int[] candidates, int remainingTarget, int start) {
        // 找到了符合条件的组合
        if (remainingTarget == 0) {
            res.add(new ArrayList<>(path)); // 必须拷贝一份 path
            return;
        }

        // 从 start 开始遍历，避免回头选造成重复（如 [2,3] 和 [3,2]）
        for (int i = start; i < candidates.length; i++) {
            // 剪枝逻辑：数组已排序，如果当前值大于剩余目标，后续肯定也大于，直接停止
            if (remainingTarget - candidates[i] < 0) {
                break;
            }

            path.add(candidates[i]);

            // 关键点：递归传入 i 而不是 i+1，表示当前数字可以重复使用
            backtrack(res, path, candidates, remainingTarget - candidates[i], i);

            // 回溯，移除最后添加的元素
            path.remove(path.size() - 1);
        }
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] candidates1 = {2, 3, 6, 7};
        int target1 = 7;

        System.out.println("示例 1 输入: candidates = " + Arrays.toString(candidates1) + ", target = " + target1);
        List<List<Integer>> result1 = combinationSum(candidates1, target1);
        System.out.println("示例 1 输出: " + result1);
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] candidates2 = {2, 3, 5};
        int target2 = 8;

        System.out.println("示例 2 输入: candidates = " + Arrays.toString(candidates2) + ", target = " + target2);
        List<List<Integer>> result2 = combinationSum(candidates2, target2);
        System.out.println("示例 2 输出: " + result2);
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        int[] candidates3 = {2};
        int target3 = 1;

        System.out.println("示例 3 输入: candidates = " + Arrays.toString(candidates3) + ", target = " + target3);
        List<List<Integer>> result3 = combinationSum(candidates3, target3);
        System.out.println("示例 3 输出: " + result3);
    }
}
```
