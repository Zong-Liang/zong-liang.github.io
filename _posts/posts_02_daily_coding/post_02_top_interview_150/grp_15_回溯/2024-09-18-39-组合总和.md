---
title: 39. 组合总和
date: 2024-09-18 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 回溯]
tags: [回溯]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233343189.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


## 题目：39. 组合总和

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target`，找出 `candidates` 中可以使数字和为目标数 `target` 的所有 **不同组合**，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取**。如果至少一个数字的被选数量不同，则两种组合是不同的。

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。



**示例 1:**

- **输入:** `candidates = [2,3,6,7]`, `target = 7`
- **输出:** `[[2,2,3],[7]]`
- **解释:**
  2 和 3 可以形成一组候选，2 + 2 + 3 = 7。注意 2 可以使用多次。
  7 也是一个候选， 7 = 7。
  仅有这两种组合。

**示例 2:**

- **输入:** `candidates = [2,3,5]`, `target = 8`
- **输出:** `[[2,2,2,2],[2,3,3],[3,5]]`

**示例 3:**

- **输入:** `candidates = [2]`, `target = 1`
- **输出:** `[]`



**提示:**

- `1 <= candidates.length <= 30`
- `2 <= candidates[i] <= 40`
- `candidates` 的所有元素 **互不相同**
- `1 <= target <= 40`



## Java 代码

**算法思路：(回溯法 + 剪枝)**

这是一个寻找所有组合的问题，非常适合使用 **回溯法**。

1.  **排序和剪枝：** 首先对 `candidates` 数组进行排序。这有助于后续的“剪枝”操作，即当我们发现当前的部分和已经大于 `target` 时，由于数组是升序的，后续的数字只会更大，所以没有必要再继续尝试，可以直接终止当前分支的搜索。
2.  **回溯函数:** 我们定义一个递归函数 `backtrack(remain, start, currentCombo)`，它表示我们需要从 `candidates` 数组的 `start` 索引开始，寻找和为 `remain` (剩余目标值) 的组合。
    - **递归终止条件:**
      - 如果 `remain` 变为 0，说明我们找到了一个有效的组合，将其加入最终的结果列表。
      - 如果 `remain` 变为负数，说明当前路径无效，直接返回。
    - **遍历选择:** 从 `start` 索引开始遍历 `candidates` 数组。
      - **做出选择:** 将当前数字 `candidates[i]` 加入到 `currentCombo` 中。
      - **进入下一层递归:** 由于同一个数字可以重复使用，我们仍然从 `i` 开始（而不是 `i+1`）调用递归函数，但目标值变为 `remain - candidates[i]`。
      - **撤销选择 (回溯):** 在递归调用返回后，将刚刚加入的数字从 `currentCombo` 中移除，以便尝试其他可能性。

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;


public class Main {

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        // 排序是剪枝的前提
        Arrays.sort(candidates);
        backtrack(result, new ArrayList<>(), candidates, target, 0);
        return result;
    }

    /**
     * 回溯法的辅助函数
     *
     * @param result       存储最终结果的列表
     * @param currentCombo 当前正在构建的组合
     * @param candidates   候选数字数组
     * @param remain       剩余需要达到的目标和
     * @param start        当前选择的起始索引
     */
    private void backtrack(List<List<Integer>> result, List<Integer> currentCombo, int[] candidates, int remain, int start) {
        // 递归终止条件1：找到了一个有效组合
        if (remain == 0) {
            result.add(new ArrayList<>(currentCombo));
            return;
        }
        // 递归终止条件2：当前路径无效
        if (remain < 0) {
            return;
        }

        // 遍历所有可能的选择
        for (int i = start; i < candidates.length; i++) {
            // 剪枝：如果当前数字已经大于剩余目标，后续数字也必然大于
            if (candidates[i] > remain) {
                break;
            }

            // --- 做出选择 ---
            currentCombo.add(candidates[i]);
            // --- 进入下一层决策 ---
            // 因为数字可以重复使用，所以下一次递归的起始索引仍然是 i
            backtrack(result, currentCombo, candidates, remain - candidates[i], i);
            // --- 撤销选择（回溯） ---
            currentCombo.remove(currentCombo.size() - 1);
        }
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        int[] candidates1 = {2, 3, 6, 7};
        int target1 = 7;
        System.out.println("输入: candidates = " + Arrays.toString(candidates1) + ", target = " + target1);
        List<List<Integer>> result1 = solution.combinationSum(candidates1, target1);
        System.out.println("输出: " + result1); // 预期输出: [[2,2,3], [7]]
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[] candidates2 = {2, 3, 5};
        int target2 = 8;
        System.out.println("输入: candidates = " + Arrays.toString(candidates2) + ", target = " + target2);
        List<List<Integer>> result2 = solution.combinationSum(candidates2, target2);
        System.out.println("输出: " + result2); // 预期输出: [[2,2,2,2], [2,3,3], [3,5]]
        System.out.println();

        System.out.println("--- 示例 3 ---");
        int[] candidates3 = {2};
        int target3 = 1;
        System.out.println("输入: candidates = " + Arrays.toString(candidates3) + ", target = " + target3);
        List<List<Integer>> result3 = solution.combinationSum(candidates3, target3);
        System.out.println("输出: " + result3); // 预期输出: []
    }
}
```
