---
title: 52. N皇后II
date: 2024-09-20 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 回溯]
tags: [回溯]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233410589.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n x n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n`，返回 **n 皇后问题** 不同的解决方案的数量。

(注：皇后可以攻击同一行、同一列、以及两条对角线上的任何棋子。)

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

- **输入:** `n = 4`
- **输出:** 2
- **解释:** 如上图所示，4 皇后问题存在两个不同的解法。

**示例 2:**

- **输入:** `n = 1`
- **输出:** 1

**提示:**

- `1 <= n <= 9`

## 题解

### 解法一：基于集合/数组的回溯法 (Standard Backtracking)

**思路：**

N 皇后问题的核心在于如何在每一行放置一个皇后，使得它不与之前放置的皇后发生冲突。我们可以逐行放置皇后（`row` 从 0 到 `n-1`），对于每一行，尝试在每一列（`col` 从 0 到 `n-1`）放置。

为了快速判断当前位置 `(row, col)` 是否合法，我们需要记录哪些列、主对角线、副对角线已经被占用：

1.  **列 (`cols`)**：直接记录某列 `col` 是否有皇后。
2.  **主对角线 (`diag1`)**：对于同一条主对角线（从左上到右下），其 `row - col` 的值是恒定的。
3.  **副对角线 (`diag2`)**：对于同一条副对角线（从右上到左下），其 `row + col` 的值是恒定的。

**数据结构：**

我们可以使用三个布尔数组来标记占用情况。

- `cols[n]`
- `diag1[2*n]`：对应 `row - col`。由于 `row - col` 可能为负数，我们需要加上偏移量 `n`，即下标为 `row - col + n`。
- `diag2[2*n]`：对应 `row + col`。

每当我们成功在第 `n` 行放置了皇后（即 `row == n`），说明找到了一组解，计数器 `+1`。

**复杂度分析：**

- **时间复杂度：** $O(N!)$，第一行有 $N$ 种选法，第二行最多 $N-1$ 种... 实际上由于剪枝，运行速度远快于 $N!$，但在最坏情况下仍属于阶乘级别。
- **空间复杂度：** $O(N)$，我们需要三个数组来记录状态，以及递归调用栈的深度最多为 $N$。

**代码片段：**

```java
public int totalNQueens(int n) {
    boolean[] cols = new boolean[n];
    boolean[] diag1 = new boolean[2 * n]; // row - col
    boolean[] diag2 = new boolean[2 * n]; // row + col
    return backtrack(0, n, cols, diag1, diag2);
}

private int backtrack(int row, int n, boolean[] cols, boolean[] diag1, boolean[] diag2) {
    if (row == n) {
        return 1;
    }

    int count = 0;
    for (int col = 0; col < n; col++) {
        int d1 = row - col + n;
        int d2 = row + col;

        // 剪枝：如果当前列或对角线已被占用，跳过
        if (cols[col] || diag1[d1] || diag2[d2]) {
            continue;
        }

        // 做选择
        cols[col] = true;
        diag1[d1] = true;
        diag2[d2] = true;

        // 递归下一行
        count += backtrack(row + 1, n, cols, diag1, diag2);

        // 撤销选择（回溯）
        cols[col] = false;
        diag1[d1] = false;
        diag2[d2] = false;
    }
    return count;
}
```

### 解法二：位运算优化 (Bit Manipulation)

**思路：**

这是 N 皇后问题的高阶解法。当 $N$ 较小时（$N \le 32$），我们可以利用整数的二进制位来表示棋盘的占用情况，从而极大地减少常数级的时间开销和空间开销。

- `col`：表示列的占用情况（第 `i` 位为 1 表示第 `i` 列被占用）。
- `ld` (Left Diagonal)：表示主对角线的占用。下一行时，受左对角线影响的位置会左移一位 (`<< 1`)。
- `rd` (Right Diagonal)：表示副对角线的占用。下一行时，受右对角线影响的位置会右移一位 (`>> 1`)。

**核心逻辑：**

1.  计算当前行所有**可放置**皇后的位置：`~(col | ld | rd) & ((1 << n) - 1)`。
2.  通过 `x & -x` 取出最低位的 1（即当前选择的放置位置）。
3.  递归到下一层，更新状态。

**复杂度分析：**

- **时间复杂度：** $O(N!)$，虽然量级不变，但位运算比数组访问快得多。
- **空间复杂度：** $O(N)$，主要用于递归栈。

**代码片段：**

```java
public int totalNQueensBitmap(int n) {
    return solve(n, 0, 0, 0, 0);
}

private int solve(int n, int row, int col, int ld, int rd) {
    if (row == n) {
        return 1;
    }

    int count = 0;
    // 获取所有可用的位置（1 表示可用）
    // ~(col | ld | rd) 将被占用的位变为 0，未被占用的变为 1
    // & ((1 << n) - 1) 是为了截断超过 n 位的高位垃圾数据
    int availableBits = ~(col | ld | rd) & ((1 << n) - 1);

    while (availableBits != 0) {
        // 取出最低位的 1，作为当前选择的位置
        int position = availableBits & -availableBits;

        // 将该位置从可用列表中移除
        availableBits = availableBits & (availableBits - 1);

        // 递归
        // col | position: 更新列占用
        // (ld | position) << 1: 左对角线限制在下一行会左移
        // (rd | position) >> 1: 右对角线限制在下一行会右移
        count += solve(n, row + 1, col | position, (ld | position) << 1, (rd | position) >> 1);
    }
    return count;
}
```

### 完整代码

```java
public class Main {

    // 这里展示解法一（数组回溯），更通用易读
    // 如果追求极致性能，可替换为解法二（位运算）
    public static int totalNQueens(int n) {
        boolean[] cols = new boolean[n];
        // row - col 的范围是 [-(n-1), n-1]，加上偏移量 n 后范围是 [1, 2n-1]
        boolean[] diag1 = new boolean[2 * n];
        // row + col 的范围是 [0, 2n-2]
        boolean[] diag2 = new boolean[2 * n];

        return backtrack(0, n, cols, diag1, diag2);
    }

    private static int backtrack(int row, int n, boolean[] cols, boolean[] diag1, boolean[] diag2) {
        // 终止条件：成功到达第 n 行（0 到 n-1 行都放好了）
        if (row == n) {
            return 1;
        }

        int count = 0;
        for (int col = 0; col < n; col++) {
            int d1 = row - col + n;
            int d2 = row + col;

            // 剪枝：检查冲突
            if (cols[col] || diag1[d1] || diag2[d2]) {
                continue;
            }

            // 做出选择
            cols[col] = true;
            diag1[d1] = true;
            diag2[d2] = true;

            // 递归进入下一行
            count += backtrack(row + 1, n, cols, diag1, diag2);

            // 撤销选择（回溯）
            cols[col] = false;
            diag1[d1] = false;
            diag2[d2] = false;
        }
        return count;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int n1 = 4;
        System.out.println("示例 1 输入: n = " + n1);
        int result1 = totalNQueens(n1);
        System.out.println("示例 1 输出: " + result1);
        // 解释: 2 种解法
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int n2 = 1;
        System.out.println("示例 2 输入: n = " + n2);
        int result2 = totalNQueens(n2);
        System.out.println("示例 2 输出: " + result2);
        System.out.println("-----------------------------");

        // --- 额外测试 ---
        int n3 = 8;
        System.out.println("额外测试 输入: n = " + n3);
        int result3 = totalNQueens(n3);
        System.out.println("额外测试 输出: " + result3); // 应该输出 92
    }
}
```
