---
title: 52. N皇后II
date: 2024-09-20 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 回溯]
tags: [回溯]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233410589.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：52. N 皇后 II

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n x n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n`，返回 **n 皇后问题** 不同的解决方案的数量。

(注：皇后可以攻击同一行、同一列、以及两条对角线上的任何棋子。)

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/11/13/n-queens.jpg)

- **输入:** `n = 4`
- **输出:** 2
- **解释:** 如上图所示，4 皇后问题存在两个不同的解法。

**示例 2:**

- **输入:** `n = 1`
- **输出:** 1

**提示:**

- `1 <= n <= 9`

## 题解

**算法思路：(回溯法)**

这是另一个经典的回溯法问题。我们的策略是逐行放置皇后。

1.  **状态记录:** 我们需要一种方法来快速判断某个位置是否可以放置皇后。我们可以使用三个布尔数组（或集合）来记录哪些列、哪些对角线已经被占用了。
    - `columns`: 记录哪一 **列** 已被占用。
    - `diag1`: 记录哪条 **主对角线** (`行号 - 列号` 的值相同) 已被占用。
    - `diag2`: 记录哪条 **副对角线** (`行号 + 列号` 的值相同) 已被占用。
2.  **回溯函数:** 我们定义一个递归函数 `backtrack(row, n)`，表示尝试在第 `row` 行放置一个皇后。
    - **遍历列:** 在函数内部，我们遍历当前行的每一列 `col`。
    - **检查合法性:** 对于每个位置 `(row, col)`，我们检查它所在的列和两条对角线是否已经被占用。
    - **做出选择:** 如果该位置合法：
      
      a. 将该位置标记为已占用（更新三个状态数组）。
      
      b. 如果已经到达最后一行 (`row == n - 1`)，说明找到了一个完整的解决方案，我们将计数器加一。
      
      c. 否则，递归调用 `backtrack(row + 1, n)`，去处理下一行。
      
      d. **撤销选择 (回溯):** 在递归返回后，将该位置的标记清除，以便为后续的搜索尝试其他可能性。

最终，计数器的值就是解决方案的总数。

```java
import java.util.HashSet;
import java.util.Set;


public class Main {

    // 使用一个数组来存储结果，因为在 Lambda 表达式或内部类中修改的变量需要是 final 或 effectively final
    private int[] count;

    public int totalNQueens(int n) {
        count = new int[]{0};

        // 使用 Set 来记录已占用的列和对角线
        Set<Integer> columns = new HashSet<>();
        Set<Integer> diag1 = new HashSet<>(); // 主对角线: row - col
        Set<Integer> diag2 = new HashSet<>(); // 副对角线: row + col

        backtrack(0, n, columns, diag1, diag2);

        return count[0];
    }

    private void backtrack(int row, int n, Set<Integer> columns, Set<Integer> diag1, Set<Integer> diag2) {
        // 递归终止条件：成功放置了 n 行
        if (row == n) {
            count[0]++;
            return;
        }

        // 遍历当前行的每一列
        for (int col = 0; col < n; col++) {
            // 检查当前位置是否合法
            if (columns.contains(col) || diag1.contains(row - col) || diag2.contains(row + col)) {
                continue;
            }

            // 做出选择
            columns.add(col);
            diag1.add(row - col);
            diag2.add(row + col);

            // 进入下一行决策
            backtrack(row + 1, n, columns, diag1, diag2);

            // 撤销选择（回溯）
            columns.remove(col);
            diag1.remove(row - col);
            diag2.remove(row + col);
        }
    }


    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        int n1 = 4;
        System.out.println("输入: n = " + n1);
        int result1 = solution.totalNQueens(n1);
        System.out.println("输出: " + result1); // 预期输出: 2
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int n2 = 1;
        System.out.println("输入: n = " + n2);
        int result2 = solution.totalNQueens(n2);
        System.out.println("输出: " + result2); // 预期输出: 1
        System.out.println();

        System.out.println("--- 更多测试 ---");
        int n3 = 8;
        System.out.println("输入: n = " + n3);
        int result3 = solution.totalNQueens(n3); // 重新实例化以重置计数器
        System.out.println("输出: " + result3); // 预期输出: 92
    }
}
```
