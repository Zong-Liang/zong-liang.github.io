---
title: 17. 电话号码的字母组合
date: 2024-09-10 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 回溯]
tags: [回溯]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233201704.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![电话按键映射](https://pic.leetcode.cn/1752723054-mfIHZs-image.png)

**示例 1:**

- **输入:** `digits = "23"`
- **输出:** `["ad","ae","af","bd","be","bf","cd","ce","cf"]`

**示例 2:**

- **输入:** `digits = "2"`
- **输出:** `["a","b","c"]`

**提示:**

- `1 <= digits.length <= 4`
- `digits[i]` 是范围 `['2', '9']` 的一个数字。

## 题解

### 解法：回溯算法 (Backtracking)

**思路：**

这是一个典型的排列组合问题。我们可以将其看作一棵决策树：

1.  根节点是空字符串。
2.  第一层是输入数字字符串中第一个数字对应的所有可能字母。
3.  第二层是第二个数字对应的所有可能字母，依此类推。
4.  当遍历到输入字符串的最后一个数字时，路径上经过的所有字母这就组成了一个合法的组合。

我们使用 **回溯法（深度优先搜索 DFS）** 来遍历这棵树：

- 首先建立数字 `2-9` 到字母的映射表（数组或哈希表）。
- 维护一个变量 `index` 表示当前处理到 `digits` 中的第几个数字。
- 维护一个 `StringBuilder`（或字符串）来保存当前路径生成的字母组合。
- **递归逻辑**：取出当前 `index` 对应的数字，找到它对应的字母集合。遍历集合中的每一个字母，将其拼接到当前组合后面，然后递归调用下一层（`index + 1`）。
- **回溯逻辑**：从下一层递归返回后，需要将刚才拼接的字母删除（“撤销选择”），以便尝试该数字对应的下一个字母。

**复杂度分析：**

- **时间复杂度：** $O(3^m \times 4^n)$。

  - 其中 $m$ 是输入中对应 3 个字母的数字个数（如 2, 3, 4, 5, 6, 8），$n$ 是对应 4 个字母的数字个数（7, 9）。
  - 因为总长度不超过 4，这个指数级复杂度是非常小的。

- **空间复杂度：** $O(m + n)$。

  - 主要消耗在于递归调用栈的空间，深度最大为输入数字的长度。

**代码片段：**

```java
// 数字到字母的映射
private String[] mapping = new String[] {
    "", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"
};
private List<String> res;

public List<String> letterCombinations(String digits) {
    res = new ArrayList<>();
    if (digits == null || digits.length() == 0) {
        return res;
    }
    backtrack(digits, 0, new StringBuilder());
    return res;
}

private void backtrack(String digits, int index, StringBuilder sb) {
    // 终止条件：生成的字符串长度等于输入数字的长度
    if (index == digits.length()) {
        res.add(sb.toString());
        return;
    }

    // 获取当前数字对应的字母字符串
    int digit = digits.charAt(index) - '0';
    String letters = mapping[digit];

    // 遍历每一个可能的字母
    for (int i = 0; i < letters.length(); i++) {
        sb.append(letters.charAt(i));       // 做选择
        backtrack(digits, index + 1, sb);   // 进入下一层
        sb.deleteCharAt(sb.length() - 1);   // 撤销选择（回溯）
    }
}
```

### 解法二：队列迭代法 (BFS)

**思路：**

除了递归，我们也可以使用队列进行广度优先搜索。

1.  初始时，队列中只有一个空字符串 `""`。
2.  遍历输入字符串 `digits` 的每一个数字。
3.  对于当前数字，取出队列中**所有**现有的字符串，分别在它们末尾追加当前数字对应的每一个字母，然后将新生成的字符串再次入队。
4.  重复此过程，直到处理完所有数字，队列中剩下的就是所有可能的组合。

**复杂度分析：**

- **时间复杂度：** $O(3^m \times 4^n)$。与回溯法相同，需要生成所有组合。
- **空间复杂度：** $O(3^m \times 4^n)$。队列需要存储当前层的所有组合，最后时刻队列中存储了所有的结果。

**代码片段：**

```java
public List<String> letterCombinations(String digits) {
    LinkedList<String> queue = new LinkedList<>();
    if (digits == null || digits.length() == 0) return queue;

    String[] mapping = new String[] {"0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    queue.add("");

    for (int i = 0; i < digits.length(); i++) {
        int digit = digits.charAt(i) - '0';
        String letters = mapping[digit];
        // 关键：检查队列头部字符串的长度，只处理上一层的字符串
        while (queue.peek().length() == i) {
            String t = queue.remove();
            for (char s : letters.toCharArray()) {
                queue.add(t + s);
            }
        }
    }
    return queue;
}
```

### 完整代码

这里提供最常用且符合面试标准的 **解法一（回溯法）** 的完整代码。

```java
import java.util.ArrayList;
import java.util.List;

public class Main {

    // 使用数组建立索引 0-9 到字母的映射
    // index 0 和 1 不对应字母，设为空字符串或特定占位符均可
    private static final String[] MAPPING = new String[] {
        "", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"
    };

    public static List<String> letterCombinations(String digits) {
        List<String> result = new ArrayList<>();
        // 边界情况处理
        if (digits == null || digits.length() == 0) {
            return result;
        }

        // 开启回溯
        backtrack(result, digits, 0, new StringBuilder());
        return result;
    }

    /**
     * 回溯函数
     * @param result 结果列表
     * @param digits 原始输入字符串
     * @param index  当前处理到 digits 的第几位
     * @param sb     当前路径已生成的字符串
     */
    private static void backtrack(List<String> result, String digits, int index, StringBuilder sb) {
        // Base Case: 当构建的字符串长度等于输入数字串长度时，说明到达叶子节点
        if (index == digits.length()) {
            result.add(sb.toString());
            return;
        }

        // 获取当前需要处理的数字
        char digitChar = digits.charAt(index);
        int digit = digitChar - '0';
        String letters = MAPPING[digit];

        // 遍历该数字对应的所有字母
        for (int i = 0; i < letters.length(); i++) {
            // 1. 做选择
            sb.append(letters.charAt(i));

            // 2. 递归进入下一层
            backtrack(result, digits, index + 1, sb);

            // 3. 撤销选择（回溯）
            sb.deleteCharAt(sb.length() - 1);
        }
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        String digits1 = "23";
        System.out.println("示例 1 输入: digits = \"23\"");
        List<String> res1 = letterCombinations(digits1);
        System.out.println("示例 1 输出: " + res1);
        // 预期: [ad, ae, af, bd, be, bf, cd, ce, cf]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        String digits2 = "2";
        System.out.println("示例 2 输入: digits = \"2\"");
        List<String> res2 = letterCombinations(digits2);
        System.out.println("示例 2 输出: " + res2);
        // 预期: [a, b, c]
        System.out.println("-----------------------------");

        // --- 示例 3 测试 (空串) ---
        String digits3 = "";
        System.out.println("示例 3 输入: digits = \"\"");
        List<String> res3 = letterCombinations(digits3);
        System.out.println("示例 3 输出: " + res3);
        // 预期: []
    }
}
```
