---
title: 17. 电话号码的字母组合
date: 2024-09-10 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 回溯]
tags: [回溯]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233201704.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


## 题目：17. 电话号码的字母组合

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![电话按键映射](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2.svg.png)



**示例 1:**

- **输入:** `digits = "23"`
- **输出:** `["ad","ae","af","bd","be","bf","cd","ce","cf"]`

**示例 2:**

- **输入:** `digits = "2"`
- **输出:** `["a","b","c"]`



**提示:**

- `1 <= digits.length <= 4`
- `digits[i]` 是范围 `['2', '9']` 的一个数字。



## Java 代码

**算法思路：(回溯法)**

这个问题要求找出所有可能的组合，是 **回溯法** 的经典应用。我们可以把这个问题想象成一个树状的决策过程：输入的 `digits` 字符串的每个数字代表树的一层，该数字对应的字母们就是这一层的不同选择。

1.  **映射表:** 首先，我们需要一个数据结构（如 `Map` 或数组）来存储数字到字母字符串的映射关系。
2.  **回溯函数:** 定义一个递归函数 `backtrack(index, currentCombination)`。
    - `index`: 表示我们当前正在处理 `digits` 字符串的第 `index` 个数字。
    - `currentCombination`: 表示到目前为止已经构建出的字母组合。
3.  **递归终止条件:** 当 `index` 等于 `digits` 的长度时，说明我们已经为每个数字都选择了一个字母，形成了一个完整的组合。将 `currentCombination` 加入最终的结果列表，并结束当前递归分支。
4.  **遍历与选择:**
    - 获取当前数字 `digits.charAt(index)` 对应的字母字符串（例如，'2' 对应 "abc"）。
    - 遍历这个字母字符串中的每一个字母 `c`。
      a. **做出选择:** 将字母 `c` 追加到 `currentCombination` 的末尾。
      b. **进入下一层:** 调用 `backtrack(index + 1, currentCombination)`，去处理下一个数字。
      c. **撤销选择 (回溯):** 在递归调用返回后，将刚刚追加的字母 `c` 从 `currentCombination` 中移除，以便尝试当前数字的其他字母选择。

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;


public class Main {

    // 存储数字到字母的映射
    private Map<Character, String> phoneMap;

    public List<String> letterCombinations(String digits) {
        List<String> combinations = new ArrayList<>();
        if (digits == null || digits.length() == 0) {
            return combinations;
        }

        phoneMap = new HashMap<Character, String>() {{
            put('2', "abc");
            put('3', "def");
            put('4', "ghi");
            put('5', "jkl");
            put('6', "mno");
            put('7', "pqrs");
            put('8', "tuv");
            put('9', "wxyz");
        }};

        backtrack(combinations, digits, 0, new StringBuilder());
        return combinations;
    }

    /**
     * 回溯法的辅助函数
     * @param combinations 存储最终结果的列表
     * @param digits       输入的数字字符串
     * @param index        当前处理的数字索引
     * @param current      当前正在构建的组合
     */
    private void backtrack(List<String> combinations, String digits, int index, StringBuilder current) {
        // 递归终止条件：当索引等于数字字符串长度时，一个完整的组合就生成了
        if (index == digits.length()) {
            combinations.add(current.toString());
            return;
        }

        // 获取当前数字对应的字母
        char digit = digits.charAt(index);
        String letters = phoneMap.get(digit);

        // 遍历当前数字可以代表的所有字母
        for (int i = 0; i < letters.length(); i++) {
            // --- 做出选择 ---
            current.append(letters.charAt(i));
            // --- 进入下一层决策 ---
            backtrack(combinations, digits, index + 1, current);
            // --- 撤销选择（回溯） ---
            current.deleteCharAt(current.length() - 1);
        }
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        String digits1 = "23";
        System.out.println("输入: digits = \"" + digits1 + "\"");
        List<String> result1 = solution.letterCombinations(digits1);
        System.out.println("输出: " + result1);
        System.out.println();

        System.out.println("--- 示例 2 ---");
        String digits2 = "2";
        System.out.println("输入: digits = \"" + digits2 + "\"");
        List<String> result2 = solution.letterCombinations(digits2);
        System.out.println("输出: " + result2);
    }
}
```
