---
title: 77. 组合
date: 2024-09-12 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 回溯]
tags: [回溯]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233229123.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

**示例 1:**

- **输入:** `n = 4`, `k = 2`
- **输出:**

  ```
  [
    [2,4],
    [3,4],
    [2,3],
    [1,2],
    [1,3],
    [1,4],
  ]
  ```

**示例 2:**

- **输入:** `n = 1`, `k = 1`
- **输出:** `[[1]]`

**提示:**

- `1 <= n <= 20`
- `1 <= k <= n`

## 题解

### 解法：回溯算法 (Backtracking)

**思路：**

这是一个典型的组合问题，要求找出所有符合条件的子集。我们可以把它看作一棵决策树的遍历过程：

1.  **路径**：记录当前已经选择的数字。
2.  **选择列表**：当前可以被选择的数字。为了防止重复（例如 `[1,2]` 和 `[2,1]` 视为同一个组合），我们约定每次选择的数字必须大于上一次选择的数字。因此，每一层的搜索起点 `startIndex` 都要加 1。
3.  **终止条件**：当路径长度等于 `k` 时，说明找到了一个合法的组合，将其加入结果集。

**剪枝优化：**

在遍历过程中，如果**当前已选元素个数**加上**剩余区间内所有元素个数**仍然小于 `k`，说明即使把后面所有数都选上，也不凑齐 `k` 个数。此时可以直接停止搜索（剪枝）。
具体来说，搜索起点的上界可以从 `n` 缩小到 `n - (k - path.size()) + 1`。

**复杂度分析：**

- **时间复杂度：** $O(\binom{n}{k} \times k)$。组合数 $\binom{n}{k}$ 是结果的数量，每次找到结果需要 $O(k)$ 的时间将其复制到结果集中。
- **空间复杂度：** $O(n)$。主要是递归调用栈的深度（最大为 $n$）以及存储当前路径的临时列表空间（最大为 $k$）。

**代码片段：**

```java
List<List<Integer>> res = new ArrayList<>();
LinkedList<Integer> path = new LinkedList<>();

public List<List<Integer>> combine(int n, int k) {
    backtrack(n, k, 1);
    return res;
}

private void backtrack(int n, int k, int startIndex) {
    // 终止条件：路径长度达到 k
    if (path.size() == k) {
        res.add(new ArrayList<>(path));
        return;
    }

    // 遍历可能的搜索起点
    // 剪枝优化：i <= n - (k - path.size()) + 1
    // 举例：n=4, k=3, 目前 path.size()=0, 还需要 3 个。
    // i 的上限是 4 - (3 - 0) + 1 = 2。如果 i 从 3 开始，后面只有 4，总共 2 个，不够 k 个。
    for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) {
        path.add(i);                // 处理节点
        backtrack(n, k, i + 1);     // 递归：下一层搜索起点 +1
        path.removeLast();          // 回溯：撤销处理
    }
}
```

### 完整代码

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class Main {

    // 全局变量用于存储最终结果
    static List<List<Integer>> result = new ArrayList<>();
    // 全局变量用于存储当前路径
    static LinkedList<Integer> path = new LinkedList<>();

    public static List<List<Integer>> combine(int n, int k) {
        // 每次调用前清空，防止静态变量污染（在 LeetCode 提交时通常不需要 clear，但在本地多次调用需要）
        result.clear();
        path.clear();

        // 从数字 1 开始搜索
        backtracking(n, k, 1);
        return result;
    }

    /**
     * 回溯函数
     * @param n 题目给定的范围 [1, n]
     * @param k 题目要求的组合大小
     * @param startIndex 本层递归开始搜索的数字位置
     */
    private static void backtracking(int n, int k, int startIndex) {
        // 终止条件：找到 k 个数
        if (path.size() == k) {
            // 注意：需要 new ArrayList 来拷贝当前路径的内容，否则存入的是引用
            result.add(new ArrayList<>(path));
            return;
        }

        // 剪枝优化逻辑：
        // 还需要需要的元素个数: k - path.size()
        // 列表中剩余元素 (n - i + 1) >= 还需要元素个数
        // 即: i <= n - (k - path.size()) + 1
        int limit = n - (k - path.size()) + 1;

        for (int i = startIndex; i <= limit; i++) {
            // 1. 处理节点
            path.add(i);

            // 2. 递归：传入 i + 1，避免重复选取
            backtracking(n, k, i + 1);

            // 3. 回溯：撤销处理
            path.removeLast();
        }
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int n1 = 4;
        int k1 = 2;
        System.out.println("示例 1 输入: n = " + n1 + ", k = " + k1);
        List<List<Integer>> res1 = combine(n1, k1);
        System.out.println("示例 1 输出: " + res1);
        // 预期: [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]] (顺序可能不同)
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        int n2 = 1;
        int k2 = 1;
        System.out.println("示例 2 输入: n = " + n2 + ", k = " + k2);
        List<List<Integer>> res2 = combine(n2, k2);
        System.out.println("示例 2 输出: " + res2);
        // 预期: [[1]]
        System.out.println("-----------------------------");

        // --- 示例 3 (剪枝效果测试) ---
        // n=5, k=4. 如果没有剪枝，循环会尝试从 3, 4, 5 开始，但实际上从 3 开始就不够 4 个了
        int n3 = 5;
        int k3 = 4;
        System.out.println("示例 3 输入: n = " + n3 + ", k = " + k3);
        List<List<Integer>> res3 = combine(n3, k3);
        System.out.println("示例 3 输出: " + res3);
    }
}
```
