---
title: 77-组合
date: 2024-09-12 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 回溯]
tags: [回溯]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233229123.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


### 题目：77. 组合

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

---

**示例 1:**

- **输入:** `n = 4`, `k = 2`
- **输出:**
  ```
  [
    [2,4],
    [3,4],
    [2,3],
    [1,2],
    [1,3],
    [1,4],
  ]
  ```

**示例 2:**

- **输入:** `n = 1`, `k = 1`
- **输出:** `[[1]]`

---

**提示:**

- `1 <= n <= 20`
- `1 <= k <= n`

---

### Java 8 解答 (赛码网格式)

**算法思路：(回溯法)**
这个问题要求找出所有组合，是 **回溯法** 的一个典型应用。我们的目标是构建一个大小为 `k` 的组合，其中的数字从 `1` 到 `n` 中选取。

1.  **递归函数:** 我们定义一个递归函数 `backtrack(start)`，它表示我们需要从数字 `start` 开始，为当前组合选择下一个数字。
2.  **递归终止条件:** 当我们构建的组合 `currentCombo` 的大小达到 `k` 时，说明找到了一个完整的、有效的组合。我们将它的一个副本添加到最终的结果列表中，并结束当前递归分支。
3.  **遍历与选择:** 在递归函数中，我们从 `start` 循环到 `n`。
    - **做出选择:** 将当前数字 `i` 添加到 `currentCombo`。
    - **进入下一层:** 调用 `backtrack(i + 1)`。传递 `i + 1` 是为了确保下一次选择的数字比当前大，这样可以避免产生重复的组合（例如，有了 `[1,2]` 就不会再有 `[2,1]`）。
    - **撤销选择 (回溯):** 在递归调用返回后，将刚刚添加的数字 `i` 从 `currentCombo` 中移除。这是回溯的关键，它允许程序返回上一步，尝试其他的选择。
4.  **剪枝优化:** 我们可以进行一个简单的剪枝。如果剩余需要选择的数字个数 `k - currentCombo.size()` 大于从当前位置到 `n` 的剩余数字总数 `n - i + 1`，那么就不可能再凑成一个大小为 `k` 的组合了，可以直接终止当前循环。

```java
import java.util.ArrayList;
import java.util.List;

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> result = new ArrayList<>();
        backtrack(result, new ArrayList<>(), 1, n, k);
        return result;
    }

    /**
     * 回溯法的辅助函数
     *
     * @param result       存储最终结果的列表
     * @param currentCombo 当前正在构建的组合
     * @param start        当前选择的起始数字
     * @param n            数字范围的上界
     * @param k            组合的大小
     */
    private void backtrack(List<List<Integer>> result, List<Integer> currentCombo, int start, int n, int k) {
        // 递归终止条件：当组合的长度等于 k 时，找到了一个解
        if (currentCombo.size() == k) {
            result.add(new ArrayList<>(currentCombo));
            return;
        }

        // 遍历所有可能的选择
        // 剪枝：如果剩余可选的数字数量已经不足以填满组合，则停止
        // (n - i + 1) 是 [i, n] 范围内的数字个数
        // (k - currentCombo.size()) 是还需要选择的数字个数
        for (int i = start; i <= n - (k - currentCombo.size()) + 1; i++) {
            // --- 做出选择 ---
            currentCombo.add(i);
            // --- 进入下一层决策 ---
            // 下一个数字从 i + 1 开始选，以避免重复
            backtrack(result, currentCombo, i + 1, n, k);
            // --- 撤销选择（回溯） ---
            currentCombo.remove(currentCombo.size() - 1);
        }
    }


    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        int n1 = 4, k1 = 2;
        System.out.println("输入: n = " + n1 + ", k = " + k1);
        List<List<Integer>> result1 = solution.combine(n1, k1);
        System.out.println("输出: " + result1);
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int n2 = 1, k2 = 1;
        System.out.println("输入: n = " + n2 + ", k = " + k2);
        List<List<Integer>> result2 = solution.combine(n2, k2);
        System.out.println("输出: " + result2);
    }
}
```
