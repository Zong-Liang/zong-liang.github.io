---
title: 22. 括号生成
date: 2024-09-21 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 回溯]
tags: [回溯]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233437511.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效** 的括号组合。

**示例 1:**

- **输入:** `n = 3`
- **输出:** `["((()))","(()())","(())()","()(())","()()()"]`

**示例 2:**

- **输入:** `n = 1`
- **输出:** `["()"]`

**提示:**

- `1 <= n <= 8`

## 题解

### 解法：深度优先搜索 / 回溯法 (DFS / Backtracking)

**思路：**

这道题的核心在于如何构造一个“有效”的括号组合。我们可以将其想象为一个填空游戏，一共有 `2 * n` 个位置，每个位置可以填 `(` 或 `)`。

为了保证生成的括号是有效的，我们在递归构造字符串的过程中需要遵守以下规则（剪枝）：

1.  **左括号数量限制**：只要当前左括号的数量 `open` 小于 `n`，我们就可以尝试放一个左括号 `(`。
2.  **右括号数量限制**：只有在当前右括号的数量 `close` 小于左括号的数量 `open` 时，我们才可以尝试放一个右括号 `)`。这是因为有效的括号组合中，任何位置左侧的左括号数量必然大于等于右括号数量。
3.  **终止条件**：当构建的字符串长度达到 `2 * n` 时，说明找到了一个合法的组合，将其加入结果列表。

**复杂度分析：**

- **时间复杂度：** $O(\frac{4^n}{\sqrt{n}})$，该问题的解的个数是第 $n$ 个**卡特兰数**（Catalan Number），其渐进增长界为 $\frac{4^n}{n\sqrt{n}}$。虽然听起来很复杂，但对于题目给定的 $n \le 8$，计算量非常小。
- **空间复杂度：** $O(n)$，主要消耗在递归调用栈的空间，最大深度为 `2 * n`，即 $O(n)$。

**代码片段：**

```java
public List<String> generateParenthesis(int n) {
    List<String> res = new ArrayList<>();
    // 初始状态：当前字符串为空，左括号用 0 个，右括号用 0 个
    backtrack(res, "", 0, 0, n);
    return res;
}

private void backtrack(List<String> res, String cur, int open, int close, int n) {
    // 终止条件：生成的字符串长度达到 2n
    if (cur.length() == n * 2) {
        res.add(cur);
        return;
    }

    // 如果左括号还能放，就放一个左括号，进入下一层
    if (open < n) {
        backtrack(res, cur + "(", open + 1, close, n);
    }

    // 如果右括号比左括号少，说明可以放右括号来闭合
    if (close < open) {
        backtrack(res, cur + ")", open, close + 1, n);
    }
}
```

### 完整代码

```java
import java.util.ArrayList;
import java.util.List;

public class Main {

    /**
     * 生成所有有效的括号组合
     * @param n 括号对数
     * @return 结果列表
     */
    public static List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        if (n <= 0) {
            return res;
        }
        backtrack(res, "", 0, 0, n);
        return res;
    }

    /**
     * 回溯核心逻辑
     * @param res   结果集合
     * @param cur   当前构建的字符串
     * @param open  已使用的左括号数量
     * @param close 已使用的右括号数量
     * @param max   n 的值（每种括号的最大数量）
     */
    private static void backtrack(List<String> res, String cur, int open, int close, int max) {
        // base case: 长度达标，收集结果
        if (cur.length() == max * 2) {
            res.add(cur);
            return;
        }

        // 剪枝与选择：
        // 1. 只要左括号没用完，就可以选 '('
        if (open < max) {
            backtrack(res, cur + "(", open + 1, close, max);
        }

        // 2. 只有当前右括号数量小于左括号数量时，才能选 ')'
        //    这保证了括号的闭合是有效的
        if (close < open) {
            backtrack(res, cur + ")", open, close + 1, max);
        }
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int n1 = 3;
        System.out.println("示例 1 输入: n = " + n1);
        List<String> result1 = generateParenthesis(n1);
        System.out.println("示例 1 输出: " + result1);
        // 预期输出: ["((()))","(()())","(())()","()(())","()()()"]
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int n2 = 1;
        System.out.println("示例 2 输入: n = " + n2);
        List<String> result2 = generateParenthesis(n2);
        System.out.println("示例 2 输出: " + result2);
        // 预期输出: ["()"]
    }
}
```
