---
title: 22. 括号生成
date: 2024-09-21 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 回溯]
tags: [回溯]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233437511.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


## 题目：22. 括号生成

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效** 的括号组合。



**示例 1:**

- **输入:** `n = 3`
- **输出:** `["((()))","(()())","(())()","()(())","()()()"]`

**示例 2:**

- **输入:** `n = 1`
- **输出:** `["()"]`



**提示:**

- `1 <= n <= 8`



## Java 代码

**算法思路：(回溯法 / 深度优先搜索 DFS)**

这个问题是生成所有可能组合的经典案例，非常适合使用 **回溯法**。我们可以通过递归来构建字符串，并在每一步做出选择：是放置一个左括号 `(` 还是一个右括号 `)`。

为了保证生成的括号组合是有效的，我们需要遵守两个关键的约束条件：

1.  **左括号数量约束：** 只要我们还没有用完所有 `n` 个左括号，我们就可以随时放置一个左括号。
2.  **右括号数量约束：** 只有当已经放置的右括号数量严格小于左括号数量时，我们才能放置一个右括号。这确保了在任何时候，字符串的前缀都不会出现右括号比左括号多的情况。

我们的递归函数会跟踪当前构建的字符串、已使用的左括号数和已使用的右括号数。当字符串的长度达到 `2 * n` 时，我们就找到了一个有效的组合，并将其添加到结果列表中。

```java
import java.util.ArrayList;
import java.util.List;


public class Main {

    /**
     * 生成所有可能的并且有效的括号组合。
     *
     * @param n 括号的对数
     * @return 所有有效括号组合的列表
     */
    public static List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<>();
        // 启动回溯过程
        backtrack(result, new StringBuilder(), 0, 0, n);
        return result;
    }

    /**
     * 回溯法的辅助函数
     *
     * @param result  存储最终结果的列表
     * @param current 当前正在构建的字符串
     * @param open    已使用的左括号数量
     * @param close   已使用的右括号数量
     * @param max     括号的总对数 n
     */
    private static void backtrack(List<String> result, StringBuilder current, int open, int close, int max) {
        // 递归终止条件：当字符串长度达到 2*n 时，一个完整的组合就生成了
        if (current.length() == max * 2) {
            result.add(current.toString());
            return;
        }

        // --- 做出选择 ---

        // 选择1：添加一个左括号
        // 约束：只要左括号没用完，就可以添加
        if (open < max) {
            current.append('(');
            backtrack(result, current, open + 1, close, max);
            // 撤销选择（回溯）
            current.deleteCharAt(current.length() - 1);
        }

        // 选择2：添加一个右括号
        // 约束：只有当已使用的右括号数 < 左括号数时，才能添加
        if (close < open) {
            current.append(')');
            backtrack(result, current, open, close + 1, max);
            // 撤销选择（回溯）
            current.deleteCharAt(current.length() - 1);
        }
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int n1 = 3;
        System.out.println("输入: n = " + n1);
        List<String> result1 = generateParenthesis(n1);
        System.out.println("输出: " + result1);
        // 预期输出: ["((()))", "(()())", "(())()", "()(())", "()()()"]
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int n2 = 1;
        System.out.println("输入: n = " + n2);
        List<String> result2 = generateParenthesis(n2);
        System.out.println("输出: " + result2); // 预期输出: ["()"]
    }
}
```
