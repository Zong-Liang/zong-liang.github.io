---
title: 46. 全排列
date: 2024-09-15 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 回溯]
tags: [回溯]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233310268.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个不含重复数字的数组 `nums`，返回其所有可能的全排列。你可以按 **任意顺序** 返回答案。

**示例 1:**

- **输入:** `nums = [1,2,3]`
- **输出:** `[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]`

**示例 2:**

- **输入:** `nums = [0,1]`
- **输出:** `[[0,1],[1,0]]`

**示例 3:**

- **输入:** `nums = [1]`
- **输出:** `[[1]]`

**提示:**

- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有整数 **互不相同**

## 题解

### 解法：回溯算法 (Backtracking)

**思路：**

全排列问题是回溯算法的经典应用场景。我们可以将生成全排列的过程想象成构造一棵决策树：

1.  **路径 (Path)**：记录当前已经选择的数字序列。
2.  **选择列表 (Choices)**：当前还可以被选择的数字。由于题目要求数字互不相同，我们需要一个机制来标记哪些数字已经被选过了。通常可以使用一个布尔数组 `used` 来记录。
3.  **结束条件 (Base Case)**：当路径的长度等于数组 `nums` 的长度时，说明包含所有数字的一个排列已经生成，将其加入结果集。

**算法流程：**

1.  定义一个递归函数 `backtrack`。
2.  遍历 `nums` 中的每一个数字：

    - 如果该数字已经被使用（`used[i] == true`），跳过。
    - **做选择**：将该数字加入当前路径 `path`，并将 `used[i]` 设为 `true`。
    - **递归**：进入下一层决策树。
    - **撤销选择 (回溯)**：将该数字从当前路径 `path` 移除，并将 `used[i]` 设为 `false`，以便在后续的分支中重新选择它。

**复杂度分析：**

- **时间复杂度：** $O(n \times n!)$。

  - 全排列的总数为 $n!$。
  - 对于每个排列，我们需要 $O(n)$ 的时间将其复制到结果列表中。

- **空间复杂度：** $O(n)$。

  - 递归栈的深度为 $n$。
  - `used` 数组和 `path` 列表的空间也是 $O(n)$。
  - （不计算用于存储最终结果的空间）。

**代码片段：**

```java
List<List<Integer>> res = new ArrayList<>();
LinkedList<Integer> track = new LinkedList<>();
boolean[] used;

public List<List<Integer>> permute(int[] nums) {
    used = new boolean[nums.length];
    backtrack(nums);
    return res;
}

void backtrack(int[] nums) {
    // 触发结束条件
    if (track.size() == nums.length) {
        res.add(new ArrayList<>(track));
        return;
    }

    for (int i = 0; i < nums.length; i++) {
        // 排除不合法的选择
        if (used[i]) {
            continue;
        }
        // 做选择
        track.add(nums[i]);
        used[i] = true;

        // 进入下一层决策树
        backtrack(nums);

        // 取消选择
        track.removeLast();
        used[i] = false;
    }
}
```

### 完整代码

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class Main {

    // 全局变量用于存储结果
    static List<List<Integer>> res = new ArrayList<>();
    // 记录当前路径
    static LinkedList<Integer> track = new LinkedList<>();
    // 记录数字是否被使用过
    static boolean[] used;

    public static List<List<Integer>> permute(int[] nums) {
        // 每次调用前清空全局变量，适应本地多次调用
        res.clear();
        track.clear();
        used = new boolean[nums.length];

        backtrack(nums);
        return res;
    }

    private static void backtrack(int[] nums) {
        // 结束条件：路径长度等于数组长度，说明找到了一个全排列
        if (track.size() == nums.length) {
            // 注意：Java 中对象是引用传递，需要 new 一个新列表拷贝当前路径
            res.add(new ArrayList<>(track));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            // 如果当前数字已经被使用过，跳过
            if (used[i]) {
                continue;
            }

            // --- 做选择 ---
            track.add(nums[i]);
            used[i] = true;

            // --- 递归进入下一层 ---
            backtrack(nums);

            // --- 撤销选择 (回溯) ---
            track.removeLast();
            used[i] = false;
        }
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int[] nums1 = {1, 2, 3};
        System.out.println("示例 1 输入: [1, 2, 3]");
        List<List<Integer>> res1 = permute(nums1);
        System.out.println("示例 1 输出: " + res1);
        // 预期输出包含: [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        int[] nums2 = {0, 1};
        System.out.println("示例 2 输入: [0, 1]");
        List<List<Integer>> res2 = permute(nums2);
        System.out.println("示例 2 输出: " + res2);
        // 预期输出: [[0, 1], [1, 0]]
        System.out.println("-----------------------------");

        // --- 示例 3 测试 ---
        int[] nums3 = {1};
        System.out.println("示例 3 输入: [1]");
        List<List<Integer>> res3 = permute(nums3);
        System.out.println("示例 3 输出: " + res3);
        // 预期输出: [[1]]
    }
}
```
