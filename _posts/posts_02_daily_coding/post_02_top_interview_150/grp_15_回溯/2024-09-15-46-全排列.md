---
title: 46. 全排列
date: 2024-09-15 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 回溯]
tags: [回溯]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233310268.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：46. 全排列

给定一个不含重复数字的数组 `nums`，返回其所有可能的全排列。你可以按 **任意顺序** 返回答案。

**示例 1:**

- **输入:** `nums = [1,2,3]`
- **输出:** `[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]`

**示例 2:**

- **输入:** `nums = [0,1]`
- **输出:** `[[0,1],[1,0]]`

**示例 3:**

- **输入:** `nums = [1]`
- **输出:** `[[1]]`

**提示:**

- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有整数 **互不相同**

## Java 代码

**算法思路：(回溯法)**

求解全排列是回溯法的经典应用场景。我们的目标是构建一个长度为 `n` 的序列，其中每个位置从 `nums` 中选择一个尚**未使用过**的数字。

1.  **状态记录:** 我们需要一个方法来跟踪哪些数字已经被用于当前的排列中。可以使用一个布尔数组 `used` 来标记。
2.  **回溯函数:** 定义一个递归函数 `backtrack(currentPermutation)`，它表示正在构建一个排列 `currentPermutation`。
    - **递归终止条件:** 如果 `currentPermutation` 的长度等于 `nums` 的长度，说明我们已经构建了一个完整的排列，将其加入最终的结果列表。
    - **遍历选择:** 遍历 `nums` 数组中的所有数字。
      - **检查合法性:** 如果当前数字 `nums[i]` 已经被使用过（`used[i]` 为 `true`），则跳过。
      - **做出选择:**
        
        a. 将 `nums[i]` 添加到 `currentPermutation` 的末尾。
        
        b. 将 `used[i]` 标记为 `true`。
      - **进入下一层递归:** 调用 `backtrack` 继续为排列的下一个位置选择数字。
      - **撤销选择 (回溯):** 在递归返回后，我们需要撤销刚才的选择，以便为其他分支的搜索做准备。
        
        a. 将 `used[i]` 标记为 `false`。
        
        b. 从 `currentPermutation` 的末尾移除 `nums[i]`。

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;


public class Main {

    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        // `used` 数组用于标记 nums 中的元素是否已被使用
        boolean[] used = new boolean[nums.length];
        backtrack(result, new ArrayList<>(), nums, used);
        return result;
    }

    /**
     * 回溯法的辅助函数
     *
     * @param result          存储最终结果的列表
     * @param currentPermutation 当前正在构建的排列
     * @param nums            原始数字数组
     * @param used            标记数组，记录数字是否被使用
     */
    private void backtrack(List<List<Integer>> result, List<Integer> currentPermutation, int[] nums, boolean[] used) {
        // 递归终止条件：当排列的长度等于原数组长度时，找到了一个完整的排列
        if (currentPermutation.size() == nums.length) {
            result.add(new ArrayList<>(currentPermutation));
            return;
        }

        // 遍历所有可能的选择
        for (int i = 0; i < nums.length; i++) {
            // 如果当前数字已经被使用过，则跳过
            if (used[i]) {
                continue;
            }

            // 做出选择
            currentPermutation.add(nums[i]);
            used[i] = true;

            // 进入下一层决策
            backtrack(result, currentPermutation, nums, used);

            // 撤销选择（回溯）
            used[i] = false;
            currentPermutation.remove(currentPermutation.size() - 1);
        }
    }


    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        int[] nums1 = {1, 2, 3};
        System.out.println("输入: nums = " + Arrays.toString(nums1));
        List<List<Integer>> result1 = solution.permute(nums1);
        System.out.println("输出: " + result1);
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[] nums2 = {0, 1};
        System.out.println("输入: nums = " + Arrays.toString(nums2));
        List<List<Integer>> result2 = solution.permute(nums2);
        System.out.println("输出: " + result2);
        System.out.println();

        System.out.println("--- 示例 3 ---");
        int[] nums3 = {1};
        System.out.println("输入: nums = " + Arrays.toString(nums3));
        List<List<Integer>> result3 = solution.permute(nums3);
        System.out.println("输出: " + result3);
    }
}
```
