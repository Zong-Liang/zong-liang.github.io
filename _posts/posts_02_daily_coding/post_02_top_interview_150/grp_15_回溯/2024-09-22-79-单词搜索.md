---
title: 79-单词搜索
date: 2024-09-22 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 回溯]
tags: [回溯]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233505438.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


### 题目：79. 单词搜索

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word`。如果 `word` 存在于网格中，返回 `true`；否则，返回 `false`。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

---

**示例 1:**
![示例1图片](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

- **输入:** `board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']]`, `word = "ABCCED"`
- **输出:** `true`

**示例 2:**
![示例2图片](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)

- **输入:** `board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']]`, `word = "SEE"`
- **输出:** `true`

**示例 3:**
![示例3图片](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)

- **输入:** `board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']]`, `word = "ABCB"`
- **输出:** `false`

---

**提示:**

- `m == board.length`
- `n = board[i].length`
- `1 <= m, n <= 6`
- `1 <= word.length <= 15`
- `board` 和 `word` 仅由大小写英文字母组成

**进阶：** 你可以使用搜索剪枝的技术来优化解决方案，使其在 `board` 更大的情况下可以更快解决问题？

---

### Java 8 解答 (赛码网格式)

**算法思路：(回溯法 / 深度优先搜索 DFS)**
这个问题是典型的矩阵搜索问题，可以使用回溯法来解决。

1.  **遍历起点:** 遍历 `board` 上的每一个单元格，尝试将其作为单词 `word` 的起始点。
2.  **深度优先搜索 (DFS):**
    - 从一个潜在的起始点开始，我们启动一个递归的 DFS 函数。该函数负责检查从当前位置 `(row, col)` 开始，是否能匹配 `word` 中从 `index` 位置开始的剩余部分。
    - **递归终止条件:**
      - 如果 `index` 等于 `word` 的长度，说明所有字符都已成功匹配，返回 `true`。
      - 如果当前位置 `(row, col)` 超出边界，或者当前格子的字符与 `word.charAt(index)` 不匹配，或者当前格子已经被访问过，则此路不通，返回 `false`。
    - **回溯过程:**
      a. 将当前格子标记为“已访问”，以防在同一次搜索中重复使用。一个常用的技巧是修改该位置的字符（例如，与一个特殊字符进行异或）。
      b. 从当前格子的四个方向（上、下、左、右）进行递归调用，搜索 `word` 的下一个字符 (`index + 1`)。
      c. 只要有任何一个方向的搜索成功，就立即返回 `true`。
      d. 如果四个方向都失败了，说明从当前点出发的路径行不通。**恢复** 当前格子的状态（取消“已访问”标记），并返回 `false`。
3.  **最终结果:** 如果遍历完所有可能的起点后，DFS 都没有返回 `true`，则说明单词不存在于网格中，返回 `false`。

```java
/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    /**
     * 判断单词是否存在于网格中。
     *
     * @param board 二维字符网格
     * @param word  要搜索的单词
     * @return 如果存在则返回 true，否则返回 false
     */
    public boolean exist(char[][] board, String word) {
        int rows = board.length;
        int cols = board[0].length;

        // 遍历每个单元格作为起点
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (dfs(board, word, i, j, 0)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * 深度优先搜索的辅助函数。
     *
     * @param board 二维网格
     * @param word  目标单词
     * @param row   当前行
     * @param col   当前列
     * @param index 当前要匹配的单词字符索引
     * @return 是否能找到匹配
     */
    private boolean dfs(char[][] board, String word, int row, int col, int index) {
        // 递归终止条件
        // 1. 边界检查 或 字符不匹配
        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length || board[row][col] != word.charAt(index)) {
            return false;
        }
        // 2. 单词所有字符都已匹配
        if (index == word.length() - 1) {
            return true;
        }

        // --- 回溯过程 ---
        // 1. 标记当前单元格为已访问 (原地修改)
        char temp = board[row][col];
        board[row][col] = '#'; // 使用一个不会出现在 board 和 word 中的字符

        // 2. 向四个方向进行递归搜索
        boolean found = dfs(board, word, row + 1, col, index + 1) ||
                        dfs(board, word, row - 1, col, index + 1) ||
                        dfs(board, word, row, col + 1, index + 1) ||
                        dfs(board, word, row, col - 1, index + 1);

        // 3. 恢复当前单元格 (回溯)
        board[row][col] = temp;

        return found;
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        char[][] board1 = {{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}};
        String word1 = "ABCCED";
        System.out.println("输入: board = [...], word = \"" + word1 + "\"");
        boolean result1 = solution.exist(board1, word1);
        System.out.println("输出: " + result1); // 预期输出: true
        System.out.println();

        System.out.println("--- 示例 2 ---");
        char[][] board2 = {{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}};
        String word2 = "SEE";
        System.out.println("输入: board = [...], word = \"" + word2 + "\"");
        boolean result2 = solution.exist(board2, word2);
        System.out.println("输出: " + result2); // 预期输出: true
        System.out.println();

        System.out.println("--- 示例 3 ---");
        char[][] board3 = {{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}};
        String word3 = "ABCB";
        System.out.println("输入: board = [...], word = \"" + word3 + "\"");
        boolean result3 = solution.exist(board3, word3);
        System.out.println("输出: " + result3); // 预期输出: false
        System.out.println();
    }
}
```
