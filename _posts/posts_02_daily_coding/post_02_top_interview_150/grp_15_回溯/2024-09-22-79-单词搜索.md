---
title: 79. 单词搜索
date: 2024-09-22 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 回溯]
tags: [回溯]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233505438.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word`。如果 `word` 存在于网格中，返回 `true`；否则，返回 `false`。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

- **输入:** `board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']]`, `word = "ABCCED"`
- **输出:** `true`

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)

- **输入:** `board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']]`, `word = "SEE"`
- **输出:** `true`

**示例 3:**

![示例3图片](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)

- **输入:** `board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']]`, `word = "ABCB"`
- **输出:** `false`

**提示:**

- `m == board.length`
- `n = board[i].length`
- `1 <= m, n <= 6`
- `1 <= word.length <= 15`
- `board` 和 `word` 仅由大小写英文字母组成

**进阶：** 你可以使用搜索剪枝的技术来优化解决方案，使其在 `board` 更大的情况下可以更快解决问题？

## 题解

### 解法一：标准回溯法 (DFS Backtracking)

**思路：**

这是解决二维网格路径搜索问题的通用解法。我们需要在网格中寻找一条路径，使得路径上的字符连接起来等于目标单词。

1.  **遍历起点**：遍历网格的每一个单元格 `(i, j)`，如果当前单元格的字符等于单词的第一个字符，则从该位置开始进行深度优先搜索（DFS）。
2.  **DFS 递归逻辑**：

    - **参数**：当前网格坐标 `(i, j)`，当前匹配到单词的第 `k` 个字符。
    - **终止条件（成功）**：如果 `k` 等于单词长度，说明单词所有字符都匹配成功，返回 `true`。
    - **终止条件（失败）**：

      - 坐标越界（超出网格范围）。
      - 当前网格字符 `board[i][j]` 不等于单词中对应的字符 `word[k]`。

    - **标记访问**：为了防止“走回头路”（同一个单元格在一次匹配中只能使用一次），我们需要暂时将当前单元格标记为已访问（例如将其修改为特殊字符 `#` 或 `0`）。
    - **递归搜索**：向上下左右四个方向递归调用 DFS，匹配单词的下一个字符（`k + 1`）。
    - **回溯（状态重置）**：如果四个方向都没有找到解，说明当前路径走不通。在返回 `false` 之前，必须将当前单元格的字符**恢复**为原来的字符，以便后续的搜索可以使用它。

**复杂度分析：**

- **时间复杂度：** $O(M \cdot N \cdot 3^L)$，其中 $M, N$ 为网格长宽，$L$ 为单词长度。我们需要遍历 $M \times N$ 个起点。在每次 DFS 中，除了由来的方向，最多有 3 个分支。
- **空间复杂度：** $O(L)$，主要是递归栈的深度，最深为单词的长度 $L$。

**代码片段：**

```java
public boolean exist(char[][] board, String word) {
    int m = board.length, n = board[0].length;
    char[] words = word.toCharArray();
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            // 从每个位置开始尝试
            if (dfs(board, words, i, j, 0)) return true;
        }
    }
    return false;
}

private boolean dfs(char[][] board, char[] word, int i, int j, int k) {
    // 1. 成功匹配完所有字符
    if (k == word.length) return true;
    // 2. 越界检查
    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length) return false;
    // 3. 字符不匹配 或 已经被访问过
    if (board[i][j] != word[k]) return false;

    // 4. 标记当前节点已访问（暂存原值）
    char temp = board[i][j];
    board[i][j] = '\0'; // 使用空字符标记已访问

    // 5. 向四个方向递归
    boolean res = dfs(board, word, i + 1, j, k + 1) ||
                  dfs(board, word, i - 1, j, k + 1) ||
                  dfs(board, word, i, j + 1, k + 1) ||
                  dfs(board, word, i, j - 1, k + 1);

    // 6. 回溯：恢复原值
    board[i][j] = temp;
    return res;
}
```

### 解法二：进阶优化（频次剪枝 + 逆序搜索）

**思路：**

虽然标准 DFS 可以通过，但在面对大规模数据或特定构造的“恶心”测试用例时（例如矩阵全是 'A'，目标词是 "AAAAAAAAAB"），标准解法会进行大量无效搜索。我们可以引入**预处理**和**剪枝**策略。

1.  **频次检测剪枝 (Frequency Pruning)**：

    在开始 DFS 之前，先统计 `board` 中所有字符的出现次数以及 `word` 中字符的出现次数。

    - 如果 `word` 中某个字符的数量 > `board` 中该字符的总数，直接返回 `false`。这可以瞬间排除掉很多不可能的情况。
    - 既然题目数据范围较小（只有英文字母），可以用一个长度为 128 的整型数组来统计 ASCII 码频次。

2.  **首尾选择策略 (Reverse Strategy)**：

    如果 `word` 的第一个字符在 `board` 中出现的次数非常多，而最后一个字符出现的次数很少，那么从 `word` 的开头开始搜索会导致很多无效的分支。

    - **策略**：比较 `word` 首字符和尾字符在 `board` 中的出现频率。如果尾字符更“稀缺”，我们将 `word` **翻转**，从原来的尾部开始搜索。这样可以更快地遇到不匹配的情况或更快地定位到解，从而大幅减少递归树的规模。

**复杂度分析：**

- **时间复杂度：** 最坏情况仍为 $O(M \cdot N \cdot 3^L)$，但在平均情况和特定“坏”用例下性能显著提升。预处理只需要 $O(M \cdot N)$。
- **空间复杂度：** $O(L)$，递归栈深度。

**代码片段：**

```java
public boolean existOptimized(char[][] board, String word) {
    int m = board.length, n = board[0].length;
    if (m * n < word.length()) return false;

    // 统计频次
    int[] boardCounts = new int[128];
    for (char[] row : board) {
        for (char c : row) boardCounts[c]++;
    }

    int[] wordCounts = new int[128];
    for (char c : word.toCharArray()) {
        wordCounts[c]++;
        // 剪枝 1：如果网格里的字符不够凑出单词，直接返回 false
        if (wordCounts[c] > boardCounts[c]) return false;
    }

    // 剪枝 2：选择更稀缺的一端开始搜索
    // 如果单词开头的字符在板上很多，而结尾的字符很少，倒着搜会更快
    if (boardCounts[word.charAt(0)] > boardCounts[word.charAt(word.length() - 1)]) {
        word = new StringBuilder(word).reverse().toString();
    }

    // 执行标准 DFS
    char[] words = word.toCharArray();
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (dfs(board, words, i, j, 0)) return true;
        }
    }
    return false;
}
// dfs 函数与解法一相同
```

### 完整代码

```java
import java.util.*;

public class Main {

    /**
     * 进阶解法：包含频次检查和搜索方向优化
     */
    public static boolean exist(char[][] board, String word) {
        int m = board.length;
        int n = board[0].length;

        // 长度快速检查
        if (m * n < word.length()) return false;

        // 1. 频次统计与剪枝
        int[] boardCounts = new int[128]; // 支持 ASCII
        for (char[] row : board) {
            for (char c : row) {
                boardCounts[c]++;
            }
        }

        char[] wordChars = word.toCharArray();
        int[] wordCounts = new int[128];
        for (char c : wordChars) {
            wordCounts[c]++;
            // 如果单词需要的某个字符数量超过了板上有的数量，不可能组成
            if (wordCounts[c] > boardCounts[c]) {
                return false;
            }
        }

        // 2. 搜索方向优化
        // 比较单词首尾字符在矩阵中的数量，从数量较少（较稀缺）的一端开始搜
        // 这样可以减少递归分支
        if (boardCounts[wordChars[0]] > boardCounts[wordChars[word.length() - 1]]) {
            // 翻转单词
            StringBuilder sb = new StringBuilder(word);
            word = sb.reverse().toString();
            wordChars = word.toCharArray();
        }

        // 3. 开始 DFS
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 只有首字符匹配才进入递归
                if (board[i][j] == wordChars[0]) {
                    if (dfs(board, wordChars, i, j, 0)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    private static boolean dfs(char[][] board, char[] word, int i, int j, int k) {
        // 终止条件：匹配完成
        if (k == word.length) {
            return true;
        }

        // 边界检查 + 字符匹配检查
        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word[k]) {
            return false;
        }

        // 标记已访问（暂存原字符）
        char temp = board[i][j];
        board[i][j] = '\0'; // 这里的 '\0' 可以是任何非字母字符

        // 递归四个方向
        boolean res = dfs(board, word, i + 1, j, k + 1) ||
                      dfs(board, word, i - 1, j, k + 1) ||
                      dfs(board, word, i, j + 1, k + 1) ||
                      dfs(board, word, i, j - 1, k + 1);

        // 回溯：恢复原字符
        board[i][j] = temp;

        return res;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        char[][] board1 = {
            {'A','B','C','E'},
            {'S','F','C','S'},
            {'A','D','E','E'}
        };
        String word1 = "ABCCED";
        System.out.println("示例 1 输入: board = " + Arrays.deepToString(board1) + ", word = " + word1);
        System.out.println("示例 1 输出: " + exist(board1, word1));
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        char[][] board2 = {
            {'A','B','C','E'},
            {'S','F','C','S'},
            {'A','D','E','E'}
        };
        String word2 = "SEE";
        // 注意：board 是引用传递，上面示例1运行后 board 会被恢复原状，不影响示例2
        System.out.println("示例 2 输入: board = " + Arrays.deepToString(board2) + ", word = " + word2);
        System.out.println("示例 2 输出: " + exist(board2, word2));
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        char[][] board3 = {
            {'A','B','C','E'},
            {'S','F','C','S'},
            {'A','D','E','E'}
        };
        String word3 = "ABCB";
        System.out.println("示例 3 输入: board = " + Arrays.deepToString(board3) + ", word = " + word3);
        System.out.println("示例 3 输出: " + exist(board3, word3));
    }
}
```
