---
title: 108. 将有序数组转换为二叉搜索树
date: 2024-09-25 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 分治]
tags: [分治]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233631087.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个整数数组 `nums`，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1」的二叉树。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

- **输入:** `nums = [-10,-3,0,5,9]`
- **输出:** `[0,-3,9,-10,null,5]`
- **解释:** `[0,-10,5,null,-3,null,9]` 也将被视为正确答案。

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg)

- **输入:** `nums = [1,3]`
- **输出:** `[3,1]`
- **解释:** `[1,null,3]` 和 `[3,1]` 都是高度平衡二叉搜索树。

**提示:**

- `1 <= nums.length <= 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 按 **严格递增** 顺序排列

## 题解

### 解法：递归分治 (Recursive Divide and Conquer)

**思路：**

二叉搜索树（BST）的中序遍历结果是一个有序数组。题目给出的恰好是一个有序数组，因此这道题可以看作是“将中序遍历结果还原为二叉树”的过程。

为了满足**高度平衡**的要求，我们需要保证根节点的左右子树节点数量差异尽可能小。最自然的方法是选择**数组中间的元素**作为根节点：

1.  **选根节点**：取数组的中间元素 `nums[mid]` 作为当前子树的根。
2.  **构建左子树**：将中间元素左边的子数组 `nums[left ... mid-1]` 递归构建为左子树。
3.  **构建右子树**：将中间元素右边的子数组 `nums[mid+1 ... right]` 递归构建为右子树。

由于每次都从中间切分，左右子树的节点个数最多相差 1，因此构建出的树必然是高度平衡的。

**复杂度分析：**

- **时间复杂度：** $O(N)$，每个元素只会被访问一次用来创建节点。
- **空间复杂度：** $O(\log N)$，主要是递归调用栈的空间。因为是平衡树，树的高度为 $\log N$。

**代码片段：**

```java
public TreeNode sortedArrayToBST(int[] nums) {
    return helper(nums, 0, nums.length - 1);
}

private TreeNode helper(int[] nums, int left, int right) {
    // Base Case: 区间无效（左边界大于右边界）
    if (left > right) {
        return null;
    }

    // 选取中间节点（如果偶数个，选左侧中间或右侧中间均可，这里选左侧中间）
    int mid = left + (right - left) / 2;

    TreeNode root = new TreeNode(nums[mid]);

    // 递归构建左右子树
    root.left = helper(nums, left, mid - 1);
    root.right = helper(nums, mid + 1, right);

    return root;
}
```

### 完整代码

为了方便验证结果，下面的代码中包含了一个简单的 `printTree` 方法（层序遍历），用于输出类似 LeetCode 示例格式的数组表示。

```java
import java.util.*;

// 定义二叉树节点
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val) { this.val = val; }
}

public class Main {

    // 核心解法
    public static TreeNode sortedArrayToBST(int[] nums) {
        return helper(nums, 0, nums.length - 1);
    }

    // 辅助递归函数
    private static TreeNode helper(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }

        // 总是选择中间位置左边的数字作为根节点
        int mid = left + (right - left) / 2;

        TreeNode root = new TreeNode(nums[mid]);
        root.left = helper(nums, left, mid - 1);
        root.right = helper(nums, mid + 1, right);

        return root;
    }

    // 辅助工具：层序遍历打印树（用于验证输出）
    public static String printTree(TreeNode root) {
        if (root == null) return "[]";
        List<String> output = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if (node == null) {
                output.add("null");
            } else {
                output.add(String.valueOf(node.val));
                // 只有当不是叶子节点的空子节点时，才需要入队 null 以保持格式
                // 这里为了简化，仅做简单的层序展示，可能尾部会有多余 null
                queue.add(node.left);
                queue.add(node.right);
            }
        }

        // 去除末尾多余的 "null"
        int i = output.size() - 1;
        while (i >= 0 && output.get(i).equals("null")) {
            output.remove(i);
            i--;
        }

        return output.toString();
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1 = {-10, -3, 0, 5, 9};
        System.out.println("示例 1 输入: nums = " + Arrays.toString(nums1));

        TreeNode root1 = sortedArrayToBST(nums1);

        System.out.println("示例 1 输出: " + printTree(root1));
        // 解释: 输出结果可能是 [0, -3, 9, -10, null, 5] 或 [0, -10, 5, null, -3, null, 9] 等，均为正确
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums2 = {1, 3};
        System.out.println("示例 2 输入: nums = " + Arrays.toString(nums2));

        TreeNode root2 = sortedArrayToBST(nums2);

        System.out.println("示例 2 输出: " + printTree(root2));
        // 解释: 输出可能是 [3, 1] 或 [1, null, 3]
        System.out.println("-----------------------------");
    }
}
```
