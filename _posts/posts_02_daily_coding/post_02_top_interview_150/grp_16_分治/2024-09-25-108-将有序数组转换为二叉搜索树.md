---
title: 108-将有序数组转换为二叉搜索树
date: 2024-09-25 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 分治]
tags: [分治]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121233631087.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


### 题目：108. 将有序数组转换为二叉搜索树

给你一个整数数组 `nums`，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1」的二叉树。

---

**示例 1:**
![示例1图片](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

- **输入:** `nums = [-10,-3,0,5,9]`
- **输出:** `[0,-3,9,-10,null,5]`
- **解释:** `[0,-10,5,null,-3,null,9]` 也将被视为正确答案。

**示例 2:**
![示例2图片](https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg)

- **输入:** `nums = [1,3]`
- **输出:** `[3,1]`
- **解释:** `[1,null,3]` 和 `[3,1]` 都是高度平衡二叉搜索树。

---

**提示:**

- `1 <= nums.length <= 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 按 **严格递增** 顺序排列

---

### Java 8 解答 (赛码网格式)

**算法思路：(递归 / 分治)**
要将一个有序数组转换为高度平衡的二叉搜索树，最直观的方法是选择数组的 **中间元素** 作为树的根节点。

1.  **选择根节点:** 找到数组的中间索引 `mid`，`nums[mid]` 就是当前子树的根。
2.  **构建左子树:** 数组中 `mid` 左边的部分 `[left, mid - 1]` 是所有小于根节点的值，用这部分递归构建根节点的左子树。
3.  **构建右子树:** 数组中 `mid` 右边的部分 `[mid + 1, right]` 是所有大于根节点的值，用这部分递归构建根节点的右子树。
4.  **递归基:** 当 `left > right` 时，表示当前的子数组为空，返回 `null`。

这种方法确保了每次分割时，左右子树的节点数量差最多为 1，从而保证了构建出的二叉搜索树是高度平衡的。

```java
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;

/**
 * 二叉树节点的定义
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    /**
     * 将有序数组转换为高度平衡的二叉搜索树。
     *
     * @param nums 升序排列的整数数组
     * @return 构建好的二叉搜索树的根节点
     */
    public static TreeNode sortedArrayToBST(int[] nums) {
        if (nums == null || nums.length == 0) {
            return null;
        }
        return buildBST(nums, 0, nums.length - 1);
    }

    /**
     * 递归构建 BST 的辅助函数。
     * @param nums  原始数组
     * @param left  当前处理的子数组的左边界
     * @param right 当前处理的子数组的右边界
     * @return 构建好的子树的根节点
     */
    private static TreeNode buildBST(int[] nums, int left, int right) {
        // 递归终止条件
        if (left > right) {
            return null;
        }

        // 选择中间位置的元素作为根节点
        int mid = left + (right - left) / 2;
        TreeNode root = new TreeNode(nums[mid]);

        // 递归构建左子树和右子树
        root.left = buildBST(nums, left, mid - 1);
        root.right = buildBST(nums, mid + 1, right);

        return root;
    }

    // --- 辅助函数，用于测试和打印结果 ---
    /**
     * 层序遍历，将树序列化为 LeetCode 格式的列表
     */
    public static List<Integer> treeToList(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) {
            return result;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if (node != null) {
                result.add(node.val);
                queue.add(node.left);
                queue.add(node.right);
            } else {
                result.add(null);
            }
        }
        // 移除末尾的 null
        while(result.get(result.size() - 1) == null) {
            result.remove(result.size() - 1);
        }
        return result;
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[] nums1 = {-10, -3, 0, 5, 9};
        System.out.println("输入: nums = " + Arrays.toString(nums1));
        TreeNode root1 = sortedArrayToBST(nums1);
        System.out.println("输出: " + treeToList(root1)); // 预期输出: [0,-3,9,-10,null,5] 或 [0,-10,5,null,-3,null,9]
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[] nums2 = {1, 3};
        System.out.println("输入: nums = " + Arrays.toString(nums2));
        TreeNode root2 = sortedArrayToBST(nums2);
        System.out.println("输出: " + treeToList(root2)); // 预期输出: [3,1] 或 [1,null,3]
    }
}
```
