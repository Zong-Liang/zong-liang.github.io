---
title: 23-合并K个升序链表
date: 2024-10-01 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 分治]
tags: [分治]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234145065.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


### 题目：23. 合并 K 个升序链表

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

---

**示例 1:**

- **输入:** `lists = [[1,4,5],[1,3,4],[2,6]]`
- **输出:** `[1,1,2,3,4,4,5,6]`
- **解释:** 链表数组如下：
  ```
  [
    1->4->5,
    1->3->4,
    2->6
  ]
  ```
  将它们合并到一个有序链表中得到。
  `1->1->2->3->4->4->5->6`

**示例 2:**

- **输入:** `lists = []`
- **输出:** `[]`

**示例 3:**

- **输入:** `lists = [[]]`
- **输出:** `[]`

---

**提示:**

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` 按 **升序** 排列
- `lists[i].length` 的总和不超过 `10^4`

---

### Java 8 解答 (赛码网格式)

**算法思路：(优先队列 / 最小堆)**
这个问题是“合并两个有序链表”的扩展。如果逐一合并链表，时间复杂度会比较高。一个更优化的方法是使用 **最小堆**（`PriorityQueue`）。

1.  **初始化堆：** 创建一个最小堆，并将 `k` 个链表的 **头节点** 全部放入堆中。堆会根据节点的值自动排序。
2.  **构建新链表：**
    - 创建一个虚拟头节点 `dummy` 和一个指针 `current`。
    - 当堆不为空时，循环执行以下操作：
      a. 从堆中弹出值最小的节点 `node`。
      b. 将 `node` 连接到新链表的末尾（`current.next = node`）。
      c. 移动 `current` 指针。
      d. 如果弹出的节点 `node` 还有下一个节点 (`node.next != null`)，则将其下一个节点加入堆中。
3.  **返回结果：** 循环结束后，`dummy.next` 就是合并后链表的头节点。

这种方法的时间复杂度为 `O(N log k)`，其中 `N` 是所有链表的总节点数，`k` 是链表的数量。

```java
import java.util.Comparator;
import java.util.PriorityQueue;

/**
 * 链表节点的定义
 */
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    /**
     * 将所有链表合并到一个升序链表中。
     *
     * @param lists 链表数组
     * @return 合并后的链表头节点
     */
    public static ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) {
            return null;
        }

        // 创建一个最小堆，并定义比较器，根据节点的值进行比较
        PriorityQueue<ListNode> minHeap = new PriorityQueue<>(Comparator.comparingInt(node -> node.val));

        // 将每个链表的头节点加入最小堆
        for (ListNode head : lists) {
            if (head != null) {
                minHeap.add(head);
            }
        }

        // 虚拟头节点和当前指针
        ListNode dummy = new ListNode(-1);
        ListNode current = dummy;

        // 当堆不为空时，持续取出最小节点并连接
        while (!minHeap.isEmpty()) {
            // 取出堆顶（值最小的）节点
            ListNode smallestNode = minHeap.poll();

            // 连接到新链表
            current.next = smallestNode;
            current = current.next;

            // 如果该节点还有下一个节点，则将其下一个节点入堆
            if (smallestNode.next != null) {
                minHeap.add(smallestNode.next);
            }
        }

        return dummy.next;
    }

    // --- 辅助函数，用于测试 ---

    /**
     * 根据数组创建链表。
     */
    public static ListNode createLinkedList(int[] arr) {
        if (arr == null || arr.length == 0) {
            return null;
        }
        ListNode dummy = new ListNode(-1);
        ListNode current = dummy;
        for (int val : arr) {
            current.next = new ListNode(val);
            current = current.next;
        }
        return dummy.next;
    }

    /**
     * 打印链表。
     */
    public static void printLinkedList(ListNode head) {
        if (head == null) {
            System.out.println("[]");
            return;
        }
        StringBuilder sb = new StringBuilder("[");
        ListNode current = head;
        while (current != null) {
            sb.append(current.val);
            if (current.next != null) {
                sb.append(",");
            }
            current = current.next;
        }
        sb.append("]");
        System.out.println(sb.toString());
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        ListNode[] lists1 = {
            createLinkedList(new int[]{1, 4, 5}),
            createLinkedList(new int[]{1, 3, 4}),
            createLinkedList(new int[]{2, 6})
        };
        System.out.println("输入: lists = [[1,4,5],[1,3,4],[2,6]]");
        ListNode result1 = mergeKLists(lists1);
        System.out.print("输出: ");
        printLinkedList(result1); // 预期输出: [1,1,2,3,4,4,5,6]
        System.out.println();

        System.out.println("--- 示例 2 ---");
        ListNode[] lists2 = {};
        System.out.println("输入: lists = []");
        ListNode result2 = mergeKLists(lists2);
        System.out.print("输出: ");
        printLinkedList(result2); // 预期输出: []
        System.out.println();

        System.out.println("--- 示例 3 ---");
        ListNode[] lists3 = {createLinkedList(new int[]{})};
        System.out.println("输入: lists = [[]]");
        ListNode result3 = mergeKLists(lists3);
        System.out.print("输出: ");
        printLinkedList(result3); // 预期输出: []
    }
}
```
