---
title: 23. 合并K个升序链表
date: 2024-10-01 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 分治]
tags: [分治]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234145065.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1:**

- **输入:** `lists = [[1,4,5],[1,3,4],[2,6]]`
- **输出:** `[1,1,2,3,4,4,5,6]`
- **解释:** 链表数组如下：

  ```
  [
    1->4->5,
    1->3->4,
    2->6
  ]
  ```

  将它们合并到一个有序链表中得到。

  `1->1->2->3->4->4->5->6`

**示例 2:**

- **输入:** `lists = []`
- **输出:** `[]`

**示例 3:**

- **输入:** `lists = [[]]`
- **输出:** `[]`

**提示:**

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` 按 **升序** 排列
- `lists[i].length` 的总和不超过 `10^4`

## 题解

### 解法一：优先队列 (Priority Queue / Min-Heap)

**思路：**

我们要合并 $k$ 个已经排好序的链表，问题的关键在于：**如何快速找到这 $k$ 个链表当前头节点中的最小值**。

1.  我们可以维护一个**小顶堆**（Min-Heap），也就是 Java 中的 `PriorityQueue`。
2.  **初始化**：将所有链表的头节点（如果不为空）加入堆中。此时堆顶就是所有链表中最小的节点。
3.  **循环处理**：

    - 弹出堆顶元素（最小节点），将其拼接到结果链表的末尾。
    - 如果这个弹出的节点还有下一个节点（`next` 不为空），就将它的下一个节点加入堆中。

4.  当堆为空时，说明所有节点都处理完毕。

**复杂度分析：**

- **时间复杂度：** $O(N \log k)$，其中 $N$ 是所有链表中节点的总数，$k$ 是链表的个数。优先队列中最多维护 $k$ 个元素，插入和删除操作的复杂度为 $O(\log k)$，总共操作 $N$ 次。
- **空间复杂度：** $O(k)$，优先队列需要 $O(k)$ 的空间来存储每个链表的当前头节点。

**代码片段：**

```java
public ListNode mergeKLists(ListNode[] lists) {
    if (lists == null || lists.length == 0) return null;

    // 创建小顶堆，根据节点值排序
    PriorityQueue<ListNode> pq = new PriorityQueue<>(lists.length, (a, b) -> a.val - b.val);

    // 将所有非空链表的头节点加入堆
    for (ListNode head : lists) {
        if (head != null) pq.offer(head);
    }

    ListNode dummy = new ListNode(0);
    ListNode tail = dummy;

    while (!pq.isEmpty()) {
        ListNode minNode = pq.poll();
        tail.next = minNode;
        tail = tail.next;

        // 如果被取出的节点还有后继，放回堆中
        if (minNode.next != null) {
            pq.offer(minNode.next);
        }
    }

    return dummy.next;
}
```

### 解法二：分治法 (Divide and Conquer)

**思路：**

这是一种类似**归并排序**的思想。我们将合并 $k$ 个链表的问题转化分解：

1.  将 $k$ 个链表配对，两两合并。
2.  合并后，链表数量减少一半（从 $k$ 变为 $k/2$）。
3.  重复此过程，直到只剩下一个链表。

之所以比“逐个合并”（第 1 个和第 2 个合，结果和第 3 个合...）要快，是因为它避免了越往后合并的链表越长、重复遍历多次长链表的问题。

**复杂度分析：**

- **时间复杂度：** $O(N \log k)$，每一轮合并都会遍历几乎所有节点 $N$，总共需要进行 $\log k$ 轮合并（二分）。
- **空间复杂度：** $O(1)$ 或 $O(\log k)$，取决于实现方式。如果使用迭代（自底向上），空间复杂度为 $O(1)$；如果使用递归（自顶向下），递归栈深度为 $O(\log k)$。

**代码片段：**

```java
public ListNode mergeKLists(ListNode[] lists) {
    if (lists == null || lists.length == 0) return null;
    return merge(lists, 0, lists.length - 1);
}

// 递归分治
private ListNode merge(ListNode[] lists, int left, int right) {
    if (left == right) return lists[left];

    int mid = left + (right - left) / 2;
    ListNode l1 = merge(lists, left, mid);
    ListNode l2 = merge(lists, mid + 1, right);

    return mergeTwoLists(l1, l2);
}

// 合并两个有序链表（基础操作）
private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if (l1 == null) return l2;
    if (l2 == null) return l1;

    if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
}
```

### 完整代码

这里提供**解法一（优先队列）** 的完整可运行代码，因为它更符合直觉，且在面试中常作为标准解法。

```java
import java.util.PriorityQueue;
import java.util.Comparator;

// 链表节点定义
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

public class Main {

    /**
     * 合并 K 个升序链表 - 使用优先队列
     */
    public static ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) {
            return null;
        }

        // 定义小顶堆，按照节点的值从小到大排序
        // 也可以写成: Comparator.comparingInt(node -> node.val)
        PriorityQueue<ListNode> pq = new PriorityQueue<>((o1, o2) -> o1.val - o2.val);

        // 1. 初始化：将所有链表的头结点加入堆中
        for (ListNode node : lists) {
            if (node != null) {
                pq.offer(node);
            }
        }

        ListNode dummy = new ListNode(-1);
        ListNode curr = dummy;

        // 2. 不断从堆中取出最小节点，并将其下一个节点放入堆中
        while (!pq.isEmpty()) {
            ListNode minNode = pq.poll();
            curr.next = minNode;
            curr = curr.next;

            if (minNode.next != null) {
                pq.offer(minNode.next);
            }
        }

        return dummy.next;
    }

    // 辅助方法：打印链表
    public static void printList(ListNode head) {
        while (head != null) {
            System.out.print(head.val + " -> ");
            head = head.next;
        }
        System.out.println("null");
    }

    // 辅助方法：构建链表
    public static ListNode buildList(int[] nums) {
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        for (int num : nums) {
            curr.next = new ListNode(num);
            curr = curr.next;
        }
        return dummy.next;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        // lists = [[1,4,5],[1,3,4],[2,6]]
        ListNode l1 = buildList(new int[]{1, 4, 5});
        ListNode l2 = buildList(new int[]{1, 3, 4});
        ListNode l3 = buildList(new int[]{2, 6});
        ListNode[] lists = new ListNode[]{l1, l2, l3};

        System.out.println("示例 1 输入: 3 个有序链表");

        ListNode result = mergeKLists(lists);

        System.out.print("示例 1 输出: ");
        printList(result);
        // 预期: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 -> null
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        ListNode[] lists2 = new ListNode[]{};
        System.out.println("示例 2 输入: []");
        ListNode result2 = mergeKLists(lists2);
        System.out.print("示例 2 输出: ");
        printList(result2);
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        ListNode[] lists3 = new ListNode[]{null}; // [[]]
        System.out.println("示例 3 输入: [[]]");
        ListNode result3 = mergeKLists(lists3);
        System.out.print("示例 3 输出: ");
        printList(result3);
    }
}
```
