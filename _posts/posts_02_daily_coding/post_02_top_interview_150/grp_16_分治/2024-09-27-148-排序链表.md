---
title: 148. 排序链表
date: 2024-09-27 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 分治]
tags: [分治]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234043546.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你链表的头结点 `head`，请将其按 **升序** 排列并返回 **排序后的链表**。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg)

- **输入:** `head = [4,2,1,3]`
- **输出:** `[1,2,3,4]`

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg)

- **输入:** `head = [-1,5,3,4,0]`
- **输出:** `[-1,0,3,4,5]`

**示例 3:**

- **输入:** `head = []`
- **输出:** `[]`

**提示:**

- 链表中节点的数目在范围 `[0, 5 * 10^4]` 内
- `-10^5 <= Node.val <= 10^5`

**进阶：** 你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

## 题解

### 解法一：自顶向下归并排序 (Top-Down Merge Sort)

**思路：**

这是最容易想到的解法，利用**分治思想**。

由于链表不像数组那样支持随机访问，快速排序在链表上的实现较为复杂且不稳定（虽然可行），而归并排序非常适合链表，因为合并两个有序链表的操作非常高效。

1.  **找中点**：使用**快慢指针**（Slow & Fast Pointers）找到链表的中间节点。快指针每次走两步，慢指针每次走一步，当快指针到达末尾时，慢指针指向中点。
2.  **断链**：将链表从中点切断，分为左半部分和右半部分。
3.  **递归**：对左、右两部分分别进行递归排序。
4.  **合并**：使用“合并两个有序链表”（LeetCode 21 题的逻辑）将排好序的左右两部分合并为一个有序链表。

**复杂度分析：**

- **时间复杂度：** $O(n \log n)$，典型的分治算法，分割层数为 $\log n$，每层合并操作遍历所有节点耗时 $O(n)$。
- **空间复杂度：** $O(\log n)$，虽然没有使用额外的数据结构存储节点，但递归调用栈的深度为 $\log n$。这不完全符合进阶要求的 $O(1)$ 空间。

**代码片段：**

```java
public ListNode sortList(ListNode head) {
    // 递归终止条件
    if (head == null || head.next == null) return head;

    // 1. 找中点
    ListNode slow = head, fast = head.next;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }

    // 2. 断链
    ListNode rightHead = slow.next;
    slow.next = null;

    // 3. 递归排序
    ListNode left = sortList(head);
    ListNode right = sortList(rightHead);

    // 4. 合并
    return merge(left, right);
}

// 辅助函数：合并两个有序链表
private ListNode merge(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode curr = dummy;
    while (l1 != null && l2 != null) {
        if (l1.val < l2.val) {
            curr.next = l1;
            l1 = l1.next;
        } else {
            curr.next = l2;
            l2 = l2.next;
        }
        curr = curr.next;
    }
    if (l1 != null) curr.next = l1;
    if (l2 != null) curr.next = l2;
    return dummy.next;
}
```

### 解法二：自底向上归并排序 (Bottom-Up Merge Sort) —— 进阶解法

**思路：**

为了满足 **$O(1)$ 空间复杂度**（不考虑结果占用的空间，仅指运行时的额外空间），我们必须消除递归栈。我们可以采用**迭代**的方式实现归并排序。

1.  **步长枚举**：从 `subLength = 1` 开始，每次将链表拆分成若干个长度为 `subLength` 的子链表进行两两合并。每轮合并后，`subLength` 翻倍（1 -> 2 -> 4 -> ...）。
2.  **拆分与合并**：

    - 在每一轮 `subLength` 中，使用一个指针遍历整个链表。
    - 每次截取两段长度为 `subLength` 的链表（如果剩余不足，则取剩余部分）。
    - 将这两段合并，并挂在结果链表的尾部。
    - 重复直到链表末尾。

3.  **循环终止**：当 `subLength` 大于或等于链表长度时，排序完成。

> **关键点：** 此方法完全通过修改指针指向完成排序，不需要递归栈，因此空间复杂度为常数级。

**复杂度分析：**

- **时间复杂度：** $O(n \log n)$，外部循环对步长进行 $\log n$ 次迭代，内部循环遍历 $n$ 个节点。
- **空间复杂度：** $O(1)$，只使用了几个指针变量，无递归栈。

**代码片段：**

```java
public ListNode sortList(ListNode head) {
    if (head == null) return null;

    // 统计长度
    int length = 0;
    ListNode node = head;
    while (node != null) {
        length++;
        node = node.next;
    }

    ListNode dummy = new ListNode(0, head);

    // 步长从 1 开始，每次翻倍
    for (int subLength = 1; subLength < length; subLength <<= 1) {
        ListNode prev = dummy;
        ListNode curr = dummy.next;

        while (curr != null) {
            // 1. 拆分出第一个子链表 head1
            ListNode head1 = curr;
            for (int i = 1; i < subLength && curr.next != null; i++) {
                curr = curr.next;
            }

            // 2. 拆分出第二个子链表 head2
            ListNode head2 = curr.next;
            curr.next = null; // 断开 head1
            curr = head2;

            // 寻找 head2 的尾部，以便断开和记录下次循环的起点
            ListNode nextHead = null;
            if (curr != null) { // head2 可能为空（如果 head1 已经是最后一段）
                for (int i = 1; i < subLength && curr.next != null; i++) {
                    curr = curr.next;
                }
                nextHead = curr.next;
                curr.next = null; // 断开 head2
            }

            // 3. 合并 head1 和 head2
            ListNode merged = merge(head1, head2);
            prev.next = merged; // 连接到前面的部分

            // 移动 prev 到合并后的尾部
            while (prev.next != null) {
                prev = prev.next;
            }

            // 4. 准备处理下一对
            curr = nextHead;
        }
    }
    return dummy.next;
}
```

### 完整代码

```java
public class Main {

    // 定义链表节点
    public static class ListNode {
        int val;
        ListNode next;
        ListNode() {}
        ListNode(int val) { this.val = val; }
        ListNode(int val, ListNode next) { this.val = val; this.next = next; }
    }

    // 这里展示进阶解法：自底向上归并排序 (O(1) 空间复杂度)
    public static ListNode sortList(ListNode head) {
        if (head == null) return null;

        // 1. 统计链表长度
        int length = 0;
        ListNode node = head;
        while (node != null) {
            length++;
            node = node.next;
        }

        ListNode dummy = new ListNode(0, head);

        // 2. 循环增加步长 subLength: 1, 2, 4, 8...
        for (int subLength = 1; subLength < length; subLength <<= 1) {
            ListNode prev = dummy;
            ListNode curr = dummy.next;

            while (curr != null) {
                // --- 剪切第一段 (head1) ---
                ListNode head1 = curr;
                for (int i = 1; i < subLength && curr.next != null; i++) {
                    curr = curr.next;
                }

                // --- 剪切第二段 (head2) ---
                ListNode head2 = curr.next;
                curr.next = null; // 切断第一段
                curr = head2;

                // 寻找第二段的末尾，并记录剩余部分的起点 (nextHead)
                ListNode nextHead = null;
                if (curr != null) {
                    for (int i = 1; i < subLength && curr.next != null; i++) {
                        curr = curr.next;
                    }
                    nextHead = curr.next;
                    curr.next = null; // 切断第二段
                }

                // --- 合并并连接 ---
                ListNode merged = merge(head1, head2);
                prev.next = merged;

                // 移动 prev 指针到当前合并段的尾部，为下一次连接做准备
                while (prev.next != null) {
                    prev = prev.next;
                }

                // 准备处理下一组
                curr = nextHead;
            }
        }
        return dummy.next;
    }

    // 辅助方法：合并两个有序链表
    private static ListNode merge(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                curr.next = l1;
                l1 = l1.next;
            } else {
                curr.next = l2;
                l2 = l2.next;
            }
            curr = curr.next;
        }
        if (l1 != null) curr.next = l1;
        if (l2 != null) curr.next = l2;
        return dummy.next;
    }

    // 辅助方法：打印链表
    public static void printList(ListNode head) {
        ListNode curr = head;
        while (curr != null) {
            System.out.print(curr.val + (curr.next != null ? " -> " : ""));
            curr = curr.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        ListNode head1 = new ListNode(4, new ListNode(2, new ListNode(1, new ListNode(3))));
        System.out.println("示例 1 输入:");
        printList(head1);

        ListNode sorted1 = sortList(head1);

        System.out.print("示例 1 输出: ");
        printList(sorted1);
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        ListNode head2 = new ListNode(-1, new ListNode(5, new ListNode(3, new ListNode(4, new ListNode(0)))));
        System.out.println("示例 2 输入:");
        printList(head2);

        ListNode sorted2 = sortList(head2);

        System.out.print("示例 2 输出: ");
        printList(sorted2);
    }
}
```
