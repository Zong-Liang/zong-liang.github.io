---
title: 148. 排序链表
date: 2024-09-27 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 分治]
tags: [分治]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234043546.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：148. 排序链表

给你链表的头结点 `head`，请将其按 **升序** 排列并返回 **排序后的链表**。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg)

- **输入:** `head = [4,2,1,3]`
- **输出:** `[1,2,3,4]`

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg)

- **输入:** `head = [-1,5,3,4,0]`
- **输出:** `[-1,0,3,4,5]`

**示例 3:**

- **输入:** `head = []`
- **输出:** `[]`

**提示:**

- 链表中节点的数目在范围 `[0, 5 * 10^4]` 内
- `-10^5 <= Node.val <= 10^5`

**进阶：** 你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

## Java 代码

**算法思路：(归并排序 - 自顶向下)**

为了满足 `O(n log n)` 的时间复杂度和常数级空间复杂度的要求，最适合链表的排序算法是 **归并排序**。

1.  **分割 (Split):**
    - 找到链表的中间节点。这可以通过 **快慢指针** 法实现：快指针一次走两步，慢指针一次走一步。当快指针到达链表末尾时，慢指针正好在中间。
    - 从中间节点处将链表断开，形成两个独立的子链表。
2.  **递归 (Recursive Sort):**
    - 对这两个子链表递归地调用排序函数，直到子链表的长度为 0 或 1（递归的终止条件）。
3.  **合并 (Merge):**
    - 将两个已经排好序的子链表合并成一个大的有序链表。这个合并过程与“合并两个有序链表”问题完全相同。

递归调用栈会产生 `O(log n)` 的空间开销，这在技术上不完全是“常数级”，但对于链表排序问题，这通常是满足进阶要求的最优解法。

```java
/**
 * 链表节点的定义
 */
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}


public class Main {

    /**
     * 按升序排列链表。
     *
     * @param head 链表的头结点
     * @return 排序后的链表
     */
    public static ListNode sortList(ListNode head) {
        // 递归终止条件：链表为空或只有一个节点
        if (head == null || head.next == null) {
            return head;
        }

        // 1. 分割链表
        ListNode mid = findMiddle(head);
        ListNode rightHead = mid.next;
        mid.next = null; // 断开链表

        // 2. 递归排序左右两部分
        ListNode left = sortList(head);
        ListNode right = sortList(rightHead);

        // 3. 合并两个有序链表
        return merge(left, right);
    }

    /**
     * 使用快慢指针找到链表的中间节点。
     */
    private static ListNode findMiddle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head.next;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    /**
     * 合并两个有序链表。
     */
    private static ListNode merge(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(-1);
        ListNode current = dummy;

        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                current.next = l1;
                l1 = l1.next;
            } else {
                current.next = l2;
                l2 = l2.next;
            }
            current = current.next;
        }

        // 连接剩余的部分
        current.next = (l1 != null) ? l1 : l2;

        return dummy.next;
    }

    // --- 辅助函数，用于测试 ---
    public static ListNode createLinkedList(int[] arr) {
        if (arr == null || arr.length == 0) return null;
        ListNode dummy = new ListNode(-1);
        ListNode current = dummy;
        for (int val : arr) {
            current.next = new ListNode(val);
            current = current.next;
        }
        return dummy.next;
    }

    public static void printLinkedList(ListNode head) {
        if (head == null) {
            System.out.println("[]");
            return;
        }
        StringBuilder sb = new StringBuilder("[");
        ListNode current = head;
        while (current != null) {
            sb.append(current.val);
            if (current.next != null) sb.append(",");
            current = current.next;
        }
        sb.append("]");
        System.out.println(sb.toString());
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        ListNode head1 = createLinkedList(new int[]{4, 2, 1, 3});
        System.out.print("输入: head = ");
        printLinkedList(head1);
        ListNode result1 = sortList(head1);
        System.out.print("输出: ");
        printLinkedList(result1); // 预期输出: [1,2,3,4]
        System.out.println();

        System.out.println("--- 示例 2 ---");
        ListNode head2 = createLinkedList(new int[]{-1, 5, 3, 4, 0});
        System.out.print("输入: head = ");
        printLinkedList(head2);
        ListNode result2 = sortList(head2);
        System.out.print("输出: ");
        printLinkedList(result2); // 预期输出: [-1,0,3,4,5]
        System.out.println();

        System.out.println("--- 示例 3 ---");
        ListNode head3 = createLinkedList(new int[]{});
        System.out.print("输入: head = ");
        printLinkedList(head3);
        ListNode result3 = sortList(head3);
        System.out.print("输出: ");
        printLinkedList(result3); // 预期输出: []
    }
}
```
