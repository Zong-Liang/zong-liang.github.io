---
title: 427-建立四叉树
date: 2024-09-29 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 分治]
tags: [分治]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234114050.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

好的，这是从图片中整理出的题目描述和解答代码。

### 题目：427. 建立四叉树

给你一个 `n * n` 矩阵 `grid`，矩阵由若干 `0` 和 `1` 组成。请你用四叉树表示该矩阵 `grid`。

你需要返回能表示矩阵 `grid` 的 **四叉树** 的根结点。

四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：

- `val`: 储存叶子结点所代表的区域的值。`1` 对应 `True`，`0` 对应 `False`。注意，当 `isLeaf` 为 `False` 时，你可以把 `True` 或者 `False` 赋值给节点，两种值都会被判题机制 **接受**。
- `isLeaf`: 当这个节点是一个叶子结点时为 `True`，如果它有 4 个子节点则为 `False`。

```java
class Node {
    public boolean val;
    public boolean isLeaf;
    public Node topLeft;
    public Node topRight;
    public Node bottomLeft;
    public Node bottomRight;
}
```

我们可以按以下步骤为二维区域构建四叉树：

1.  如果当前网格的值相同（即，全为 `0` 或者全为 `1`），将 `isLeaf` 设为 `True`，将 `val` 设为网格相应的值，并将四个子节点都设为 `Null` 然后停止。
2.  如果当前网格的值不同，将 `isLeaf` 设为 `False`，将 `val` 设为任意值，然后如下图所示，将当前网格划分为四个子网格。
3.  使用适当的子网格递归每个子节点。

![四叉树划分](https://assets.leetcode.com/uploads/2020/02/11/grid_quad_tree_2.png)

---

**示例 1:**
![示例1图片](https://assets.leetcode.com/uploads/2020/02/11/grid_quad_tree.png)

- **输入:** `grid = [[0,1],[1,0]]`
- **输出:** (根据层序遍历的序列化格式) `[[0,1],[1,0],[1,1],[1,1],[1,0]]`
- **解释:** 在下图四叉树的图示中，0 表示 `false`，1 表示 `True`。

---

**示例 2:**

- **输入:** `grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]`
- **输出:** `[[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]`

---

**提示:**

- `n == grid.length == grid[i].length`
- `n == 2^x` 其中 `0 <= x <= 6`

---

### Java 8 解答 (赛码网格式)

**算法思路：(递归/分治)**
这个问题天然适合使用递归来解决。我们定义一个递归函数，该函数接收当前要处理的子网格的边界（例如，左上角坐标和边长）作为参数。

1.  **检查子网格是否纯色：**
    - 在递归函数内部，首先检查当前子网格内的所有值是否都相同。
    - 遍历子网格，如果发现有不同的值，则该子网格不是纯色的。
2.  **创建节点：**
    - **如果是纯色：** 创建一个 **叶子节点** (`isLeaf = true`)，`val` 设置为该区域的值。返回这个节点。
    - **如果不是纯色：** 创建一个 **内部节点** (`isLeaf = false`)，`val` 可以是任意值。然后，将当前子网格划分为四个更小的子网格（`topLeft`, `topRight`, `bottomLeft`, `bottomRight`），并对每个子网格 **递归调用** 自身。将递归调用的返回值分别赋给当前节点的四个子节点指针。返回这个节点。
3.  **递归基：** 递归的终止条件是当子网格的边长为 1 时，它必然是纯色的。

```java
// LeetCode 提供的 Node 类定义
class Node {
    public boolean val;
    public boolean isLeaf;
    public Node topLeft;
    public Node topRight;
    public Node bottomLeft;
    public Node bottomRight;

    public Node() {
        this.val = false;
        this.isLeaf = false;
        this.topLeft = null;
        this.topRight = null;
        this.bottomLeft = null;
        this.bottomRight = null;
    }

    public Node(boolean val, boolean isLeaf) {
        this.val = val;
        this.isLeaf = isLeaf;
        this.topLeft = null;
        this.topRight = null;
        this.bottomLeft = null;
        this.bottomRight = null;
    }

    public Node(boolean val, boolean isLeaf, Node topLeft, Node topRight, Node bottomLeft, Node bottomRight) {
        this.val = val;
        this.isLeaf = isLeaf;
        this.topLeft = topLeft;
        this.topRight = topRight;
        this.bottomLeft = bottomLeft;
        this.bottomRight = bottomRight;
    }
}

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    /**
     * 构建四叉树的入口函数。
     */
    public Node construct(int[][] grid) {
        return build(grid, 0, 0, grid.length);
    }

    /**
     * 递归构建四叉树的辅助函数。
     * @param grid  原始矩阵
     * @param row   当前子矩阵的起始行
     * @param col   当前子矩阵的起始列
     * @param size  当前子矩阵的边长
     * @return 构建好的子树的根节点
     */
    private Node build(int[][] grid, int row, int col, int size) {
        // 检查当前子矩阵是否所有值都相同
        if (isSameValue(grid, row, col, size)) {
            // 如果是，创建一个叶子节点
            boolean val = (grid[row][col] == 1);
            return new Node(val, true);
        } else {
            // 如果不是，创建一个内部节点并递归构建四个子节点
            Node root = new Node(true, false); // val 可以是任意值
            int newSize = size / 2;

            root.topLeft = build(grid, row, col, newSize);
            root.topRight = build(grid, row, col + newSize, newSize);
            root.bottomLeft = build(grid, row + newSize, col, newSize);
            root.bottomRight = build(grid, row + newSize, col + newSize, newSize);

            return root;
        }
    }

    /**
     * 检查给定子矩阵内的所有值是否相同。
     */
    private boolean isSameValue(int[][] grid, int row, int col, int size) {
        int firstVal = grid[row][col];
        for (int i = row; i < row + size; i++) {
            for (int j = col; j < col + size; j++) {
                if (grid[i][j] != firstVal) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * 主函数，包含测试用例。
     * 由于输出是序列化的树结构，这里仅调用函数，不打印复杂结果。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        int[][] grid1 = {{0, 1}, {1, 0}};
        System.out.println("输入: grid = [[0,1],[1,0]]");
        Node root1 = solution.construct(grid1);
        System.out.println("输出: (根据题目格式，结果为序列化的树，此处仅表示已执行)");
        // 预期输出: [[0,1],[1,0],[1,1],[1,1],[1,0]]
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[][] grid2 = {
            {1, 1, 1, 1, 0, 0, 0, 0},
            {1, 1, 1, 1, 0, 0, 0, 0},
            {1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 0, 0, 0, 0},
            {1, 1, 1, 1, 0, 0, 0, 0},
            {1, 1, 1, 1, 0, 0, 0, 0},
            {1, 1, 1, 1, 0, 0, 0, 0}
        };
        System.out.println("输入: grid = [[...]] (8x8)");
        Node root2 = solution.construct(grid2);
        System.out.println("输出: (根据题目格式，结果为序列化的树，此处仅表示已执行)");
        // 预期输出: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]
    }
}
```
