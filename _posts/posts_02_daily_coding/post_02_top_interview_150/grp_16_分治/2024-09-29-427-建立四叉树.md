---
title: 427. 建立四叉树
date: 2024-09-29 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 分治]
tags: [分治]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234114050.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个 `n * n` 矩阵 `grid`，矩阵由若干 `0` 和 `1` 组成。请你用四叉树表示该矩阵 `grid`。

你需要返回能表示矩阵 `grid` 的 **四叉树** 的根结点。

四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：

- `val`: 储存叶子结点所代表的区域的值。`1` 对应 `True`，`0` 对应 `False`。注意，当 `isLeaf` 为 `False` 时，你可以把 `True` 或者 `False` 赋值给节点，两种值都会被判题机制 **接受**。
- `isLeaf`: 当这个节点是一个叶子结点时为 `True`，如果它有 4 个子节点则为 `False`。

```java
class Node {
    public boolean val;
    public boolean isLeaf;
    public Node topLeft;
    public Node topRight;
    public Node bottomLeft;
    public Node bottomRight;
}
```

我们可以按以下步骤为二维区域构建四叉树：

1.  如果当前网格的值相同（即，全为 `0` 或者全为 `1`），将 `isLeaf` 设为 `True`，将 `val` 设为网格相应的值，并将四个子节点都设为 `Null` 然后停止。
2.  如果当前网格的值不同，将 `isLeaf` 设为 `False`，将 `val` 设为任意值，然后如下图所示，将当前网格划分为四个子网格。
3.  使用适当的子网格递归每个子节点。

![四叉树划分](https://assets.leetcode.com/uploads/2020/02/11/new_top.png)

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/02/11/grid1.png)

- **输入:** `grid = [[0,1],[1,0]]`
- **输出:** (根据层序遍历的序列化格式) `[[0,1],[1,0],[1,1],[1,1],[1,0]]`
- **解释:** 在下图四叉树的图示中，0 表示 `false`，1 表示 `True`。

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2020/02/12/e2mat.png)

- **输入:** `grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]`
- **输出:** `[[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]`
- **解释：**

网格中的所有值都不相同。我们将网格划分为四个子网格。

topLeft，bottomLeft 和 bottomRight 均具有相同的值。

topRight 具有不同的值，因此我们将其再分为 4 个子网格，这样每个子网格都具有相同的值。

解释如下图所示：

![解释图片](https://assets.leetcode.com/uploads/2020/02/12/e2tree.png)

**提示:**

- `n == grid.length == grid[i].length`
- `n == 2^x` 其中 `0 <= x <= 6`

## 题解

### 解法：递归分治 (Divide and Conquer)

**思路：**

这是一道典型的**分治算法**（Divide and Conquer）题目。我们要根据当前的网格区域构建一个树节点：

1.  **判断当前区域是否“纯粹”**：

    - 遍历当前指定的正方形区域（由左上角坐标 `(r, c)` 和边长 `length` 决定）。
    - 检查区域内所有数值是否相同。

2.  **Base Case（叶子节点）**：

    - 如果当前区域内的值**全部相同**（全为 0 或全为 1），则当前节点为**叶子节点**。
    - 设置 `isLeaf = true`，`val` 为网格中的该值，子节点均为 `null`。
    - 返回该节点。

3.  **Recursive Case（内部节点）**：

    - 如果当前区域内的值**不全相同**，则当前节点不是叶子节点。
    - 设置 `isLeaf = false`，`val` 可以设为任意值（通常设为 `true` 或跟左上角一致，题目不强求）。
    - 将当前区域划分为四个大小相等的子区域（边长减半）。
    - 递归调用函数，分别构建 `topLeft`、`topRight`、`bottomLeft`、`bottomRight` 四个子节点。
    - 返回该节点。

**复杂度分析：**

- **时间复杂度：** $O(N^2 \log N)$

  - 递归树的深度为 $\log N$。每一层递归中，我们实际上都遍历了整个网格的所有像素点（总共 $N^2$ 个点）。
  - 例如：第一层遍历 $N^2$ 次；第二层有 4 个子任务，每个遍历 $(N/2)^2$ 次，总和仍是 $N^2$。
  - 总共 $\log N$ 层，所以是 $O(N^2 \log N)$。
  - _注：可以通过前缀和优化判断过程达到 $O(N^2)$，或者使用自底向上的后序遍历优化到 $O(N^2)$，但由于 $N \le 64$，由于数据规模极小，直接遍历判断最直观且足够快。_

- **空间复杂度：** $O(\log N)$

  - 主要是递归调用栈的深度，最大为网格边长的对数。

**代码片段：**

```java
public Node construct(int[][] grid) {
    return build(grid, 0, 0, grid.length);
}

// 递归构建函数
private Node build(int[][] grid, int r, int c, int len) {
    // 1. 检查当前区域是否全为 0 或全为 1
    if (isUniform(grid, r, c, len)) {
        // 是叶子节点
        return new Node(grid[r][c] == 1, true);
    }

    // 2. 如果不是，分裂成四个子区域
    Node node = new Node(true, false); // val 任意，isLeaf 为 false
    int half = len / 2;

    node.topLeft = build(grid, r, c, half);
    node.topRight = build(grid, r, c + half, half);
    node.bottomLeft = build(grid, r + half, c, half);
    node.bottomRight = build(grid, r + half, c + half, half);

    return node;
}

// 辅助函数：检查区域数值是否一致
private boolean isUniform(int[][] grid, int r, int c, int len) {
    int val = grid[r][c];
    for (int i = r; i < r + len; i++) {
        for (int j = c; j < c + len; j++) {
            if (grid[i][j] != val) return false;
        }
    }
    return true;
}
```

### 完整代码

```java
// 题目给出的 Node 定义
class Node {
    public boolean val;
    public boolean isLeaf;
    public Node topLeft;
    public Node topRight;
    public Node bottomLeft;
    public Node bottomRight;

    public Node() {
        this.val = false;
        this.isLeaf = false;
        this.topLeft = null;
        this.topRight = null;
        this.bottomLeft = null;
        this.bottomRight = null;
    }

    public Node(boolean val, boolean isLeaf) {
        this.val = val;
        this.isLeaf = isLeaf;
        this.topLeft = null;
        this.topRight = null;
        this.bottomLeft = null;
        this.bottomRight = null;
    }

    public Node(boolean val, boolean isLeaf, Node topLeft, Node topRight, Node bottomLeft, Node bottomRight) {
        this.val = val;
        this.isLeaf = isLeaf;
        this.topLeft = topLeft;
        this.topRight = topRight;
        this.bottomLeft = bottomLeft;
        this.bottomRight = bottomRight;
    }
}

public class Main {

    public Node construct(int[][] grid) {
        return build(grid, 0, 0, grid.length);
    }

    /**
     * 递归构建四叉树
     * @param grid 原矩阵
     * @param r 当前区域左上角的行索引
     * @param c 当前区域左上角的列索引
     * @param len 当前区域的边长
     */
    private Node build(int[][] grid, int r, int c, int len) {
        // 步骤 1: 检查当前范围内所有值是否相同
        if (isUniform(grid, r, c, len)) {
            // 如果相同，创建一个叶子节点
            // val 为格子里的值 (1->true, 0->false)
            return new Node(grid[r][c] == 1, true);
        }

        // 步骤 2: 如果不相同，创建一个非叶子节点，并递归处理四个子区域
        Node node = new Node(true, false); // val 对非叶子节点无所谓，设为 true 即可
        int half = len / 2;

        // 递归构建四个孩子
        node.topLeft = build(grid, r, c, half);
        node.topRight = build(grid, r, c + half, half);
        node.bottomLeft = build(grid, r + half, c, half);
        node.bottomRight = build(grid, r + half, c + half, half);

        return node;
    }

    /**
     * 辅助函数：判断指定区域内的值是否全部相同
     */
    private boolean isUniform(int[][] grid, int r, int c, int len) {
        int val = grid[r][c];
        for (int i = r; i < r + len; i++) {
            for (int j = c; j < c + len; j++) {
                if (grid[i][j] != val) {
                    return false;
                }
            }
        }
        return true;
    }

    public static void main(String[] args) {
        Main solution = new Main();

        // --- 示例 1 ---
        int[][] grid1 = {
            {0, 1},
            {1, 0}
        };
        System.out.println("示例 1 构建开始...");
        Node root1 = solution.construct(grid1);
        System.out.println("示例 1 构建完成 (根节点 isLeaf: " + root1.isLeaf + ")");
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[][] grid2 = {
            {1, 1, 1, 1, 0, 0, 0, 0},
            {1, 1, 1, 1, 0, 0, 0, 0},
            {1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 0, 0, 0, 0},
            {1, 1, 1, 1, 0, 0, 0, 0},
            {1, 1, 1, 1, 0, 0, 0, 0},
            {1, 1, 1, 1, 0, 0, 0, 0}
        };
        System.out.println("示例 2 构建开始...");
        Node root2 = solution.construct(grid2);
        System.out.println("示例 2 构建完成 (根节点 isLeaf: " + root2.isLeaf + ")");

        // 注意：由于树的结构比较复杂，这里仅打印根节点状态作为演示。
        // 实际验证通常依赖于 LeetCode 的判题系统或编写专门的层序遍历序列化函数。
    }
}
```
