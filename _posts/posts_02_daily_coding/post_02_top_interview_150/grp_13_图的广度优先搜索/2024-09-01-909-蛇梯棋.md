---
title: 909-蛇梯棋
date: 2024-09-01 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 图的广度优先搜索]
tags: [图的广度优先搜索]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232711922.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

好的，这是从图片中整理出的题目描述和解答代码。

### 题目：909. 蛇梯棋

给你一个大小为 `n x n` 的整数矩阵 `board`，方格按从 `1` 到 `n^2` 编号，编号遵循 **转行交替方向** 方式，从左下角开始（即，从 `board[n-1][0]` 开始）的每一行改变方向。

你一开始位于棋盘上的方格 `1`。每一回合，玩家从当前方格 `curr` 开始出发，按下述要求前进：

- 选定目标方格 `next`，目标方格的编号在范围 `[curr + 1, min(curr + 6, n^2)]` 内。
  - 该选择模拟了掷 **六面体骰子** 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。
- 传送玩家：如果目标方格 `next` 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 `next`。
- 当玩家到达编号 `n^2` 的方格时，游戏结束。

如果 `board[r][c] != -1`，位于 `r` 行 `c` 列的棋盘格中可能存在“蛇”或“梯子”。那个蛇或梯子的目的地将会是 `board[r][c]`。编号为 `1` 和 `n^2` 的方格不是任何蛇或梯子的起点。

**注意**，玩家在每次掷骰的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 **不能** 继续移动。

返回达到编号为 `n^2` 的方格所需的最少掷骰次数，如果不可能，则返回 `-1`。

---

**示例 1:**

- **输入:** `board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]`
- **输出:** 4

---

**示例 2:**

- **输入:** `board = [[-1,-1],[-1,3]]`
- **输出:** 1

---

**提示:**

- `n == board.length == board[i].length`
- `2 <= n <= 20`
- `board[i][j]` 的值是 `-1` 或在范围 `[1, n^2]` 内
- 编号为 `1` 和 `n^2` 的方格上没有蛇或梯子

---

### Java 8 解答 (赛码网格式)

**算法思路：(广度优先搜索 BFS)**
这个问题要求的是“最少次数”，这是一个典型的 **广度优先搜索 (BFS)** 应用场景。我们可以把棋盘的每个方格看作图中的一个节点，掷骰子的移动看作是边。

1.  **坐标转换:** 棋盘的编号方式比较特殊（转行交替），而我们的 `board` 数组是常规的二维索引。因此，首先需要一个辅助函数 `getCoordinates(square, n)`，能将方格编号 `square` 转换为 `[row, col]` 坐标。
2.  **BFS 初始化:**
    - 创建一个队列 `queue`，用于存放 `[当前方格编号, 移动步数]`。将 `[1, 0]` 加入队列。
    - 创建一个 `visited` 数组或集合，用于记录已经访问过的方格，避免重复计算和死循环。将方格 `1` 标记为已访问。
3.  **BFS 循环:**
    - 当队列不为空时，取出队首元素 `[currentSquare, moves]`。
    - 如果 `currentSquare` 是终点 `n^2`，则返回 `moves`。
    - 模拟掷骰子，遍历从 `currentSquare + 1` 到 `min(currentSquare + 6, n^2)` 的所有可能目的地 `nextSquare`。
    - 对于每个 `nextSquare`：
      a. 使用坐标转换函数找到它在 `board` 上的 `[row, col]`。
      b. 检查该位置是否有蛇或梯子。如果有，更新 `nextSquare` 到传送后的目的地。
      c. 如果最终的目的地 `nextSquare` **没有被访问过**，则将其标记为已访问，并将其和 `moves + 1` 一起加入队列。
4.  如果队列变空后仍未到达终点，说明无法到达，返回 `-1`。

```java
import java.util.LinkedList;
import java.util.Queue;

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    public int snakesAndLadders(int[][] board) {
        int n = board.length;
        int target = n * n;

        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{1, 0}); // {current_square, moves}

        boolean[] visited = new boolean[n * n + 1];
        visited[1] = true;

        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int square = current[0];
            int moves = current[1];

            if (square == target) {
                return moves;
            }

            // 模拟掷骰子
            for (int i = 1; i <= 6; i++) {
                int nextSquare = square + i;
                if (nextSquare > target) {
                    break;
                }

                int[] coords = getCoordinates(nextSquare, n);
                int row = coords[0];
                int col = coords[1];

                // 检查是否有蛇或梯子
                if (board[row][col] != -1) {
                    nextSquare = board[row][col];
                }

                if (!visited[nextSquare]) {
                    visited[nextSquare] = true;
                    queue.offer(new int[]{nextSquare, moves + 1});
                }
            }
        }

        return -1;
    }

    /**
     * 将方格编号转换为二维坐标
     */
    private int[] getCoordinates(int square, int n) {
        int rowFromBottom = (square - 1) / n;
        int row = n - 1 - rowFromBottom;
        int col;

        // 判断当前行的方向
        if (rowFromBottom % 2 == 0) { // 从左到右
            col = (square - 1) % n;
        } else { // 从右到左
            col = n - 1 - ((square - 1) % n);
        }

        return new int[]{row, col};
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        int[][] board1 = {
            {-1,-1,-1,-1,-1,-1},
            {-1,-1,-1,-1,-1,-1},
            {-1,-1,-1,-1,-1,-1},
            {-1,35,-1,-1,13,-1},
            {-1,-1,-1,-1,-1,-1},
            {-1,15,-1,-1,-1,-1}
        };
        System.out.println("输入: board = [...]");
        int result1 = solution.snakesAndLadders(board1);
        System.out.println("输出: " + result1); // 预期输出: 4
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[][] board2 = {{-1,-1},{-1,3}};
        System.out.println("输入: board = [[-1,-1],[-1,3]]");
        int result2 = solution.snakesAndLadders(board2);
        System.out.println("输出: " + result2); // 预期输出: 1
    }
}
```
