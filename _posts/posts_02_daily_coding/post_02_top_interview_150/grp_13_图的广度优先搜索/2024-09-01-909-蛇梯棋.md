---
title: 909. 蛇梯棋
date: 2024-09-01 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 图的广度优先搜索]
tags: [图的广度优先搜索]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232711922.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个大小为 `n x n` 的整数矩阵 `board`，方格按从 `1` 到 `n^2` 编号，编号遵循 **转行交替方向** 方式，从左下角开始（即，从 `board[n-1][0]` 开始）的每一行改变方向。

你一开始位于棋盘上的方格 `1`。每一回合，玩家从当前方格 `curr` 开始出发，按下述要求前进：

- 选定目标方格 `next`，目标方格的编号在范围 `[curr + 1, min(curr + 6, n^2)]` 内。

  - 该选择模拟了掷 **六面体骰子** 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。

- 传送玩家：如果目标方格 `next` 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 `next`。
- 当玩家到达编号 `n^2` 的方格时，游戏结束。

如果 `board[r][c] != -1`，位于 `r` 行 `c` 列的棋盘格中可能存在“蛇”或“梯子”。那个蛇或梯子的目的地将会是 `board[r][c]`。编号为 `1` 和 `n^2` 的方格不是任何蛇或梯子的起点。

**注意**，玩家在每次掷骰的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 **不能** 继续移动。

返回达到编号为 `n^2` 的方格所需的最少掷骰次数，如果不可能，则返回 `-1`。

**示例 1:**

- **输入:** `board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]`
- **输出:** 4

**示例 2:**

- **输入:** `board = [[-1,-1],[-1,3]]`
- **输出:** 1

**提示:**

- `n == board.length == board[i].length`
- `2 <= n <= 20`
- `board[i][j]` 的值是 `-1` 或在范围 `[1, n^2]` 内
- 编号为 `1` 和 `n^2` 的方格上没有蛇或梯子

## 题解

### 解法：广度优先搜索 (BFS)

**思路：**

这个问题可以被建模为寻找从起点（节点 1）到终点（节点 $n^2$）的最短路径问题。由于每一步掷骰子的代价都是 1，**广度优先搜索 (BFS)** 是求无权图最短路径的最佳选择。

核心难点在于棋盘坐标与数字编号的转换。棋盘是 $n \times n$ 的，编号从 1 到 $n^2$，起始于左下角，呈蛇形（Boustrophedon）交替上升。

1.  **坐标转换**：

    我们需要一个辅助函数，根据当前的数字编号 `id` 计算出它在矩阵中的行列坐标 `(r, c)`。

    - 假设行号从底部向上数是 `row` (0-indexed)：`row = (id - 1) / n`。
    - 列号 `col`：`col = (id - 1) % n`。
    - **实际矩阵行索引**：因为矩阵索引从上到下，所以实际行 `x = n - 1 - row`。
    - **实际矩阵列索引**：

      - 如果 `row` 是偶数（从底部数第 0, 2... 行），方向是从左到右，实际列 `y = col`。
      - 如果 `row` 是奇数（从底部数第 1, 3... 行），方向是从右到左，实际列 `y = n - 1 - col`。

2.  **BFS 流程**：

    - 创建一个队列 `queue`，将起点 `1` 加入。
    - 创建一个 `visited` 数组，记录访问过的节点，防止重复处理和死循环。
    - 维护一个 `step` 变量记录掷骰子次数。
    - 当队列不为空时：

      - 遍历当前层的所有节点。
      - 对于当前节点 `curr`，枚举骰子可能的点数 $1 \dots 6$。
      - 计算 `next = curr + i`。如果 `next` 超过 $n^2$，跳过。
      - **检查蛇/梯子**：根据 `next` 计算出棋盘坐标 `(r, c)`。如果 `board[r][c] != -1`，说明这里有蛇或梯子，**强制传送**，目标变为 `destination = board[r][c]`；否则目标保持为 `next`。
      - 如果 `destination` 等于 $n^2$，直接返回 `step + 1`。
      - 如果 `destination` 未被访问过，将其加入队列并标记为已访问。

**复杂度分析：**

- **时间复杂度：** $O(N^2)$。棋盘共有 $N^2$ 个格子，BFS 过程中每个格子最多入队一次，每次扩展最多检查 6 个方向。
- **空间复杂度：** $O(N^2)$。需要 `visited` 数组记录状态，队列最坏情况下也可能存储 $O(N^2)$ 个节点。

**代码片段：**

```java
public int snakesAndLadders(int[][] board) {
    int n = board.length;
    boolean[] visited = new boolean[n * n + 1];
    Queue<Integer> queue = new LinkedList<>();

    // 起点是 1
    queue.offer(1);
    visited[1] = true;
    int step = 0;

    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            int curr = queue.poll();
            if (curr == n * n) return step;

            // 掷骰子 1-6
            for (int k = 1; k <= 6; k++) {
                int next = curr + k;
                if (next > n * n) break;

                // 坐标转换
                int[] pos = id2rc(next, n);
                int r = pos[0];
                int c = pos[1];

                // 检查是否有蛇或梯子
                // 如果 board[r][c] != -1，说明必须跳到指定位置
                // 否则，位置就是骰子投出的 next
                int dest = (board[r][c] != -1) ? board[r][c] : next;

                if (!visited[dest]) {
                    visited[dest] = true;
                    queue.offer(dest);
                }
            }
        }
        step++;
    }

    return -1;
}

// 辅助函数：将编号转换为矩阵坐标
private int[] id2rc(int id, int n) {
    int r = (id - 1) / n; // 从底部往上数的行索引 (0, 1, 2...)
    int c = (id - 1) % n; // 基本列索引

    int x = n - 1 - r; // 矩阵实际行索引
    int y = (r % 2 == 0) ? c : n - 1 - c; // 矩阵实际列索引（处理蛇形方向）

    return new int[]{x, y};
}
```

### 完整代码

```java
import java.util.LinkedList;
import java.util.Queue;

public class Main {

    // 核心算法实现
    public static int snakesAndLadders(int[][] board) {
        int n = board.length;
        // 标记数组，范围是 1 到 n^2
        boolean[] visited = new boolean[n * n + 1];
        Queue<Integer> queue = new LinkedList<>();

        // 初始状态
        queue.offer(1);
        visited[1] = true;
        int step = 0;

        while (!queue.isEmpty()) {
            int size = queue.size();
            // 层序遍历
            for (int i = 0; i < size; i++) {
                int curr = queue.poll();

                // 如果到达终点，返回步数
                if (curr == n * n) {
                    return step;
                }

                // 尝试掷骰子 1 到 6
                for (int k = 1; k <= 6; k++) {
                    int next = curr + k;
                    // 超出棋盘范围，停止
                    if (next > n * n) break;

                    // 获取 next 在棋盘上的实际坐标
                    int[] pos = idToPosition(next, n);
                    int r = pos[0];
                    int c = pos[1];

                    // 如果该位置有蛇或梯子，必须传送；否则停留在 next
                    int destination = (board[r][c] != -1) ? board[r][c] : next;

                    // 如果该目的地没有访问过，加入队列
                    if (!visited[destination]) {
                        visited[destination] = true;
                        queue.offer(destination);
                    }
                }
            }
            step++;
        }

        return -1;
    }

    // 坐标转换辅助函数
    private static int[] idToPosition(int id, int n) {
        // 计算从底部开始的行号 (0-indexed)
        int rowFromBottom = (id - 1) / n;
        // 计算原始列号
        int colSimple = (id - 1) % n;

        // 计算矩阵中的实际行号 (顶部为0)
        int r = n - 1 - rowFromBottom;

        // 计算矩阵中的实际列号 (处理蛇形交替)
        // 偶数行(底部起): 从左到右 -> colSimple
        // 奇数行(底部起): 从右到左 -> n - 1 - colSimple
        int c = (rowFromBottom % 2 == 0) ? colSimple : n - 1 - colSimple;

        return new int[]{r, c};
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int[][] board1 = {
            {-1,-1,-1,-1,-1,-1},
            {-1,-1,-1,-1,-1,-1},
            {-1,-1,-1,-1,-1,-1},
            {-1,35,-1,-1,13,-1},
            {-1,-1,-1,-1,-1,-1},
            {-1,15,-1,-1,-1,-1}
        };

        System.out.println("示例 1 输出: " + snakesAndLadders(board1));
        // 预期: 4
        // 路径: 1 -> (骰子2) -> 3 -> (梯子) -> 15 -> (骰子) -> 17 -> (骰子) -> 23 -> (梯子) -> 35 -> (骰子1) -> 36
        // 或者: 1 -> 2 (梯子->15) -> 17 (梯子->13，不可行)
        // 最优: 1 -> 2 (梯子->15) -> 17 -> 22 -> 35 -> 36 ? 不对
        // 最优路径解释:
        // 1. Start at 1. Roll 2 to 3. No ladder. (Wait, board[-1][15] is row 5 col 1. Id 2. board[5][1]=15)
        // 正确路径:
        // 1 (start)
        // -> Roll 2 to 2 (board[5][1]=15, jump to 15) [Step 1]
        // -> From 15, Roll 2 to 17 (board[-1]) [Step 2]
        // -> From 17, Roll 4 to 21 (board[-1]) -> Wait, is there a better way?
        // 实际上: 1 -> 2(跳15) -> 17 -> 22(跳35) -> 36. 总共4步.
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        int[][] board2 = {
            {-1, -1},
            {-1, 3}
        };
        // n=2, 终点4.
        // board[1][0] is 1. board[1][1] is 2. board[0][1] is 3. board[0][0] is 4.
        // board[1][1] = 3. 意味着在 ID 2 的位置有个梯子去 3.
        System.out.println("示例 2 输出: " + snakesAndLadders(board2));
        // 预期: 1 (直接掷出 1 到 2，梯子传送到 3？不，直接掷出 1 到 ID 2 (board值为3)，传送到 3。如果在 ID 1 掷出 3 可以直接到 4，只需 1 步。)
        // 解释: Start 1. Roll 1 -> ID 2 (Jump to 3). Roll 1 -> ID 4. Total 2 steps.
        // BUT: Can roll 3? No, min(1+6, 4) = 4.
        // Try Roll 1: Land on 2 -> Jump to 3. (1 step). From 3 roll 1 to 4 (2 steps total).
        // Try Roll 2: Land on 3. (1 step). From 3 roll 1 to 4 (2 steps total).
        // Try Roll 3: Land on 4. (1 step).
        // 所以最少是 1 步。
        System.out.println("-----------------------------");
    }
}
```
