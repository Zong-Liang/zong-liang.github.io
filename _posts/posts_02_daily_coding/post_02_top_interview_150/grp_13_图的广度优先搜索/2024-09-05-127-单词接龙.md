---
title: 127-单词接龙
date: 2024-09-05 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 图的广度优先搜索]
tags: [图的广度优先搜索]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232846163.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


### 题目：127. 单词接龙

字典 `wordList` 中从单词 `beginWord` 到 `endWord` 的 **转换序列** 是一个按如下规格形成的序列 `beginWord -> s1 -> s2 -> ... -> sk`：

- 每一对相邻的单词只差一个字母。
- 对于 `1 <= i <= k` 时，每个 `si` 都在 `wordList` 中。注意，`beginWord` 不需要 nécessairement 在 `wordList` 中。
- `sk == endWord`

给你两个单词 `beginWord` 和 `endWord` 和一个字典 `wordList`，返回从 `beginWord` 到 `endWord` 的 **最短转换序列** 中的 **单词数目**。如果不存在这样的转换序列，返回 `0`。

---

**示例 1:**

- **输入:** `beginWord = "hit"`, `endWord = "cog"`, `wordList = ["hot","dot","dog","lot","log","cog"]`
- **输出:** 5
- **解释:** 一个最短转换序列是 `"hit" -> "hot" -> "dot" -> "dog" -> "cog"`, 返回它的长度 5。

**示例 2:**

- **输入:** `beginWord = "hit"`, `endWord = "cog"`, `wordList = ["hot","dot","dog","lot","log"]`
- **输出:** 0
- **解释:** `endWord` `"cog"` 不在字典中，所以无法进行转换。

---

**提示:**

- `1 <= beginWord.length <= 10`
- `endWord.length == beginWord.length`
- `1 <= wordList.length <= 5000`
- `wordList[i].length == beginWord.length`
- `beginWord`、`endWord` 和 `wordList[i]` 由小写英文字母组成
- `beginWord != endWord`
- `wordList` 中的所有字符串 **互不相同**

---

### Java 8 解答 (赛码网格式)

**算法思路：(广度优先搜索 BFS)**
这个问题可以被建模为一个图论问题：寻找图中两个节点之间的最短路径。每个单词可以看作是一个节点，如果两个单词只相差一个字母，则它们之间有一条边。因为我们要求的是 **最短** 路径，所以 **广度优先搜索 (BFS)** 是最合适的算法。

1.  **预处理：** 将 `wordList` 放入一个 `Set` 中，以便快速查询一个单词是否存在于字典中。首先检查 `endWord` 是否在 `wordList` 中，如果不在，直接返回 `0`。
2.  **BFS 初始化:**
    - 创建一个队列 `queue`，并将 `beginWord` 加入队列。
    - 创建一个 `visited` 集合，用于记录已经访问过的单词，避免循环。将 `beginWord` 加入 `visited`。
    - 初始化 `level = 1`，代表转换序列的初始长度。
3.  **BFS 循环:**
    - 当队列不为空时，处理当前层的所有节点。
    - 对于队列中的每个单词 `currentWord`：
      a. 生成所有与 `currentWord` 只相差一个字母的“邻居”单词。这可以通过遍历 `currentWord` 的每一位，并将其替换为 'a' 到 'z' 中的其他字母来实现。
      b. 对于每个生成的邻居 `nextWord`：
      _ 如果 `nextWord` 等于 `endWord`，说明我们找到了最短路径，返回 `level + 1`。
      _ 如果 `nextWord` 存在于 `wordList` 中且 **未被访问过**，则将其加入队列和 `visited` 集合。
    - 处理完当前层的所有节点后，将 `level` 加一。
4.  如果队列变空后仍未找到 `endWord`，说明不存在转换路径，返回 `0`。

```java
import java.util.*;

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        // 1. 预处理
        Set<String> wordSet = new HashSet<>(wordList);
        if (!wordSet.contains(endWord)) {
            return 0;
        }

        // 2. BFS 初始化
        Queue<String> queue = new LinkedList<>();
        queue.offer(beginWord);

        Set<String> visited = new HashSet<>();
        visited.add(beginWord);

        int level = 1;

        // 3. BFS 循环
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            for (int i = 0; i < levelSize; i++) {
                String currentWord = queue.poll();

                // 检查是否到达终点
                if (currentWord.equals(endWord)) {
                    return level;
                }

                // 生成所有可能的下一个单词
                char[] charArray = currentWord.toCharArray();
                for (int j = 0; j < charArray.length; j++) {
                    char originalChar = charArray[j];
                    for (char c = 'a'; c <= 'z'; c++) {
                        if (c == originalChar) continue;

                        charArray[j] = c;
                        String nextWord = new String(charArray);

                        // 如果 nextWord 在字典中且未被访问
                        if (wordSet.contains(nextWord) && !visited.contains(nextWord)) {
                            queue.offer(nextWord);
                            visited.add(nextWord);
                        }
                    }
                    // 恢复原始字符
                    charArray[j] = originalChar;
                }
            }
            // 进入下一层
            level++;
        }

        // 如果队列为空还没找到，说明无法转换
        return 0;
    }


    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        String beginWord1 = "hit";
        String endWord1 = "cog";
        List<String> wordList1 = Arrays.asList("hot","dot","dog","lot","log","cog");
        System.out.println("输入: beginWord = \"" + beginWord1 + "\", endWord = \"" + endWord1 + "\", wordList = " + wordList1);
        int result1 = solution.ladderLength(beginWord1, endWord1, wordList1);
        System.out.println("输出: " + result1); // 预期输出: 5
        System.out.println();

        System.out.println("--- 示例 2 ---");
        String beginWord2 = "hit";
        String endWord2 = "cog";
        List<String> wordList2 = Arrays.asList("hot","dot","dog","lot","log");
        System.out.println("输入: beginWord = \"" + beginWord2 + "\", endWord = \"" + endWord2 + "\", wordList = " + wordList2);
        int result2 = solution.ladderLength(beginWord2, endWord2, wordList2);
        System.out.println("输出: " + result2); // 预期输出: 0
    }
}
```
