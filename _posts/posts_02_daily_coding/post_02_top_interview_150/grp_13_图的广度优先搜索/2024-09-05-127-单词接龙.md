---
title: 127. 单词接龙
date: 2024-09-05 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 图的广度优先搜索]
tags: [图的广度优先搜索]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232846163.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

字典 `wordList` 中从单词 `beginWord` 到 `endWord` 的 **转换序列** 是一个按如下规格形成的序列 `beginWord -> s1 -> s2 -> ... -> sk`：

- 每一对相邻的单词只差一个字母。
- 对于 `1 <= i <= k` 时，每个 `si` 都在 `wordList` 中。注意，`beginWord` 不需要 nécessairement 在 `wordList` 中。
- `sk == endWord`

给你两个单词 `beginWord` 和 `endWord` 和一个字典 `wordList`，返回从 `beginWord` 到 `endWord` 的 **最短转换序列** 中的 **单词数目**。如果不存在这样的转换序列，返回 `0`。

**示例 1:**

- **输入:** `beginWord = "hit"`, `endWord = "cog"`, `wordList = ["hot","dot","dog","lot","log","cog"]`
- **输出:** 5
- **解释:** 一个最短转换序列是 `"hit" -> "hot" -> "dot" -> "dog" -> "cog"`, 返回它的长度 5。

**示例 2:**

- **输入:** `beginWord = "hit"`, `endWord = "cog"`, `wordList = ["hot","dot","dog","lot","log"]`
- **输出:** 0
- **解释:** `endWord` `"cog"` 不在字典中，所以无法进行转换。

**提示:**

- `1 <= beginWord.length <= 10`
- `endWord.length == beginWord.length`
- `1 <= wordList.length <= 5000`
- `wordList[i].length == beginWord.length`
- `beginWord`、`endWord` 和 `wordList[i]` 由小写英文字母组成
- `beginWord != endWord`
- `wordList` 中的所有字符串 **互不相同**

## 题解

### 解法一：广度优先搜索 (BFS)

**思路：**

这个问题本质上是要求无向无权图中的 **最短路径**。

- **节点**：单词。
- **边**：如果两个单词只相差一个字母，则它们之间有一条边。
- **目标**：找到从 `beginWord` 到 `endWord` 的最短路径长度。

由于要求的是最短路径，**广度优先搜索 (BFS)** 是最合适的算法。BFS 会一层一层地向外扩展，第一次遇到 `endWord` 时经过的层数就是最短路径长度。

**算法流程：**

1.  **预处理**：将 `wordList` 放入一个哈希集合 `wordSet` 中，以便在 $O(1)$ 时间内判断单词是否有效。如果 `endWord` 不在集合中，直接返回 0。
2.  **初始化**：

    - 创建一个队列 `queue`，将 `beginWord` 加入。
    - 为了避免重复访问导致死循环，我们需要记录已访问的节点。这里有一个小技巧：**直接从 `wordSet` 中移除已访问的单词**，这样就不需要额外的 `visited` 集合，且能保证每个单词只被访问一次。

3.  **BFS 循环**：

    - 只要队列不为空，进行循环。
    - 记录当前步数 `step`（初始为 1）。
    - 分层遍历：记录当前队列大小 `size`，循环 `size` 次处理当前层的所有单词。
    - **变换单词**：对于当前取出的单词，尝试将它的每一位字符从 `'a'` 替换到 `'z'`。
    - **检查**：

      - 生成的每个新单词，如果等于 `endWord`，说明找到了，返回 `step + 1`。
      - 如果新单词在 `wordSet` 中存在，说明它是邻居节点且未被访问，将其加入队列，并从 `wordSet` 中移除。

4.  **结束**：如果队列为空还没找到 `endWord`，说明无法转换，返回 0。

**复杂度分析：**

- **时间复杂度：** $O(N \times L^2)$。

  - $N$ 是 `wordList` 的长度，$L$ 是单词的长度。
  - BFS 中每个单词最多入队一次。
  - 对于每个单词，我们需要遍历 $L$ 个字符位置，每个位置尝试 26 个字母，生成新字符串并哈希查找需要 $O(L)$。所以处理一个单词是 $O(26 \times L \times L)$。
  - 总复杂度约为 $O(N \times L^2)$。鉴于 $L$ 很小（<= 10），这个解法非常高效。

- **空间复杂度：** $O(N \times L)$。需要存储 `wordSet` 和队列。

**代码片段：**

```java
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    Set<String> wordSet = new HashSet<>(wordList);
    if (!wordSet.contains(endWord)) return 0;

    Queue<String> queue = new LinkedList<>();
    queue.offer(beginWord);

    int step = 1;

    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            String currWord = queue.poll();

            // 尝试修改每一位字符
            char[] chars = currWord.toCharArray();
            for (int j = 0; j < chars.length; j++) {
                char originalChar = chars[j];

                for (char k = 'a'; k <= 'z'; k++) {
                    if (k == originalChar) continue;

                    chars[j] = k;
                    String nextWord = new String(chars);

                    if (nextWord.equals(endWord)) {
                        return step + 1;
                    }

                    if (wordSet.contains(nextWord)) {
                        queue.offer(nextWord);
                        wordSet.remove(nextWord); // 标记为已访问
                    }
                }
                chars[j] = originalChar; // 恢复
            }
        }
        step++;
    }
    return 0;
}
```

### 解法二：双向广度优先搜索 (Bidirectional BFS)

**思路：**

普通的 BFS 会随着层数增加，每一层的节点数呈指数级增长。如果起点和终点距离较远，搜索空间会非常大。

**双向 BFS** 从 `beginWord` 和 `endWord` 两端同时开始搜索，当两端的搜索范围有交集时，搜索结束。这通常能显著减少搜索的节点数量。

1.  使用两个集合 `beginSet` 和 `endSet` 分别存储从起点和终点扩散的节点。
2.  每次循环时，选择 **较小** 的那个集合进行扩展（平衡两端搜索进度）。
3.  在扩展过程中，如果生成的邻居节点已经在 **另一个集合** 中出现，说明路径打通，直接返回当前总步数。

**复杂度分析：**

- **时间复杂度：** 理论上仍是 $O(N \times L^2)$，但在实际运行中往往比单向 BFS 快很多。
- **空间复杂度：** $O(N \times L)$。

_(由于解法一已经足够解决问题且更易于面试手写，双向 BFS 作为一个优化思路提及，完整代码展示解法一的逻辑)_

### 完整代码

```java
import java.util.*;

public class Main {

    // 核心算法实现：单向 BFS
    public static int ladderLength(String beginWord, String endWord, List<String> wordList) {
        // 1. 将字典转换为 HashSet 以便快速查找 (O(1))
        Set<String> wordSet = new HashSet<>(wordList);

        // 剪枝：如果字典里没有 endWord，直接返回 0
        if (!wordSet.contains(endWord)) {
            return 0;
        }

        // 2. 初始化队列和步数
        Queue<String> queue = new LinkedList<>();
        queue.offer(beginWord);

        // 结果包含起点和终点，所以初始步数为 1
        int step = 1;

        // 3. 开始 BFS
        while (!queue.isEmpty()) {
            int size = queue.size(); // 当前层的节点个数

            // 遍历当前层
            for (int i = 0; i < size; i++) {
                String currWord = queue.poll();

                // 对当前单词的每一个位置进行替换尝试
                char[] chars = currWord.toCharArray();
                for (int j = 0; j < chars.length; j++) {
                    char originalChar = chars[j];

                    // 尝试 'a' 到 'z'
                    for (char k = 'a'; k <= 'z'; k++) {
                        if (k == originalChar) continue;

                        chars[j] = k;
                        String nextWord = new String(chars);

                        // 如果找到了 endWord，返回当前步数 + 1
                        if (nextWord.equals(endWord)) {
                            return step + 1;
                        }

                        // 如果 nextWord 在字典中，说明是合法的邻居节点
                        if (wordSet.contains(nextWord)) {
                            queue.offer(nextWord);
                            // 关键优化：立即从集合中移除，相当于标记 visited
                            // 避免后续重复访问造成死循环或效率降低
                            wordSet.remove(nextWord);
                        }
                    }
                    // 恢复当前位置的字符，以便进行下一个位置的变换
                    chars[j] = originalChar;
                }
            }
            // 一层遍历结束，步数加 1
            step++;
        }

        return 0;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        String beginWord1 = "hit";
        String endWord1 = "cog";
        List<String> wordList1 = new ArrayList<>(Arrays.asList("hot", "dot", "dog", "lot", "log", "cog"));

        System.out.println("示例 1 输入:");
        System.out.println("beginWord: " + beginWord1);
        System.out.println("endWord: " + endWord1);
        System.out.println("wordList: " + wordList1);

        int result1 = ladderLength(beginWord1, endWord1, wordList1);
        System.out.println("示例 1 输出: " + result1); // 预期: 5
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        String beginWord2 = "hit";
        String endWord2 = "cog";
        List<String> wordList2 = new ArrayList<>(Arrays.asList("hot", "dot", "dog", "lot", "log"));

        System.out.println("示例 2 输入:");
        System.out.println("beginWord: " + beginWord2);
        System.out.println("endWord: " + endWord2);
        System.out.println("wordList: " + wordList2);

        int result2 = ladderLength(beginWord2, endWord2, wordList2);
        System.out.println("示例 2 输出: " + result2); // 预期: 0
        System.out.println("-----------------------------");

        // --- 示例 3 测试 (直接相连) ---
        String beginWord3 = "a";
        String endWord3 = "c";
        List<String> wordList3 = new ArrayList<>(Arrays.asList("a", "b", "c"));

        System.out.println("示例 3 输入:");
        System.out.println("beginWord: " + beginWord3);
        System.out.println("endWord: " + endWord3);
        System.out.println("wordList: " + wordList3);

        int result3 = ladderLength(beginWord3, endWord3, wordList3);
        System.out.println("示例 3 输出: " + result3); // 预期: 2 (a -> c)
    }
}
```
