---
title: 433. 最小基因变化
date: 2024-09-04 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 图的广度优先搜索]
tags: [图的广度优先搜索]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232808756.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：433. 最小基因变化

基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 `'A'`、`'C'`、`'G'` 和 `'T'` 之一。

假设我们需要调查从基因序列 `start` 变为 `end` 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。

- 例如，`"AACCGGTT" --> "AACCGGTA"` 就是一次基因变化。

另有一个基因库 `bank` 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 `bank` 中）

给你两个基因序列 `start` 和 `end`，以及一个基因库 `bank`，请你找出并返回能够使 `start` 变化为 `end` 所需的 **最少变化次数**。如果无法完成此基因变化，返回 `-1`。

**注意：** 起始基因序列 `start` 默认是有效的，但是它并不一定会出现 在基因库中。

**示例 1:**

- **输入:** `start = "AACCGGTT"`, `end = "AACCGGTA"`, `bank = ["AACCGGTA"]`
- **输出:** 1

**示例 2:**

- **输入:** `start = "AACCGGTT"`, `end = "AAACGGTA"`, `bank = ["AACCGGTA", "AACCGCTA", "AAACGGTA"]`
- **输出:** 2

**示例 3:**

- **输入:** `start = "AAAAACCC"`, `end = "AACCCCCC"`, `bank = ["AAAACCCC", "AAACCCCC", "AACCCCCC"]`
- **输出:** 3

**提示:**

- `start.length == 8`
- `end.length == 8`
- `0 <= bank.length <= 10`
- `bank[i].length == 8`
- `start`、`end` 和 `bank[i]` 仅由字符 `['A', 'C', 'G', 'T']` 组成

## 题解

**算法思路：(广度优先搜索 BFS)**

这个问题与“单词接龙”非常相似，本质上是在一个由基因序列构成的图中寻找两个节点之间的最短路径。图中每个有效的基因序列是一个节点，如果两个序列只相差一个字符，则它们之间存在一条边。由于是求 **最少** 变化次数，**广度优先搜索 (BFS)** 是最适合的算法。

1.  **预处理：** 将 `bank` 转换为一个 `Set`，以便 O(1) 复杂度的查找。首先检查 `end` 是否在 `bank` 中，如果不在，则永远无法到达，直接返回 `-1`。
2.  **BFS 初始化:**
    - 创建一个队列 `queue`，并将起始基因 `start` 加入队列。
    - 创建一个 `visited` 集合来记录已访问过的基因，防止形成环路。将 `start` 加入 `visited`。
    - 初始化 `level = 0`，代表变化的次数。
3.  **BFS 循环:**
    - 当队列不为空时，逐层进行搜索。
    - 对于队列中的每个基因 `currentGene`：
      a. 如果 `currentGene` 等于 `end`，说明已经找到了最短路径，返回当前的 `level`。
      b. 尝试将 `currentGene` 的每一位字符替换为 `'A', 'C', 'G', 'T'` 中的一个，生成所有可能的“邻居”基因 `nextGene`。
      c. 对于每个生成的 `nextGene`： \* 如果它存在于基因库 `bank` 中且 **未被访问过**，则将其加入队列和 `visited` 集合。
    - 处理完当前层的所有节点后，将 `level` 加一。
4.  如果队列变空后仍未找到 `end`，说明不存在可行的变化路径，返回 `-1`。

```java
import java.util.*;


public class Main {

    public int minMutation(String start, String end, String[] bank) {
        // 1. 预处理
        Set<String> bankSet = new HashSet<>(Arrays.asList(bank));
        if (!bankSet.contains(end)) {
            return -1;
        }

        // 2. BFS 初始化
        char[] geneChars = {'A', 'C', 'G', 'T'};
        Queue<String> queue = new LinkedList<>();
        queue.offer(start);

        Set<String> visited = new HashSet<>();
        visited.add(start);

        int level = 0;

        // 3. BFS 循环
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            for (int i = 0; i < levelSize; i++) {
                String currentGene = queue.poll();

                // 检查是否到达终点
                if (currentGene.equals(end)) {
                    return level;
                }

                char[] charArray = currentGene.toCharArray();
                for (int j = 0; j < charArray.length; j++) {
                    char originalChar = charArray[j];
                    // 尝试替换当前位的字符
                    for (char c : geneChars) {
                        if (c == originalChar) continue;

                        charArray[j] = c;
                        String nextGene = new String(charArray);

                        // 如果 nextGene 在基因库中且未被访问
                        if (bankSet.contains(nextGene) && !visited.contains(nextGene)) {
                            queue.offer(nextGene);
                            visited.add(nextGene);
                        }
                    }
                    // 恢复原始字符
                    charArray[j] = originalChar;
                }
            }
            // 进入下一层
            level++;
        }

        // 如果队列为空还没找到，说明无法转换
        return -1;
    }


    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        String start1 = "AACCGGTT", end1 = "AACCGGTA";
        String[] bank1 = {"AACCGGTA"};
        System.out.println("输入: start = \"" + start1 + "\", end = \"" + end1 + "\", bank = " + Arrays.toString(bank1));
        int result1 = solution.minMutation(start1, end1, bank1);
        System.out.println("输出: " + result1); // 预期输出: 1
        System.out.println();

        System.out.println("--- 示例 2 ---");
        String start2 = "AACCGGTT", end2 = "AAACGGTA";
        String[] bank2 = {"AACCGGTA", "AACCGCTA", "AAACGGTA"};
        System.out.println("输入: start = \"" + start2 + "\", end = \"" + end2 + "\", bank = " + Arrays.toString(bank2));
        int result2 = solution.minMutation(start2, end2, bank2);
        System.out.println("输出: " + result2); // 预期输出: 2
        System.out.println();

        System.out.println("--- 示例 3 ---");
        String start3 = "AAAAACCC", end3 = "AACCCCCC";
        String[] bank3 = {"AAAACCCC", "AAACCCCC", "AACCCCCC"};
        System.out.println("输入: start = \"" + start3 + "\", end = \"" + end3 + "\", bank = " + Arrays.toString(bank3));
        int result3 = solution.minMutation(start3, end3, bank3);
        System.out.println("输出: " + result3); // 预期输出: 3
    }
}
```
