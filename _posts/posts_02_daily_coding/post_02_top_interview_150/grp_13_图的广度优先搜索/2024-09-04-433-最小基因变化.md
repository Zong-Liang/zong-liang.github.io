---
title: 433. 最小基因变化
date: 2024-09-04 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 图的广度优先搜索]
tags: [图的广度优先搜索]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232808756.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 `'A'`、`'C'`、`'G'` 和 `'T'` 之一。

假设我们需要调查从基因序列 `start` 变为 `end` 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。

- 例如，`"AACCGGTT" --> "AACCGGTA"` 就是一次基因变化。

另有一个基因库 `bank` 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 `bank` 中）

给你两个基因序列 `start` 和 `end`，以及一个基因库 `bank`，请你找出并返回能够使 `start` 变化为 `end` 所需的 **最少变化次数**。如果无法完成此基因变化，返回 `-1`。

**注意：** 起始基因序列 `start` 默认是有效的，但是它并不一定会出现 在基因库中。

**示例 1:**

- **输入:** `start = "AACCGGTT"`, `end = "AACCGGTA"`, `bank = ["AACCGGTA"]`
- **输出:** 1

**示例 2:**

- **输入:** `start = "AACCGGTT"`, `end = "AAACGGTA"`, `bank = ["AACCGGTA", "AACCGCTA", "AAACGGTA"]`
- **输出:** 2

**示例 3:**

- **输入:** `start = "AAAAACCC"`, `end = "AACCCCCC"`, `bank = ["AAAACCCC", "AAACCCCC", "AACCCCCC"]`
- **输出:** 3

**提示:**

- `start.length == 8`
- `end.length == 8`
- `0 <= bank.length <= 10`
- `bank[i].length == 8`
- `start`、`end` 和 `bank[i]` 仅由字符 `['A', 'C', 'G', 'T']` 组成

## 题解

### 解法：广度优先搜索 (BFS)

**思路：**

这是一个典型的 **最短路径** 问题。我们可以将每一个基因序列看作图中的一个 **节点**。

如果两个基因序列之间只有一个字符不同，则它们之间存在一条 **边**。

题目要求从 `start` 变为 `end` 的最少变化次数，也就是求无权图中的 **最短路径长度**。**广度优先搜索 (BFS)** 是解决此类问题的最佳选择。

**算法流程：**

1.  **预处理**：

    - 将 `bank` 转化为哈希集合 `bankSet`，以便在 $O(1)$ 时间内判断一个基因是否有效。
    - 如果 `end` 不在 `bankSet` 中，直接返回 `-1`（因为最终目标必须是合法的）。

2.  **初始化 BFS**：

    - 创建一个队列 `queue`，将 `start` 加入队列。
    - 创建一个哈希集合 `visited`，记录已经访问过的基因序列，防止走回头路（死循环）。初始将 `start` 加入 `visited`。
    - 初始化步数 `steps = 0`。

3.  **BFS 循环**：

    - 当队列不为空时，遍历当前层的所有节点。
    - 对于当前取出的基因字符串 `curr`，尝试改变它的每一个字符（共 8 个位置），将其变为 `'A', 'C', 'G', 'T'` 中的其他字符。
    - 生成的新字符串 `next` 需要满足：

      1.  在 `bankSet` 中。
      2.  没有被访问过 (`!visited.contains(next)`).

    - 如果 `next` 等于 `end`，说明找到了目标，返回 `steps + 1`。
    - 否则，将 `next` 加入队列，并标记为已访问。
    - 当前层遍历结束后，`steps` 加 1。

4.  **无法到达**：如果队列为空仍未找到 `end`，返回 `-1`。

**复杂度分析：**

- **时间复杂度：** $O(N \times L \times 4)$。

  - $N$ 是基因库 `bank` 的大小。
  - $L$ 是基因序列的长度（固定为 8）。
  - 4 代表基因字符的种类（A, C, G, T）。
  - BFS 最多访问所有合法的节点，对于每个节点，我们需要尝试 $L \times 4$ 种突变。

- **空间复杂度：** $O(N \times L)$。需要集合来存储基因库和已访问节点，队列中最多也存储 $N$ 个字符串。

**代码片段：**

```java
public int minMutation(String start, String end, String[] bank) {
    Set<String> bankSet = new HashSet<>(Arrays.asList(bank));
    if (!bankSet.contains(end)) return -1;

    char[] genes = {'A', 'C', 'G', 'T'};
    Queue<String> queue = new LinkedList<>();
    queue.offer(start);

    Set<String> visited = new HashSet<>();
    visited.add(start);

    int steps = 0;

    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            String curr = queue.poll();
            if (curr.equals(end)) return steps;

            char[] currArray = curr.toCharArray();
            // 尝试修改每一个位置的字符
            for (int j = 0; j < 8; j++) {
                char oldChar = currArray[j];
                for (char gene : genes) {
                    if (gene == oldChar) continue;

                    currArray[j] = gene;
                    String next = new String(currArray);

                    if (bankSet.contains(next) && !visited.contains(next)) {
                        visited.add(next);
                        queue.offer(next);
                    }
                }
                // 恢复字符，以便进行下一个位置的尝试
                currArray[j] = oldChar;
            }
        }
        steps++;
    }

    return -1;
}
```

### 完整代码

```java
import java.util.*;

public class Main {

    // 核心算法实现
    public static int minMutation(String start, String end, String[] bank) {
        // 1. 将 bank 转换为 Set 以实现 O(1) 查找
        Set<String> bankSet = new HashSet<>();
        for (String s : bank) {
            bankSet.add(s);
        }

        // 如果目标基因不在基因库中，直接返回 -1
        if (!bankSet.contains(end)) {
            return -1;
        }

        // 2. BFS 初始化
        char[] geneChars = {'A', 'C', 'G', 'T'};
        Queue<String> queue = new LinkedList<>();
        queue.offer(start);

        Set<String> visited = new HashSet<>();
        visited.add(start);

        int steps = 0;

        // 3. 开始 BFS 遍历
        while (!queue.isEmpty()) {
            int size = queue.size(); // 当前层的节点数

            // 遍历当前层的所有基因
            for (int i = 0; i < size; i++) {
                String curr = queue.poll();

                // 如果找到目标，返回步数
                if (curr.equals(end)) {
                    return steps;
                }

                // 对当前基因的 8 个位置进行突变尝试
                char[] currArr = curr.toCharArray();
                for (int j = 0; j < 8; j++) {
                    char originalChar = currArr[j];

                    // 尝试替换为 A, C, G, T
                    for (char g : geneChars) {
                        if (g == originalChar) continue;

                        currArr[j] = g;
                        String nextGene = new String(currArr);

                        // 如果突变后的基因在库中且未访问过
                        if (bankSet.contains(nextGene) && !visited.contains(nextGene)) {
                            visited.add(nextGene);
                            queue.offer(nextGene);
                        }
                    }
                    // 回溯：恢复当前位置的字符，准备下一次循环修改下一个位置
                    currArr[j] = originalChar;
                }
            }
            // 当前层遍历完，步数 +1
            steps++;
        }

        return -1;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        String start1 = "AACCGGTT";
        String end1 = "AACCGGTA";
        String[] bank1 = {"AACCGGTA"};

        System.out.println("示例 1 输入:");
        System.out.println("start: " + start1);
        System.out.println("end:   " + end1);
        System.out.println("bank:  " + Arrays.toString(bank1));

        int res1 = minMutation(start1, end1, bank1);
        System.out.println("示例 1 输出: " + res1); // 预期: 1
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        String start2 = "AACCGGTT";
        String end2 = "AAACGGTA";
        String[] bank2 = {"AACCGGTA", "AACCGCTA", "AAACGGTA"};

        System.out.println("示例 2 输入:");
        System.out.println("start: " + start2);
        System.out.println("end:   " + end2);
        System.out.println("bank:  " + Arrays.toString(bank2));

        int res2 = minMutation(start2, end2, bank2);
        System.out.println("示例 2 输出: " + res2); // 预期: 2
        System.out.println("-----------------------------");

        // --- 示例 3 测试 ---
        String start3 = "AAAAACCC";
        String end3 = "AACCCCCC";
        String[] bank3 = {"AAAACCCC", "AAACCCCC", "AACCCCCC"};

        System.out.println("示例 3 输入:");
        System.out.println("start: " + start3);
        System.out.println("end:   " + end3);
        System.out.println("bank:  " + Arrays.toString(bank3));

        int res3 = minMutation(start3, end3, bank3);
        System.out.println("示例 3 输出: " + res3); // 预期: 3
    }
}
```
