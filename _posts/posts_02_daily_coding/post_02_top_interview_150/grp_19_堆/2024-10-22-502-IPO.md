---
title: 502-IPO
date: 2024-10-22 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 堆]
tags: [堆]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234747452.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

好的，这是从图片中整理出的题目描述和解答代码。

### 题目：502. IPO

假设力扣（LeetCode）即将开始 **IPO**。为了以更高的价格将股票卖给风险投资公司，力扣希望在 IPO 之前开展一些项目以增加其资本。由于资源有限，它只能在 IPO 之前完成最多 `k` 个不同的项目。帮助力扣设计完成最多 `k` 个不同项目后得到最大总资本的方式。

给你 `n` 个项目。对于每个项目 `i`，它都有一个纯利润 `profits[i]` 和启动该项目需要的最小资本 `capital[i]`。

最初，你的资本为 `w`。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。

总而言之，从给定项目中选择 **最多** `k` 个不同项目的列表，以 **最大化最终资本**，并输出最终可获得的最多的资本。

答案保证在 32 位有符号整数范围内。

---

**示例 1:**

- **输入:** `k = 2`, `w = 0`, `profits = [1,2,3]`, `capital = [0,1,1]`
- **输出:** 4
- **解释:**
  由于你的初始资本为 0，你仅可以从 0 号项目开始。
  在完成后，你将获得 1 的利润，你的总资本将变为 1。
  此时你可以选择开始 1 号或 2 号项目。
  由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。
  因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。

**示例 2:**

- **输入:** `k = 3`, `w = 0`, `profits = [1,2,3]`, `capital = [0,1,2]`
- **输出:** 6

---

**提示:**

- `1 <= k <= 10^5`
- `0 <= w <= 10^9`
- `n == profits.length`
- `n == capital.length`
- `1 <= n <= 10^5`
- `0 <= profits[i] <= 10^4`
- `0 <= capital[i] <= 10^9`

---

### Java 8 解答 (赛码网格式)

**算法思路：(贪心 + 优先队列)**
这是一个典型的贪心问题。在每一步，我们都想选择当前 **能够承担得起** 的项目中 **利润最高** 的一个来做。

1.  **数据准备:** 将 `capital` 和 `profits` 组合成一个项目列表，并按所需资本 `capital` 从小到大排序。
2.  **贪心选择:** 我们循环 `k` 次，代表最多能做的 `k` 个项目。
    - 在每一次循环中，我们找出所有当前资本 `w` 能够启动的项目。
    - 将这些可启动项目 的 **利润** 放入一个 **大顶堆**（`PriorityQueue`）。
    - 从大顶堆中取出堆顶元素，这就是当前能做的、利润最高的项目。
    - 将这个项目的利润加到我们的资本 `w` 上。
3.  重复这个过程 `k` 次，或者直到我们再也无法启动任何新项目（大顶堆为空）。

通过这种方式，我们确保每一步都做出了局部最优（利润最大）的选择，从而最终达到全局最优。

```java
import java.util.Arrays;
import java.util.PriorityQueue;

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    /**
     * 计算完成最多 k 个项目后能得到的最大总资本。
     *
     * @param k       最多可完成的项目数
     * @param w       初始资本
     * @param profits 各项目的利润
     * @param capital 启动各项目所需的资本
     * @return 最大化的最终资本
     */
    public static int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
        int n = profits.length;
        // 创建一个二维数组来存储 [capital, profit] 对
        int[][] projects = new int[n][2];
        for (int i = 0; i < n; i++) {
            projects[i][0] = capital[i];
            projects[i][1] = profits[i];
        }

        // 按所需资本对项目进行升序排序
        Arrays.sort(projects, (a, b) -> a[0] - b[0]);

        // 创建一个大顶堆，用于存储当前可启动项目的所有利润
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((x, y) -> y - x);

        // 指向已处理项目的指针
        int projectPointer = 0;

        // 循环 k 次，选择 k 个项目
        for (int i = 0; i < k; i++) {
            // 将所有当前资本 w 可启动的项目利润加入大顶堆
            while (projectPointer < n && projects[projectPointer][0] <= w) {
                maxHeap.add(projects[projectPointer][1]);
                projectPointer++;
            }

            // 如果堆为空，说明当前资本无法启动任何新项目，提前结束
            if (maxHeap.isEmpty()) {
                break;
            }

            // 贪心选择：做当前可做的项目中利润最高的那个
            w += maxHeap.poll();
        }

        return w;
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int k1 = 2, w1 = 0;
        int[] profits1 = {1, 2, 3};
        int[] capital1 = {0, 1, 1};
        System.out.println("输入: k = " + k1 + ", w = " + w1 + ", profits = " + Arrays.toString(profits1) + ", capital = " + Arrays.toString(capital1));
        int result1 = findMaximizedCapital(k1, w1, profits1, capital1);
        System.out.println("输出: " + result1); // 预期输出: 4
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int k2 = 3, w2 = 0;
        int[] profits2 = {1, 2, 3};
        int[] capital2 = {0, 1, 2};
        System.out.println("输入: k = " + k2 + ", w = " + w2 + ", profits = " + Arrays.toString(profits2) + ", capital = " + Arrays.toString(capital2));
        int result2 = findMaximizedCapital(k2, w2, profits2, capital2);
        System.out.println("输出: " + result2); // 预期输出: 6
        System.out.println();
    }
}
```
