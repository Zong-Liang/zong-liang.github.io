---
title: 502. IPO
date: 2024-10-22 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 堆]
tags: [堆]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234747452.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

假设力扣（LeetCode）即将开始 **IPO**。为了以更高的价格将股票卖给风险投资公司，力扣希望在 IPO 之前开展一些项目以增加其资本。由于资源有限，它只能在 IPO 之前完成最多 `k` 个不同的项目。帮助力扣设计完成最多 `k` 个不同项目后得到最大总资本的方式。

给你 `n` 个项目。对于每个项目 `i`，它都有一个纯利润 `profits[i]` 和启动该项目需要的最小资本 `capital[i]`。

最初，你的资本为 `w`。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。

总而言之，从给定项目中选择 **最多** `k` 个不同项目的列表，以 **最大化最终资本**，并输出最终可获得的最多的资本。

答案保证在 32 位有符号整数范围内。

**示例 1:**

- **输入:** `k = 2`, `w = 0`, `profits = [1,2,3]`, `capital = [0,1,1]`
- **输出:** 4
- **解释:**

  - 由于你的初始资本为 0，你仅可以从 0 号项目开始。
  - 在完成后，你将获得 1 的利润，你的总资本将变为 1。
  - 此时你可以选择开始 1 号或 2 号项目。
  - 由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。
  - 因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。

**示例 2:**

- **输入:** `k = 3`, `w = 0`, `profits = [1,2,3]`, `capital = [0,1,2]`
- **输出:** 6

**提示:**

- `1 <= k <= 10^5`
- `0 <= w <= 10^9`
- `n == profits.length`
- `n == capital.length`
- `1 <= n <= 10^5`
- `0 <= profits[i] <= 10^4`
- `0 <= capital[i] <= 10^9`

## 题解

### 解法：贪心算法 + 优先队列 (Greedy + Priority Queue)

**思路：**

这是一个典型的**贪心算法**问题。为了最大化最终资本，我们在每一步选择项目时，都应该遵循以下策略：

在**当前拥有的资本 $w$** 能够启动的所有项目中，选择**利润最大**的那一个。

为了高效地实现这个策略，我们需要两个辅助结构：

1.  **按启动资本排序的项目列表**：我们需要知道当前有哪些项目是“买得起”的。将所有项目按照 `capital` 从小到大排序，这样随着我们资本 `w` 的增加，我们可以按顺序解锁更多的项目，而不需要每次遍历整个数组。
2.  **大顶堆（优先队列）**：在所有“买得起”的项目中，我们需要快速找到利润最大的那个。将这些项目的 `profits` 放入大顶堆中，堆顶即为当前可获取的最大利润。

**算法流程：**

1.  将 `capital` and `profits` 组合成 `(capital[i], profits[i])` 的二元组，并按照 `capital` 升序排序。
2.  创建一个大顶堆（Max-Heap）用于存储利润。
3.  循环 `k` 次（我们要选 `k` 个项目）：

    - 遍历排序后的项目列表，将所有当前资本 `w` 足以启动的项目（`project.capital <= w`）的利润压入大顶堆。
    - 检查堆是否为空：

      - 如果堆为空，说明当前没有资金能启动任何新项目，提前结束。
      - 如果堆不为空，弹出堆顶（最大利润），将其加到当前资本 `w` 中。

4.  返回最终的 `w`。

**复杂度分析：**

- **时间复杂度：** $O(N \log N + K \log N)$

  - 排序项目需要 $O(N \log N)$。
  - 每个项目最多入堆一次、出堆一次，堆的操作为 $O(\log N)$。在最坏情况下，我们可能会进行 $K$ 次出堆和 $N$ 次入堆操作。

- **空间复杂度：** $O(N)$

  - 用于存储项目数组和优先队列的空间。

**代码片段：**

```java
public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
    int n = profits.length;
    // 存储 (capital, profit) 对
    int[][] projects = new int[n][2];
    for (int i = 0; i < n; i++) {
        projects[i][0] = capital[i];
        projects[i][1] = profits[i];
    }

    // 按启动资本从小到大排序
    Arrays.sort(projects, (a, b) -> a[0] - b[0]);

    // 大顶堆，存储当前能做项目的利润
    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);

    int curr = 0;
    // 最多做 k 个项目
    for (int i = 0; i < k; i++) {
        // 将所有当前买得起的项目加入堆中
        while (curr < n && projects[curr][0] <= w) {
            maxHeap.add(projects[curr][1]);
            curr++;
        }

        // 如果堆为空，说明没项目可做了，直接退出
        if (maxHeap.isEmpty()) {
            break;
        }

        // 选利润最大的做，累加资本
        w += maxHeap.poll();
    }

    return w;
}
```

### 完整代码

```java
import java.util.Arrays;
import java.util.PriorityQueue;

public class Main {

    /**
     * 502. IPO - 贪心 + 优先队列
     */
    public static int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
        int n = profits.length;
        // 1. 预处理：将 capital 和 profits 绑定在一起
        // projects[i][0] = capital, projects[i][1] = profit
        int[][] projects = new int[n][2];
        for (int i = 0; i < n; i++) {
            projects[i][0] = capital[i];
            projects[i][1] = profits[i];
        }

        // 2. 按所需资本从小到大排序
        // 这样我们可以随着 w 的增加，线性地将项目加入候选池
        Arrays.sort(projects, (a, b) -> Integer.compare(a[0], b[0]));

        // 3. 使用大顶堆存储当前可启动项目的利润
        // Java 的 PriorityQueue 默认是小顶堆，所以需要自定义 Comparator (b - a)
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);

        int i = 0; // 指向排序后 projects 的指针

        // 4. 循环选择 k 个项目
        for (int step = 0; step < k; step++) {
            // 将所有 启动资本 <= 当前资本 w 的项目利润加入堆
            while (i < n && projects[i][0] <= w) {
                maxHeap.offer(projects[i][1]);
                i++;
            }

            // 如果堆为空，说明当前资本不足以启动任何剩余的项目，提前结束
            if (maxHeap.isEmpty()) {
                break;
            }

            // 贪心选择：取出利润最大的项目
            w += maxHeap.poll();
        }

        return w;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int k1 = 2;
        int w1 = 0;
        int[] profits1 = {1, 2, 3};
        int[] capital1 = {0, 1, 1};

        System.out.println("示例 1 输入: k=" + k1 + ", w=" + w1 +
                           ", profits=" + Arrays.toString(profits1) +
                           ", capital=" + Arrays.toString(capital1));
        int result1 = findMaximizedCapital(k1, w1, profits1, capital1);
        System.out.println("示例 1 输出: " + result1);
        // 解释: 初始 w=0, 只能选 capital=0 的项目(利润1) -> w=1。
        // 此时可从 capital<=1 的项目中选最大利润(3) -> w=1+3=4。
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int k2 = 3;
        int w2 = 0;
        int[] profits2 = {1, 2, 3};
        int[] capital2 = {0, 1, 2};

        System.out.println("示例 2 输入: k=" + k2 + ", w=" + w2 +
                           ", profits=" + Arrays.toString(profits2) +
                           ", capital=" + Arrays.toString(capital2));
        int result2 = findMaximizedCapital(k2, w2, profits2, capital2);
        System.out.println("示例 2 输出: " + result2);
        // 解释: 0->1(利润1), 1->3(利润2), 3->6(利润3)
        System.out.println("-----------------------------");
    }
}
```
