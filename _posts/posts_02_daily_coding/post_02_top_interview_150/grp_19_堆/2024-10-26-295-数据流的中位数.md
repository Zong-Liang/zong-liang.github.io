---
title: 295. 数据流的中位数
date: 2024-10-26 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 堆]
tags: [堆]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234843031.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

**中位数**是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

- 例如 `arr = [2,3,4]` 的中位数是 `3`。
- 例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5`。

实现 `MedianFinder` 类：

- `MedianFinder()` 初始化 `MedianFinder` 对象。
- `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。
- `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10^-5` 以内的答案将被接受。

**示例 1:**

- **输入**

  `["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]`

  `[[], [1], [2], [], [3], []]`

- **输出**

  `[null, null, null, 1.5, null, 2.0]`

- **解释**

  ```
  MedianFinder medianFinder = new MedianFinder();
  medianFinder.addNum(1);    // arr = [1]
  medianFinder.addNum(2);    // arr = [1, 2]
  medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)
  medianFinder.addNum(3);    // arr = [1, 2, 3]
  medianFinder.findMedian(); // 返回 2.0
  ```

**提示:**

- `-10^5 <= num <= 10^5`
- 在调用 `findMedian` 之前，数据结构中至少有一个元素
- 最多 `5 * 10^4` 次调用 `addNum` 和 `findMedian`

## 题解

### 解法：双堆 (Two Heaps)

**思路：**

我们要维护一个数据流的中位数。中位数的本质是将一组有序数据分为**数量相等的两部分**（如果总数是奇数，则其中一部分多一个）。

- 左半部分：包含较小的一半元素。
- 右半部分：包含较大的一半元素。

如果我们可以快速拿到“左半部分的最大值”和“右半部分的最小值”，就能立刻计算出中位数。

因此，我们可以使用两个**优先队列（堆）**来维护数据：

1.  **大顶堆 (`queMin`)**：维护较小的一半元素。堆顶是这部分元素的最大值。
2.  **小顶堆 (`queMax`)**：维护较大的一半元素。堆顶是这部分元素的最小值。

**维护规则（平衡策略）：**

为了保证中位数的定义，我们需要让两个堆的元素数量维持平衡。我们要约定：`queMin` 的元素个数要么等于 `queMax`，要么比 `queMax` 多 1 个。

- `addNum(num)`：

  1.  先将新元素放入 `queMin`。
  2.  为了保证顺序（`queMin` 中的所有元素都要小于等于 `queMax` 中的元素），将 `queMin` 的堆顶（最大值）弹出，放入 `queMax`。
  3.  为了保证数量平衡（`queMin` 数量 $\ge$ `queMax` 数量），如果此时 `queMax` 的元素多于 `queMin`，将 `queMax` 的堆顶弹出，放回 `queMin`。

- `findMedian()`：

  - 如果 `queMin` 元素比 `queMax` 多，中位数就是 `queMin` 的堆顶。
  - 如果元素数量相等，中位数是两个堆顶元素的平均值。

**复杂度分析：**

- **时间复杂度：**

  - `addNum`: $O(\log N)$，其中 $N$ 是当前元素个数。堆的插入和弹出操作为对数级。
  - `findMedian`: $O(1)$，直接访问堆顶。

- **空间复杂度：** $O(N)$，需要存储数据流中的所有元素。

**代码片段：**

```java
class MedianFinder {
    // 存放较小的一半，大顶堆
    PriorityQueue<Integer> queMin;
    // 存放较大的一半，小顶堆
    PriorityQueue<Integer> queMax;

    public MedianFinder() {
        queMin = new PriorityQueue<>((a, b) -> b - a);
        queMax = new PriorityQueue<>((a, b) -> a - b);
    }

    public void addNum(int num) {
        queMin.offer(num);
        queMax.offer(queMin.poll());
        if (queMin.size() < queMax.size()) {
            queMin.offer(queMax.poll());
        }
    }

    public double findMedian() {
        if (queMin.size() > queMax.size()) {
            return queMin.peek();
        }
        return (queMin.peek() + queMax.peek()) / 2.0;
    }
}
```

### 完整代码

```java
import java.util.PriorityQueue;

public class Main {

    static class MedianFinder {
        // 大顶堆：存储数据流中较小的一半元素
        // 堆顶是这一半里的最大值
        private PriorityQueue<Integer> smallHalf;

        // 小顶堆：存储数据流中较大的一半元素
        // 堆顶是这一半里的最小值
        private PriorityQueue<Integer> largeHalf;

        public MedianFinder() {
            // Java 默认是小顶堆，实现大顶堆需要自定义比较器 (b - a)
            smallHalf = new PriorityQueue<>((a, b) -> b - a);
            largeHalf = new PriorityQueue<>(); // 默认小顶堆
        }

        public void addNum(int num) {
            // 1. 先把新数加入【较小部分】，让它内部自动排序
            smallHalf.offer(num);

            // 2. 把【较小部分】中最大的那个数拿出来，放到【较大部分】去
            // 这样保证了 largeHalf 中的所有数都比 smallHalf 中的大
            largeHalf.offer(smallHalf.poll());

            // 3. 平衡两个堆的大小
            // 我们约定：smallHalf 的大小要么等于 largeHalf，要么比它大 1
            if (smallHalf.size() < largeHalf.size()) {
                smallHalf.offer(largeHalf.poll());
            }
        }

        public double findMedian() {
            // 如果 smallHalf 元素更多，中位数就是它的堆顶
            if (smallHalf.size() > largeHalf.size()) {
                return smallHalf.peek();
            }
            // 否则元素数量相等，中位数是两个堆顶的平均值
            // 注意除以 2.0 以获得 double 结果
            return (smallHalf.peek() + largeHalf.peek()) / 2.0;
        }
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        System.out.println("示例 1 测试开始:");
        MedianFinder medianFinder = new MedianFinder();

        medianFinder.addNum(1);
        System.out.println("addNum(1)");

        medianFinder.addNum(2);
        System.out.println("addNum(2)");

        double m1 = medianFinder.findMedian();
        System.out.println("findMedian() -> " + m1);
        // 预期输出: 1.5

        medianFinder.addNum(3);
        System.out.println("addNum(3)");

        double m2 = medianFinder.findMedian();
        System.out.println("findMedian() -> " + m2);
        // 预期输出: 2.0

        System.out.println("-----------------------------");

        // --- 额外测试 ---
        System.out.println("额外测试 (加入更多数据):");
        medianFinder.addNum(4); // [1, 2, 3, 4] -> Median: 2.5
        System.out.println("addNum(4), Median: " + medianFinder.findMedian());

        medianFinder.addNum(5); // [1, 2, 3, 4, 5] -> Median: 3.0
        System.out.println("addNum(5), Median: " + medianFinder.findMedian());
    }
}
```
