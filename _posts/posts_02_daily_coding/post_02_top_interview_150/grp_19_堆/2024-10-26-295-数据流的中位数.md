---
title: 295. 数据流的中位数
date: 2024-10-26 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 堆]
tags: [堆]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234843031.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：295. 数据流的中位数

**中位数**是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

- 例如 `arr = [2,3,4]` 的中位数是 `3`。
- 例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5`。

实现 `MedianFinder` 类：

- `MedianFinder()` 初始化 `MedianFinder` 对象。
- `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。
- `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10^-5` 以内的答案将被接受。

**示例 1:**

- **输入**
  `["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]`
  `[[], [1], [2], [], [3], []]`
- **输出**
  `[null, null, null, 1.5, null, 2.0]`
- **解释**
  ```
  MedianFinder medianFinder = new MedianFinder();
  medianFinder.addNum(1);    // arr = [1]
  medianFinder.addNum(2);    // arr = [1, 2]
  medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)
  medianFinder.addNum(3);    // arr = [1, 2, 3]
  medianFinder.findMedian(); // 返回 2.0
  ```

**提示:**

- `-10^5 <= num <= 10^5`
- 在调用 `findMedian` 之前，数据结构中至少有一个元素
- 最多 `5 * 10^4` 次调用 `addNum` 和 `findMedian`

## 题解

**算法思路：(双优先队列/双堆)**

要高效地找到数据流的中位数，我们需要一种能够快速访问中间元素的数据结构。使用两个优先队列（堆）是解决这个问题的经典方法：

1.  **大顶堆 (maxHeap):** 存储数据流中较小的一半数字。堆顶是这一半数字中的最大值。
2.  **小顶堆 (minHeap):** 存储数据流中较大的一半数字。堆顶是这一半数字中的最小值。

我们维护这两个堆，并确保：

- `maxHeap` 的大小等于 `minHeap` 的大小，或者比 `minHeap` 多一个元素。
- `maxHeap` 中的所有元素都小于或等于 `minHeap` 中的所有元素。

**`addNum(num)` 逻辑:**

1.  将新数字 `num` 加入 `maxHeap`。
2.  为了维持堆的性质，将 `maxHeap` 的堆顶元素弹出并加入 `minHeap`。
3.  如果 `maxHeap` 的大小变得比 `minHeap` 小，则将 `minHeap` 的堆顶元素弹出并加入 `maxHeap`，以恢复平衡。

**`findMedian()` 逻辑:**

1.  如果 `maxHeap` 的大小比 `minHeap` 大（总数为奇数），则中位数就是 `maxHeap` 的堆顶元素。
2.  如果两个堆的大小相等（总数为偶数），则中位数是两个堆顶元素的平均值。

这种方法使得 `addNum` 的时间复杂度为 O(log n)，`findMedian` 的时间复杂度为 O(1)。

```java
import java.util.Collections;
import java.util.PriorityQueue;

/**
 * LeetCode 的类名是 MedianFinder。
 * 我们可以将逻辑放在 Main 类中并创建一个实例来测试。
 */
class MedianFinder {

    // 大顶堆，存储较小的一半数字
    private PriorityQueue<Integer> maxHeap;
    // 小顶堆，存储较大的一半数字
    private PriorityQueue<Integer> minHeap;

    /** initialize your data structure here. */
    public MedianFinder() {
        // Java 的 PriorityQueue 默认是小顶堆
        minHeap = new PriorityQueue<>();
        // 要实现大顶堆，需要传入一个自定义的比较器
        maxHeap = new PriorityQueue<>(Collections.reverseOrder());
    }

    public void addNum(int num) {
        // 1. 先将元素加入大顶堆
        maxHeap.offer(num);
        // 2. 将大顶堆的最大元素（堆顶）移动到小顶堆
        minHeap.offer(maxHeap.poll());

        // 3. 维护平衡：如果大顶堆元素少了，从小顶堆补充
        if (maxHeap.size() < minHeap.size()) {
            maxHeap.offer(minHeap.poll());
        }
    }

    public double findMedian() {
        // 如果大顶堆元素多，说明总数是奇数，中位数是 maxHeap 的堆顶
        if (maxHeap.size() > minHeap.size()) {
            return maxHeap.peek();
        } else {
            // 如果两个堆大小相等，说明总数是偶数，中位数是两个堆顶的平均值
            return (maxHeap.peek() + minHeap.peek()) / 2.0;
        }
    }
}


public class Main {
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        System.out.println("输入: [\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]");
        System.out.println("      [[], [1], [2], [], [3], []]");

        MedianFinder medianFinder = new MedianFinder();
        System.out.print("输出: [null");

        medianFinder.addNum(1);
        System.out.print(", null");

        medianFinder.addNum(2);
        System.out.print(", null");

        double median1 = medianFinder.findMedian();
        System.out.print(", " + median1);

        medianFinder.addNum(3);
        System.out.print(", null");

        double median2 = medianFinder.findMedian();
        System.out.print(", " + median2);

        System.out.println("]");
    }
}
```
