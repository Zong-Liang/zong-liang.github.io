---
title: 215. 数组中的第K个最大元素
date: 2024-10-20 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 堆]
tags: [堆]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234724521.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：215. 数组中的第 K 个最大元素

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

- **输入:** `[3,2,1,5,6,4]`, `k = 2`
- **输出:** 5

**示例 2:**

- **输入:** `[3,2,3,1,2,4,5,5,6]`, `k = 4`
- **输出:** 4

**提示:**

- `1 <= k <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`

## Java 代码

**算法思路：(快速选择 - Quickselect)**

为了达到 `O(n)` 的平均时间复杂度，我们不能使用完全排序（`O(n log n)`）。这个问题的最佳解法是 **快速选择** 算法，它是快速排序的一种变体。

1.  **目标转换：** 寻找第 `k` 大的元素等价于寻找升序排序后，下标为 `n - k` 的元素（其中 `n` 是数组长度）。
2.  **分区 (Partition):** 随机选择一个枢轴（pivot），将数组分区，使得所有小于枢轴的元素都在其左边，所有大于枢轴的元素都在其右边。枢轴元素此时就位于其最终排序好的位置。
3.  **缩小范围：**
    - 如果枢轴的下标正好是我们寻找的目标下标 `n - k`，那么就找到了答案。
    - 如果枢轴的下标小于 `n - k`，说明第 `k` 大的元素在枢轴的右边，我们只需要在右半部分继续查找。
    - 如果枢轴的下标大于 `n - k`，说明第 `k` 大的元素在枢轴的左边，我们只需要在左半部分继续查找。
4.  通过不断缩小查找范围，该算法的平均时间复杂度可以达到 `O(n)`。

```java
import java.util.Arrays;
import java.util.Random;


public class Main {

    private static final Random random = new Random();

    /**
     * 查找数组中第 k 个最大的元素。
     *
     * @param nums 整数数组
     * @param k    整数 k
     * @return 第 k 个最大的元素
     */
    public static int findKthLargest(int[] nums, int k) {
        // 第 k 大的元素，在升序排序后，其下标为 nums.length - k
        return quickSelect(nums, 0, nums.length - 1, nums.length - k);
    }

    /**
     * 快速选择的递归实现。
     */
    private static int quickSelect(int[] nums, int left, int right, int targetIndex) {
        // 随机选择一个 pivot 并进行分区
        int pivotIndex = partition(nums, left, right);

        if (pivotIndex == targetIndex) {
            return nums[pivotIndex];
        } else if (pivotIndex < targetIndex) {
            // 目标在右半部分
            return quickSelect(nums, pivotIndex + 1, right, targetIndex);
        } else {
            // 目标在左半部分
            return quickSelect(nums, left, pivotIndex - 1, targetIndex);
        }
    }

    /**
     * 分区操作，将数组分为 < pivot, pivot, > pivot 三部分。
     */
    private static int partition(int[] nums, int left, int right) {
        // 随机选择 pivot 以避免最坏情况
        int randomIndex = left + random.nextInt(right - left + 1);
        swap(nums, randomIndex, right);
        int pivot = nums[right];

        int storeIndex = left;
        for (int i = left; i < right; i++) {
            if (nums[i] < pivot) {
                swap(nums, storeIndex, i);
                storeIndex++;
            }
        }

        swap(nums, storeIndex, right);
        return storeIndex;
    }

    /**
     * 交换数组中的两个元素。
     */
    private static void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }


    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[] nums1 = {3, 2, 1, 5, 6, 4};
        int k1 = 2;
        System.out.println("输入: nums = " + Arrays.toString(nums1) + ", k = " + k1);
        int result1 = findKthLargest(nums1, k1);
        System.out.println("输出: " + result1); // 预期输出: 5
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[] nums2 = {3, 2, 3, 1, 2, 4, 5, 5, 6};
        int k2 = 4;
        System.out.println("输入: nums = " + Arrays.toString(nums2) + ", k = " + k2);
        int result2 = findKthLargest(nums2, k2);
        System.out.println("输出: " + result2); // 预期输出: 4
        System.out.println();
    }
}
```
