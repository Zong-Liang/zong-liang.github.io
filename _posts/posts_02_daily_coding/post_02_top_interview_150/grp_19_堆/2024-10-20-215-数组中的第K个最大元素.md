---
title: 215. 数组中的第K个最大元素
date: 2024-10-20 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 堆]
tags: [堆]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234724521.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

- **输入:** `[3,2,1,5,6,4]`, `k = 2`
- **输出:** 5

**示例 2:**

- **输入:** `[3,2,3,1,2,4,5,5,6]`, `k = 4`
- **输出:** 4

**提示:**

- `1 <= k <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`

## 题解

### 解法一：快速选择算法 (Quick Select)

**思路：**

题目要求时间复杂度为 $O(n)$，这排除了普通的排序算法（$O(n \log n)$）。最经典的线性时间查找第 K 大/小元素的算法是 **快速选择算法 (Quick Select)**。

该算法基于 **快速排序 (Quick Sort)** 的分区思想（Partition）：

1.  **分区 (Partition)**：随机选择一个基准元素（pivot），将数组分为两部分：左边部分所有元素小于等于 pivot，右边部分所有元素大于 pivot。此时 pivot 所在的下标 `p` 就是它在最终排序数组中的正确位置。
2.  **选择 (Select)**：

    - 如果 `p` 正好等于我们要找的目标下标 `target`，则说明找到了，直接返回 `nums[p]`。
    - 如果 `p < target`，说明目标元素在 pivot 的右侧，我们只需递归右半部分。
    - 如果 `p > target`，说明目标元素在 pivot 的左侧，我们只需递归左半部分。

**目标下标转换**：

题目求的是“第 K 个**最大**元素”。如果在升序排序的数组中，第 K 个最大元素的下标应该是 `nums.length - k`。

**为什么是 $O(n)$？**

每次分区，我们期望将搜索范围减半（$N + N/2 + N/4 + ...$），这是一个等比数列，其和收敛于 $2N$，即 $O(N)$。最坏情况下（每次只排除一个元素）是 $O(N^2)$，但通过**随机选择 pivot** 可以极大概率避免最坏情况。

**复杂度分析：**

- **时间复杂度：** 平均 $O(n)$，最坏 $O(n^2)$（极少发生）。
- **空间复杂度：** $O(1)$（迭代写法）或 $O(\log n)$（递归栈）。

**代码片段：**

```java
public int findKthLargest(int[] nums, int k) {
    int n = nums.length;
    // 第 k 个最大元素，即升序排列后的第 n-k 个位置
    int target = n - k;
    int left = 0, right = n - 1;

    while (true) {
        int index = partition(nums, left, right);
        if (index == target) {
            return nums[index];
        } else if (index < target) {
            left = index + 1;
        } else {
            right = index - 1;
        }
    }
}

private int partition(int[] nums, int left, int right) {
    // 随机化 pivot 防止最坏情况
    int randomIndex = left + new java.util.Random().nextInt(right - left + 1);
    swap(nums, randomIndex, right);

    int pivot = nums[right];
    int i = left;
    for (int j = left; j < right; j++) {
        if (nums[j] <= pivot) {
            swap(nums, i, j);
            i++;
        }
    }
    swap(nums, i, right);
    return i;
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```

### 解法二：小顶堆 (Min-Heap) - 备选

**思路：**

虽然严格来说这个方法的时间复杂度是 $O(n \log k)$，略慢于 $O(n)$，但在实际工程和许多面试中，这也是一个非常优秀的解法，特别是当 $k$ 远小于 $n$ 时，或者处理海量数据流时。

1.  维护一个大小为 `k` 的小顶堆。
2.  遍历数组：

    - 如果堆未满，直接放入。
    - 如果堆已满，比较当前元素与堆顶元素：

      - 如果当前元素 > 堆顶，则弹出堆顶，放入当前元素。
      - 否则忽略。

3.  遍历结束后，堆顶元素就是第 K 个最大的元素（因为堆里存的是最大的 K 个数，而小顶堆的堆顶是这 K 个数里最小的，即第 K 大）。

**复杂度分析：**

- **时间复杂度：** $O(n \log k)$。
- **空间复杂度：** $O(k)$。

**代码片段：**

```java
public int findKthLargestHeap(int[] nums, int k) {
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    for (int num : nums) {
        heap.add(num);
        if (heap.size() > k) {
            heap.poll();
        }
    }
    return heap.peek();
}
```

### 完整代码

这里提供符合题目 $O(n)$ 要求的**快速选择算法**完整实现。

```java
import java.util.Random;
import java.util.Arrays;
import java.util.PriorityQueue;

public class Main {

    private static final Random random = new Random();

    /**
     * 寻找第 K 个最大元素 - 快速选择算法 (O(n))
     */
    public static int findKthLargest(int[] nums, int k) {
        // 目标索引：数组升序排序后，第 K 大元素的索引是 nums.length - k
        // 例如：[1,2,3,4,5,6], k=2, 第2大是5, 索引是 6-2=4
        int targetIndex = nums.length - k;
        int left = 0;
        int right = nums.length - 1;

        while (left <= right) {
            int pivotIndex = partition(nums, left, right);

            if (pivotIndex == targetIndex) {
                return nums[pivotIndex];
            } else if (pivotIndex < targetIndex) {
                // 目标在右半部分
                left = pivotIndex + 1;
            } else {
                // 目标在左半部分
                right = pivotIndex - 1;
            }
        }
        return -1; // Should not reach here
    }

    /**
     * 分区函数
     * @param nums 数组
     * @param left 左边界
     * @param right 右边界
     * @return pivot 最终所在的位置索引
     */
    private static int partition(int[] nums, int left, int right) {
        // 1. 随机选择 pivot，并交换到最右边
        // 这一步对于避免 LeetCode 针对特定顺序的测试用例导致超时至关重要
        int randomIndex = left + random.nextInt(right - left + 1);
        swap(nums, randomIndex, right);

        int pivot = nums[right];
        int i = left;

        // 2. 将小于等于 pivot 的移到左边
        for (int j = left; j < right; j++) {
            if (nums[j] <= pivot) {
                swap(nums, i, j);
                i++;
            }
        }

        // 3. 将 pivot 放到正确的位置 (i)
        swap(nums, i, right);
        return i;
    }

    private static void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1 = {3, 2, 1, 5, 6, 4};
        int k1 = 2;
        System.out.println("示例 1 输入: nums = " + Arrays.toString(nums1) + ", k = " + k1);
        int result1 = findKthLargest(nums1, k1);
        System.out.println("示例 1 输出: " + result1);
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums2 = {3, 2, 3, 1, 2, 4, 5, 5, 6};
        int k2 = 4;
        System.out.println("示例 2 输入: nums = " + Arrays.toString(nums2) + ", k = " + k2);
        int result2 = findKthLargest(nums2, k2);
        System.out.println("示例 2 输出: " + result2);
        System.out.println("-----------------------------");

        // --- 额外测试：有序数组 (测试随机化 pivot 的效果) ---
        int[] nums3 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int k3 = 10;
        System.out.println("示例 3 (有序) 输入: k = " + k3);
        int result3 = findKthLargest(nums3, k3);
        System.out.println("示例 3 输出: " + result3); // 应该是 1
    }
}
```
