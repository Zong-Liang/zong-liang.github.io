---
title: 373-查找和最小的K对数字
date: 2024-10-25 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 堆]
tags: [堆]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234811687.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


### 题目：373. 查找和最小的 K 对数字

给定两个以 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，以及一个整数 `k`。

定义一对值 `(u,v)`，其中第一个元素来自 `nums1`，第二个元素来自 `nums2`。

请找到和最小的 `k` 个数对 `(u1,v1), (u2,v2) ... (uk,vk)`。

---

**示例 1:**

- **输入:** `nums1 = [1,7,11]`, `nums2 = [2,4,6]`, `k = 3`
- **输出:** `[[1,2],[1,4],[1,6]]`
- **解释:** 返回序列中的前 3 对数：
  `[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]`

**示例 2:**

- **输入:** `nums1 = [1,1,2]`, `nums2 = [1,2,3]`, `k = 2`
- **输出:** `[[1,1],[1,1]]`
- **解释:** 返回序列中的前 2 对数：
  `[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]`

---

**提示:**

- `1 <= nums1.length, nums2.length <= 10^5`
- `-10^9 <= nums1[i], nums2[i] <= 10^9`
- `nums1` 和 `nums2` 均为升序排列
- `1 <= k <= 10^4`
- `k <= nums1.length * nums2.length`

---

### Java 8 解答 (赛码网格式)

**算法思路：(优先队列 / 最小堆)**
这个问题可以看作是在一个 `m x n` 的矩阵中寻找 `k` 个最小的元素，其中矩阵的 `(i, j)` 位置的值是 `nums1[i] + nums2[j]`。由于 `nums1` 和 `nums2` 是有序的，这个虚拟矩阵的每一行和每一列也都是有序的。

我们可以使用一个最小堆（`PriorityQueue`）来解决这个问题，这类似于多路归并排序的思想。

1.  **初始化堆：**
    - 首先，我们将 `nums1` 的每个元素与 `nums2` 的第一个元素 `nums2[0]` 组成的数对加入最小堆。堆中存储的是一个数组 `[nums1[i], nums2[0], 0]`，其中第三个元素 `0` 是 `nums2` 的索引。
    - 堆根据数对的和 `nums1[i] + nums2[0]` 进行排序。
2.  **提取并扩展：**
    - 我们循环 `k` 次，每次从堆中提取和最小的数对 `(u, v, index)`。
    - 将这个数对 `[u, v]` 加入结果列表。
    - 然后，如果这个数对中来自 `nums2` 的元素的索引 `index` 还没有到达 `nums2` 的末尾，我们就将 `u` 与 `nums2` 的下一个元素 `nums2[index + 1]` 组成新的数对，并将其加入堆中。

这样，我们每次都能从所有可能的候选数对中选出和最小的一个，直到找到 `k` 个为止。

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.PriorityQueue;

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    /**
     * 查找和最小的 k 对数字。
     *
     * @param nums1 第一个有序数组
     * @param nums2 第二个有序数组
     * @param k     要查找的数对数量
     * @return 包含 k 个和最小数对的列表
     */
    public static List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        // 创建一个最小堆，用于存储数对。
        // 堆中元素是一个数组：[num1, num2, index_in_nums2]
        // 比较器根据 num1 + num2 的和进行排序。
        PriorityQueue<int[]> minHeap = new PriorityQueue<>(
            (a, b) -> (a[0] + a[1]) - (b[0] + b[1])
        );

        // 初始化堆：将 nums1 的每个元素与 nums2 的第一个元素组成的数对入队
        // 为了避免 k > nums1.length 的情况，最多只添加 min(k, nums1.length) 个初始元素
        for (int i = 0; i < Math.min(k, nums1.length); i++) {
            minHeap.offer(new int[]{nums1[i], nums2[0], 0});
        }

        List<List<Integer>> result = new ArrayList<>();

        // 从堆中取出 k 个最小的数对
        while (k > 0 && !minHeap.isEmpty()) {
            int[] current = minHeap.poll();
            int u = current[0];
            int v = current[1];
            int index2 = current[2];

            result.add(Arrays.asList(u, v));
            k--;

            // 如果当前数对中来自 nums2 的元素不是最后一个元素，
            // 则将 u 与 nums2 中的下一个元素组成新数对并入队
            if (index2 + 1 < nums2.length) {
                minHeap.offer(new int[]{u, nums2[index2 + 1], index2 + 1});
            }
        }

        return result;
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[] nums1_1 = {1, 7, 11};
        int[] nums2_1 = {2, 4, 6};
        int k1 = 3;
        System.out.println("输入: nums1 = " + Arrays.toString(nums1_1) + ", nums2 = " + Arrays.toString(nums2_1) + ", k = " + k1);
        List<List<Integer>> result1 = kSmallestPairs(nums1_1, nums2_1, k1);
        System.out.println("输出: " + result1); // 预期输出: [[1,2], [1,4], [1,6]]
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[] nums1_2 = {1, 1, 2};
        int[] nums2_2 = {1, 2, 3};
        int k2 = 2;
        System.out.println("输入: nums1 = " + Arrays.toString(nums1_2) + ", nums2 = " + Arrays.toString(nums2_2) + ", k = " + k2);
        List<List<Integer>> result2 = kSmallestPairs(nums1_2, nums2_2, k2);
        System.out.println("输出: " + result2); // 预期输出: [[1,1], [1,1]]
        System.out.println();
    }
}
```
