---
title: 373. 查找和最小的K对数字
date: 2024-10-25 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 堆]
tags: [堆]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234811687.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定两个以 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，以及一个整数 `k`。

定义一对值 `(u,v)`，其中第一个元素来自 `nums1`，第二个元素来自 `nums2`。

请找到和最小的 `k` 个数对 `(u1,v1), (u2,v2) ... (uk,vk)`。

**示例 1:**

- **输入:** `nums1 = [1,7,11]`, `nums2 = [2,4,6]`, `k = 3`
- **输出:** `[[1,2],[1,4],[1,6]]`
- **解释:** 返回序列中的前 3 对数：

  `[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]`

**示例 2:**

- **输入:** `nums1 = [1,1,2]`, `nums2 = [1,2,3]`, `k = 2`
- **输出:** `[[1,1],[1,1]]`
- **解释:** 返回序列中的前 2 对数：

  `[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]`

**提示:**

- `1 <= nums1.length, nums2.length <= 10^5`
- `-10^9 <= nums1[i], nums2[i] <= 10^9`
- `nums1` 和 `nums2` 均为升序排列
- `1 <= k <= 10^4`
- `k <= nums1.length * nums2.length`

## 题解

### 解法：优先队列 (Min-Heap) / 多路归并

**思路：**

由于数组 `nums1` 和 `nums2` 都是**有序**的，我们可以把这个问题看作是 **"合并 K 个有序链表"** 的变体。

我们可以将所有可能的数对 `(nums1[i], nums2[j])` 想象成 `nums1.length` 个有序序列（行）：

- 序列 1：`(nums1[0], nums2[0]), (nums1[0], nums2[1]), (nums1[0], nums2[2])...`
- 序列 2：`(nums1[1], nums2[0]), (nums1[1], nums2[1]), (nums1[1], nums2[2])...`
- ...
- 序列 m：`(nums1[m-1], nums2[0]), (nums1[m-1], nums2[1])...`

显然，每个序列内部的和都是递增的。我们的目标就是从这些序列中找出最小的 `k` 个元素。

**算法步骤：**

1.  **初始化**：

    - 创建一个小顶堆（PriorityQueue），用于存储二元组的索引信息 `[nums1Index, nums2Index]`（为了节省空间和方便计算，可以直接存 `[sum, nums1Index, nums2Index]`）。
    - 将所有序列的**首元素**加入堆中。为了避免不必要的计算，如果 `nums1` 的长度很大，我们只需要将前 `k` 个序列的首元素加入堆即可（因为 `nums1[k]` 开始的序列首元素肯定比前 `k` 个结果要大）。即加入 `(nums1[0], nums2[0]), (nums1[1], nums2[0])...`。

2.  **循环取值**：

    - 循环 `k` 次（或直到堆为空）。
    - 弹出堆顶元素，这必定是当前剩余候选集中和最小的一对。
    - 将该数对加入结果列表。
    - **推入后续节点**：如果刚弹出的数对是 `(nums1[i], nums2[j])`，这就代表第 `i` 个序列的当前头节点被取走了，我们需要把该序列的下一个节点 `(nums1[i], nums2[j+1])` 加入堆中（前提是 `j+1` 不越界）。

**为什么这种方法不会重复？**

因为我们固定了 `nums1` 的索引 `i`，只在 `nums2` 的维度上向后移动指针 `j`。这保证了每对组合只会被访问一次。

**复杂度分析：**

- **时间复杂度：** $O(k \log k)$

  - 堆中最多维护 `min(k, nums1.length)` 个元素。
  - 每次操作（弹出和插入）耗时 $O(\log k)$，共执行 `k` 次。

- **空间复杂度：** $O(k)$

  - 优先队列最大占用空间为 `k`。

**代码片段：**

```java
public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
    List<List<Integer>> res = new ArrayList<>();
    // 小顶堆，数组元素含义：[pairSum, index1, index2]
    // 按照 pairSum 从小到大排序
    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);

    // 1. 初始化：将 nums1 中前 k 个元素与 nums2[0] 组成的数对入堆
    for (int i = 0; i < Math.min(nums1.length, k); i++) {
        pq.offer(new int[]{nums1[i] + nums2[0], i, 0});
    }

    // 2. 循环 k 次寻找最小值
    while (k > 0 && !pq.isEmpty()) {
        int[] curr = pq.poll();
        int i = curr[1];
        int j = curr[2];

        res.add(Arrays.asList(nums1[i], nums2[j]));

        // 如果 nums2 还有下一个元素，将 (nums1[i], nums2[j+1]) 入堆
        if (j + 1 < nums2.length) {
            pq.offer(new int[]{nums1[i] + nums2[j + 1], i, j + 1});
        }

        k--;
    }

    return res;
}
```

### 完整代码

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.PriorityQueue;

public class Main {

    /**
     * 373. 查找和最小的 K 对数字
     * 使用优先队列实现多路归并
     */
    public static List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        List<List<Integer>> res = new ArrayList<>();

        // 边界检查
        if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0 || k <= 0) {
            return res;
        }

        // 定义小顶堆
        // 存储结构：int[] {sum, i, j}
        // i 是 nums1 的下标，j 是 nums2 的下标
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);

        // 初始化：将 nums1 的前 k 个元素与 nums2 的第 0 个元素配对加入堆
        // 这一步相当于初始化了最多 k 个有序链表的头结点
        int n = nums1.length;
        int m = nums2.length;

        // 只需要遍历 nums1 的前 k 个，因为 nums1[k] + nums2[0] 肯定比前 k 个结果大（如果存在）
        for (int i = 0; i < Math.min(n, k); i++) {
            pq.offer(new int[]{nums1[i] + nums2[0], i, 0});
        }

        // 不断弹出最小值，并加入后续候选
        while (k > 0 && !pq.isEmpty()) {
            int[] curr = pq.poll();
            int i = curr[1];
            int j = curr[2];

            res.add(Arrays.asList(nums1[i], nums2[j]));

            // 关键步骤：固定 nums1[i]，尝试移动 nums2 的指针到 j+1
            if (j + 1 < m) {
                pq.offer(new int[]{nums1[i] + nums2[j + 1], i, j + 1});
            }

            k--;
        }

        return res;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1_1 = {1, 7, 11};
        int[] nums2_1 = {2, 4, 6};
        int k1 = 3;

        System.out.println("示例 1 输入: nums1=" + Arrays.toString(nums1_1) + ", nums2=" + Arrays.toString(nums2_1) + ", k=" + k1);
        List<List<Integer>> res1 = kSmallestPairs(nums1_1, nums2_1, k1);
        System.out.println("示例 1 输出: " + res1);
        // 预期: [[1, 2], [1, 4], [1, 6]]
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums1_2 = {1, 1, 2};
        int[] nums2_2 = {1, 2, 3};
        int k2 = 2;

        System.out.println("示例 2 输入: nums1=" + Arrays.toString(nums1_2) + ", nums2=" + Arrays.toString(nums2_2) + ", k=" + k2);
        List<List<Integer>> res2 = kSmallestPairs(nums1_2, nums2_2, k2);
        System.out.println("示例 2 输出: " + res2);
        // 预期: [[1, 1], [1, 1]]
        System.out.println("-----------------------------");

        // --- 示例 3 (k 较大) ---
        int[] nums1_3 = {1, 2};
        int[] nums2_3 = {3};
        int k3 = 3; // k 大于总对数 2

        System.out.println("示例 3 输入: nums1=" + Arrays.toString(nums1_3) + ", nums2=" + Arrays.toString(nums2_3) + ", k=" + k3);
        List<List<Integer>> res3 = kSmallestPairs(nums1_3, nums2_3, k3);
        System.out.println("示例 3 输出: " + res3);
        // 预期: [[1, 3], [2, 3]]
    }
}
```
