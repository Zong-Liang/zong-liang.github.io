---
title: 117-填充每个节点的下一个右侧节点指针II
date: 2024-07-17 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231521988.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


### 题目：117. 填充每个节点的下一个右侧节点指针 II

给定一个二叉树：

```c
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 `next` 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 `next` 指针设置为 `NULL`。

初始状态下，所有 `next` 指针都被设置为 `NULL`。

---

**示例 1:**
![示例1图片](https://assets.leetcode.com/uploads/2019/02/15/117_sample.png)

- **输入:** `root = [1,2,3,4,5,null,7]`
- **输出:** `[1,#,2,3,#,4,5,7,#]`
- **解释:** 给定二叉树如图 A 所示，你的函数应该填充它的每个 `next` 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 `next` 指针连接），`'#'` 表示每层的末尾。

**示例 2:**

- **输入:** `root = []`
- **输出:** `[]`

---

**提示:**

- 树中的节点数在范围 `[0, 6000]` 内
- `-100 <= Node.val <= 100`

**进阶:**

- 你只能使用常量级额外空间。
- 使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。

---

### Java 8 解答 (赛码网格式)

**算法思路：(层序遍历 - 空间 O(1))**
为了满足进阶要求中的 `O(1)` 空间复杂度，我们不能使用常规的队列来进行层序遍历。但是，我们可以利用已经建立好的 `next` 指针来遍历 **下一层** 的节点。

1.  **逐层处理:** 我们的主循环将逐层向下移动。我们使用一个指针 `current` 来遍历当前层的节点（通过 `current = current.next`）。
2.  **构建下一层的 `next` 链表:**
    - 在遍历当前层时，我们需要构建 **下一层** 的 `next` 指针链表。
    - 为此，我们使用一个虚拟头节点 `dummy` 和一个尾指针 `tail` 来串联下一层的节点。
    - 当 `current` 在当前层移动时，我们检查它的 `left` 和 `right` 子节点：
      - 如果 `current.left` 存在，就将它连接到 `tail` 的后面，并移动 `tail`。
      - 如果 `current.right` 存在，也将其连接到 `tail` 的后面，并移动 `tail`。
3.  **进入下一层:** 当 `current` 遍历完当前层后，下一层的所有节点已经被 `dummy.next` 串联起来了。我们将 `root` 更新为 `dummy.next`，作为下一层遍历的起点，然后重复上述过程。
4.  这个过程一直持续到某一层没有任何子节点为止。

```java
// LeetCode 提供的 Node 类定义
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node(int _val, Node _left, Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
    // 其他构造函数...
}

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    /**
     * 填充每个节点的 next 指针。
     */
    public static Node connect(Node root) {
        if (root == null) {
            return null;
        }

        // `startNode` 是每一层的起始节点
        Node startNode = root;

        while (startNode != null) {
            // `dummy` 是下一层的虚拟头节点
            Node dummy = new Node(0, null, null);
            // `tail` 是下一层链表的尾指针
            Node tail = dummy;
            // `current` 用于遍历当前层
            Node current = startNode;

            while (current != null) {
                // 连接左子节点
                if (current.left != null) {
                    tail.next = current.left;
                    tail = tail.next;
                }
                // 连接右子节点
                if (current.right != null) {
                    tail.next = current.right;
                    tail = tail.next;
                }
                // 移动到当前层的下一个节点
                current = current.next;
            }

            // 移动到下一层的起始节点
            startNode = dummy.next;
        }

        return root;
    }

    /**
     * 主函数，包含测试用例。
     * 由于输出是特殊的序列化格式，这里仅演示调用。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        // 构建树: [1,2,3,4,5,null,7]
        Node root1 = new Node(1,
                          new Node(2, new Node(4, null, null), new Node(5, null, null)),
                          new Node(3, null, new Node(7, null, null)));
        System.out.println("输入: root = [1,2,3,4,5,null,7]");
        connect(root1);
        System.out.println("输出: (根据题目格式，结果为带'#'的序列化树，此处仅表示已执行)");
        // 验证逻辑（例如，通过断点调试或打印特定连接）会显示：
        // root1.left (2) -> next 指向 root1.right (3)
        // root1.left.left (4) -> next 指向 root1.left.right (5)
        // root1.left.right (5) -> next 指向 root1.right.right (7)
        System.out.println();

        System.out.println("--- 示例 2 ---");
        Node root2 = null;
        System.out.println("输入: root = []");
        connect(root2);
        System.out.println("输出: []");
    }
}
```
