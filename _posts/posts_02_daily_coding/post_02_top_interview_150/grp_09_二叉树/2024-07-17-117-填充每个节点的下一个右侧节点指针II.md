---
title: 117. 填充每个节点的下一个右侧节点指针II
date: 2024-07-17 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231521988.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个二叉树：

```c
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 `next` 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 `next` 指针设置为 `NULL`。

初始状态下，所有 `next` 指针都被设置为 `NULL`。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2019/02/15/117_sample.png)

- **输入:** `root = [1,2,3,4,5,null,7]`
- **输出:** `[1,#,2,3,#,4,5,7,#]`
- **解释:** 给定二叉树如图 A 所示，你的函数应该填充它的每个 `next` 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 `next` 指针连接），`'#'` 表示每层的末尾。

**示例 2:**

- **输入:** `root = []`
- **输出:** `[]`

**提示:**

- 树中的节点数在范围 `[0, 6000]` 内
- `-100 <= Node.val <= 100`

**进阶:**

- 你只能使用常量级额外空间。
- 使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。

## 题解

### 解法一：层序遍历（队列法）

**思路：**

最直观的方法是使用广度优先搜索（BFS）。我们可以利用一个队列将二叉树的每一层节点按顺序存储下来。

在遍历每一层时，我们将当前节点的 `next` 指针指向队列中的下一个节点。如果是该层的最后一个节点，则指向 `null`（或者保持默认的 `null`）。

1.  **初始化**：如果根节点为空，直接返回。建立一个队列，加入根节点。
2.  **层序遍历**：

    - 获取当前队列的大小 `size`（即当前层的节点数）。
    - 遍历 `0` 到 `size - 1`：

      - 取出队首节点 `node`。
      - 如果这不是该层的最后一个节点（`i < size - 1`），将 `node.next` 指向队列当前的队首（即下一个节点）。
      - 将 `node` 的左右子节点（如果存在）加入队列。

3.  **重复**：直到队列为空。

**复杂度分析：**

- **时间复杂度：** $O(N)$。每个节点进出队列各一次。
- **空间复杂度：** $O(N)$。队列中最多需要存储一层的所有节点，最坏情况下（完全二叉树的底层）约为 $N/2$ 个节点。

**代码片段：**

```java
public Node connect(Node root) {
    if (root == null) return null;
    Queue<Node> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            Node node = queue.poll();
            // 如果不是本层最后一个节点，指向下一个
            if (i < size - 1) {
                node.next = queue.peek();
            }
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
    }
    return root;
}
```

### 解法二：利用已有的 Next 指针（进阶：O(1) 空间）

**思路：**

题目进阶要求使用 $O(1)$ 空间。我们可以利用上一层已经构建好的 `next` 指针来遍历整层，从而为下一层构建 `next` 连接。

这相当于把每一层看作一个链表。当我们遍历第 `N` 层（链表）时，我们将第 `N+1` 层的节点串联起来形成一个新的链表。

1.  **三个关键指针**：

    - `cur`：当前层正在遍历的节点。
    - `dummy`：下一层的虚拟头节点（哨兵），用于记录下一层的起始位置。
    - `tail`：下一层链表的尾节点，用于不断连接新的子节点。

2.  **流程**：

    - 外层循环：只要当前层不为空（`cur != null`），就开始构建下一层。
    - 内层循环：遍历当前层的所有节点（通过 `cur = cur.next`）。

      - 如果 `cur` 有左子节点，将 `tail.next` 指向它，并移动 `tail`。
      - 如果 `cur` 有右子节点，将 `tail.next` 指向它，并移动 `tail`。

    - 换层：当前层遍历完后，将 `cur` 更新为 `dummy.next`（即下一层的第一个节点），重置 `dummy` 和 `tail`。

**复杂度分析：**

- **时间复杂度：** $O(N)$。每个节点被访问常数次。
- **空间复杂度：** $O(1)$。只使用了有限的指针变量，没有使用队列或递归栈。

**代码片段：**

```java
public Node connect(Node root) {
    Node cur = root;
    while (cur != null) {
        // 虚拟头节点，用于记录下一层的开头
        Node dummy = new Node(0);
        // tail 指针负责连接下一层的节点
        Node tail = dummy;

        // 遍历当前层
        while (cur != null) {
            if (cur.left != null) {
                tail.next = cur.left;
                tail = tail.next;
            }
            if (cur.right != null) {
                tail.next = cur.right;
                tail = tail.next;
            }
            // 移动到本层的下一个节点
            cur = cur.next;
        }

        // 移动到下一层
        cur = dummy.next;
    }
    return root;
}
```

### 完整代码

```java
import java.util.*;

// 节点定义
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};

public class Main {

    // 核心算法实现（进阶解法：O(1) 空间）
    public static Node connect(Node root) {
        Node cur = root;
        while (cur != null) {
            Node dummy = new Node(0);
            Node tail = dummy; // tail 始终指向下一层链表的最后一个节点

            // 遍历当前层，构建下一层的链表关系
            while (cur != null) {
                if (cur.left != null) {
                    tail.next = cur.left;
                    tail = tail.next;
                }
                if (cur.right != null) {
                    tail.next = cur.right;
                    tail = tail.next;
                }
                cur = cur.next;
            }

            // 准备处理下一层
            cur = dummy.next;
        }
        return root;
    }

    // 辅助方法：打印带有 next 指针的树（层序输出）
    public static void printTreeNextPointers(Node root) {
        if (root == null) {
            System.out.println("[]");
            return;
        }

        Node curLevel = root;
        List<String> result = new ArrayList<>();

        while (curLevel != null) {
            Node cur = curLevel;
            Node nextLevelHead = null;

            while (cur != null) {
                result.add(String.valueOf(cur.val));

                // 寻找下一层的第一个节点，用于外层循环跳转
                if (nextLevelHead == null) {
                    if (cur.left != null) nextLevelHead = cur.left;
                    else if (cur.right != null) nextLevelHead = cur.right;
                }

                cur = cur.next;
            }
            result.add("#"); // 每层结束标记
            curLevel = nextLevelHead;
        }
        System.out.println(result);
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        // 构造树: [1,2,3,4,5,null,7]
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);
        root.right.right = new Node(7);

        System.out.println("示例 1 输入: root = [1,2,3,4,5,null,7]");
        connect(root);
        System.out.print("示例 1 输出: ");
        printTreeNextPointers(root); // 预期: [1, #, 2, 3, #, 4, 5, 7, #]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        Node root2 = null;
        System.out.println("示例 2 输入: root = []");
        connect(root2);
        System.out.print("示例 2 输出: ");
        printTreeNextPointers(root2); // 预期: []
    }
}
```
