---
title: 101. 对称二叉树
date: 2024-07-13 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231327689.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个二叉树的根节点 `root`，检查它是否轴对称。

**示例 1:**

![示例1图片](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)

- **输入:** `root = [1,2,2,3,4,4,3]`
- **输出:** `true`

**示例 2:**

![示例2图片](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

- **输入:** `root = [1,2,2,null,3,null,3]`
- **输出:** `false`

**提示:**

- 树中节点数目在范围 `[1, 1000]` 内
- `-100 <= Node.val <= 100`

**进阶：** 你可以运用递归和迭代两种方法解决这个问题吗？

## 题解

### 解法一：递归法（DFS - 深度优先搜索）

**思路：**

二叉树是否对称，实际上是看左右子树是否互为**镜像**。我们可以定义一个辅助函数 `check(p, q)` 来检查两个节点（及其子树）是否对称。

1.  **比较逻辑**：

    - 如果 `p` 和 `q` 都为 `null`，说明到底了且一致，返回 `true`。
    - 如果 `p` 和 `q` 只有一个为 `null`，或者 `p` 和 `q` 的值不相等，说明不对称，返回 `false`。

2.  **递归策略**：

    - 判断 `p` 的左子节点和 `q` 的右子节点是否对称（外侧对比）。
    - 判断 `p` 的右子节点和 `q` 的左子节点是否对称（内侧对比）。
    - 只有上述两个条件同时满足，整棵树才是对称的。

**复杂度分析：**

- **时间复杂度：** $O(N)$。遍历了整棵树，每个节点最多被访问一次。
- **空间复杂度：** $O(N)$。最坏情况下（链状树），递归栈的深度为 $O(N)$。在平衡树情况下为 $O(\log N)$。

**代码片段：**

```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    return check(root.left, root.right);
}

private boolean check(TreeNode p, TreeNode q) {
    if (p == null && q == null) {
        return true;
    }
    if (p == null || q == null || p.val != q.val) {
        return false;
    }
    // 递归比较：外侧 vs 外侧，内侧 vs 内侧
    return check(p.left, q.right) && check(p.right, q.left);
}
```

### 解法二：迭代法（BFS - 队列）

**思路：**

我们可以引入一个**队列**，通过迭代的方式模拟递归的过程。这里的核心是将需要比较的两个节点**成对**地放入队列中。

1.  **初始化**：将 `root.left` 和 `root.right` 入队。
2.  **循环处理**：当队列不为空时，每次连续取出两个节点 `u`和 `v`。
3.  **比较逻辑**：

    - 如果 `u` 和 `v` 都是 `null`，继续下一轮循环（continue）。
    - 如果 `u` 和 `v` 只有一个是 `null`，或者值不相等，返回 `false`。

4.  **子节点入队**：

    - 将 `u` 的左节点和 `v` 的右节点放入队列（外侧）。
    - 将 `u` 的右节点和 `v` 的左节点放入队列（内侧）。

5.  如果循环结束没有发现不对称的情况，返回 `true`。

**复杂度分析：**

- **时间复杂度：** $O(N)$。每个节点入队和出队各一次。
- **空间复杂度：** $O(N)$。队列中最多同时存储一层的节点数，最坏情况下为 $O(N)$。

**代码片段：**

```java
public boolean isSymmetricIterative(TreeNode root) {
    if (root == null) {
        return true;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root.left);
    queue.offer(root.right);

    while (!queue.isEmpty()) {
        TreeNode u = queue.poll();
        TreeNode v = queue.poll();

        if (u == null && v == null) {
            continue;
        }
        if ((u == null || v == null) || (u.val != v.val)) {
            return false;
        }

        // 成对入队：外侧配对
        queue.offer(u.left);
        queue.offer(v.right);
        // 成对入队：内侧配对
        queue.offer(u.right);
        queue.offer(v.left);
    }
    return true;
}
```

### 完整代码

```java
import java.util.*;

// 二叉树节点定义
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

public class Main {

    // --- 解法一：递归法 ---
    public static boolean isSymmetricRecursion(TreeNode root) {
        if (root == null) return true;
        return check(root.left, root.right);
    }

    private static boolean check(TreeNode p, TreeNode q) {
        if (p == null && q == null) return true;
        if (p == null || q == null || p.val != q.val) return false;
        return check(p.left, q.right) && check(p.right, q.left);
    }

    // --- 解法二：迭代法 ---
    public static boolean isSymmetricIterative(TreeNode root) {
        if (root == null) return true;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root.left);
        queue.offer(root.right);

        while (!queue.isEmpty()) {
            TreeNode u = queue.poll();
            TreeNode v = queue.poll();

            if (u == null && v == null) continue;
            if (u == null || v == null || u.val != v.val) return false;

            // 按照镜像顺序推入队列
            queue.offer(u.left);
            queue.offer(v.right);

            queue.offer(u.right);
            queue.offer(v.left);
        }
        return true;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        // 构造树: [1,2,2,3,4,4,3]
        TreeNode root1 = new TreeNode(1);
        root1.left = new TreeNode(2);
        root1.right = new TreeNode(2);
        root1.left.left = new TreeNode(3);
        root1.left.right = new TreeNode(4);
        root1.right.left = new TreeNode(4);
        root1.right.right = new TreeNode(3);

        System.out.println("示例 1 输入: root = [1,2,2,3,4,4,3]");
        System.out.println("递归法输出: " + isSymmetricRecursion(root1));
        System.out.println("迭代法输出: " + isSymmetricIterative(root1)); // 预期 true
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        // 构造树: [1,2,2,null,3,null,3]
        TreeNode root2 = new TreeNode(1);
        root2.left = new TreeNode(2);
        root2.right = new TreeNode(2);
        root2.left.right = new TreeNode(3);
        root2.right.right = new TreeNode(3);

        System.out.println("示例 2 输入: root = [1,2,2,null,3,null,3]");
        System.out.println("递归法输出: " + isSymmetricRecursion(root2));
        System.out.println("迭代法输出: " + isSymmetricIterative(root2)); // 预期 false
    }
}
```
