---
title: 101. 对称二叉树
date: 2024-07-13 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231327689.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：101. 对称二叉树

给你一个二叉树的根节点 `root`，检查它是否轴对称。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/02/19/symtree_1.jpg)

- **输入:** `root = [1,2,2,3,4,4,3]`
- **输出:** `true`

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2021/02/19/symtree_2.jpg)

- **输入:** `root = [1,2,2,null,3,null,3]`
- **输出:** `false`

**提示:**

- 树中节点数目在范围 `[1, 1000]` 内
- `-100 <= Node.val <= 100`

**进阶：** 你可以运用递归和迭代两种方法解决这个问题吗？

## Java 代码

**算法思路：(递归法)**

判断一棵树是否轴对称，等价于判断其 **左子树** 和 **右子树** 是否 **镜像对称**。

我们可以设计一个递归辅助函数 `isMirror(node1, node2)`，用于判断两棵树是否互为镜像。

1.  **递归终止条件:**
    - 如果 `node1` 和 `node2` **都为 null**，说明这对称位置上都没有节点，是镜像的，返回 `true`。
    - 如果 `node1` 和 `node2` **只有一个为 null**，说明结构不对称，返回 `false`。
    - 如果 `node1` 和 `node2` 的 **值不相等**，返回 `false`。
2.  **递归检查子节点:**
    - 如果以上条件都通过，我们需要进一步检查它们的子节点是否也满足镜像对称。
    - `node1` 的 **左子节点** 必须与 `node2` 的 **右子节点** 镜像对称。
    - `node1` 的 **右子节点** 必须与 `node2` 的 **左子节点** 镜像对称。
    - 只有当这两个条件 **同时** 满足时，`node1` 和 `node2` 才互为镜像。
3.  **初始调用:**
    - 从根节点开始，调用 `isMirror(root.left, root.right)`。

```java
/**
 * 二叉树节点的定义
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val) { this.val = val; }
}


public class Main {

    /**
     * 检查一个二叉树是否是轴对称的。
     */
    public static boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return isMirror(root.left, root.right);
    }

    /**
     * 递归辅助函数，判断两棵树是否互为镜像。
     * @param t1 树1
     * @param t2 树2
     * @return 如果互为镜像则返回 true
     */
    private static boolean isMirror(TreeNode t1, TreeNode t2) {
        // 递归终止条件
        if (t1 == null && t2 == null) return true;
        if (t1 == null || t2 == null) return false;

        // 判断当前节点值是否相等，并递归判断子树是否镜像对称
        return (t1.val == t2.val)
            && isMirror(t1.left, t2.right)
            && isMirror(t1.right, t2.left);
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        TreeNode root1 = new TreeNode(1);
        root1.left = new TreeNode(2);
        root1.right = new TreeNode(2);
        root1.left.left = new TreeNode(3);
        root1.left.right = new TreeNode(4);
        root1.right.left = new TreeNode(4);
        root1.right.right = new TreeNode(3);
        System.out.println("输入: root = [1,2,2,3,4,4,3]");
        boolean result1 = isSymmetric(root1);
        System.out.println("输出: " + result1); // 预期输出: true
        System.out.println();

        System.out.println("--- 示例 2 ---");
        TreeNode root2 = new TreeNode(1);
        root2.left = new TreeNode(2);
        root2.right = new TreeNode(2);
        root2.left.right = new TreeNode(3);
        root2.right.right = new TreeNode(3);
        System.out.println("输入: root = [1,2,2,null,3,null,3]");
        boolean result2 = isSymmetric(root2);
        System.out.println("输出: " + result2); // 预期输出: false
    }
}
```
