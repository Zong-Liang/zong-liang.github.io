---
title: 222. 完全二叉树的节点个数
date: 2024-08-02 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231840380.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一棵 **完全二叉树** 的根节点 `root`，求出该树的节点个数。

**完全二叉树** 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层（从第 0 层开始），则该层包含 `1`~`2^h` 个节点。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)

- **输入:** `root = [1,2,3,4,5,6]`
- **输出:** 6

**示例 2:**

- **输入:** `root = []`
- **输出:** 0

**示例 3:**

- **输入:** `root = [1]`
- **输出:** 1

**提示:**

- 树中节点的数目范围是 `[0, 5 * 10^4]`
- `0 <= Node.val <= 5 * 10^4`
- 题目数据保证输入的树是 **完全二叉树**

**进阶：** 遍历树来统计节点是一种时间复杂度为 `O(n)` 的简单解决方案。你可以设计一个更快的算法吗？

## 题解

### 解法一：普通遍历（线性时间复杂度）

**思路：**

最简单的方法是将完全二叉树视为普通二叉树，遍历每个节点并计数。可以使用递归（DFS）或迭代（BFS）来实现。

1.  如果根节点为 `null`，返回 0。
2.  否则，节点总数 = 1（根节点）+ 左子树节点数 + 右子树节点数。

**复杂度分析：**

- **时间复杂度：** $O(n)$。需要访问每一个节点。
- **空间复杂度：** $O(h)$，其中 $h$ 是树的高度。递归调用栈的深度。

**代码片段：**

```java
public int countNodes(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return 1 + countNodes(root.left) + countNodes(root.right);
}
```

### 解法二：利用完全二叉树性质（进阶：$O(\log^2 n)$）

**思路：**

完全二叉树有一个重要的性质：**它的左右子树中，至少有一棵是“满二叉树”**。

我们可以通过比较当前节点 **左子树的深度** 和 **右子树的深度** 来判断哪一边是满的，从而利用公式直接计算出该满子树的节点数，避免遍历。

1.  **定义高度函数**：由于是完全二叉树，计算树的高度（层数）只需要一直向左遍历即可，时间复杂度为 $O(\log n)$。
2.  **比较高度**：

    - 计算左子树的高度 `leftDepth`。

    - 计算右子树的高度 `rightDepth`。

3.  **判断逻辑**：

    - **情况 A：`leftDepth == rightDepth`**

      这说明 **左子树一定是满二叉树**。

      因为完全二叉树的底层节点是从左向右填的，如果右子树的高度能追上左子树，说明左边已经填满了。

      - 左子树节点数 + 根节点 = $2^{\text{leftDepth}} - 1 + 1 = 2^{\text{leftDepth}}$。
      - 利用位运算 `(1 << leftDepth)` 快速计算。
      - 总数 = `(1 << leftDepth) + countNodes(root.right)`。

    - **情况 B：`leftDepth > rightDepth`**

      这说明 **右子树一定是满二叉树**（只是比左边少一层）。

      说明最后一层的节点还未填到右子树，或者刚填到左子树的右半部分。

      - 右子树节点数 + 根节点 = $2^{\text{rightDepth}} - 1 + 1 = 2^{\text{rightDepth}}$。
      - 总数 = `(1 << rightDepth) + countNodes(root.left)`。

**复杂度分析：**

- **时间复杂度：** $O(\log^2 n)$。

  - 递归深度为树的高度 $h \approx \log n$。
  - 每次递归中我们需要计算子树高度，耗时 $O(\log n)$。
  - 总复杂度为 $O(h \times h) = O(\log^2 n)$。
  - 对于 $50000$ 个节点，普通遍历需 $50000$ 次操作，此算法仅需约 $16^2 = 256$ 次操作。

- **空间复杂度：** $O(\log n)$。递归栈的深度。

**代码片段：**

```java
public int countNodes(TreeNode root) {
    if (root == null) return 0;

    int leftLevel = countLevel(root.left);
    int rightLevel = countLevel(root.right);

    if (leftLevel == rightLevel) {
        // 左子树是满的 (高度为 leftLevel)
        // 节点数 = 左子树(2^leftLevel - 1) + 根(1) + 递归右子树
        return (1 << leftLevel) + countNodes(root.right);
    } else {
        // leftLevel > rightLevel，说明右子树是满的 (高度为 rightLevel)
        // 节点数 = 右子树(2^rightLevel - 1) + 根(1) + 递归左子树
        return (1 << rightLevel) + countNodes(root.left);
    }
}

// 辅助函数：计算完全二叉树的高度（一直向左走）
private int countLevel(TreeNode node) {
    int level = 0;
    while (node != null) {
        level++;
        node = node.left;
    }
    return level;
}
```

### 完整代码

```java
import java.util.*;

// 二叉树节点定义
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

public class Main {

    // --- 解法二：利用完全二叉树性质 (推荐) ---
    public static int countNodes(TreeNode root) {
        if (root == null) {
            return 0;
        }

        // 计算左右子树的高度（层数）
        int leftH = getHeight(root.left);
        int rightH = getHeight(root.right);

        if (leftH == rightH) {
            // 左子树一定是满二叉树
            // 公式：(2^leftH - 1) + 1 + 递归右子树
            // 1 << leftH 等价于 2^leftH
            return (1 << leftH) + countNodes(root.right);
        } else {
            // 右子树一定是满二叉树（高度比左边小 1）
            // 公式：(2^rightH - 1) + 1 + 递归左子树
            return (1 << rightH) + countNodes(root.left);
        }
    }

    // 统计树的高度：由于是完全二叉树，一直向左遍历即可
    private static int getHeight(TreeNode node) {
        int height = 0;
        while (node != null) {
            height++;
            node = node.left;
        }
        return height;
    }

    // --- 辅助方法：构建完全二叉树 ---
    // 使用层序遍历数组构建二叉树
    public static TreeNode buildTree(Integer[] arr) {
        if (arr.length == 0) return null;
        TreeNode root = new TreeNode(arr[0]);
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        int i = 1;
        while (i < arr.length) {
            TreeNode curr = q.poll();
            if (i < arr.length && arr[i] != null) {
                curr.left = new TreeNode(arr[i]);
                q.add(curr.left);
            }
            i++;
            if (i < arr.length && arr[i] != null) {
                curr.right = new TreeNode(arr[i]);
                q.add(curr.right);
            }
            i++;
        }
        return root;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        Integer[] input1 = {1, 2, 3, 4, 5, 6};
        TreeNode root1 = buildTree(input1);

        System.out.println("示例 1 输入: root = [1,2,3,4,5,6]");
        int res1 = countNodes(root1);
        System.out.println("示例 1 输出: " + res1); // 预期 6
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        Integer[] input2 = {};
        TreeNode root2 = buildTree(input2);

        System.out.println("示例 2 输入: root = []");
        int res2 = countNodes(root2);
        System.out.println("示例 2 输出: " + res2); // 预期 0
        System.out.println("-----------------------------");

        // --- 示例 3 测试 ---
        Integer[] input3 = {1};
        TreeNode root3 = buildTree(input3);

        System.out.println("示例 3 输入: root = [1]");
        int res3 = countNodes(root3);
        System.out.println("示例 3 输出: " + res3); // 预期 1

        // --- 额外测试：验证非满的完全二叉树 logic ---
        // 输入: [1, 2, 3, 4, 5] (总数 5)
        //       1
        //     /   \
        //    2     3
        //   / \
        //  4   5
        Integer[] input4 = {1, 2, 3, 4, 5};
        TreeNode root4 = buildTree(input4);
        System.out.println("-----------------------------");
        System.out.println("额外测试输入: root = [1,2,3,4,5]");
        System.out.println("额外测试输出: " + countNodes(root4)); // 预期 5
    }
}
```
