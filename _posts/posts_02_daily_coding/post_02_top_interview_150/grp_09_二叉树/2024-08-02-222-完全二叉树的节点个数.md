---
title: 222-完全二叉树的节点个数
date: 2024-08-02 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231840380.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

### 题目：222. 完全二叉树的节点个数

给你一棵 **完全二叉树** 的根节点 `root`，求出该树的节点个数。

**完全二叉树** 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层（从第 0 层开始），则该层包含 `1`~`2^h` 个节点。

---

**示例 1:**
![示例1图片](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)

- **输入:** `root = [1,2,3,4,5,6]`
- **输出:** 6

**示例 2:**

- **输入:** `root = []`
- **输出:** 0

**示例 3:**

- **输入:** `root = [1]`
- **输出:** 1

---

**提示:**

- 树中节点的数目范围是 `[0, 5 * 10^4]`
- `0 <= Node.val <= 5 * 10^4`
- 题目数据保证输入的树是 **完全二叉树**

**进阶：** 遍历树来统计节点是一种时间复杂度为 `O(n)` 的简单解决方案。你可以设计一个更快的算法吗？

---

### Java 8 解答 (赛码网格式)

**算法思路：(利用完全二叉树性质)**
为了设计一个比 `O(n)` 更快的算法，我们需要利用 **完全二叉树** 的特性。

1.  对于一个完全二叉树，我们可以快速计算其 **左子树** 和 **右子树** 的高度。
    - 左子树的高度可以通过不断访问 `node.left` 来得到。
    - 右子树的高度可以通过不断访问 `node.right` 来得到。
2.  **比较高度:**
    - **如果 `左子树高度 == 右子树高度`:** 这意味着左子树是一棵 **满二叉树**，并且右子树是一棵 **完全二叉树**。
      - 左子树的节点数可以由公式 `2^h - 1` 计算得出，加上根节点，总共是 `2^h` 个节点（`h` 是左子树高度）。
      - 然后，我们只需要递归地计算右子树的节点数。
      - 总节点数 = `(1 << leftHeight)` + `countNodes(root.right)`
    - **如果 `左子树高度 > 右子树高度`:** 这意味着右子树是一棵 **满二叉树**，其高度比左子树小 1，并且左子树是一棵 **完全二叉树**。
      - 右子树的节点数可以由公式 `2^h - 1` 计算得出，加上根节点，总共是 `2^h` 个节点（`h` 是右子树高度）。
      - 然后，我们只需要递归地计算左子树的节点数。
      - 总节点数 = `(1 << rightHeight)` + `countNodes(root.left)`

通过这种方式，在每次递归中，我们都有一半的子树是满二叉树，可以直接计算其节点数，从而避免了对这部分子树的完全遍历。这使得算法的时间复杂度降低到 `O((log n)^2)`。

```java
/**
 * 二叉树节点的定义
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val) { this.val = val; }
}

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    /**
     * 计算完全二叉树的节点个数。
     */
    public static int countNodes(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int leftHeight = getHeight(root.left);
        int rightHeight = getHeight(root.right);

        if (leftHeight == rightHeight) {
            // 左子树是满二叉树
            // 节点数 = 左子树节点数 + 根节点 + 递归计算右子树
            // (1 << leftHeight) - 1 是左子树节点数, +1 是根节点
            return (1 << leftHeight) + countNodes(root.right);
        } else {
            // 右子树是满二叉树
            // 节点数 = 右子树节点数 + 根节点 + 递归计算左子树
            return (1 << rightHeight) + countNodes(root.left);
        }
    }

    /**
     * 计算完全二叉树的高度（沿着最左侧路径）
     */
    private static int getHeight(TreeNode node) {
        int height = 0;
        while (node != null) {
            height++;
            node = node.left;
        }
        return height;
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        TreeNode root1 = new TreeNode(1);
        root1.left = new TreeNode(2);
        root1.right = new TreeNode(3);
        root1.left.left = new TreeNode(4);
        root1.left.right = new TreeNode(5);
        root1.right.left = new TreeNode(6);
        System.out.println("输入: root = [1,2,3,4,5,6]");
        int result1 = countNodes(root1);
        System.out.println("输出: " + result1); // 预期输出: 6
        System.out.println();

        System.out.println("--- 示例 2 ---");
        TreeNode root2 = null;
        System.out.println("输入: root = []");
        int result2 = countNodes(root2);
        System.out.println("输出: " + result2); // 预期输出: 0
        System.out.println();

        System.out.println("--- 示例 3 ---");
        TreeNode root3 = new TreeNode(1);
        System.out.println("输入: root = [1]");
        int result3 = countNodes(root3);
        System.out.println("输出: " + result3); // 预期输出: 1
    }
}
```
