---
title: 114. 二叉树展开为链表
date: 2024-07-20 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231616326.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你二叉树的根节点 `root`，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode`，其中 `right` 子指针指向链表中下一个节点，而左子指针始终为 `null`。
- 展开后的单链表应该与二叉树 **先序遍历** 顺序相同。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

- **输入:** `root = [1,2,5,3,4,null,6]`
- **输出:** `[1,null,2,null,3,null,4,null,5,null,6]`

**示例 2:**

- **输入:** `root = []`
- **输出:** `[]`

**示例 3:**

- **输入:** `root = [0]`
- **输出:** `[0]`

**提示:**

- 树中节点数在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`

**进阶：** 你可以使用原地算法（`O(1)` 额外空间）展开这棵树吗？

## 题解

### 解法一：递归法（后序遍历思路）

**思路：**

我们要将二叉树展开为链表，且顺序为**先序遍历**（根 -> 左 -> 右）。

我们可以利用递归的分治思想，自底向上地处理：

1.  **递归展开**：先递归地将左子树展开，再递归地将右子树展开。
2.  **暂存右子树**：因为我们要把左子树放到根节点的右边，所以原来的右子树需要先暂存起来，防止丢失。
3.  **拼接**：

    - 将展开后的左子树接到根节点的 `right` 指针上。
    - 将根节点的 `left` 指针置为 `null`。
    - 找到当前新的右子树（原左子树）的**末尾**。
    - 将暂存的原右子树接到末尾。

**复杂度分析：**

- **时间复杂度：** $O(N)$。前序遍历每个节点访问一次，但拼接时寻找尾节点在最坏情况下（链状）可能导致总体稍高于线性，但均摊看来仍是 $O(N)$。
- **空间复杂度：** $O(N)$。最坏情况下递归栈的深度为 $N$。

**代码片段：**

```java
public void flatten(TreeNode root) {
    if (root == null) {
        return;
    }

    // 1. 递归处理左右子树
    flatten(root.left);
    flatten(root.right);

    // 2. 后序处理：此时左右子树已经分别被拉平成链表了
    TreeNode left = root.left;
    TreeNode right = root.right;

    // 3. 将左子树插到右边
    root.left = null;
    root.right = left;

    // 4. 找到新右子树的末尾，把原右子树接上去
    TreeNode p = root;
    while (p.right != null) {
        p = p.right;
    }
    p.right = right;
}
```

### 解法二：寻找前驱节点（进阶：原地算法 O(1) 空间）

**思路：**

为了满足 $O(1)$ 的空间要求，我们不能使用递归或栈。我们可以参考 **Morris 遍历** 的思想，通过调整指针来直接修改树的结构。

对于当前节点 `curr`：

1.  如果 `curr` 有左子节点：

    - 我们需要找到左子树中**最右边的节点**（即左子树在先序遍历中的最后一个节点，也是 `curr` 右子树在先序遍历中的**前驱节点**）。
    - 将 `curr` 原本的右子树接到这个“最右节点”的右边。
    - 将 `curr` 的左子树移动到 `curr` 的右边。
    - 将 `curr` 的左子树置空。

2.  如果 `curr` 没有左子节点，或者上述操作完成后：

    - `curr` 向右移动（`curr = curr.right`），处理下一个节点。

通过这种方式，我们一边遍历一边将左子树“嫁接”到右边，最终形成一个单链表。

**示意图逻辑：**

```
    1              1
   / \            / \
  2   5   ==>    2   5
 / \   \          \   \
3   4   6          3   6
                    \
                     4
                     ^
         (4 是 2 的子树中最右的，将 1 的右子树 5 挂在 4 后面)
```

**复杂度分析：**

- **时间复杂度：** $O(N)$。每个节点会被访问常数次（寻找前驱节点虽然有循环，但每条边最多被遍历两次）。
- **空间复杂度：** $O(1)$。只使用了常数个指针变量，原地修改。

**代码片段：**

```java
public void flatten(TreeNode root) {
    TreeNode curr = root;
    while (curr != null) {
        // 如果左子节点不为空，才需要处理
        if (curr.left != null) {
            TreeNode next = curr.left;
            TreeNode predecessor = next;

            // 找到左子树中的最右节点
            while (predecessor.right != null) {
                predecessor = predecessor.right;
            }

            // 将当前节点的右子树挂到左子树的最右节点后面
            predecessor.right = curr.right;

            // 将左子树移到右边，左边置空
            curr.left = null;
            curr.right = next;
        }
        // 继续处理下一个节点
        curr = curr.right;
    }
}
```

---

### 完整代码

```java
import java.util.*;

// 二叉树节点定义
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

public class Main {

    // 核心算法实现（进阶解法：寻找前驱节点，O(1) 空间）
    public static void flatten(TreeNode root) {
        TreeNode curr = root;
        while (curr != null) {
            // 如果存在左子节点，说明破坏了“单链表”结构，需要将左子树移到右边
            if (curr.left != null) {
                TreeNode next = curr.left;
                TreeNode predecessor = next;

                // 1. 找到左子树中最右边的节点
                while (predecessor.right != null) {
                    predecessor = predecessor.right;
                }

                // 2. 将 curr 原本的右子树，接到 predecessor 的后面
                // 这样保证了先序遍历的顺序：左子树遍历完 -> 原右子树
                predecessor.right = curr.right;

                // 3. 将左子树整体移到右边，并将左指针置空
                curr.left = null;
                curr.right = next;
            }
            // 4. 移动到下一个节点（因为左子树已经移到了右边，所以这里总是向右走）
            curr = curr.right;
        }
    }

    // 辅助方法：打印“链表化”后的树
    public static void printFlattenedTree(TreeNode root) {
        List<String> res = new ArrayList<>();
        TreeNode curr = root;
        while (curr != null) {
            res.add(String.valueOf(curr.val));
            // 检查 left 是否真的为 null
            if (curr.left != null) {
                System.err.println("Error: Node " + curr.val + " has left child!");
            }
            curr = curr.right;
        }
        System.out.println(res);
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        // 构造树: [1,2,5,3,4,null,6]
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(5);
        root.left.left = new TreeNode(3);
        root.left.right = new TreeNode(4);
        root.right.right = new TreeNode(6);

        System.out.println("示例 1 输入: root = [1,2,5,3,4,null,6]");
        flatten(root);
        System.out.print("示例 1 输出: ");
        printFlattenedTree(root); // 预期: [1, 2, 3, 4, 5, 6]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        TreeNode root2 = null;
        System.out.println("示例 2 输入: root = []");
        flatten(root2);
        System.out.print("示例 2 输出: ");
        printFlattenedTree(root2); // 预期: []
        System.out.println("-----------------------------");

        // --- 示例 3 测试 ---
        TreeNode root3 = new TreeNode(0);
        System.out.println("示例 3 输入: root = [0]");
        flatten(root3);
        System.out.print("示例 3 输出: ");
        printFlattenedTree(root3); // 预期: [0]
    }
}
```
