---
title: 114. 二叉树展开为链表
date: 2024-07-20 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231616326.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：114. 二叉树展开为链表

给你二叉树的根节点 `root`，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode`，其中 `right` 子指针指向链表中下一个节点，而左子指针始终为 `null`。
- 展开后的单链表应该与二叉树 **先序遍历** 顺序相同。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

- **输入:** `root = [1,2,5,3,4,null,6]`
- **输出:** `[1,null,2,null,3,null,4,null,5,null,6]`

**示例 2:**

- **输入:** `root = []`
- **输出:** `[]`

**示例 3:**

- **输入:** `root = [0]`
- **输出:** `[0]`

**提示:**

- 树中节点数在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`

**进阶：** 你可以使用原地算法（`O(1)` 额外空间）展开这棵树吗？

## Java 代码

**算法思路：(寻找前驱节点 / O(1) 空间)**

为了满足进阶要求 `O(1)` 的空间复杂度，我们不能使用递归或显式栈（它们会使用 `O(h)` 的空间）。一个巧妙的 **原地算法** 如下：

我们遍历树，对于每个节点 `curr`：

1.  **如果 `curr` 有左子树:**
    a. 我们需要找到 `curr` 的 **前驱节点**。在先序遍历中，一个节点的前驱是其左子树中“最右”的节点。
    b. 我们可以通过 `predecessor = curr.left` 开始，然后不断 `predecessor = predecessor.right` 直到 `predecessor.right` 为空。
    c. 找到前驱节点后，我们将 `curr` 的 **右子树** 拼接到前驱节点的 **右子节点** 上 (`predecessor.right = curr.right`)。
    d. 然后，将 `curr` 的 **左子树** 移动到其 **右子节点** 的位置 (`curr.right = curr.left`)。
    e. 最后，将 `curr` 的左子节点设为 `null` (`curr.left = null`)。
2.  **如果 `curr` 没有左子树:**
    - 它已经符合链表的部分结构（左边为空），我们直接处理它的下一个节点，即 `curr = curr.right`。

重复这个过程，直到 `curr` 变为 `null`，整棵树就会被原地展开成链表。

```java
import java.util.ArrayList;
import java.util.List;

/**
 * 二叉树节点的定义
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val) { this.val = val; }
}


public class Main {

    /**
     * 将二叉树展开为单链表。
     */
    public void flatten(TreeNode root) {
        TreeNode curr = root;
        while (curr != null) {
            if (curr.left != null) {
                // 找到左子树的最右节点 (即 curr 的前驱)
                TreeNode predecessor = curr.left;
                while (predecessor.right != null) {
                    predecessor = predecessor.right;
                }

                // 1. 将 curr 的右子树连接到前驱节点的右边
                predecessor.right = curr.right;

                // 2. 将 curr 的左子树移动到右边
                curr.right = curr.left;

                // 3. 将 curr 的左子树置空
                curr.left = null;
            }
            // 继续处理下一个节点
            curr = curr.right;
        }
    }

    // 辅助函数，用于测试和打印结果
    public static void printFlattenedTree(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        TreeNode current = root;
        while (current != null) {
            result.add(current.val);
            if(current.left != null) { // 检查左子树是否为空
                 result.add(null);
            }
            if(current.right != null) { // 检查是否需要为下一个节点添加 null
                 result.add(null);
            }
            current = current.right;
        }

        // 模拟 LeetCode 的输出格式
        StringBuilder sb = new StringBuilder("[");
        current = root;
        while(current != null){
            sb.append(current.val);
            sb.append(",null,");
            current = current.right;
        }
        if(sb.length() > 1) {
            sb.setLength(sb.length() - 1); // 移除最后一个逗号
        }
        if(sb.length() > 6) { // 移除 [1,null,2,null,...] 最后的 ",null"
            sb.setLength(sb.length()-5);
        }
        sb.append("]");

        if (root == null) {
            System.out.println("[]");
        } else if (root.left == null && root.right == null) {
            System.out.println("[" + root.val + "]");
        } else {
             System.out.println(sb.toString());
        }
    }


    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        TreeNode root1 = new TreeNode(1);
        root1.left = new TreeNode(2);
        root1.right = new TreeNode(5);
        root1.left.left = new TreeNode(3);
        root1.left.right = new TreeNode(4);
        root1.right.right = new TreeNode(6);
        System.out.println("输入: root = [1,2,5,3,4,null,6]");
        solution.flatten(root1);
        System.out.print("输出: ");
        printFlattenedTree(root1); // 预期输出: [1,null,2,null,3,null,4,null,5,null,6]
        System.out.println();

        System.out.println("--- 示例 2 ---");
        TreeNode root2 = null;
        System.out.println("输入: root = []");
        solution.flatten(root2);
        System.out.print("输出: ");
        printFlattenedTree(root2); // 预期输出: []
        System.out.println();

        System.out.println("--- 示例 3 ---");
        TreeNode root3 = new TreeNode(0);
        System.out.println("输入: root = [0]");
        solution.flatten(root3);
        System.out.print("输出: ");
        printFlattenedTree(root3); // 预期输出: [0]
    }
}
```
