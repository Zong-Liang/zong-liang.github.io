---
title: 124. 二叉树中的最大路径和
date: 2024-07-28 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231747601.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

二叉树中的 **路径** 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 **至多出现一次**。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root`，返回其 **最大路径和**。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

- **输入:** `root = [1,2,3]`
- **输出:** 6
- **解释:** 最优路径是 `2 -> 1 -> 3`，路径和为 `2 + 1 + 3 = 6`

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

- **输入:** `root = [-10,9,20,null,null,15,7]`
- **输出:** 42
- **解释:** 最优路径是 `15 -> 20 -> 7`，路径和为 `15 + 20 + 7 = 42`

**提示:**

- 树中节点数目范围是 `[1, 3 * 10^4]`
- `-1000 <= Node.val <= 1000`

## 题解

### 解法：递归法 (DFS / 后序遍历)

**思路：**

寻找二叉树中的最大路径和，核心在于理解路径的组成。对于任意一个节点 `node`，经过该节点的最大路径和可能来自于以下两种情况：

1.  **“拱形”路径（作为路径的最高点）**：路径从左子树上来，经过当前节点，再下到右子树去。这种路径的形态类似倒 `V` 字形。路径和 = `左子树提供的最大贡献 + 当前节点值 + 右子树提供的最大贡献`。**注意**：这种路径不能再向上延伸连接父节点，因为它已经分叉了。
2.  **“单边”路径（作为子路径贡献给父节点）**：路径从左子树（或右子树）上来，经过当前节点，继续向上延伸连接父节点。路径和 = `当前节点值 + max(左子树最大贡献, 右子树最大贡献)`。

**算法流程：**

我们定义一个递归函数 `maxGain(node)`，它的含义是：**计算以 `node` 为起点，向下延伸到子树的最大路径和**（即该节点能给父节点提供的最大贡献）。

1.  **全局变量**：我们需要一个全局变量 `maxSum` 来记录遍历过程中发现的所有可能路径（包括拱形路径）的最大值。初始化为 `Integer.MIN_VALUE`。
2.  **递归逻辑**：

    - **终止条件**：如果 `node` 为空，贡献为 0。
    - **递归计算**：

      - 计算左子树的最大贡献 `leftGain = maxGain(node.left)`。**关键点**：如果子树的贡献是负数，我们不如不选它（即贡献视作 0），所以 `leftGain = max(maxGain(node.left), 0)`。
      - 同理计算右子树的最大贡献 `rightGain = max(maxGain(node.right), 0)`。

    - **更新全局最大值**：当前节点作为“拱形”路径顶点时的和为 `node.val + leftGain + rightGain`。我们用这个值尝试更新 `maxSum`。
    - **返回值**：返回给父节点的是“单边”最大路径和，即 `node.val + max(leftGain, rightGain)`。

**复杂度分析：**

- **时间复杂度：** $O(N)$，其中 $N$ 是二叉树的节点个数。我们需要遍历每个节点一次。
- **空间复杂度：** $O(H)$，其中 $H$ 是二叉树的高度。主要消耗在递归栈空间。最坏情况（链状）为 $O(N)$，平均情况为 $O(\log N)$。

**代码片段：**

```java
int maxSum = Integer.MIN_VALUE;

public int maxPathSum(TreeNode root) {
    maxGain(root);
    return maxSum;
}

public int maxGain(TreeNode node) {
    if (node == null) {
        return 0;
    }

    // 递归计算左右子节点的最大贡献值
    // 只有在最大贡献值大于 0 时，才会选取对应子节点
    int leftGain = Math.max(maxGain(node.left), 0);
    int rightGain = Math.max(maxGain(node.right), 0);

    // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
    // 这里计算的是以当前节点为最高点的路径和（倒 V 型），用来更新全局最大值
    int priceNewpath = node.val + leftGain + rightGain;

    // 更新全局最大值
    maxSum = Math.max(maxSum, priceNewpath);

    // 返回节点的最大贡献值（只能选一边）
    return node.val + Math.max(leftGain, rightGain);
}
```

### 完整代码

```java
import java.util.LinkedList;
import java.util.Queue;

public class Main {

    // Definition for a binary tree node.
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode() {}
        TreeNode(int val) { this.val = val; }
        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    // 全局变量，记录最大路径和
    static int maxSum = Integer.MIN_VALUE;

    public static int maxPathSum(TreeNode root) {
        // 每次调用前重置全局变量（防止多个测试用例干扰）
        maxSum = Integer.MIN_VALUE;
        maxGain(root);
        return maxSum;
    }

    /**
     * 计算节点的最大贡献值
     * 定义：以该节点为起点，在子树中向下延伸的一条路径的最大和
     */
    public static int maxGain(TreeNode node) {
        if (node == null) {
            return 0;
        }

        // 递归计算左右子节点的最大贡献值
        // 如果子树路径和为负数，则应当舍弃（取0），因为加上负数只会让总和变小
        int leftGain = Math.max(maxGain(node.left), 0);
        int rightGain = Math.max(maxGain(node.right), 0);

        // 计算包含当前节点及左右子树的路径和（倒V型路径）
        // 这条路径不能继续向上延伸，所以只用来更新全局最大值
        int priceNewPath = node.val + leftGain + rightGain;

        // 更新全局最大值
        maxSum = Math.max(maxSum, priceNewPath);

        // 返回给父节点：当前节点值 + 左右子树中较大的一个（只能选一条路向上延伸）
        return node.val + Math.max(leftGain, rightGain);
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        // 输入: root = [1,2,3]
        TreeNode root1 = new TreeNode(1);
        root1.left = new TreeNode(2);
        root1.right = new TreeNode(3);

        System.out.println("示例 1 输入: [1,2,3]");
        System.out.println("示例 1 输出: " + maxPathSum(root1)); // 预期: 6 (2 + 1 + 3)
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        // 输入: root = [-10,9,20,null,null,15,7]
        TreeNode root2 = new TreeNode(-10);
        root2.left = new TreeNode(9);
        root2.right = new TreeNode(20);
        root2.right.left = new TreeNode(15);
        root2.right.right = new TreeNode(7);

        System.out.println("示例 2 输入: [-10,9,20,null,null,15,7]");
        System.out.println("示例 2 输出: " + maxPathSum(root2)); // 预期: 42 (15 + 20 + 7)
        System.out.println("-----------------------------");

        // --- 示例 3 测试 (全负数) ---
        // 输入: root = [-3]
        TreeNode root3 = new TreeNode(-3);
        System.out.println("示例 3 输入: [-3]");
        System.out.println("示例 3 输出: " + maxPathSum(root3)); // 预期: -3
    }
}
```
