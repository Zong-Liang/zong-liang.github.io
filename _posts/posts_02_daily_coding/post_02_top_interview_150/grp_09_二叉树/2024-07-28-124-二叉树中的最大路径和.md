---
title: 124. 二叉树中的最大路径和
date: 2024-07-28 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231747601.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：124. 二叉树中的最大路径和

二叉树中的 **路径** 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 **至多出现一次**。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root`，返回其 **最大路径和**。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

- **输入:** `root = [1,2,3]`
- **输出:** 6
- **解释:** 最优路径是 `2 -> 1 -> 3`，路径和为 `2 + 1 + 3 = 6`

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

- **输入:** `root = [-10,9,20,null,null,15,7]`
- **输出:** 42
- **解释:** 最优路径是 `15 -> 20 -> 7`，路径和为 `15 + 20 + 7 = 42`

**提示:**

- 树中节点数目范围是 `[1, 3 * 10^4]`
- `-1000 <= Node.val <= 1000`

## 题解

**算法思路：(递归 / 后序遍历)**

这个问题需要对树进行深度优先搜索。对于任何一个节点 `node`，以它为“拐点”的最大路径和，等于 `node.val` 加上其左、右子树提供的最大“单边”路径和。

我们需要一个递归函数，它不仅要计算以当前节点为根的子树中的最大路径和，还要返回一个值给它的父节点使用。

1.  **全局变量 `maxSum`:** 创建一个全局变量（或一个包装类/数组以便在递归中修改）来存储遍历过程中遇到的最大路径和。
2.  **递归函数 `maxGain(node)`:**
    - 这个函数的核心任务是计算并返回从 `node` 出发 **向下** 的 **单边最大路径和**。
    - **递归基:** 如果 `node` 为 `null`，它不能提供任何增益，返回 `0`。
    - **递归计算子树增益:**
      - 递归调用 `maxGain(node.left)` 和 `maxGain(node.right)` 来获取左右子树能提供的最大单边路径和。
      - **重要：** 如果子树返回的增益是负数，我们应该舍弃它，因为它只会让路径和变小。所以我们用 `Math.max(0, maxGain(child))`。
    - **更新全局最大路径和:**
      - 在当前节点 `node`，一个新的、可能的最大路径和是 `node.val + leftGain + rightGain`。我们用这个值来更新全局的 `maxSum`。
    - **返回值:**
      - 函数必须返回从 `node` **向下** 的 **单边** 路径的最大和，即 `node.val + Math.max(leftGain, rightGain)`。这个返回值是给 `node` 的父节点使用的。

通过对整棵树进行一次后序遍历，我们就能确保在每个节点都计算了以其为“拐点”的最大路径和，从而找到全局的最大值。

```java
/**
 * 二叉树节点的定义
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val) { this.val = val; }
}


public class Main {

    // 使用一个成员变量来存储全局最大路径和
    private int maxSum;

    /**
     * 返回二叉树的最大路径和。
     */
    public int maxPathSum(TreeNode root) {
        // 初始化为树中可能存在的最小值
        maxSum = Integer.MIN_VALUE;
        maxGain(root);
        return maxSum;
    }

    /**
     * 递归辅助函数，计算以 node 为起点的最大单边路径和，
     * 并在此过程中更新全局最大路径和 maxSum。
     * @param node 当前节点
     * @return 从 node 出发向下的单边最大路径和
     */
    private int maxGain(TreeNode node) {
        if (node == null) {
            return 0;
        }

        // 递归计算左右子树提供的最大增益
        // 如果子树的增益是负数，则舍弃（取 0）
        int leftGain = Math.max(0, maxGain(node.left));
        int rightGain = Math.max(0, maxGain(node.right));

        // 更新全局最大路径和：当前节点值 + 左增益 + 右增益
        // 这代表以当前节点为“拐点”的路径
        maxSum = Math.max(maxSum, node.val + leftGain + rightGain);

        // 返回给父节点的、经过当前节点的单边最大路径和
        return node.val + Math.max(leftGain, rightGain);
    }


    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        TreeNode root1 = new TreeNode(1);
        root1.left = new TreeNode(2);
        root1.right = new TreeNode(3);
        System.out.println("输入: root = [1,2,3]");
        int result1 = solution.maxPathSum(root1);
        System.out.println("输出: " + result1); // 预期输出: 6
        System.out.println();

        // 为下一个示例重置实例
        solution = new Main();

        System.out.println("--- 示例 2 ---");
        TreeNode root2 = new TreeNode(-10);
        root2.left = new TreeNode(9);
        root2.right = new TreeNode(20);
        root2.right.left = new TreeNode(15);
        root2.right.right = new TreeNode(7);
        System.out.println("输入: root = [-10,9,20,null,null,15,7]");
        int result2 = solution.maxPathSum(root2);
        System.out.println("输出: " + result2); // 预期输出: 42
    }
}
```
