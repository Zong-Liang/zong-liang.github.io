---
title: 104. 二叉树的最大深度
date: 2024-07-09 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231144714.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述**

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

**示例 1:**

- **输入:** `root = [3,9,20,null,null,15,7]`
- **输出:** 3

**示例 2:**

- **输入:** `root = [1,null,2]`
- **输出:** 2

**提示:**

- 树中节点的数量在 `[0, 10^4]` 区间内。
- `-100 <= Node.val <= 100`

## 题解

### 解法一：递归法 (DFS)

**思路：**

二叉树的最大深度可以看作是“根节点的高度”。根据递归的定义，一棵树的最大深度等于其 **左子树的最大深度** 和 **右子树的最大深度** 中的 **较大者** 加 1（这个 1 代表根节点自己这一层）。

这是一个典型的后序遍历（Bottom-up）思路：

1.  **终止条件**：如果当前节点 `root` 为空，说明到达了叶子节点的下一层，深度为 0。
2.  **递归计算**：分别计算左子树的深度和右子树的深度。
3.  **返回结果**：当前节点的深度 = `max(leftDepth, rightDepth) + 1`。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 为二叉树的节点数。我们需要遍历每个节点一次。
- **空间复杂度：** $O(height)$，其中 $height$ 为二叉树的高度。递归函数需要栈空间，最坏情况下（树退化为链表）为 $O(n)$，平均情况下（平衡树）为 $O(\log n)$。

**代码片段：**

```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftHeight = maxDepth(root.left);
    int rightHeight = maxDepth(root.right);
    return Math.max(leftHeight, rightHeight) + 1;
}
```

### 解法二：迭代法 (BFS / 层序遍历)

**思路：**

我们也可以使用 **广度优先搜索 (BFS)** 进行层序遍历。最大深度实际上就是二叉树的 **层数**。

1.  使用一个队列 `queue`，初始将 `root` 入队。
2.  只要队列不为空，说明还有下一层：

    - 深度 `depth` 加 1。
    - 记录当前队列的大小 `size`（即当前层的节点个数）。
    - 循环 `size` 次，将当前层的所有节点依次出队，并将它们的左右子节点（如果不为空）加入队列。

3.  循环结束后，`depth` 即为最大深度。

**复杂度分析：**

- **时间复杂度：** $O(n)$，每个节点进出队列各一次。
- **空间复杂度：** $O(n)$，最坏情况下，队列中需要存储树中最宽的一层节点，这可能达到 $O(n)$（例如满二叉树的叶子层）。

**代码片段：**

```java
public int maxDepth(TreeNode root) {
    if (root == null) return 0;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int depth = 0;

    while (!queue.isEmpty()) {
        int size = queue.size();
        // 遍历当前层的所有节点
        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        // 当前层遍历完，深度 + 1
        depth++;
    }

    return depth;
}
```

### 完整代码

```java
import java.util.LinkedList;
import java.util.Queue;

public class Main {

    // Definition for a binary tree node.
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode() {}
        TreeNode(int val) { this.val = val; }
        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    // 核心算法实现：解法一（递归 DFS）
    public static int maxDepthRecursive(TreeNode root) {
        if (root == null) {
            return 0;
        }
        return Math.max(maxDepthRecursive(root.left), maxDepthRecursive(root.right)) + 1;
    }

    // 核心算法实现：解法二（迭代 BFS）
    public static int maxDepthIterative(TreeNode root) {
        if (root == null) return 0;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int depth = 0;

        while (!queue.isEmpty()) {
            int size = queue.size();
            // 将当前层的节点全部出队，把下一层的节点全部入队
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
            depth++;
        }
        return depth;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        // 构造树: [3,9,20,null,null,15,7]
        TreeNode root1 = new TreeNode(3);
        root1.left = new TreeNode(9);
        root1.right = new TreeNode(20);
        root1.right.left = new TreeNode(15);
        root1.right.right = new TreeNode(7);

        System.out.println("示例 1 输入: [3,9,20,null,null,15,7]");
        System.out.println("DFS 结果: " + maxDepthRecursive(root1)); // 预期: 3
        System.out.println("BFS 结果: " + maxDepthIterative(root1)); // 预期: 3
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        // 构造树: [1,null,2]
        TreeNode root2 = new TreeNode(1);
        root2.right = new TreeNode(2);

        System.out.println("示例 2 输入: [1,null,2]");
        System.out.println("DFS 结果: " + maxDepthRecursive(root2)); // 预期: 2
        System.out.println("BFS 结果: " + maxDepthIterative(root2)); // 预期: 2
        System.out.println("-----------------------------");

        // --- 示例 3 测试 (空树) ---
        TreeNode root3 = null;
        System.out.println("示例 3 输入: []");
        System.out.println("DFS 结果: " + maxDepthRecursive(root3)); // 预期: 0
        System.out.println("BFS 结果: " + maxDepthIterative(root3)); // 预期: 0
    }
}
```
