---
title: 104-二叉树的最大深度
date: 2024-07-09 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231144714.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

好的，这是图片中问题的整理以及符合要求的 Java 8 解答。

### 题目：104. 二叉树的最大深度

**描述**
给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

**示例 1:**

- **输入:** `root = [3,9,20,null,null,15,7]`
- **输出:** 3

**示例 2:**

- **输入:** `root = [1,null,2]`
- **输出:** 2

**提示:**

- 树中节点的数量在 `[0, 10^4]` 区间内。
- `-100 <= Node.val <= 100`

---

### 赛码网格式 Java 8 代码

```java
import java.util.LinkedList;
import java.util.Queue;

/**
 * Definition for a binary tree node.
 * 为了符合题目要求，将 TreeNode 定义为独立的公开类。
 * 在赛码网等平台提交时，通常平台会预定义这个类。
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

public class Main {

    /**
     * 计算二叉树的最大深度 (递归方法)
     *
     * @param root 树的根节点
     * @return 树的最大深度
     */
    public static int maxDepth(TreeNode root) {
        // 递归的终止条件：如果节点为空，深度为0
        if (root == null) {
            return 0;
        } else {
            // 递归计算左子树的深度
            int leftDepth = maxDepth(root.left);
            // 递归计算右子树的深度
            int rightDepth = maxDepth(root.right);
            // 树的最大深度 = 左右子树深度的最大值 + 1 (根节点)
            return Math.max(leftDepth, rightDepth) + 1;
        }
    }

    // ----------- 以下为辅助方法，用于根据数组构建树 -----------

    /**
     * 根据数组（层序遍历）构建二叉树
     *
     * @param nums 代表树的层序遍历的数组，null 表示空节点
     * @return 构建好的树的根节点
     */
    public static TreeNode buildTree(Integer[] nums) {
        if (nums == null || nums.length == 0 || nums[0] == null) {
            return null;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        TreeNode root = new TreeNode(nums[0]);
        queue.offer(root);
        int i = 1;

        while (!queue.isEmpty() && i < nums.length) {
            TreeNode current = queue.poll();

            //构建左子节点
            if (nums[i] != null) {
                current.left = new TreeNode(nums[i]);
                queue.offer(current.left);
            }
            i++;

            //构建右子节点
            if (i < nums.length && nums[i] != null) {
                current.right = new TreeNode(nums[i]);
                queue.offer(current.right);
            }
            i++;
        }
        return root;
    }

    public static void main(String[] args) {
        // 示例 1
        Integer[] nums1 = {3, 9, 20, null, null, 15, 7};
        TreeNode root1 = buildTree(nums1);
        System.out.println(maxDepth(root1)); // 预期输出: 3

        // 示例 2
        Integer[] nums2 = {1, null, 2};
        TreeNode root2 = buildTree(nums2);
        System.out.println(maxDepth(root2)); // 预期输出: 2

        // 空树示例
        Integer[] nums3 = {};
        TreeNode root3 = buildTree(nums3);
        System.out.println(maxDepth(root3)); // 预期输出: 0
    }
}
```
