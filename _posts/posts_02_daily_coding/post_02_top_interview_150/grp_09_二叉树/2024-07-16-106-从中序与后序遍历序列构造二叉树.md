---
title: 106. 从中序与后序遍历序列构造二叉树
date: 2024-07-16 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231453961.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定两个整数数组 `inorder` 和 `postorder`，其中 `inorder` 是二叉树的中序遍历，`postorder` 是同一棵树的后序遍历，请你构造并返回这颗 **二叉树**。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

- **输入:** `inorder = [9,3,15,20,7]`, `postorder = [9,15,7,20,3]`
- **输出:** `[3,9,20,null,null,15,7]`

**示例 2:**

- **输入:** `inorder = [-1]`, `postorder = [-1]`
- **输出:** `[-1]`

**提示:**

- `1 <= inorder.length <= 3000`
- `postorder.length == inorder.length`
- `-3000 <= inorder[i], postorder[i] <= 3000`
- `inorder` 和 `postorder` 都由 **不同** 的值组成
- `postorder` 中每一个值都在 `inorder` 中
- `inorder` **保证**是树的中序遍历
- `postorder` **保证**是树的后序遍历

## 题解

### 解法：递归 + 哈希表优化

**思路：**

构造二叉树的核心在于**定位根节点**并**划分左右子树**。

1.  **后序遍历 (Postorder)** 的特性：`[[左子树], [右子树], 根节点]`。

    - 这意味着 `postorder` 数组的**最后一个元素**一定是当前子树的**根节点**。

2.  **中序遍历 (Inorder)** 的特性：`[[左子树], 根节点, [右子树]]`。

    - 只要我们在中序遍历中找到了根节点的位置，就可以确定左子树和右子树的**节点数量**和**范围**。

**算法流程：**

1.  **哈希映射**：为了在 $O(1)$ 时间内找到根节点在中序遍历中的位置，我们首先遍历 `inorder` 数组，将 `数值 -> 索引` 的映射存入哈希表 `indexMap`。
2.  **递归构建**：定义递归函数，传入当前子树在两个数组中的索引范围：

    - 中序范围：`[inLeft, inRight]`
    - 后序范围：`[postLeft, postRight]`

3.  **递归逻辑**：

    - **终止条件**：如果 `inLeft > inRight`，说明当前区间为空，返回 `null`。
    - **获取根节点**：取 `postorder[postRight]` 作为当前根节点的值。
    - **定位切割点**：通过哈希表找到该值在 `inorder` 中的索引 `inRootIndex`。
    - **计算左子树大小**：`leftSubtreeSize = inRootIndex - inLeft`。
    - **构建左子树**：

      - 中序范围：`[inLeft, inRootIndex - 1]`
      - 后序范围：`[postLeft, postLeft + leftSubtreeSize - 1]` （后序遍历中，左子树紧跟在起始位置）

    - **构建右子树**：

      - 中序范围：`[inRootIndex + 1, inRight]`
      - 后序范围：`[postLeft + leftSubtreeSize, postRight - 1]` （后序遍历中，右子树在左子树后面，根节点前面）

    - **连接并返回**：`root.left = leftChild`, `root.right = rightChild`，返回 `root`。

**复杂度分析：**

- **时间复杂度：** $O(n)$。构建哈希表需要 $O(n)$，递归构建每个节点访问一次，操作均为 $O(1)$。
- **空间复杂度：** $O(n)$。需要哈希表存储 $n$ 个元素，以及递归栈的空间（最坏情况 $O(n)$，平均 $O(\log n)$）。

**代码片段：**

```java
Map<Integer, Integer> indexMap;

public TreeNode buildTree(int[] inorder, int[] postorder) {
    int n = inorder.length;
    indexMap = new HashMap<>();
    for (int i = 0; i < n; i++) {
        indexMap.put(inorder[i], i);
    }
    return myBuildTree(inorder, 0, n - 1, postorder, 0, n - 1);
}

private TreeNode myBuildTree(int[] inorder, int inLeft, int inRight,
                             int[] postorder, int postLeft, int postRight) {
    if (inLeft > inRight) {
        return null;
    }

    // 后序遍历的最后一个元素是根节点
    int rootVal = postorder[postRight];
    TreeNode root = new TreeNode(rootVal);

    // 获取根节点在中序遍历中的索引
    int inRootIndex = indexMap.get(rootVal);

    // 计算左子树的节点数量
    int leftSubtreeSize = inRootIndex - inLeft;

    // 递归构建左子树
    // 中序：[左边界, 根位置-1]
    // 后序：[后序左边界, 后序左边界 + 左子树长度 - 1]
    root.left = myBuildTree(inorder, inLeft, inRootIndex - 1,
                            postorder, postLeft, postLeft + leftSubtreeSize - 1);

    // 递归构建右子树
    // 中序：[根位置+1, 右边界]
    // 后序：[后序左边界 + 左子树长度, 后序右边界 - 1 (减去当前的根节点)]
    root.right = myBuildTree(inorder, inRootIndex + 1, inRight,
                             postorder, postLeft + leftSubtreeSize, postRight - 1);

    return root;
}
```

### 完整代码

```java
import java.util.HashMap;
import java.util.Map;
import java.util.LinkedList;
import java.util.Queue;

public class Main {

    // Definition for a binary tree node.
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode() {}
        TreeNode(int val) { this.val = val; }
        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    // 哈希表用于存储中序遍历中 值 -> 索引 的映射
    private static Map<Integer, Integer> indexMap;

    public static TreeNode buildTree(int[] inorder, int[] postorder) {
        int n = inorder.length;
        indexMap = new HashMap<>();
        // 1. 预处理：将 inorder 的元素索引存入 Map，加速查找
        for (int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i);
        }

        // 2. 开始递归构建
        return myBuildTree(inorder, 0, n - 1, postorder, 0, n - 1);
    }

    /**
     * @param inorder   中序遍历数组
     * @param inLeft    当前子树的中序左边界
     * @param inRight   当前子树的中序右边界
     * @param postorder 后序遍历数组
     * @param postLeft  当前子树的后序左边界
     * @param postRight 当前子树的后序右边界
     */
    private static TreeNode myBuildTree(int[] inorder, int inLeft, int inRight,
                                        int[] postorder, int postLeft, int postRight) {
        // 递归终止条件：区间无效
        if (inLeft > inRight) {
            return null;
        }

        // 1. 后序遍历的最后一个元素就是当前的根节点
        int rootVal = postorder[postRight];
        TreeNode root = new TreeNode(rootVal);

        // 2. 找到根节点在中序遍历中的位置
        int inRootIndex = indexMap.get(rootVal);

        // 3. 计算左子树的大小 (用于确定后序遍历中左子树的范围)
        int leftSubtreeSize = inRootIndex - inLeft;

        // 4. 递归构建左子树
        // 左子树在 postorder 中的区间：从 postLeft 开始，长度为 leftSubtreeSize
        root.left = myBuildTree(inorder, inLeft, inRootIndex - 1,
                                postorder, postLeft, postLeft + leftSubtreeSize - 1);

        // 5. 递归构建右子树
        // 右子树在 postorder 中的区间：紧接在左子树之后，到 postRight - 1 (去掉根节点)
        root.right = myBuildTree(inorder, inRootIndex + 1, inRight,
                                 postorder, postLeft + leftSubtreeSize, postRight - 1);

        return root;
    }

    // --- 辅助方法：层序遍历打印二叉树 ---
    public static void printTree(TreeNode root) {
        if (root == null) {
            System.out.println("[]");
            return;
        }
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if (node == null) {
                sb.append("null, ");
            } else {
                sb.append(node.val).append(", ");
                // 只有当左右孩子不全为空时，或者是中间层的 null，才需要入队
                if (node.left != null || node.right != null) {
                    queue.offer(node.left);
                    queue.offer(node.right);
                }
            }
        }
        // 去除尾部逗号
        if (sb.lastIndexOf(", ") > 0) {
            sb.setLength(sb.length() - 2);
        }
        sb.append("]");
        System.out.println(sb.toString());
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int[] inorder1 = {9, 3, 15, 20, 7};
        int[] postorder1 = {9, 15, 7, 20, 3};

        System.out.println("示例 1 输入:");
        System.out.println("inorder   = [9,3,15,20,7]");
        System.out.println("postorder = [9,15,7,20,3]");

        TreeNode root1 = buildTree(inorder1, postorder1);

        System.out.print("示例 1 输出: ");
        printTree(root1); // 预期: [3, 9, 20, null, null, 15, 7]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        int[] inorder2 = {-1};
        int[] postorder2 = {-1};

        System.out.println("示例 2 输入:");
        System.out.println("inorder   = [-1]");
        System.out.println("postorder = [-1]");

        TreeNode root2 = buildTree(inorder2, postorder2);

        System.out.print("示例 2 输出: ");
        printTree(root2); // 预期: [-1]
    }
}
```
