---
title: 106. 从中序与后序遍历序列构造二叉树
date: 2024-07-16 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231453961.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：106. 从中序与后序遍历序列构造二叉树

给定两个整数数组 `inorder` 和 `postorder`，其中 `inorder` 是二叉树的中序遍历，`postorder` 是同一棵树的后序遍历，请你构造并返回这颗 **二叉树**。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

- **输入:** `inorder = [9,3,15,20,7]`, `postorder = [9,15,7,20,3]`
- **输出:** `[3,9,20,null,null,15,7]`

**示例 2:**

- **输入:** `inorder = [-1]`, `postorder = [-1]`
- **输出:** `[-1]`

**提示:**

- `1 <= inorder.length <= 3000`
- `postorder.length == inorder.length`
- `-3000 <= inorder[i], postorder[i] <= 3000`
- `inorder` 和 `postorder` 都由 **不同** 的值组成
- `postorder` 中每一个值都在 `inorder` 中
- `inorder` **保证**是树的中序遍历
- `postorder` **保证**是树的后序遍历

## Java 代码

**算法思路：(递归 / 分治)**

重建二叉树的经典问题可以通过递归解决，关键在于利用不同遍历序列的特性来定位根、左子树和右子树。

1.  **定位根节点:**
    - 后序遍历 `postorder` 的 **最后一个元素** 永远是当前（子）树的 **根节点**。
2.  **分割左右子树:**
    - 一旦确定了根节点的值 `rootVal`，我们就可以在中序遍历 `inorder` 数组中找到这个值的位置 `rootIndex`。
    - `inorder` 数组中 `rootIndex` **左边** 的所有元素都属于根节点的 **左子树**。
    - `inorder` 数组中 `rootIndex` **右边** 的所有元素都属于根节点的 **右子树**。
3.  **递归构建:**
    - 我们可以根据左子树和右子树的元素数量，在 `postorder` 数组中也确定它们各自的范围。
    - 然后，递归地为左子树和右子树调用构建函数。
4.  **优化:** 每次在 `inorder` 数组中查找 `rootIndex` 都是一个耗时操作。我们可以预先将 `inorder` 的 `(值, 索引)` 存入一个哈希表，将查找时间优化到 O(1)。

```java
import java.util.HashMap;
import java.util.Map;

/**
 * 二叉树节点的定义
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val) { this.val = val; }
}


public class Main {

    // 使用 Map 优化在中序遍历中查找根节点索引的过程
    private static Map<Integer, Integer> inorderMap;
    private static int postorderIndex;

    public static TreeNode buildTree(int[] inorder, int[] postorder) {
        inorderMap = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            inorderMap.put(inorder[i], i);
        }

        // 从后序遍历的末尾开始构建
        postorderIndex = postorder.length - 1;

        // 递归构建整个树
        return build(inorder, postorder, 0, inorder.length - 1);
    }

    /**
     * 递归构建子树的辅助函数
     * @param inorder    中序遍历数组
     * @param postorder  后序遍历数组
     * @param inStart    当前子树在中序数组中的起始索引
     * @param inEnd      当前子树在中序数组中的结束索引
     * @return 构建好的子树的根节点
     */
    private static TreeNode build(int[] inorder, int[] postorder, int inStart, int inEnd) {
        // 递归终止条件
        if (inStart > inEnd) {
            return null;
        }

        // 1. 创建根节点（从后序遍历的末尾获取）
        int rootVal = postorder[postorderIndex];
        TreeNode root = new TreeNode(rootVal);
        postorderIndex--;

        // 2. 在中序遍历中找到根节点的位置，以分割左右子树
        int rootIndex = inorderMap.get(rootVal);

        // 3. 递归构建右子树和左子树
        // **注意：必须先构建右子树，再构建左子树**
        // 因为我们是从 postorder 的末尾向前取根节点的
        root.right = build(inorder, postorder, rootIndex + 1, inEnd);
        root.left = build(inorder, postorder, inStart, rootIndex - 1);

        return root;
    }


    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[] inorder1 = {9, 3, 15, 20, 7};
        int[] postorder1 = {9, 15, 7, 20, 3};
        System.out.println("输入: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]");
        TreeNode root1 = buildTree(inorder1, postorder1);
        // 此处应有层序遍历来验证树结构，为简化仅打印调用成功
        System.out.println("输出: (树已构建，根节点值为 " + root1.val + ")");
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[] inorder2 = {-1};
        int[] postorder2 = {-1};
        System.out.println("输入: inorder = [-1], postorder = [-1]");
        TreeNode root2 = buildTree(inorder2, postorder2);
        System.out.println("输出: (树已构建，根节点值为 " + root2.val + ")");
    }
}
```
