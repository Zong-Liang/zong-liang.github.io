---
title: 100. 相同的树
date: 2024-07-10 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231213340.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：100. 相同的树

**描述**

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例 1:**

- **输入:** `p = [1,2,3]`, `q = [1,2,3]`
- **输出:** `true`

**示例 2:**

- **输入:** `p = [1,2]`, `q = [1,null,2]`
- **输出:** `false`

**示例 3:**

- **输入:** `p = [1,2,1]`, `q = [1,1,2]`
- **输出:** `false`

**提示:**

- 两棵树上的节点数目都在范围 `[0, 100]` 内
- `-10^4 <= Node.val <= 10^4`

## 题解

```java
import java.util.LinkedList;
import java.util.Queue;

/**
 * Definition for a binary tree node.
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

public class Main {

    /**
     * 检查两棵树是否相同
     *
     * @param p 第一棵树的根节点
     * @param q 第二棵树的根节点
     * @return 如果两棵树相同则返回 true，否则返回 false
     */
    public static boolean isSameTree(TreeNode p, TreeNode q) {
        // 1. 如果两个节点都为 null，则它们是相同的
        if (p == null && q == null) {
            return true;
        }

        // 2. 如果其中一个为 null，另一个不为 null，则它们不相同
        if (p == null || q == null) {
            return false;
        }

        // 3. 如果节点的值不相等，则它们不相同
        if (p.val != q.val) {
            return false;
        }

        // 4. 递归地比较左子树和右子树
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }

    // 以下为辅助方法，用于根据数组构建树

    /**
     * 根据数组（层序遍历）构建二叉树
     *
     * @param nums 代表树的层序遍历的数组，null 表示空节点
     * @return 构建好的树的根节点
     */
    public static TreeNode buildTree(Integer[] nums) {
        if (nums == null || nums.length == 0 || nums[0] == null) {
            return null;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        TreeNode root = new TreeNode(nums[0]);
        queue.offer(root);
        int i = 1;

        while (!queue.isEmpty() && i < nums.length) {
            TreeNode current = queue.poll();

            //构建左子节点
            if (nums[i] != null) {
                current.left = new TreeNode(nums[i]);
                queue.offer(current.left);
            }
            i++;

            //构建右子节点
            if (i < nums.length && nums[i] != null) {
                current.right = new TreeNode(nums[i]);
                queue.offer(current.right);
            }
            i++;
        }
        return root;
    }

    public static void main(String[] args) {
        // 示例 1
        TreeNode p1 = buildTree(new Integer[]{1, 2, 3});
        TreeNode q1 = buildTree(new Integer[]{1, 2, 3});
        System.out.println(isSameTree(p1, q1)); // 预期输出: true

        // 示例 2
        TreeNode p2 = buildTree(new Integer[]{1, 2});
        TreeNode q2 = buildTree(new Integer[]{1, null, 2});
        System.out.println(isSameTree(p2, q2)); // 预期输出: false

        // 示例 3
        TreeNode p3 = buildTree(new Integer[]{1, 2, 1});
        TreeNode q3 = buildTree(new Integer[]{1, 1, 2});
        System.out.println(isSameTree(p3, q3)); // 预期输出: false
    }
}
```
