---
title: 100. 相同的树
date: 2024-07-10 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231213340.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述**

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例 1:**

- **输入:** `p = [1,2,3]`, `q = [1,2,3]`
- **输出:** `true`

**示例 2:**

- **输入:** `p = [1,2]`, `q = [1,null,2]`
- **输出:** `false`

**示例 3:**

- **输入:** `p = [1,2,1]`, `q = [1,1,2]`
- **输出:** `false`

**提示:**

- 两棵树上的节点数目都在范围 `[0, 100]` 内
- `-10^4 <= Node.val <= 10^4`

## 题解

### 解法一：深度优先搜索（递归）

**思路：**

这是解决树相关问题最自然的方法。判断两棵树是否相同，实际上就是递归地判断它们的根节点、左子树和右子树是否完全一致。

1.  **终止条件（基准情况）**：

    - 如果 `p` 和 `q` 都是 `null`，说明已经遍历到叶子节点之下且没有差异，返回 `true`。
    - 如果 `p` 和 `q` 中 **只有一个** 是 `null`（另一个非空），说明结构不同，返回 `false`。
    - 如果 `p` 和 `q` 都非空，但它们的 **值 (`val`) 不相等**，说明节点值不同，返回 `false`。

2.  **递归步骤**：

    - 只有当 **左子树相同** (`isSameTree(p.left, q.left)`) **且** **右子树相同** (`isSameTree(p.right, q.right)`) 时，整棵树才相同。

**复杂度分析：**

- **时间复杂度：** $O(\min(m, n))$，其中 $m$ 和 $n$ 分别是两棵树的节点数。我们只需要遍历较短的那棵树即可发现差异，最坏情况下遍历所有节点。
- **空间复杂度：** $O(\min(height_p, height_q))$，递归调用栈的深度取决于树的高度。平均情况为 $O(\log n)$，最坏情况（链状）为 $O(n)$。

**代码片段：**

```java
public boolean isSameTree(TreeNode p, TreeNode q) {
    // 1. 都为空，相同
    if (p == null && q == null) {
        return true;
    }
    // 2. 一个为空一个不为空，或者值不相等，不同
    if (p == null || q == null || p.val != q.val) {
        return false;
    }
    // 3. 递归比较左右子树
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}
```

### 解法二：广度优先搜索（迭代/BFS）

**思路：**

我们可以使用两个队列分别存储 `p` 树和 `q` 树的节点，按照层序遍历的顺序同步比较。

1.  初始化两个队列，将 `p` 和 `q` 分别入队。
2.  当队列不为空时，循环执行：

    - 分别从两个队列取出一个节点 `nodeP` 和 `nodeQ`。
    - **比较逻辑**：

      - 如果两个节点值不相等，返回 `false`。
      - 对于左子节点：如果 `nodeP.left` 和 `nodeQ.left` 的空/非空状态不一致（一个有一外没有），返回 `false`；如果都有，则入队。
      - 对于右子节点：同上逻辑。

3.  如果循环结束没有发现不同，返回 `true`。

**复杂度分析：**

- **时间复杂度：** $O(\min(m, n))$。
- **空间复杂度：** $O(\min(m, n))$，队列中最多存储树中最宽那一层的节点数。

**代码片段：**

```java
public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null && q == null) return true;
    if (p == null || q == null) return false;

    Queue<TreeNode> queueP = new LinkedList<>();
    Queue<TreeNode> queueQ = new LinkedList<>();
    queueP.offer(p);
    queueQ.offer(q);

    while (!queueP.isEmpty() && !queueQ.isEmpty()) {
        TreeNode nodeP = queueP.poll();
        TreeNode nodeQ = queueQ.poll();

        if (nodeP.val != nodeQ.val) return false;

        // 比较左子树结构
        if (nodeP.left != null && nodeQ.left != null) {
            queueP.offer(nodeP.left);
            queueQ.offer(nodeQ.left);
        } else if (nodeP.left != null || nodeQ.left != null) {
            return false; // 一个有一个没有
        }

        // 比较右子树结构
        if (nodeP.right != null && nodeQ.right != null) {
            queueP.offer(nodeP.right);
            queueQ.offer(nodeQ.right);
        } else if (nodeP.right != null || nodeQ.right != null) {
            return false;
        }
    }
    return true;
}
```

### 完整代码

```java
import java.util.LinkedList;
import java.util.Queue;

public class Main {

    // Definition for a binary tree node.
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode() {}
        TreeNode(int val) { this.val = val; }
        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    // 核心算法实现（解法一：递归法，推荐）
    public static boolean isSameTree(TreeNode p, TreeNode q) {
        // 1. 如果两个节点都为空，认为相同
        if (p == null && q == null) {
            return true;
        }
        // 2. 如果只有一个为空，或者两个节点的值不同，认为不同
        if (p == null || q == null || p.val != q.val) {
            return false;
        }
        // 3. 递归检查左子树和右子树
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        // p = [1,2,3], q = [1,2,3]
        TreeNode p1 = new TreeNode(1, new TreeNode(2), new TreeNode(3));
        TreeNode q1 = new TreeNode(1, new TreeNode(2), new TreeNode(3));

        System.out.println("示例 1 测试:");
        System.out.println("Result: " + isSameTree(p1, q1)); // 预期: true
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        // p = [1,2], q = [1,null,2]
        TreeNode p2 = new TreeNode(1);
        p2.left = new TreeNode(2);

        TreeNode q2 = new TreeNode(1);
        q2.right = new TreeNode(2);

        System.out.println("示例 2 测试:");
        System.out.println("Result: " + isSameTree(p2, q2)); // 预期: false
        System.out.println("-----------------------------");

        // --- 示例 3 测试 ---
        // p = [1,2,1], q = [1,1,2]
        TreeNode p3 = new TreeNode(1, new TreeNode(2), new TreeNode(1));
        TreeNode q3 = new TreeNode(1, new TreeNode(1), new TreeNode(2));

        System.out.println("示例 3 测试:");
        System.out.println("Result: " + isSameTree(p3, q3)); // 预期: false
    }
}
```
