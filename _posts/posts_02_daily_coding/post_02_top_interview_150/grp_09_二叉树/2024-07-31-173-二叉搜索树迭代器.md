---
title: 173. 二叉搜索树迭代器
date: 2024-07-31 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231813297.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

实现一个二叉搜索树迭代器类 `BSTIterator`，表示一个按 **中序遍历** 二叉搜索树（BST）的迭代器：

- `BSTIterator(TreeNode root)` 初始化 `BSTIterator` 类的一个对象。BST 的根节点 `root` 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。
- `boolean hasNext()` 如果指针向右侧遍历存在数字，则返回 `true`；否则返回 `false`。
- `int next()` 将指针向右移动，然后返回指针处的数字。

**注意**，指针初始化为一个不存在于 BST 中的数字，所以对 `next()` 的首次调用将返回 BST 中的最小元素。

你可以假设 `next()` 调用总是有效的，也就是说，当调用 `next()` 时，BST 的中序遍历中至少存在一个下一个数字。

**示例:**
![示例图片](https://assets.leetcode.com/uploads/2018/12/25/bst-iterator.png)

- **输入**
  `["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]`
  `[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]`
- **输出**
  `[null, 3, 7, true, 9, true, 15, true, 20, false]`

**提示:**

- 树中节点数目在范围 `[1, 10^5]` 内
- `0 <= Node.val <= 10^6`
- 最多调用 `10^5` 次 `hasNext` 和 `next` 操作

**进阶:**

- 你可以设计一个满足下述条件的解决方案吗？`next()` 和 `hasNext()` 操作均摊时间复杂度为 `O(1)`，并使用 `O(h)` 内存，其中 `h` 是树的高度。

## 题解

### 解法一：预处理扁平化（标准解法）

**思路：**

既然题目要求按照 **中序遍历** 的顺序输出，最简单的方法就是在构造函数中直接完成整个树的中序遍历，将结果存入一个数组或列表（`ArrayList`）中。
之后，`next()` 和 `hasNext()` 操作就变成了简单的数组索引操作。

1.  **初始化**：创建一个列表 `list` 和一个指针 `index`。
2.  **构造函数**：调用递归函数对二叉树进行中序遍历（左 -> 根 -> 右），将所有节点的值按顺序加入 `list`。
3.  **next()**：返回 `list[index]`，并将 `index` 加 1。
4.  **hasNext()**：判断 `index` 是否小于 `list` 的长度。

**复杂度分析：**

- **时间复杂度：**

  - 构造函数：$O(N)$，因为需要遍历所有节点。
  - `next()`：$O(1)$。
  - `hasNext()`：$O(1)$。

- **空间复杂度：** $O(N)$。需要存储所有节点的值。这不满足进阶要求的 $O(h)$ 空间。

**代码片段：**

```java
class BSTIterator {
    private List<Integer> nodes;
    private int index;

    public BSTIterator(TreeNode root) {
        nodes = new ArrayList<>();
        index = 0;
        inorder(root);
    }

    private void inorder(TreeNode root) {
        if (root == null) return;
        inorder(root.left);
        nodes.add(root.val);
        inorder(root.right);
    }

    public int next() {
        return nodes.get(index++);
    }

    public boolean hasNext() {
        return index < nodes.size();
    }
}
```

### 解法二：单调栈迭代（进阶解法：O(h) 空间）

**思路：**

为了满足 $O(h)$ 的空间复杂度，我们不能存储所有节点。我们可以利用 **栈（Stack）** 来模拟递归的中序遍历过程，实现“受控”的遍历。我们不需要一次性算完，而是每次调用 `next()` 时才计算出下一个节点。

1.  **核心逻辑**：中序遍历的顺序是“左、根、右”。这意味着对于任意节点，我们必须先访问它所有的左后代。
2.  **栈的作用**：栈用来存储当前路径上等待访问的节点。
3.  **辅助方法 `pushLeft(node)`**：将给定节点及其所有左子节点依次压入栈中。这相当于找到了当前子树中最小的节点（栈顶）。
4.  **初始化**：调用 `pushLeft(root)`，此时栈顶就是整棵树最小的元素。
5.  **next()**：

    - 弹出栈顶元素 `cur`，这就是下一个要返回的节点（因为它左边没有了，或者已经访问过了）。
    - 如果 `cur` 有右子节点，说明右子树还没访问。调用 `pushLeft(cur.right)`，将右子树中最左侧的一条路径压入栈。
    - 返回 `cur.val`。

6.  **hasNext()**：只要栈不为空，就说明还有元素没遍历完。

**复杂度分析：**

- **时间复杂度：**

  - `hasNext()`：$O(1)$。
  - `next()`：**均摊 $O(1)$**。虽然在 `pushLeft` 时可能有 `while` 循环（最坏 $O(h)$），但在整个遍历过程中，每个节点最多被压入栈一次，弹出栈一次。对于 $N$ 个节点，总操作次数是 $O(N)$，平均每次调用是 $O(1)$。

- **空间复杂度：** $O(h)$。栈中存储的是树的一条路径，最大深度为树的高度 $h$。

**代码片段：**

```java
class BSTIterator {
    private Deque<TreeNode> stack;

    public BSTIterator(TreeNode root) {
        stack = new ArrayDeque<>();
        pushLeft(root);
    }

    // 辅助方法：将节点及其所有左孩子压入栈
    private void pushLeft(TreeNode node) {
        while (node != null) {
            stack.push(node);
            node = node.left;
        }
    }

    public int next() {
        // 1. 弹出栈顶元素，即为当前最小元素
        TreeNode node = stack.pop();

        // 2. 如果该节点有右子树，处理右子树（把右子树的最左路径入栈）
        if (node.right != null) {
            pushLeft(node.right);
        }

        return node.val;
    }

    public boolean hasNext() {
        return !stack.isEmpty();
    }
}
```

### 完整代码

```java
import java.util.*;

// 二叉树节点定义
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

public class Main {

    // --- 进阶解法：栈模拟递归 ---
    static class BSTIterator {
        // 使用 Deque 作为栈，性能优于 Stack 类
        private Deque<TreeNode> stack;

        public BSTIterator(TreeNode root) {
            stack = new ArrayDeque<>();
            // 初始化时，将根节点及其所有左子节点入栈
            pushLeft(root);
        }

        // 辅助函数：一路向左，将沿途节点入栈
        private void pushLeft(TreeNode node) {
            while (node != null) {
                stack.push(node);
                node = node.left;
            }
        }

        public int next() {
            // 栈顶元素永远是当前未访问部分中最小的
            TreeNode curr = stack.pop();

            // 如果弹出的节点有右子节点，说明该节点的“根”部分访问完了，
            // 接下来该访问“右”部分了。将右子节点及其所有左后代入栈。
            if (curr.right != null) {
                pushLeft(curr.right);
            }

            return curr.val;
        }

        public boolean hasNext() {
            return !stack.isEmpty();
        }
    }

    public static void main(String[] args) {
        // --- 示例测试 ---
        // 构造树: [7, 3, 15, null, null, 9, 20]
        //       7
        //      / \
        //     3   15
        //        /  \
        //       9    20
        TreeNode root = new TreeNode(7);
        root.left = new TreeNode(3);
        root.right = new TreeNode(15);
        root.right.left = new TreeNode(9);
        root.right.right = new TreeNode(20);

        System.out.println("示例输入: root = [7, 3, 15, null, null, 9, 20]");

        BSTIterator iterator = new BSTIterator(root);

        // 模拟调用过程
        System.out.println("iterator.next()    -> " + iterator.next());    // return 3
        System.out.println("iterator.next()    -> " + iterator.next());    // return 7
        System.out.println("iterator.hasNext() -> " + iterator.hasNext()); // return true
        System.out.println("iterator.next()    -> " + iterator.next());    // return 9
        System.out.println("iterator.hasNext() -> " + iterator.hasNext()); // return true
        System.out.println("iterator.next()    -> " + iterator.next());    // return 15
        System.out.println("iterator.hasNext() -> " + iterator.hasNext()); // return true
        System.out.println("iterator.next()    -> " + iterator.next());    // return 20
        System.out.println("iterator.hasNext() -> " + iterator.hasNext()); // return false

        System.out.println("-----------------------------");
        System.out.println("预期输出应为: 3, 7, true, 9, true, 15, true, 20, false");
    }
}
```
