---
title: 173. 二叉搜索树迭代器
date: 2024-07-31 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231813297.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：173. 二叉搜索树迭代器

实现一个二叉搜索树迭代器类 `BSTIterator`，表示一个按 **中序遍历** 二叉搜索树（BST）的迭代器：

- `BSTIterator(TreeNode root)` 初始化 `BSTIterator` 类的一个对象。BST 的根节点 `root` 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。
- `boolean hasNext()` 如果指针向右侧遍历存在数字，则返回 `true`；否则返回 `false`。
- `int next()` 将指针向右移动，然后返回指针处的数字。

**注意**，指针初始化为一个不存在于 BST 中的数字，所以对 `next()` 的首次调用将返回 BST 中的最小元素。

你可以假设 `next()` 调用总是有效的，也就是说，当调用 `next()` 时，BST 的中序遍历中至少存在一个下一个数字。

**示例:**
![示例图片](https://assets.leetcode.com/uploads/2018/12/25/bst-iterator.png)

- **输入**
  `["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]`
  `[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]`
- **输出**
  `[null, 3, 7, true, 9, true, 15, true, 20, false]`

**提示:**

- 树中节点数目在范围 `[1, 10^5]` 内
- `0 <= Node.val <= 10^6`
- 最多调用 `10^5` 次 `hasNext` 和 `next` 操作

**进阶:**

- 你可以设计一个满足下述条件的解决方案吗？`next()` 和 `hasNext()` 操作均摊时间复杂度为 `O(1)`，并使用 `O(h)` 内存，其中 `h` 是树的高度。

## 题解

**算法思路：(受控的递归 / 迭代中序遍历)**

为了满足进阶要求（`O(1)` 均摊时间和 `O(h)` 空间），我们不能在初始化时就遍历整个树并将所有节点存储起来（这将导致 `O(n)` 空间）。

正确的方法是模拟 **迭代式** 的中序遍历，并使用一个 **栈** 来“暂停”和“恢复”遍历过程。

1.  **数据结构:**
    - 使用一个 `Stack<TreeNode>` 来存储遍历路径上的节点。
2.  **构造函数 `BSTIterator(root)`:**
    - 在构造函数中，我们不遍历整个树。而是立即执行中序遍历的第一步：从根节点开始，将所有左子节点一路压入栈中。
    - 这样，当构造函数结束时，栈顶元素就是 BST 中最小的节点（即中序遍历的第一个节点）。
3.  **`hasNext()`:**
    - 这个操作变得非常简单：只需要检查栈是否为空即可。如果栈不为空，就说明还有下一个元素。
4.  **`next()`:**
    - 从栈顶弹出一个节点 `node`。这就是我们要返回的下一个最小元素。
    - 在返回之前，我们需要为 **下一次** `next()` 调用做准备。根据中序遍历的规则（左 -> 根 -> 右），在处理完一个节点后，接下来应该处理它的 **右子树**。
    - 因此，我们将 `node` 的右子节点 `node.right` 作为新的起点，并将该右子树中所有“最左侧”的节点压入栈中。

这种方法将 `O(n)` 的遍历工作分摊到了每次 `next()` 调用中，实现了 `O(1)` 的均摊时间复杂度和 `O(h)` 的空间复杂度。

```java
import java.util.Stack;

/**
 * 二叉树节点的定义
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val) { this.val = val; }
}

/**
 * BSTIterator 类
 */
class BSTIterator {
    private Stack<TreeNode> stack;

    public BSTIterator(TreeNode root) {
        stack = new Stack<>();
        // 初始化时，将根节点及其所有左子节点入栈
        pushAllLeft(root);
    }

    public int next() {
        // 栈顶元素就是下一个最小的节点
        TreeNode node = stack.pop();
        // 在返回之前，处理该节点的右子树
        pushAllLeft(node.right);
        return node.val;
    }

    public boolean hasNext() {
        return !stack.isEmpty();
    }

    // 辅助函数：将一个节点及其所有左子节点压入栈中
    private void pushAllLeft(TreeNode node) {
        while (node != null) {
            stack.push(node);
            node = node.left;
        }
    }
}


public class Main {
    public static void main(String[] args) {
        System.out.println("--- 示例 ---");

        // 构建树
        TreeNode root = new TreeNode(7);
        root.left = new TreeNode(3);
        root.right = new TreeNode(15);
        root.right.left = new TreeNode(9);
        root.right.right = new TreeNode(20);

        BSTIterator bstIterator = new BSTIterator(root);
        System.out.print("[null");

        int res1 = bstIterator.next();
        System.out.print(", " + res1); // 3

        int res2 = bstIterator.next();
        System.out.print(", " + res2); // 7

        boolean res3 = bstIterator.hasNext();
        System.out.print(", " + res3); // true

        int res4 = bstIterator.next();
        System.out.print(", " + res4); // 9

        boolean res5 = bstIterator.hasNext();
        System.out.print(", " + res5); // true

        int res6 = bstIterator.next();
        System.out.print(", " + res6); // 15

        boolean res7 = bstIterator.hasNext();
        System.out.print(", " + res7); // true

        int res8 = bstIterator.next();
        System.out.print(", " + res8); // 20

        boolean res9 = bstIterator.hasNext();
        System.out.print(", " + res9); // false

        System.out.println("]");
    }
}
```
