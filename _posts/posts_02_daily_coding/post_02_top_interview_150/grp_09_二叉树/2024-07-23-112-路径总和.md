---
title: 112. 路径总和
date: 2024-07-23 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231647371.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


## 题目：112. 路径总和

给你二叉树的根节点 `root` 和一个表示目标的整数 `targetSum`。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum`。如果存在，返回 `true`；否则，返回 `false`。

**叶子节点** 是指没有子节点的节点。


**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)

- **输入:** `root = [5,4,8,11,null,13,4,7,2,null,null,null,1]`, `targetSum = 22`
- **输出:** `true`
- **解释:** 等于目标和的根节点到叶节点路径如上图所示。

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

- **输入:** `root = [1,2,3]`, `targetSum = 5`
- **输出:** `false`

**示例 3:**

- **输入:** `root = []`, `targetSum = 0`
- **输出:** `false`
- **解释:** 由于树是空的，所以不存在根节点到叶子节点的路径。


**提示:**

- 树中节点的数目在范围 `[0, 5000]` 内
- `-1000 <= Node.val <= 1000`
- `-1000 <= targetSum <= 1000`


## Java 代码

**算法思路：(递归 / 深度优先搜索 DFS)**

这个问题可以通过一次 **深度优先搜索 (DFS)** 遍历来优雅地解决。我们的思路是在遍历树的同时，不断地从 `targetSum` 中减去当前节点的值。

1.  **递归函数:** 我们定义一个递归函数 `hasPathSum(node, remainingSum)`。
    - `node`: 当前正在访问的节点。
    - `remainingSum`: 还需要凑齐的目标和。
2.  **递归基 (终止条件):**
    - 如果 `node` 为 `null`，说明这条路走不通（或者树为空），返回 `false`。
3.  **处理当前节点:**
    - 从 `remainingSum` 中减去当前节点的值：`newSum = remainingSum - node.val`。
4.  **检查叶子节点:**
    - 如果当前节点是一个 **叶子节点**（即 `node.left == null` 且 `node.right == null`），我们检查 `newSum` 是否等于 0。
      - 如果等于 0，说明从根到这个叶子节点的路径和正好是 `targetSum`，返回 `true`。
      - 如果不等于 0，这条路径不符合要求。
5.  **递归子树:**
    - 如果当前节点不是叶子节点，我们继续向其子节点递归搜索。
    - 只要 **左子树** 或者 **右子树** 的递归调用返回 `true`，就说明找到了一条符合条件的路径，我们就可以立即返回 `true`。
    - `return hasPathSum(node.left, newSum) || hasPathSum(node.right, newSum);`

```java
/**
 * 二叉树节点的定义
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val) { this.val = val; }
}


public class Main {

    /**
     * 判断是否存在根节点到叶子节点的路径，其和等于 targetSum。
     */
    public boolean hasPathSum(TreeNode root, int targetSum) {
        // 边界情况：空树
        if (root == null) {
            return false;
        }

        // 检查叶子节点
        if (root.left == null && root.right == null) {
            return targetSum == root.val;
        }

        // 递归检查左右子树
        return hasPathSum(root.left, targetSum - root.val) ||
               hasPathSum(root.right, targetSum - root.val);
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        TreeNode root1 = new TreeNode(5);
        root1.left = new TreeNode(4);
        root1.right = new TreeNode(8);
        root1.left.left = new TreeNode(11);
        root1.left.left.left = new TreeNode(7);
        root1.left.left.right = new TreeNode(2);
        root1.right.left = new TreeNode(13);
        root1.right.right = new TreeNode(4);
        root1.right.right.right = new TreeNode(1);
        int targetSum1 = 22;
        System.out.println("输入: root = [...], targetSum = " + targetSum1);
        boolean result1 = solution.hasPathSum(root1, targetSum1);
        System.out.println("输出: " + result1); // 预期输出: true
        System.out.println();

        System.out.println("--- 示例 2 ---");
        TreeNode root2 = new TreeNode(1);
        root2.left = new TreeNode(2);
        root2.right = new TreeNode(3);
        int targetSum2 = 5;
        System.out.println("输入: root = [1,2,3], targetSum = " + targetSum2);
        boolean result2 = solution.hasPathSum(root2, targetSum2);
        System.out.println("输出: " + result2); // 预期输出: false
        System.out.println();

        System.out.println("--- 示例 3 ---");
        TreeNode root3 = null;
        int targetSum3 = 0;
        System.out.println("输入: root = [], targetSum = " + targetSum3);
        boolean result3 = solution.hasPathSum(root3, targetSum3);
        System.out.println("输出: " + result3); // 预期输出: false
    }
}
```
