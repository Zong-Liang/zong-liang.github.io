---
title: 112. 路径总和
date: 2024-07-23 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231647371.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你二叉树的根节点 `root` 和一个表示目标的整数 `targetSum`。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum`。如果存在，返回 `true`；否则，返回 `false`。

**叶子节点** 是指没有子节点的节点。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)

- **输入:** `root = [5,4,8,11,null,13,4,7,2,null,null,null,1]`, `targetSum = 22`
- **输出:** `true`
- **解释:** 等于目标和的根节点到叶节点路径如上图所示。

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

- **输入:** `root = [1,2,3]`, `targetSum = 5`
- **输出:** `false`

**示例 3:**

- **输入:** `root = []`, `targetSum = 0`
- **输出:** `false`
- **解释:** 由于树是空的，所以不存在根节点到叶子节点的路径。

**提示:**

- 树中节点的数目在范围 `[0, 5000]` 内
- `-1000 <= Node.val <= 1000`
- `-1000 <= targetSum <= 1000`

## 题解

### 解法一：递归法 (DFS)

**思路：**

判断从根节点到叶子节点的路径和是否等于 `targetSum`，可以转化为：询问左子树或右子树是否存在一条路径，其和为 `targetSum - root.val`。

我们可以使用深度优先搜索（DFS）的递归方式来解决：

1.  **终止条件**：

    - 如果 `root` 为空，直接返回 `false`（空树不存在路径）。
    - 如果 `root` 是 **叶子节点**（即 `root.left` 和 `root.right` 均为 null），此时判断 `root.val` 是否等于当前的 `targetSum`。如果是，则找到了路径，返回 `true`。

2.  **递归步骤**：

    - 递归检查左子树，目标和变为 `targetSum - root.val`。
    - 递归检查右子树，目标和变为 `targetSum - root.val`。
    - 只要左右子树中有一个返回 `true`，整棵树的结果就为 `true`。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是二叉树的节点数。最坏情况下我们需要遍历整棵树。
- **空间复杂度：** $O(height)$，其中 $height$ 是二叉树的高度。主要消耗在递归栈的空间。最坏情况（链状）为 $O(n)$，平均情况为 $O(\log n)$。

**代码片段：**

```java
public boolean hasPathSum(TreeNode root, int targetSum) {
    if (root == null) {
        return false;
    }

    //如果是叶子节点，判断值是否相等
    if (root.left == null && root.right == null) {
        return root.val == targetSum;
    }

    // 递归判断左右子树，注意目标值减去当前节点值
    return hasPathSum(root.left, targetSum - root.val)
        || hasPathSum(root.right, targetSum - root.val);
}
```

### 解法二：广度优先搜索 (BFS)

**思路：**

我们可以使用两个队列来进行层序遍历：

- 一个队列 `nodeQueue` 用于存储当前的节点。
- 另一个队列 `valQueue` 用于存储从根节点到当前节点的 **路径和**。

1.  初始将 `root` 入 `nodeQueue`，将 `root.val` 入 `valQueue`。
2.  当队列不为空时，取出节点和对应的路径和。
3.  如果当前节点是 **叶子节点**，检查路径和是否等于 `targetSum`。若是，直接返回 `true`。
4.  如果不是叶子节点，将存在的左右子节点加入队列，并将（当前路径和 + 子节点值）加入值队列。
5.  遍历结束若未找到，返回 `false`。

**复杂度分析：**

- **时间复杂度：** $O(n)$。
- **空间复杂度：** $O(n)$。最坏情况下队列需要存储树中最宽一层的节点。

**代码片段：**

```java
public boolean hasPathSum(TreeNode root, int targetSum) {
    if (root == null) return false;

    Queue<TreeNode> nodeQueue = new LinkedList<>();
    Queue<Integer> valQueue = new LinkedList<>();

    nodeQueue.offer(root);
    valQueue.offer(root.val);

    while (!nodeQueue.isEmpty()) {
        TreeNode curr = nodeQueue.poll();
        int currVal = valQueue.poll();

        // 判断叶子节点
        if (curr.left == null && curr.right == null) {
            if (currVal == targetSum) return true;
        }

        if (curr.left != null) {
            nodeQueue.offer(curr.left);
            valQueue.offer(currVal + curr.left.val);
        }

        if (curr.right != null) {
            nodeQueue.offer(curr.right);
            valQueue.offer(currVal + curr.right.val);
        }
    }
    return false;
}
```

### 完整代码

```java
import java.util.LinkedList;
import java.util.Queue;

public class Main {

    // Definition for a binary tree node.
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode() {}
        TreeNode(int val) { this.val = val; }
        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    // 核心算法实现：解法一（递归法，通常为面试首选）
    public static boolean hasPathSum(TreeNode root, int targetSum) {
        // 1. 空节点直接返回 false
        if (root == null) {
            return false;
        }

        // 2. 判断是否是叶子节点
        if (root.left == null && root.right == null) {
            // 如果是叶子节点，检查当前值是否等于剩余的 targetSum
            return root.val == targetSum;
        }

        // 3. 递归检查左右子树，目标值减去当前节点的值
        // 只要有一条路径满足即可，所以用 ||
        return hasPathSum(root.left, targetSum - root.val)
            || hasPathSum(root.right, targetSum - root.val);
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        // 输入: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
        TreeNode root1 = new TreeNode(5);
        root1.left = new TreeNode(4);
        root1.right = new TreeNode(8);
        root1.left.left = new TreeNode(11);
        root1.left.left.left = new TreeNode(7);
        root1.left.left.right = new TreeNode(2);
        root1.right.left = new TreeNode(13);
        root1.right.right = new TreeNode(4);
        root1.right.right.right = new TreeNode(1);

        int target1 = 22;
        System.out.println("示例 1 (target=22): " + hasPathSum(root1, target1)); // 预期: true
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        // 输入: root = [1,2,3], targetSum = 5
        TreeNode root2 = new TreeNode(1);
        root2.left = new TreeNode(2);
        root2.right = new TreeNode(3);

        int target2 = 5;
        // 路径只有 1->2 (sum=3) 和 1->3 (sum=4)，没有 5
        System.out.println("示例 2 (target=5): " + hasPathSum(root2, target2)); // 预期: false
        System.out.println("-----------------------------");

        // --- 示例 3 测试 ---
        // 输入: root = [], targetSum = 0
        TreeNode root3 = null;
        int target3 = 0;
        System.out.println("示例 3 (空树): " + hasPathSum(root3, target3)); // 预期: false
    }
}
```
