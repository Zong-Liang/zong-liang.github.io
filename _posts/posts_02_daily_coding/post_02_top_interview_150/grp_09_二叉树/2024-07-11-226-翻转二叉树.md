---
title: 226. 翻转二叉树
date: 2024-07-11 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231241542.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

**示例 1:**

- **输入:** `root = [4,2,7,1,3,6,9]`
- **输出:** `[4,7,2,9,6,3,1]`

**示例 2:**

- **输入:** `root = [2,1,3]`
- **输出:** `[2,3,1]`

**示例 3:**

- **输入:** `root = []`
- **输出:** `[]`

**提示:**

- 树中节点数目范围在 `[0, 100]` 内
- `-100 <= Node.val <= 100`

## 题解

### 解法一：递归法 (DFS)

**思路：**

翻转二叉树的一个核心思想是：**对于每一个节点，交换其左右子节点。**

我们可以使用递归（深度优先搜索）来解决这个问题。这是一个典型的“分治”问题：

1.  **终止条件**：如果当前节点 `root` 为 `null`，无需翻转，直接返回 `null`。
2.  **交换**：保存当前节点的左子节点，将左子节点指向右子节点，将右子节点指向保存的左子节点。
3.  **递归**：分别对交换后的左子树和右子树进行递归调用 `invertTree`。

（注：先交换再递归，或者先递归再交换都可以，属于前序遍历或后序遍历的逻辑。中序遍历需要小心处理，因为交换后左右子树位置变了。）

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是二叉树的节点数。每个节点都需要被访问一次并进行交换操作。
- **空间复杂度：** $O(height)$，也就是递归栈的深度。最坏情况下（树退化为链表）为 $O(n)$，平均情况下（平衡树）为 $O(\log n)$。

**代码片段：**

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }

    // 1. 暂存左子节点
    TreeNode temp = root.left;
    // 2. 交换左右子节点
    root.left = root.right;
    root.right = temp;

    // 3. 递归处理子树
    invertTree(root.left);
    invertTree(root.right);

    return root;
}
```

### 解法二：迭代法 (BFS / 层序遍历)

**思路：**

我们要遍历树中的每一个节点并交换其左右孩子。使用队列（Queue）进行广度优先搜索（BFS）也是一个直观的方法。

1.  创建一个队列，初始将根节点入队。
2.  当队列不为空时，取出队头节点。
3.  交换该节点的左、右子节点。
4.  如果左子节点（交换后的）不为空，将其入队。
5.  如果右子节点（交换后的）不为空，将其入队。
6.  重复上述过程直到队列为空。

**复杂度分析：**

- **时间复杂度：** $O(n)$，每个节点进出队列各一次。
- **空间复杂度：** $O(n)$，最坏情况下，队列需要存储树中最宽一层的节点数。

**代码片段：**

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) return null;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        TreeNode current = queue.poll();

        // 交换当前节点的左右子节点
        TreeNode temp = current.left;
        current.left = current.right;
        current.right = temp;

        // 将子节点加入队列等待后续处理
        if (current.left != null) queue.offer(current.left);
        if (current.right != null) queue.offer(current.right);
    }

    return root;
}
```

### 完整代码

```java
import java.util.LinkedList;
import java.util.Queue;

public class Main {

    // Definition for a binary tree node.
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode() {}
        TreeNode(int val) { this.val = val; }
        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    // 核心算法实现（解法一：递归法，代码最简洁）
    public static TreeNode invertTree(TreeNode root) {
        // 递归终止条件
        if (root == null) {
            return null;
        }

        // 交换左右子树
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;

        // 递归处理子节点
        invertTree(root.left);
        invertTree(root.right);

        return root;
    }

    // 辅助方法：层序遍历打印二叉树（用于验证结果）
    public static void printTree(TreeNode root) {
        if (root == null) {
            System.out.println("[]");
            return;
        }
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if (node == null) {
                // 这里简化打印，如果遇到 null 就不再继续打印它的子节点了，
                // 实际 LeetCode 格式对 null 的处理更复杂，这里仅作示意。
                continue;
            }
            sb.append(node.val).append(", ");
            if (node.left != null || node.right != null) {
                queue.offer(node.left);
                queue.offer(node.right);
            }
        }
        // 去掉最后多余的逗号
        if (sb.lastIndexOf(", ") > 0) {
            sb.setLength(sb.length() - 2);
        }
        sb.append("]");
        System.out.println(sb.toString());
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        // 输入: root = [4,2,7,1,3,6,9]
        TreeNode root1 = new TreeNode(4);
        root1.left = new TreeNode(2, new TreeNode(1), new TreeNode(3));
        root1.right = new TreeNode(7, new TreeNode(6), new TreeNode(9));

        System.out.println("示例 1 原树 (层序): [4, 2, 7, 1, 3, 6, 9]");

        TreeNode res1 = invertTree(root1);

        System.out.print("示例 1 翻转后: ");
        printTree(res1); // 预期: [4, 7, 2, 9, 6, 3, 1]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        // 输入: root = [2,1,3]
        TreeNode root2 = new TreeNode(2, new TreeNode(1), new TreeNode(3));

        System.out.println("示例 2 原树 (层序): [2, 1, 3]");

        TreeNode res2 = invertTree(root2);

        System.out.print("示例 2 翻转后: ");
        printTree(res2); // 预期: [2, 3, 1]
    }
}
```
