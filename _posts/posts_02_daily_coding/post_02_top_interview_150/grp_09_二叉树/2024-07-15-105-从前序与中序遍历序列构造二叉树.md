---
title: 105. 从前序与中序遍历序列构造二叉树
date: 2024-07-15 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231409678.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


## 题目：105. 从前序与中序遍历序列构造二叉树

给定两个整数数组 `preorder` 和 `inorder`，其中 `preorder` 是二叉树的 **先序遍历**，`inorder` 是同一棵树的 **中序遍历**，请构造二叉树并返回其根节点。


**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

- **输入:** `preorder = [3,9,20,15,7]`, `inorder = [9,3,15,20,7]`
- **输出:** `[3,9,20,null,null,15,7]`

**示例 2:**

- **输入:** `preorder = [-1]`, `inorder = [-1]`
- **输出:** `[-1]`



**提示:**

- `1 <= preorder.length <= 3000`
- `inorder.length == preorder.length`
- `-3000 <= preorder[i], inorder[i] <= 3000`
- `preorder` 和 `inorder` 均 **无重复元素**
- `inorder` 均出现在 `preorder`
- `preorder` **保证** 为二叉树的前序遍历序列
- `inorder` **保证** 为二叉树的中序遍历序列


## Java 代码

**算法思路：(递归 / 分治)**

这个经典问题可以通过递归的方式解决，核心是利用两种遍历序列的特性：

1.  **定位根节点:**
    - **先序遍历** (`根 -> 左 -> 右`) 的 **第一个元素** 永远是当前（子）树的 **根节点**。
2.  **分割左右子树:**
    - 一旦我们从 `preorder` 中确定了根节点的值，就可以在 **中序遍历** (`左 -> 根 -> 右`) 数组中找到这个值的位置。
    - 在该位置 **左边** 的所有元素都属于根节点的 **左子树**。
    - 在该位置 **右边** 的所有元素都属于根节点的 **右子树**。
3.  **递归构建:**
    - 我们根据左子树的元素数量，可以确定 `preorder` 数组中属于左子树的范围，然后对其进行递归构建。
    - 同理，对右子树也进行递归构建。
4.  **优化:** 为了避免每次递归都在 `inorder` 数组中线性搜索根节点的位置，我们可以预先使用一个哈希表存储 `inorder` 数组中每个值对应的索引，将查找时间优化到 O(1)。

```java
import java.util.HashMap;
import java.util.Map;

/**
 * 二叉树节点的定义
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val) { this.val = val; }
}


public class Main {
    // 使用 Map 优化在中序遍历中查找根节点索引的过程
    private static Map<Integer, Integer> inorderMap;
    // preorderIndex 用于追踪先序遍历数组中的当前根节点位置
    private static int preorderIndex;

    public static TreeNode buildTree(int[] preorder, int[] inorder) {
        inorderMap = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            inorderMap.put(inorder[i], i);
        }

        preorderIndex = 0;

        // 递归构建整个树
        return build(preorder, 0, preorder.length - 1);
    }

    /**
     * 递归构建子树的辅助函数
     * @param preorder   先序遍历数组
     * @param inStart    当前子树在中序数组中的起始索引
     * @param inEnd      当前子树在中序数组中的结束索引
     * @return 构建好的子树的根节点
     */
    private static TreeNode build(int[] preorder, int inStart, int inEnd) {
        // 递归终止条件
        if (inStart > inEnd) {
            return null;
        }

        // 1. 创建根节点（从先序遍历中按顺序获取）
        int rootVal = preorder[preorderIndex++];
        TreeNode root = new TreeNode(rootVal);

        // 2. 在中序遍历中找到根节点的位置，以分割左右子树
        int rootIndex = inorderMap.get(rootVal);

        // 3. 递归构建左子树和右子树
        root.left = build(preorder, inStart, rootIndex - 1);
        root.right = build(preorder, rootIndex + 1, inEnd);

        return root;
    }

    /**
     * 主函数，包含测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[] preorder1 = {3, 9, 20, 15, 7};
        int[] inorder1 = {9, 3, 15, 20, 7};
        System.out.println("输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]");
        TreeNode root1 = buildTree(preorder1, inorder1);
        // 此处应有层序遍历来验证树结构，为简化仅打印调用成功
        System.out.println("输出: (树已构建，根节点值为 " + root1.val + ")");
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[] preorder2 = {-1};
        int[] inorder2 = {-1};
        System.out.println("输入: preorder = [-1], inorder = [-1]");
        TreeNode root2 = buildTree(preorder2, inorder2);
        System.out.println("输出: (树已构建，根节点值为 " + root2.val + ")");
    }
}
```
