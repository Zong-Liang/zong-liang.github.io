---
title: 105. 从前序与中序遍历序列构造二叉树
date: 2024-07-15 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231409678.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定两个整数数组 `preorder` 和 `inorder`，其中 `preorder` 是二叉树的 **先序遍历**，`inorder` 是同一棵树的 **中序遍历**，请构造二叉树并返回其根节点。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

- **输入:** `preorder = [3,9,20,15,7]`, `inorder = [9,3,15,20,7]`
- **输出:** `[3,9,20,null,null,15,7]`

**示例 2:**

- **输入:** `preorder = [-1]`, `inorder = [-1]`
- **输出:** `[-1]`

**提示:**

- `1 <= preorder.length <= 3000`
- `inorder.length == preorder.length`
- `-3000 <= preorder[i], inorder[i] <= 3000`
- `preorder` 和 `inorder` 均 **无重复元素**
- `inorder` 均出现在 `preorder`
- `preorder` **保证** 为二叉树的前序遍历序列
- `inorder` **保证** 为二叉树的中序遍历序列

## 题解

### 解法：递归 + 哈希表优化 (Recursive + HashMap)

**思路：**

二叉树重建的核心在于找准 **根节点** 以及 **左右子树的边界**。

1.  **前序遍历 (Preorder)** 的性质：`[根节点, [左子树的前序遍历], [右子树的前序遍历]]`。即数组的第一个元素一定是当前的根节点。
2.  **中序遍历 (Inorder)** 的性质：`[[左子树的中序遍历], 根节点, [右子树的中序遍历]]`。即只要找到了根节点在中序遍历中的位置，就能确定左子树和右子树的节点范围。

**算法流程：**

1.  **哈希映射**：为了避免每次都在 `inorder` 数组中线性查找根节点的位置（会导致 $O(N^2)$ 的复杂度），我们先使用一个哈希表 `Map<Integer, Integer>` 存储 `inorder` 中元素到索引的映射。这样查找根节点位置的时间复杂度降为 $O(1)$。
2.  **递归构建**：定义一个递归函数，接收前序遍历的范围 `[preLeft, preRight]` 和中序遍历的范围 `[inLeft, inRight]`。

    - **Base Case**：如果 `preLeft > preRight`，说明子树为空，返回 `null`。
    - **根节点**：取 `preorder[preLeft]` 作为当前根节点的值，建立 `TreeNode`。
    - **定位**：利用哈希表找到该根节点在 `inorder` 中的索引 `inRootIndex`。
    - **计算长度**：左子树的节点数量 `leftSubtreeSize = inRootIndex - inLeft`。
    - **递归构造左子树**：

      - 前序范围：`[preLeft + 1, preLeft + leftSubtreeSize]`
      - 中序范围：`[inLeft, inRootIndex - 1]`

    - **递归构造右子树**：

      - 前序范围：`[preLeft + leftSubtreeSize + 1, preRight]`
      - 中序范围：`[inRootIndex + 1, inRight]`

    - 返回根节点。

**复杂度分析：**

- **时间复杂度：** $O(n)$。构建哈希表需要 $O(n)$，递归构建每个节点访问一次，每次查找和计算都是 $O(1)$，总共 $O(n)$。
- **空间复杂度：** $O(n)$。需要哈希表存储 $n$ 个映射关系，递归栈的深度在最坏情况下（链状树）为 $O(n)$，平均为 $O(\log n)$。

**代码片段：**

```java
private Map<Integer, Integer> indexMap;

public TreeNode buildTree(int[] preorder, int[] inorder) {
    int n = preorder.length;
    indexMap = new HashMap<>();
    for (int i = 0; i < n; i++) {
        indexMap.put(inorder[i], i);
    }
    return myBuildTree(preorder, 0, n - 1, inorder, 0, n - 1);
}

private TreeNode myBuildTree(int[] preorder, int preLeft, int preRight,
                             int[] inorder, int inLeft, int inRight) {
    if (preLeft > preRight) {
        return null;
    }

    // 前序遍历的第一个节点就是当前的根节点
    int rootVal = preorder[preLeft];
    TreeNode root = new TreeNode(rootVal);

    // 在中序遍历中定位根节点
    int inRootIndex = indexMap.get(rootVal);

    // 计算左子树的节点个数
    int leftSubtreeSize = inRootIndex - inLeft;

    // 递归构造左子树
    // 前序区间：[根节点+1, 根节点+左子树长度]
    // 中序区间：[左边界, 根节点索引-1]
    root.left = myBuildTree(preorder, preLeft + 1, preLeft + leftSubtreeSize,
                            inorder, inLeft, inRootIndex - 1);

    // 递归构造右子树
    // 前序区间：[根节点+左子树长度+1, 右边界]
    // 中序区间：[根节点索引+1, 右边界]
    root.right = myBuildTree(preorder, preLeft + leftSubtreeSize + 1, preRight,
                             inorder, inRootIndex + 1, inRight);

    return root;
}
```

### 完整代码

```java
import java.util.HashMap;
import java.util.Map;
import java.util.LinkedList;
import java.util.Queue;

public class Main {

    // Definition for a binary tree node.
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode() {}
        TreeNode(int val) { this.val = val; }
        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    // 为了快速定位中序遍历中的根节点位置，使用哈希表
    private static Map<Integer, Integer> indexMap;

    public static TreeNode buildTree(int[] preorder, int[] inorder) {
        int n = preorder.length;
        indexMap = new HashMap<>();
        // 构造哈希映射，key 为节点值，value 为 inorder 中的索引
        for (int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i);
        }
        return myBuildTree(preorder, 0, n - 1, inorder, 0, n - 1);
    }

    /**
     * @param preorder 前序遍历数组
     * @param preLeft  当前子树在前序数组中的左边界
     * @param preRight 当前子树在前序数组中的右边界
     * @param inorder  中序遍历数组
     * @param inLeft   当前子树在中序数组中的左边界
     * @param inRight  当前子树在中序数组中的右边界
     */
    private static TreeNode myBuildTree(int[] preorder, int preLeft, int preRight,
                                        int[] inorder, int inLeft, int inRight) {
        // 递归终止条件：范围无效
        if (preLeft > preRight) {
            return null;
        }

        // 1. 获取根节点的值（前序遍历的第一个元素）
        int rootVal = preorder[preLeft];
        TreeNode root = new TreeNode(rootVal);

        // 2. 获取根节点在中序遍历中的位置
        int inRootIndex = indexMap.get(rootVal);

        // 3. 计算左子树的大小
        int leftSubtreeSize = inRootIndex - inLeft;

        // 4. 递归构建左子树
        // 左子树的前序范围：从 preLeft + 1 开始，长度为 leftSubtreeSize
        // 左子树的中序范围：从 inLeft 到 inRootIndex - 1
        root.left = myBuildTree(preorder, preLeft + 1, preLeft + leftSubtreeSize,
                                inorder, inLeft, inRootIndex - 1);

        // 5. 递归构建右子树
        // 右子树的前序范围：从 preLeft + leftSubtreeSize + 1 到 preRight
        // 右子树的中序范围：从 inRootIndex + 1 到 inRight
        root.right = myBuildTree(preorder, preLeft + leftSubtreeSize + 1, preRight,
                                 inorder, inRootIndex + 1, inRight);

        return root;
    }

    // --- 辅助方法：层序遍历打印二叉树 ---
    public static void printTree(TreeNode root) {
        if (root == null) {
            System.out.println("[]");
            return;
        }
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if (node == null) {
                sb.append("null, ");
            } else {
                sb.append(node.val).append(", ");
                // 只有当左右孩子不全为空时，或者是中间层的 null，才需要入队
                // 这里为了简单展示，不做过于复杂的 null 压缩处理
                if (node.left != null || node.right != null) {
                    queue.offer(node.left);
                    queue.offer(node.right);
                }
            }
        }
        // 去除尾部逗号
        if (sb.lastIndexOf(", ") > 0) {
            sb.setLength(sb.length() - 2);
        }
        sb.append("]");
        System.out.println(sb.toString());
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int[] preorder1 = {3, 9, 20, 15, 7};
        int[] inorder1 = {9, 3, 15, 20, 7};

        System.out.println("示例 1 输入:");
        System.out.println("preorder = [3,9,20,15,7]");
        System.out.println("inorder  = [9,3,15,20,7]");

        TreeNode root1 = buildTree(preorder1, inorder1);

        System.out.print("示例 1 输出: ");
        printTree(root1); // 预期: [3, 9, 20, 15, 7] (层序)
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        int[] preorder2 = {-1};
        int[] inorder2 = {-1};

        System.out.println("示例 2 输入:");
        System.out.println("preorder = [-1]");
        System.out.println("inorder  = [-1]");

        TreeNode root2 = buildTree(preorder2, inorder2);

        System.out.print("示例 2 输出: ");
        printTree(root2); // 预期: [-1]
    }
}
```
