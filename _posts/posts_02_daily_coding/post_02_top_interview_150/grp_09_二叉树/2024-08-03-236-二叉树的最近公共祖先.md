---
title: 236. 二叉树的最近公共祖先
date: 2024-08-03 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231909090.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

**百度百科中最近公共祖先的定义为：** “对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

- **输入:** `root = [3,5,1,6,2,0,8,null,null,7,4]`, `p = 5`, `q = 1`
- **输出:** `3`
- **解释:** 节点 `5` 和节点 `1` 的最近公共祖先是节点 `3`。

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

- **输入:** `root = [3,5,1,6,2,0,8,null,null,7,4]`, `p = 5`, `q = 4`
- **输出:** `5`
- **解释:** 节点 `5` 和节点 `4` 的最近公共祖先是节点 `5`。因为根据定义最近公共祖先节点可以为节点本身。

**示例 3:**

- **输入:** `root = [1,2]`, `p = 1`, `q = 2`
- **输出:** `1`

**提示:**

- 树中节点数目在范围 `[2, 10^5]` 内。
- `-10^9 <= Node.val <= 10^9`
- 所有 `Node.val` **互不相同**。
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中。

## 题解

### 解法：递归法 (DFS / 后序遍历)

**思路：**

寻找最近公共祖先（LCA）可以通过递归的方式来解决。我们可以采用 **后序遍历**（Bottom-up）的策略，从底向上回溯查找。

对于当前节点 `root`，我们需要做如下判断：

1.  **终止条件**：

    - 如果 `root` 为 `null`，说明已经越过叶子节点，没找到，返回 `null`。
    - 如果 `root` 等于 `p` 或者 `root` 等于 `q`，说明当前节点就是我们要找的其中一个目标（或者两个都在这，其中一个是另一个的祖先），直接返回 `root`。

2.  **递归步骤**：

    - 在左子树中查找 `p` 或 `q`，记为 `left`。
    - 在右子树中查找 `p` 或 `q`，记为 `right`。

3.  **处理返回值**：

    - **情况 1**：如果 `left` 和 `right` **都不为空**。说明 `p` 和 `q` 分别散落在 `root` 的左、右子树中。那么当前 `root` 就是它们的最近公共祖先，返回 `root`。
    - **情况 2**：如果 `left` 为空，但 `right` 不为空。说明 `p` 和 `q` 都不在左子树，而在右子树中（或者是其中一个在右子树，另一个是该节点的子孙）。直接返回 `right`。
    - **情况 3**：如果 `left` 不为空，但 `right` 为空。说明都在左子树。直接返回 `left`。
    - **情况 4**：如果都为空，返回 `null`。

**复杂度分析：**

- **时间复杂度：** $O(N)$，其中 $N$ 是二叉树的节点数。在最坏情况下，我们需要遍历二叉树的所有节点。
- **空间复杂度：** $O(N)$。递归调用的栈深度取决于二叉树的高度，最坏情况（链状）为 $O(N)$，平均情况为 $O(\log N)$。

**代码片段：**

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    // 1. 终止条件：越过叶子节点，或者找到了 p 或 q
    if (root == null || root == p || root == q) {
        return root;
    }

    // 2. 递归查找左右子树
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);

    // 3. 根据查找结果判断
    // 如果左右子树返回值都不为空，说明 p 和 q 分居两侧，root 即为 LCA
    if (left != null && right != null) {
        return root;
    }

    // 如果左边没找到，那一定在右边（或者右边也没找到，返回 null）
    // 如果右边没找到，那一定在左边
    return (left != null) ? left : right;
}
```

### 完整代码

```java
public class Main {

    // Definition for a binary tree node.
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) { val = x; }
    }

    // 核心算法实现
    public static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 1. Base case: 根节点为空，或者根节点就是 p 或 q
        if (root == null || root == p || root == q) {
            return root;
        }

        // 2. 递归向左和向右搜索
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        // 3. 处理结果
        // 两个节点分别在左右子树中 -> root 是最近公共祖先
        if (left != null && right != null) {
            return root;
        }

        // 两个节点都在右子树（或者只找到了一个，另一个在下面）
        if (left == null) {
            return right;
        }

        // 两个节点都在左子树
        return left;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        // 构建树: [3,5,1,6,2,0,8,null,null,7,4]
        TreeNode root = new TreeNode(3);
        TreeNode n5 = new TreeNode(5);
        TreeNode n1 = new TreeNode(1);
        TreeNode n6 = new TreeNode(6);
        TreeNode n2 = new TreeNode(2);
        TreeNode n0 = new TreeNode(0);
        TreeNode n8 = new TreeNode(8);
        TreeNode n7 = new TreeNode(7);
        TreeNode n4 = new TreeNode(4);

        root.left = n5;
        root.right = n1;
        n5.left = n6;
        n5.right = n2;
        n1.left = n0;
        n1.right = n8;
        n2.left = n7;
        n2.right = n4;

        // 测试 1: p=5, q=1
        System.out.println("示例 1 输入: root=[3...], p=5, q=1");
        // 注意：这里传入的必须是树中实际存在的节点对象，而不是新 new 出来的同值节点
        TreeNode result1 = lowestCommonAncestor(root, n5, n1);
        System.out.println("示例 1 输出: " + (result1 != null ? result1.val : "null")); // 预期: 3
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        // 测试 2: p=5, q=4
        System.out.println("示例 2 输入: root=[3...], p=5, q=4");
        TreeNode result2 = lowestCommonAncestor(root, n5, n4);
        System.out.println("示例 2 输出: " + (result2 != null ? result2.val : "null")); // 预期: 5
        System.out.println("-----------------------------");

        // --- 示例 3 测试 ---
        // 构建树: [1, 2]
        TreeNode root3 = new TreeNode(1);
        TreeNode node2 = new TreeNode(2);
        root3.left = node2;

        System.out.println("示例 3 输入: root=[1,2], p=1, q=2");
        TreeNode result3 = lowestCommonAncestor(root3, root3, node2);
        System.out.println("示例 3 输出: " + (result3 != null ? result3.val : "null")); // 预期: 1
    }
}
```
