---
title: 236. 二叉树的最近公共祖先
date: 2024-08-03 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231909090.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：236. 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

**百度百科中最近公共祖先的定义为：** “对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

- **输入:** `root = [3,5,1,6,2,0,8,null,null,7,4]`, `p = 5`, `q = 1`
- **输出:** `3`
- **解释:** 节点 `5` 和节点 `1` 的最近公共祖先是节点 `3`。

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

- **输入:** `root = [3,5,1,6,2,0,8,null,null,7,4]`, `p = 5`, `q = 4`
- **输出:** `5`
- **解释:** 节点 `5` 和节点 `4` 的最近公共祖先是节点 `5`。因为根据定义最近公共祖先节点可以为节点本身。

**示例 3:**

- **输入:** `root = [1,2]`, `p = 1`, `q = 2`
- **输出:** `1`

**提示:**

- 树中节点数目在范围 `[2, 10^5]` 内。
- `-10^9 <= Node.val <= 10^9`
- 所有 `Node.val` **互不相同**。
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中。

## Java 代码

**算法思路：(递归 / 深度优先搜索 DFS)**

这是一个经典的树遍历问题，使用递归可以非常优雅地解决。我们可以定义一个递归函数，该函数在以 `currentNode` 为根的子树中查找 `p` 和 `q`。

1.  **递归终止条件:**
    - 如果当前节点 `currentNode` 为 `null`，说明这条路径上没有 `p` 或 `q`，返回 `null`。
    - 如果当前节点 `currentNode` 就是 `p` 或者 `q`，那么它就是这个子树中能找到的“最高”的目标节点，直接返回 `currentNode`。
2.  **递归搜索子树:**
    - 对当前节点的左子树和右子树分别进行递归调用：
      - `leftResult = lowestCommonAncestor(currentNode.left, p, q)`
      - `rightResult = lowestCommonAncestor(currentNode.right, p, q)`
3.  **分析返回结果:**
    - 如果 `leftResult` 和 `rightResult` **都不为 null**，这意味着 `p` 和 `q` 分别位于 `currentNode` 的左右两个子树中。在这种情况下，`currentNode` 就是它们的最近公共祖先。
    - 如果 `leftResult` 为 `null` 而 `rightResult` **不为 null**，说明 `p` 和 `q` 都在右子树中，那么 `rightResult` 就是从右子树中找到的 LCA，我们将其返回。
    - 如果 `rightResult` 为 `null` 而 `leftResult` **不为 null**，说明 `p` 和 `q` 都在左子树中，同理，返回 `leftResult`。
    - 如果两者都为 `null`，说明此子树不包含 `p` 或 `q`。

通过这种后序遍历的方式，我们将子问题的结果向上传递，最终在根节点层面得到答案。

```java
/**
 * 二叉树节点的定义
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}


public class Main {

    /**
     * 找到二叉树中两个指定节点的最近公共祖先。
     */
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 递归终止条件
        if (root == null || root == p || root == q) {
            return root;
        }

        // 递归搜索左右子树
        TreeNode leftResult = lowestCommonAncestor(root.left, p, q);
        TreeNode rightResult = lowestCommonAncestor(root.right, p, q);

        // 分析结果
        if (leftResult != null && rightResult != null) {
            // p 和 q 分布在 root 的两侧，root 就是 LCA
            return root;
        }
        if (leftResult != null) {
            // p 和 q 都在左子树
            return leftResult;
        }
        // p 和 q 都在右子树，或只有一个在右子树
        return rightResult;
    }

    // --- 辅助函数，用于在树中根据值查找节点 ---
    public TreeNode findNode(TreeNode root, int val) {
        if (root == null) return null;
        if (root.val == val) return root;
        TreeNode left = findNode(root.left, val);
        if (left != null) return left;
        return findNode(root.right, val);
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        Main solution = new Main();

        // --- 构建示例 1 & 2 的树 ---
        TreeNode root = new TreeNode(3);
        root.left = new TreeNode(5);
        root.right = new TreeNode(1);
        root.left.left = new TreeNode(6);
        root.left.right = new TreeNode(2);
        root.right.left = new TreeNode(0);
        root.right.right = new TreeNode(8);
        root.left.right.left = new TreeNode(7);
        root.left.right.right = new TreeNode(4);

        System.out.println("--- 示例 1 ---");
        TreeNode p1 = solution.findNode(root, 5);
        TreeNode q1 = solution.findNode(root, 1);
        System.out.println("输入: root = [3,5,1,...], p = 5, q = 1");
        TreeNode result1 = solution.lowestCommonAncestor(root, p1, q1);
        System.out.println("输出: " + result1.val); // 预期输出: 3
        System.out.println();

        System.out.println("--- 示例 2 ---");
        TreeNode p2 = solution.findNode(root, 5);
        TreeNode q2 = solution.findNode(root, 4);
        System.out.println("输入: root = [3,5,1,...], p = 5, q = 4");
        TreeNode result2 = solution.lowestCommonAncestor(root, p2, q2);
        System.out.println("输出: " + result2.val); // 预期输出: 5
        System.out.println();

        System.out.println("--- 示例 3 ---");
        TreeNode root3 = new TreeNode(1);
        root3.left = new TreeNode(2);
        TreeNode p3 = solution.findNode(root3, 1);
        TreeNode q3 = solution.findNode(root3, 2);
        System.out.println("输入: root = [1,2], p = 1, q = 2");
        TreeNode result3 = solution.lowestCommonAncestor(root3, p3, q3);
        System.out.println("输出: " + result3.val); // 预期输出: 1
    }
}
```
