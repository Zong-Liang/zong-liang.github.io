---
title: 129. 求根节点到叶节点数字之和
date: 2024-07-26 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231713555.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：129. 求根节点到叶节点数字之和

给你一个二叉树的根节点 `root`，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。

每条从根节点到叶节点的路径都代表一个数字：

- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123`。

计算从根节点到叶节点生成的 **所有数字之和**。

**叶节点** 是指没有子节点的节点。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/02/19/pathsum1.jpg)

- **输入:** `root = [1,2,3]`
- **输出:** 25
- **解释:**
  从根到叶子节点路径 `1->2` 代表数字 `12`
  从根到叶子节点路径 `1->3` 代表数字 `13`
  因此，数字总和 = `12 + 13 = 25`

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2021/02/19/pathsum2.jpg)

- **输入:** `root = [4,9,0,5,1]`
- **输出:** 1026
- **解释:**
  从根到叶子节点路径 `4->9->5` 代表数字 `495`
  从根到叶子节点路径 `4->9->1` 代表数字 `491`
  从根到叶子节点路径 `4->0` 代表数字 `40`
  因此，数字总和 = `495 + 491 + 40 = 1026`

**提示:**

- 树中节点的数目在范围 `[1, 1000]` 内
- `0 <= Node.val <= 9`
- 树的深度不超过 `10`

## Java 代码

**算法思路：(深度优先搜索 DFS / 递归)**

这个问题可以通过一次 **深度优先搜索 (DFS)** 遍历来解决。我们在遍历树的同时，构建从根到当前节点的路径所代表的数字。

1.  **递归函数:** 我们定义一个递归函数 `dfs(node, currentSum)`。
    - `node`: 当前正在访问的节点。
    - `currentSum`: 从根节点到 `node` 的 **父节点** 为止的路径所代表的数字。
2.  **在递归中:**
    
    a. 计算到达当前节点 `node` 所形成的数字：`pathValue = currentSum * 10 + node.val`。
    
    b. **判断叶子节点:** 如果当前节点 `node` 是一个叶子节点（即 `node.left == null` 且 `node.right == null`），说明我们找到了一条完整的路径。将 `pathValue` 返回，这个值将贡献给最终的总和。
    
    c. **递归子树:** 如果当前节点不是叶子节点，则递归地对其非空的左、右子节点调用 `dfs`，并将返回的结果累加起来。 \* `sum = dfs(node.left, pathValue) + dfs(node.right, pathValue)`
3.  **初始调用:** 从根节点开始调用 `dfs(root, 0)`。

```java
/**
 * 二叉树节点的定义
 */
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val) { this.val = val; }
}


public class Main {

    /**
     * 计算从根节点到叶节点生成的所有数字之和。
     */
    public int sumNumbers(TreeNode root) {
        return dfs(root, 0);
    }

    /**
     * 深度优先搜索的辅助函数
     * @param node       当前节点
     * @param currentSum 从根到当前节点父节点的路径所代表的数字
     * @return 以当前节点为根的子树中所有根到叶路径数字的和
     */
    private int dfs(TreeNode node, int currentSum) {
        if (node == null) {
            return 0;
        }

        // 计算到达当前节点的路径值
        int pathValue = currentSum * 10 + node.val;

        // 如果是叶子节点，返回当前路径值
        if (node.left == null && node.right == null) {
            return pathValue;
        }

        // 如果不是叶子节点，递归计算左右子树的和
        return dfs(node.left, pathValue) + dfs(node.right, pathValue);
    }


    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        TreeNode root1 = new TreeNode(1);
        root1.left = new TreeNode(2);
        root1.right = new TreeNode(3);
        System.out.println("输入: root = [1,2,3]");
        int result1 = solution.sumNumbers(root1);
        System.out.println("输出: " + result1); // 预期输出: 25
        System.out.println();

        System.out.println("--- 示例 2 ---");
        TreeNode root2 = new TreeNode(4);
        root2.left = new TreeNode(9);
        root2.right = new TreeNode(0);
        root2.left.left = new TreeNode(5);
        root2.left.right = new TreeNode(1);
        System.out.println("输入: root = [4,9,0,5,1]");
        int result2 = solution.sumNumbers(root2);
        System.out.println("输出: " + result2); // 预期输出: 1026
    }
}
```
