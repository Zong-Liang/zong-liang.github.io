---
title: 129. 求根节点到叶节点数字之和
date: 2024-07-26 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 二叉树]
tags: [二叉树]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121231713555.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个二叉树的根节点 `root`，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。

每条从根节点到叶节点的路径都代表一个数字：

- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123`。

计算从根节点到叶节点生成的 **所有数字之和**。

**叶节点** 是指没有子节点的节点。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/02/19/pathsum1.jpg)

- **输入:** `root = [1,2,3]`
- **输出:** 25
- **解释:**

  从根到叶子节点路径 `1->2` 代表数字 `12`

  从根到叶子节点路径 `1->3` 代表数字 `13`

  因此，数字总和 = `12 + 13 = 25`

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2021/02/19/pathsum2.jpg)

- **输入:** `root = [4,9,0,5,1]`
- **输出:** 1026
- **解释:**

  从根到叶子节点路径 `4->9->5` 代表数字 `495`

  从根到叶子节点路径 `4->9->1` 代表数字 `491`

  从根到叶子节点路径 `4->0` 代表数字 `40`

  因此，数字总和 = `495 + 491 + 40 = 1026`

**提示:**

- 树中节点的数目在范围 `[1, 1000]` 内
- `0 <= Node.val <= 9`
- 树的深度不超过 `10`

## 题解

### 解法一：深度优先搜索 (DFS)

**思路：**

这道题本质上是对二叉树进行一次遍历。我们需要维护从根节点到当前节点的路径所代表的数字。

使用递归的 DFS 是最直观的方法：

1.  **参数传递**：递归函数接收当前节点 `node` 和父节点传递下来的数值 `prevSum`。
2.  **数值更新**：当前节点形成的数值为 `sum = prevSum * 10 + node.val`。
3.  **终止条件（叶子节点）**：如果当前节点是叶子节点（即没有左子节点和右子节点），说明一条路径结束，直接返回当前的 `sum`。
4.  **递归计算**：如果不是叶子节点，则将当前 `sum` 传递给左子节点和右子节点，并将它们的返回值相加。
5.  **空节点处理**：如果遇到空节点，返回 `0`（不贡献累加和）。

**复杂度分析：**

- **时间复杂度：** $O(N)$，其中 $N$ 是二叉树的节点个数。对每个节点访问一次。
- **空间复杂度：** $O(H)$，其中 $H$ 是二叉树的高度。空间主要取决于递归调用的栈空间。最坏情况（链状）为 $O(N)$，平均情况为 $O(\log N)$。

**代码片段：**

```java
public int sumNumbers(TreeNode root) {
    return dfs(root, 0);
}

private int dfs(TreeNode node, int prevSum) {
    if (node == null) {
        return 0;
    }
    int sum = prevSum * 10 + node.val;

    // 如果是叶子节点，返回当前路径生成的数
    if (node.left == null && node.right == null) {
        return sum;
    }

    // 否则递归计算左右子树之和
    return dfs(node.left, sum) + dfs(node.right, sum);
}
```

### 解法二：广度优先搜索 (BFS)

**思路：**

我们也可以使用层序遍历（BFS）来解决，这时需要两个队列：

1.  `nodeQueue`：存储当前的节点。
2.  `numQueue`：存储根节点到当前节点路径所表示的数值。

算法流程：

1.  初始将 `root` 入 `nodeQueue`，将 `root.val` 入 `numQueue`。
2.  当队列不为空时，同时取出节点和数值。
3.  如果当前节点是叶子节点，将该数值累加到总结果 `totalSum` 中。
4.  如果有左子节点，计算左子节点对应的新数值（`当前数值 * 10 + 左节点值`），并将左子节点和新数值分别入队。
5.  右子节点同理。

**复杂度分析：**

- **时间复杂度：** $O(N)$。
- **空间复杂度：** $O(N)$，队列在最坏情况下（满二叉树的最底层）需要存储 $N/2$ 个节点。

**代码片段：**

```java
public int sumNumbers(TreeNode root) {
    if (root == null) return 0;

    int totalSum = 0;
    Queue<TreeNode> nodeQueue = new LinkedList<>();
    Queue<Integer> numQueue = new LinkedList<>();

    nodeQueue.offer(root);
    numQueue.offer(root.val);

    while (!nodeQueue.isEmpty()) {
        TreeNode node = nodeQueue.poll();
        int num = numQueue.poll();

        // 如果是叶子节点，累加结果
        if (node.left == null && node.right == null) {
            totalSum += num;
        } else {
            // 处理左子节点
            if (node.left != null) {
                nodeQueue.offer(node.left);
                numQueue.offer(num * 10 + node.left.val);
            }
            // 处理右子节点
            if (node.right != null) {
                nodeQueue.offer(node.right);
                numQueue.offer(num * 10 + node.right.val);
            }
        }
    }
    return totalSum;
}
```

### 完整代码

```java
import java.util.LinkedList;
import java.util.Queue;

public class Main {

    // Definition for a binary tree node.
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode() {}
        TreeNode(int val) { this.val = val; }
        TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    // 核心算法实现：解法一（DFS 递归，代码更简洁）
    public static int sumNumbers(TreeNode root) {
        return dfs(root, 0);
    }

    private static int dfs(TreeNode node, int prevSum) {
        if (node == null) {
            return 0;
        }

        // 计算当前节点代表的数字：上一层的值 * 10 + 当前节点值
        int currentSum = prevSum * 10 + node.val;

        // 如果是叶子节点，说明一条路径走完了，返回当前数字
        if (node.left == null && node.right == null) {
            return currentSum;
        }

        // 否则继续累加左右子树的结果
        return dfs(node.left, currentSum) + dfs(node.right, currentSum);
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        // 输入: root = [1,2,3]
        TreeNode root1 = new TreeNode(1);
        root1.left = new TreeNode(2);
        root1.right = new TreeNode(3);

        System.out.println("示例 1 输入: [1,2,3]");
        int result1 = sumNumbers(root1);
        System.out.println("示例 1 输出: " + result1); // 预期: 25 (12 + 13)
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        // 输入: root = [4,9,0,5,1]
        // 构造树结构
        TreeNode root2 = new TreeNode(4);
        root2.left = new TreeNode(9);
        root2.right = new TreeNode(0);
        root2.left.left = new TreeNode(5);
        root2.left.right = new TreeNode(1);

        System.out.println("示例 2 输入: [4,9,0,5,1]");
        int result2 = sumNumbers(root2);
        System.out.println("示例 2 输出: " + result2); // 预期: 1026 (495 + 491 + 40)
        System.out.println("-----------------------------");

        // --- 示例 3 测试 (单节点) ---
        TreeNode root3 = new TreeNode(5);
        System.out.println("示例 3 输入: [5]");
        int result3 = sumNumbers(root3);
        System.out.println("示例 3 输出: " + result3); // 预期: 5
    }
}
```
