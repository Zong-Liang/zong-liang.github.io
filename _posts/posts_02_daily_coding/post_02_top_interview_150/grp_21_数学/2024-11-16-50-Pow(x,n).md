---
title: 50-Pow(x,n)
date: 2024-11-16 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数学]
tags: [数学]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235531519.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


### 题目：50. Pow(x, n)

实现 `pow(x, n)`，即计算 `x` 的整数 `n` 次幂函数（即，`x^n`）。

---

**示例 1:**

- **输入:** `x = 2.00000`, `n = 10`
- **输出:** `1024.00000`

**示例 2:**

- **输入:** `x = 2.10000`, `n = 3`
- **输出:** `9.26100`

**示例 3:**

- **输入:** `x = 2.00000`, `n = -2`
- **输出:** `0.25000`
- **解释:** `2^-2 = 1/2^2 = 1/4 = 0.25`

---

**提示:**

- `-100.0 < x < 100.0`
- `-2^31 <= n <= 2^31 - 1`
- `n` 是一个整数
- 要么 `x` 不为零，要么 `n > 0`。
- `-10^4 <= x^n <= 10^4`

---

### Java 8 解答 (赛码网格式)

以下是使用 **快速幂（递归）** 算法实现的解决方案。该算法的时间复杂度为 O(log n)，可以高效地处理 `n` 非常大的情况。

**算法思路：**
该方法利用了 `x^n = (x^(n/2))^2` （当 n 为偶数）和 `x^n = x * (x^((n-1)/2))^2` （当 n 为奇数）的原理，通过递归将问题规模减半，从而实现对数级的时间复杂度。

```java
import java.text.DecimalFormat;

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    /**
     * 计算 x 的 n 次幂。
     *
     * @param x 底数
     * @param n 指数
     * @return x 的 n 次幂的结果
     */
    public static double myPow(double x, int n) {
        // 将 int 类型的 n 转换为 long，以处理 n = Integer.MIN_VALUE 的边界情况。
        // -Integer.MIN_VALUE 会导致整数溢出。
        long N = n;

        // 如果指数为负，则将底数取倒数，指数取相反数。
        if (N < 0) {
            x = 1 / x;
            N = -N;
        }

        return fastPow(x, N);
    }

    /**
     * 快速幂算法的辅助函数。
     *
     * @param x 底数
     * @param n 非负指数
     * @return x 的 n 次幂的结果
     */
    private static double fastPow(double x, long n) {
        // 递归的终止条件：任何数的 0 次幂都是 1。
        if (n == 0) {
            return 1.0;
        }

        // 递归计算 x 的 n/2 次幂
        double half = fastPow(x, n / 2);

        // 如果 n 是偶数，结果是 half * half
        if (n % 2 == 0) {
            return half * half;
        } else { // 如果 n 是奇数，结果是 half * half * x
            return half * half * x;
        }
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        // LeetCode 的输出格式通常是固定的小数位数，这里为了匹配示例进行格式化
        DecimalFormat df = new DecimalFormat("0.00000");

        System.out.println("--- 示例 1 ---");
        double x1 = 2.00000;
        int n1 = 10;
        System.out.println("输入: x = " + x1 + ", n = " + n1);
        double result1 = myPow(x1, n1);
        System.out.println("输出: " + df.format(result1)); // 预期输出: 1024.00000
        System.out.println();

        System.out.println("--- 示例 2 ---");
        double x2 = 2.10000;
        int n2 = 3;
        System.out.println("输入: x = " + x2 + ", n = " + n2);
        double result2 = myPow(x2, n2);
        System.out.println("输出: " + df.format(result2)); // 预期输出: 9.26100
        System.out.println();

        System.out.println("--- 示例 3 ---");
        double x3 = 2.00000;
        int n3 = -2;
        System.out.println("输入: x = " + x3 + ", n = " + n3);
        double result3 = myPow(x3, n3);
        System.out.println("输出: " + df.format(result3)); // 预期输出: 0.25000
    }
}
```
