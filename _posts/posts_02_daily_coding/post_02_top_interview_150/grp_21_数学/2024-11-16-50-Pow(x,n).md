---
title: 50. Pow(x,n)
date: 2024-11-16 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数学]
tags: [数学]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235531519.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

实现 `pow(x, n)`，即计算 `x` 的整数 `n` 次幂函数（即，`x^n`）。

**示例 1:**

- **输入:** `x = 2.00000`, `n = 10`
- **输出:** `1024.00000`

**示例 2:**

- **输入:** `x = 2.10000`, `n = 3`
- **输出:** `9.26100`

**示例 3:**

- **输入:** `x = 2.00000`, `n = -2`
- **输出:** `0.25000`
- **解释:** `2^-2 = 1/2^2 = 1/4 = 0.25`

**提示:**

- `-100.0 < x < 100.0`
- `-2^31 <= n <= 2^31 - 1`
- `n` 是一个整数
- 要么 `x` 不为零，要么 `n > 0`。
- `-10^4 <= x^n <= 10^4`

## 题解

### 解法：快速幂 (Binary Exponentiation / Exponentiation by Squaring)

**思路：**

如果我们直接使用循环将 $x$ 连乘 $n$ 次，时间复杂度为 $O(n)$。当 $n$ 非常大（例如 $2^{31}-1$）时，会导致超时（Time Limit Exceeded）。因此，我们需要使用**快速幂**算法，将时间复杂度降低到 $O(\log n)$。

快速幂的核心思想是将指数 $n$ 进行拆分（利用二进制的性质）：

1.  **二分思想**：

    - 如果 $n$ 是偶数，那么 $x^n = x^{n/2} \times x^{n/2} = (x^{n/2})^2$。
    - 如果 $n$ 是奇数，那么 $x^n = x \times x^{n-1} = x \times (x^{(n-1)/2})^2$。
    - 通过这种方式，每次迭代都可以将指数减半，从而极大减少计算次数。

2.  **处理负指数**：

    - 如果 $n < 0$，我们可以利用公式 $x^n = (1/x)^{-n}$。即将 $x$ 取倒数，并将 $n$ 变为正数计算。

3.  **处理边界溢出**：

    - 题目提示 $n$ 的范围是 $[-2^{31}, 2^{31}-1]$。
    - 当 $n = -2^{31}$ （即 `Integer.MIN_VALUE`）时，直接执行 `-n` 会导致整型溢出（因为正数的最大值是 $2^{31}-1$）。
    - **解决方案**：先将 `n` 转换为 `long` 类型再进行操作。

**算法步骤（迭代法）：**

1.  将 `n` 转换为 `long` 类型的 `N`。
2.  如果 `N` 是负数，置 `x = 1/x`，并将 `N` 取反为正数。
3.  初始化结果 `ans = 1.0`。
4.  当 `N > 0` 时循环：

    - 如果 `N` 是奇数（`N % 2 == 1`），说明当前的权重需要计入结果，执行 `ans = ans * x`。
    - 将底数平方 `x = x * x`。
    - 将指数减半 `N = N / 2`。

5.  返回 `ans`。

**复杂度分析：**

- **时间复杂度：** $O(\log n)$，每次循环指数 $n$ 都会减半，因此循环次数为二进制位的长度。
- **空间复杂度：** $O(1)$，迭代法只使用常数空间。如果使用递归，空间复杂度为 $O(\log n)$ 的栈空间。

**代码片段：**

```java
public double myPow(double x, int n) {
    long N = n; // 使用 long 防止 n = Integer.MIN_VALUE 时取反溢出
    if (N < 0) {
        x = 1 / x;
        N = -N;
    }

    double ans = 1.0;
    while (N > 0) {
        if ((N % 2) == 1) { // 如果当前二进制位是 1
            ans *= x;
        }
        x *= x; // 底数翻倍
        N /= 2; // 指数右移一位
    }
    return ans;
}
```

### 完整代码

```java
public class Main {

    /**
     * 计算 x 的 n 次幂 - 快速幂算法 (Iterative)
     */
    public static double myPow(double x, int n) {
        // 1. 将 n 转换为 long，防止 -2147483648 取反越界
        long N = n;

        // 2. 如果是负指数，转换为正指数计算：x^-n = (1/x)^n
        if (N < 0) {
            x = 1 / x;
            N = -N;
        }

        double ans = 1.0;

        // 3. 循环迭代，每次指数减半，底数平方
        while (N > 0) {
            // 如果当前指数是奇数（二进制末位是1），把当前的底数乘入结果
            if ((N & 1) == 1) { // 等价于 N % 2 == 1
                ans *= x;
            }

            // 底数平方 (x -> x^2 -> x^4 ...)
            x *= x;

            // 指数右移一位 (除以 2)
            N >>= 1; // 等价于 N /= 2
        }

        return ans;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        double x1 = 2.00000;
        int n1 = 10;
        System.out.println("示例 1 输入: x = " + x1 + ", n = " + n1);
        System.out.println("示例 1 输出: " + myPow(x1, n1));
        // 预期: 1024.0
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        double x2 = 2.10000;
        int n2 = 3;
        System.out.println("示例 2 输入: x = " + x2 + ", n = " + n2);
        System.out.println("示例 2 输出: " + String.format("%.5f", myPow(x2, n2)));
        // 预期: 9.26100
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        double x3 = 2.00000;
        int n3 = -2;
        System.out.println("示例 3 输入: x = " + x3 + ", n = " + n3);
        System.out.println("示例 3 输出: " + myPow(x3, n3));
        // 预期: 0.25
        System.out.println("-----------------------------");

        // --- 边界测试 (Integer.MIN_VALUE) ---
        double x4 = 2.0;
        int n4 = -2147483648;
        System.out.println("边界测试 输入: x = " + x4 + ", n = " + n4);
        // 如果不转 long，直接 -n 会溢出变成 -2147483648，导致死循环或错误
        System.out.println("边界测试 输出: " + myPow(x4, n4));
        // 预期: 0.0
    }
}
```
