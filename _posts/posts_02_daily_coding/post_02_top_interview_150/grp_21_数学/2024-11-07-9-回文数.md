---
title: 9. 回文数
date: 2024-11-07 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数学]
tags: [数学]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235229976.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个整数 `x`，如果 `x` 是一个回文整数，返回 `true`；否则，返回 `false`。

**回文数** 是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

- 例如，121 是回文，而 123 不是。

**示例 1:**

- **输入:** `x = 121`
- **输出:** `true`

**示例 2:**

- **输入:** `x = -121`
- **输出:** `false`
- **解释:** 从左向右读, 为 -121。 从右向左读, 为 121-。因此它不是一个回文数。

**示例 3:**

- **输入:** `x = 10`
- **输出:** `false`
- **解释:** 从右向左读, 为 01。因此它不是一个回文数。

**提示:**

- `-2^31 <= x <= 2^31 - 1`

**进阶:** 你能不将整数转为字符串来解决这个问题吗？

## 题解

### 解法一：字符串转换法 (String Conversion)

**思路：**

这是最直观的解法。将整数转换为字符串，然后检查字符串是否为回文串。

判断字符串回文的方法是使用**双指针**：一个指针指向头部，一个指针指向尾部，向中间移动并比较字符是否相等。

1.  将整数 `x` 转为字符串 `s`。
2.  定义 `left` 指针为 0，`right` 指针为 `s.length() - 1`。
3.  循环比较 `s.charAt(left)` 和 `s.charAt(right)`，如果不相等则返回 `false`。
4.  指针相遇后仍未发现不匹配，则返回 `true`。

**复杂度分析：**

- **时间复杂度：** $O(\log_{10} x)$，需要遍历整数的每一位数字。
- **空间复杂度：** $O(\log_{10} x)$，需要创建字符串来存储整数的文本表示。

**代码片段：**

```java
public boolean isPalindrome(int x) {
    String s = String.valueOf(x);
    int left = 0, right = s.length() - 1;
    while (left < right) {
        if (s.charAt(left) != s.charAt(right)) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}
```

### 解法二：反转一半数字 (Revert Half of the Number) —— 进阶解法

**思路：**

题目进阶要求**不使用字符串**。我们可以通过数学方法反转数字。

如果反转整个数字，可能会遇到**整数溢出**的问题（例如反转后的数字超过了 int 范围）。

更精妙的做法是**只反转数字的后半部分**。

1.  **特殊情况排除**：

    - 负数一定不是回文数（例如 `-121`）。
    - 最后一位是 `0` 且该数不是 `0` 的情况（例如 `10`），也不可能是回文数（因为首位不可能是 0）。

2.  **反转逻辑**：

    - 通过 `% 10` 取出 `x` 的末尾数字，将其添加到 `revertedNumber` 中。
    - 通过 `/ 10` 去掉 `x` 的末尾数字。
    - **循环终止条件**：当原始数字 `x` 小于或等于 `revertedNumber` 时，说明已经处理了一半（或超过一半）的数字。

3.  **结果判定**：

    - **偶数位数字**（如 `1221`）：循环结束后 `x = 12`, `revertedNumber = 12`。判断 `x == revertedNumber`。
    - **奇数位数字**（如 `12321`）：循环结束后 `x = 12`, `revertedNumber = 123`。中间的数字 `3` 不影响回文性，可以通过 `/ 10` 去除。判断 `x == revertedNumber / 10`。

**复杂度分析：**

- **时间复杂度：** $O(\log_{10} x)$，每次迭代输入除以 10，因此循环次数为数字的位数的一半。
- **空间复杂度：** $O(1)$，不依赖字符串，只使用了常数个整型变量。

**代码片段：**

```java
public boolean isPalindromeMath(int x) {
    // 特殊情况：
    // 1. 负数不是回文数
    // 2. 如果最后一位是 0，那么第一位也必须是 0，只有 0 满足
    if (x < 0 || (x % 10 == 0 && x != 0)) {
        return false;
    }

    int revertedNumber = 0;
    // 当 x > revertedNumber 时，说明还没有处理到一半
    while (x > revertedNumber) {
        revertedNumber = revertedNumber * 10 + x % 10;
        x /= 10;
    }

    // x == revertedNumber 对应偶数位数字 (如 1221 -> x=12, rev=12)
    // x == revertedNumber / 10 对应奇数位数字 (如 121 -> x=1, rev=12 -> 12/10=1)
    return x == revertedNumber || x == revertedNumber / 10;
}
```

### 完整代码

```java
public class Main {

    // 解法一：字符串转换法
    public static boolean isPalindromeStr(int x) {
        String s = String.valueOf(x);
        int i = 0, j = s.length() - 1;
        while (i < j) {
            if (s.charAt(i) != s.charAt(j)) return false;
            i++;
            j--;
        }
        return true;
    }

    // 解法二：进阶数学解法（推荐）
    public static boolean isPalindrome(int x) {
        // 排除负数和非0的整十数
        if (x < 0 || (x % 10 == 0 && x != 0)) {
            return false;
        }

        int revertedNumber = 0;
        // 不断取出 x 的末尾，构建 revertedNumber，直到 x 不再大于 revertedNumber
        while (x > revertedNumber) {
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }

        // 偶数长度检查 x == revertedNumber
        // 奇数长度检查 x == revertedNumber / 10 (去除中间位)
        return x == revertedNumber || x == revertedNumber / 10;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int x1 = 121;
        System.out.println("示例 1 输入: " + x1);
        System.out.println("示例 1 输出: " + isPalindrome(x1));
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int x2 = -121;
        System.out.println("示例 2 输入: " + x2);
        System.out.println("示例 2 输出: " + isPalindrome(x2));
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        int x3 = 10;
        System.out.println("示例 3 输入: " + x3);
        System.out.println("示例 3 输出: " + isPalindrome(x3));
    }
}
```
