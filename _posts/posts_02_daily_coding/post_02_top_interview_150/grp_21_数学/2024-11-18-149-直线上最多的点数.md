---
title: 149. 直线上最多的点数
date: 2024-11-18 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数学]
tags: [数学]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235603890.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：149. 直线上最多的点数

给你一个数组 `points`，其中 `points[i] = [xi, yi]` 表示 **X-Y** 平面上的一个点。求最多有多少个点在同一条直线上。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg)

- **输入:** `points = [[1,1],[2,2],[3,3]]`
- **输出:** 3

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg)

- **输入:** `points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`
- **输出:** 4

**提示:**

- `1 <= points.length <= 300`
- `points[i].length == 2`
- `-10^4 <= xi, yi <= 10^4`
- `points` 中的所有点 **互不相同**

## 题解

**算法思路：**

这个问题可以通过遍历所有点来解决。我们固定一个点作为“锚点”，然后计算其他所有点与该锚点形成的直线的斜率。

1.  **遍历锚点**：我们以数组中的每一个点 `points[i]` 作为固定的锚点。
2.  **计算斜率**：对于每个锚点，我们再遍历数组中所有其他的点 `points[j]`，并计算它们与锚点形成的直线的斜率。
3.  **存储斜率**：使用一个哈希表（`HashMap`）来存储每个斜率以及具有该斜率的点的数量。
    - 为了避免浮点数精度问题，我们不直接存储 `double` 类型的斜率，而是将其表示为最简分数 `dy/dx`。我们可以通过计算 `y` 坐标差 `dy` 和 `x` 坐标差 `dx`，然后除以它们的最大公约数（GCD）来实现。
    - 垂直线（`dx = 0`）需要特殊处理，可以为其指定一个特殊的键，例如 `"infinity"`。
4.  **更新最大值**：在遍历完所有其他点后，哈希表中出现次数最多的斜率，就对应了穿过当前锚点的直线上最多的点数。我们用一个全局变量来记录所有锚点情况下的最大值。
5.  **循环**：重复这个过程，直到每个点都被作为锚点处理过一次。

这个算法的时间复杂度是 O(n^2)，其中 n 是点的数量。

```java
import java.util.HashMap;
import java.util.Map;


public class Main {

    /**
     * 计算在同一条直线上的最大点数。
     *
     * @param points 点的坐标数组。
     * @return 最多有多少个点在同一条直线上。
     */
    public static int maxPoints(int[][] points) {
        // 如果点的数量小于等于2，则所有点都在一条直线上
        if (points.length <= 2) {
            return points.length;
        }

        int maxCount = 0;

        // 遍历每个点作为锚点
        for (int i = 0; i < points.length; i++) {
            // Key: 斜率的最简分数表示（"dy/dx"），Value: 该斜率出现的次数
            Map<String, Integer> slopeMap = new HashMap<>();

            // 当前锚点 i 对应的直线上点的最大数量
            int currentMax = 0;

            // 遍历其他点，计算与锚点的斜率
            for (int j = i + 1; j < points.length; j++) {
                int dx = points[j][0] - points[i][0];
                int dy = points[j][1] - points[i][1];

                String key;
                if (dx == 0) {
                    // 垂直线
                    key = "infinity";
                } else {
                    // 计算最大公约数以简化分数
                    int commonDivisor = gcd(dy, dx);
                    key = (dy / commonDivisor) + "/" + (dx / commonDivisor);
                }

                // 更新斜率计数
                slopeMap.put(key, slopeMap.getOrDefault(key, 0) + 1);
                // 更新当前锚点的最大值
                currentMax = Math.max(currentMax, slopeMap.get(key));
            }

            // 更新全局最大值。currentMax 是除了锚点之外的点数，所以要加1
            maxCount = Math.max(maxCount, currentMax + 1);
        }

        return maxCount;
    }

    /**
     * 使用欧几里得算法计算最大公约数。
     */
    private static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }


    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[][] points1 = {{1, 1}, {2, 2}, {3, 3}};
        System.out.println("输入: points = [[1,1],[2,2],[3,3]]");
        int result1 = maxPoints(points1);
        System.out.println("输出: " + result1); // 预期输出: 3
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[][] points2 = {{1, 1}, {3, 2}, {5, 3}, {4, 1}, {2, 3}, {1, 4}};
        System.out.println("输入: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]");
        int result2 = maxPoints(points2);
        System.out.println("输出: " + result2); // 预期输出: 4
        System.out.println();
    }
}
```
