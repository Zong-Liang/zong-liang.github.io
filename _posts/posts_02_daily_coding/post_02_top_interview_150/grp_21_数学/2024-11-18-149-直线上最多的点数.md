---
title: 149. 直线上最多的点数
date: 2024-11-18 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数学]
tags: [数学]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235603890.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个数组 `points`，其中 `points[i] = [xi, yi]` 表示 **X-Y** 平面上的一个点。求最多有多少个点在同一条直线上。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg)

- **输入:** `points = [[1,1],[2,2],[3,3]]`
- **输出:** 3

**示例 2:**

![示例2图片](https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg)

- **输入:** `points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`
- **输出:** 4

**提示:**

- `1 <= points.length <= 300`
- `points[i].length == 2`
- `-10^4 <= xi, yi <= 10^4`
- `points` 中的所有点 **互不相同**

## 题解

### 解法：枚举 + 哈希表 + 最大公约数 (Enumeration + HashMap + GCD)

**思路：**

这是一道经典的计算几何题目。我们需要找到同一条直线上的最大点数。

两点确定一条直线。如果第三个点也在直线上，那么它与前两个点中任意一点连线的**斜率**必然相同。

**算法核心逻辑：**

我们可以遍历每一个点 $P_i$ 作为**基准点（Anchor Point）**，然后计算它与其他所有点 $P_j (j > i)$ 的斜率。

如果 $P_i$ 与 $P_j$ 的斜率等于 $P_i$ 与 $P_k$ 的斜率，那么 $P_i, P_j, P_k$ 三点共线。

1.  **双重循环**：

    - 外层循环枚举基准点 `points[i]`。
    - 内层循环枚举后续的点 `points[j]`。

2.  **计算斜率**：

    - 直接使用浮点数 `double slope = (y2-y1)/(x2-x1)` 计算斜率可能会遇到精度问题（例如 `1.0/3.0`）。
    - 为了保证准确性，我们使用**分数**来表示斜率。即保存 $\Delta y$ 和 $\Delta x$ 的最简形式。
    - 我们通过计算 `gcd(dy, dx)` （最大公约数）将 `dy` 和 `dx` 约分到最简。例如 `(4, 2)` 约分为 `(2, 1)`。

3.  **哈希表计数**：

    - 使用 `HashMap`，Key 为斜率的唯一标识（例如字符串 `"dy/dx"` 或一个特制的 `long` 值），Value 为该斜率出现的次数。
    - 对于每个基准点 `i`，统计所有 `j` 产生的斜率，找出出现次数最多的那个斜率，加上基准点自身（+1），即为经过点 `i` 的直线上最多的点数。

4.  **特殊情况处理**：

    - **垂直线**：$\Delta x = 0$。
    - **水平线**：$\Delta y = 0$。
    - 通过 GCD 约分后，垂直线通常变为 `(1, 0)`，水平线变为 `(0, 1)`，可以统一处理，无需特殊 if-else。
    - **符号规范化**：为了确保 `(1, -1)` 和 `(-1, 1)` 被视为相同的斜率，我们在约分后，可以规定 `dx` 必须为非负数；如果 `dx` 为 0，则 `dy` 必须为正数。

**复杂度分析：**

- **时间复杂度：** $O(N^2 \cdot \log M)$，其中 $N$ 是点的数量，$\log M$ 是计算 GCD 的开销（$M$ 为坐标差值的最大值）。因为 $N \le 300$，这个复杂度完全可以接受。
- **空间复杂度：** $O(N)$，哈希表最多存储 $N$ 个斜率。

**代码片段：**

```java
public int maxPoints(int[][] points) {
    int n = points.length;
    if (n <= 2) return n;

    int res = 0;
    for (int i = 0; i < n; i++) {
        // 如果剩下的点数加上当前已知的最大值都不超过目前的最优解，可以提前剪枝
        if (res >= n - i || res > n / 2) {
            break;
        }

        Map<String, Integer> map = new HashMap<>();
        for (int j = i + 1; j < n; j++) {
            int x = points[i][0] - points[j][0];
            int y = points[i][1] - points[j][1];

            // 约分
            int gcd = gcd(x, y);
            x /= gcd;
            y /= gcd;

            // 规范化符号，保证斜率唯一性
            // 比如 1/-1 和 -1/1 应该视为同一个斜率
            // 约定 x 总是非负，如果 x 是 0，则 y 总是非负
            if (x < 0) {
                x = -x;
                y = -y;
            } else if (x == 0) {
                y = Math.abs(y);
            }

            String key = x + "_" + y;
            map.put(key, map.getOrDefault(key, 0) + 1);
        }

        // 统计经过当前点 i 的直线上最多的点数
        for (int count : map.values()) {
            res = Math.max(res, count + 1); // +1 是加上基准点 i
        }
    }
    return res;
}

private int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
```

### 完整代码

```java
import java.util.HashMap;
import java.util.Map;

public class Main {

    /**
     * 149. 直线上最多的点数
     */
    public static int maxPoints(int[][] points) {
        int n = points.length;
        // 如果点的数量小于等于 2，直接返回 n，因为两点一线
        if (n <= 2) {
            return n;
        }

        int maxCount = 0;

        // 枚举每一个点作为基准点
        for (int i = 0; i < n; i++) {
            // 优化：如果当前已找到的最大点数超过了剩下的点数或者是总数的一半，
            // 那么剩下的点作为基准点不可能产生更多的共线点，可以直接结束。
            // (注：这个优化不是必须的，但能提升效率)
            if (maxCount >= n - i || maxCount > n / 2) {
                break;
            }

            // Key: 斜率的唯一标识 (dy/dx 的字符串表示), Value: 拥有该斜率的点的数量
            Map<String, Integer> slopeMap = new HashMap<>();

            // 枚举 i 之后的所有点 j
            for (int j = i + 1; j < n; j++) {
                int deltaX = points[i][0] - points[j][0];
                int deltaY = points[i][1] - points[j][1];

                // 计算最大公约数进行约分
                int gcdVal = gcd(deltaX, deltaY);
                deltaX /= gcdVal;
                deltaY /= gcdVal;

                // 规范化符号：
                // 我们统一将向量调整到右半平面或正y轴上
                // 1. 如果 x < 0，将向量取反 -> (-x, -y)
                // 2. 如果 x == 0 (垂直线)，确保 y > 0
                if (deltaX < 0) {
                    deltaX = -deltaX;
                    deltaY = -deltaY;
                } else if (deltaX == 0) {
                    deltaY = Math.abs(deltaY);
                }

                // 构造 Key
                String key = deltaX + "_" + deltaY;
                slopeMap.put(key, slopeMap.getOrDefault(key, 0) + 1);
            }

            // 更新全局最大值
            // map 中的 value 是除基准点外的点数，所以计算总数时要 +1 (基准点本身)
            for (int count : slopeMap.values()) {
                maxCount = Math.max(maxCount, count + 1);
            }
        }

        return maxCount;
    }

    // 辅助方法：求最大公约数
    private static int gcd(int a, int b) {
        while (b != 0) {
            int temp = a % b;
            a = b;
            b = temp;
        }
        return a;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[][] points1 = {{1, 1}, {2, 2}, {3, 3}};
        System.out.println("示例 1 输入: [[1,1],[2,2],[3,3]]");
        System.out.println("示例 1 输出: " + maxPoints(points1));
        // 解释: 3个点都在 y=x 上
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[][] points2 = {{1, 1}, {3, 2}, {5, 3}, {4, 1}, {2, 3}, {1, 4}};
        System.out.println("示例 2 输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]");
        System.out.println("示例 2 输出: " + maxPoints(points2));
        // 解释: (4,1), (3,2), (2,3), (1,4) 四点共线
        System.out.println("-----------------------------");

        // --- 特殊测试：垂直线 ---
        int[][] points3 = {{0, 0}, {0, 1}, {0, 2}};
        System.out.println("特殊测试 (垂直线): [[0,0],[0,1],[0,2]]");
        System.out.println("输出: " + maxPoints(points3)); // 预期 3
    }
}
```
