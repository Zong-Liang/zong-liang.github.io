---
title: 172. 阶乘后的零
date: 2024-11-10 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数学]
tags: [数学]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235436909.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个整数 `n`，返回 `n!` 结果中尾随零的数量。

提示：`n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`

**示例 1:**

- **输入:** `n = 3`
- **输出:** 0
- **解释:** `3! = 6`，不含尾随 0。

**示例 2:**

- **输入:** `n = 5`
- **输出:** 1
- **解释:** `5! = 120`，有一个尾随 0。

**示例 3:**

- **输入:** `n = 0`
- **输出:** 0

**提示:**

- `0 <= n <= 10^4`

**进阶:** 你可以设计并实现对数时间复杂度的算法来解决此问题吗？

## 题解

### 解法一：遍历计数法 (Iterative Counting)

**思路：**

计算 $n!$ 末尾有多少个零，实际上就是计算 $n!$ 的质因数分解中包含多少个 $10$。
因为 $10 = 2 \times 5$，而质因子 $2$ 的数量远多于 $5$ 的数量（每两个数就有一个偶数），所以末尾零的数量完全取决于质因子 **$5$ 的数量**。

最直观的方法是遍历 $1$ 到 $n$ 的每一个数，计算每个数中包含多少个因子 $5$，并将它们累加起来。

**复杂度分析：**

- **时间复杂度：** $O(n)$，我们需要遍历 $n$ 个数。对于每个数，虽然可能进行多次除以 5 的操作，但总体平均时间复杂度接近线性。
- **空间复杂度：** $O(1)$，只使用了常数个变量。

**代码片段：**

```java
public int trailingZeroesNaive(int n) {
    int count = 0;
    // 遍历每一个数，统计它包含多少个因子 5
    for (int i = 5; i <= n; i += 5) {
        int current = i;
        while (current % 5 == 0) {
            count++;
            current /= 5;
        }
    }
    return count;
}
```

### 解法二：数学归纳法 / 勒让德定理 (Legendre's Formula) —— 进阶解法

**思路：**

题目要求的进阶解法是 **对数时间复杂度**。我们可以换个角度思考，不用去分解每一个数，而是直接计算 $[1, n]$ 范围内有多少个数能提供因子 $5$。

1.  **第一层**：$n$ 个数中，每 $5$ 个数贡献一个因子 $5$。贡献数量为 $\lfloor \frac{n}{5} \rfloor$。

    - 举例：$5, 10, 15, 20, 25...$

2.  **第二层**：在这些倍数中，每 $25$ ($5 \times 5$) 个数会**额外**再贡献一个因子 $5$。贡献数量为 $\lfloor \frac{n}{25} \rfloor$。

    - 注意：$25$ 在第一层被算了一次，在这里又被算了一次，正好对应 $25 = 5 \times 5$ 的两个因子。

3.  **第三层**：每 $125$ ($5 \times 5 \times 5$) 个数会再贡献一个因子 $5$。贡献数量为 $\lfloor \frac{n}{125} \rfloor$。
4.  以此类推，直到 $5^k > n$。

总公式：$Count = \lfloor \frac{n}{5} \rfloor + \lfloor \frac{n}{25} \rfloor + \lfloor \frac{n}{125} \rfloor + \dots$

算法实现非常简单：每次将 $n$ 除以 $5$，累加商，直到 $n$ 为 $0$。

**复杂度分析：**

- **时间复杂度：** $O(\log_5 n)$，每次循环 $n$ 都会缩小 5 倍，因此循环次数为 $\log_5 n$。
- **空间复杂度：** $O(1)$，仅使用常数空间。

**代码片段：**

```java
public int trailingZeroes(int n) {
    int count = 0;
    while (n > 0) {
        n /= 5;
        count += n;
    }
    return count;
}
```

### 完整代码

```java
public class Main {

    // --- 解法一：遍历计数 (O(n)) ---
    public static int trailingZeroesNaive(int n) {
        int count = 0;
        // 只需要检查 5 的倍数
        for (int i = 5; i <= n; i += 5) {
            int current = i;
            while (current % 5 == 0) {
                count++;
                current /= 5;
            }
        }
        return count;
    }

    // --- 解法二：数学优化 (O(log n)) ---
    public static int trailingZeroes(int n) {
        int count = 0;
        // 不断除以 5，累加商
        // 例如 n = 26
        // 第一次: 26 / 5 = 5 (有 5, 10, 15, 20, 25 这5个数贡献了至少一个5)
        // 第二次: 5 / 5 = 1  (有 25 这1个数额外贡献了一个5)
        // 第三次: 1 / 5 = 0  (结束)
        // 总计: 5 + 1 = 6
        while (n > 0) {
            n /= 5;
            count += n;
        }
        return count;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int n1 = 3;
        System.out.println("示例 1 输入: n = " + n1);
        System.out.println("示例 1 输出: " + trailingZeroes(n1));
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int n2 = 5;
        System.out.println("示例 2 输入: n = " + n2);
        System.out.println("示例 2 输出: " + trailingZeroes(n2));
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        int n3 = 0;
        System.out.println("示例 3 输入: n = " + n3);
        System.out.println("示例 3 输出: " + trailingZeroes(n3));
        System.out.println("-----------------------------");

        // --- 额外测试：较大数字 ---
        int n4 = 125;
        // 期望：125/5 = 25; 25/5 = 5; 5/5 = 1; Total = 31
        System.out.println("额外测试 输入: n = " + n4);
        System.out.println("Naive 解法: " + trailingZeroesNaive(n4));
        System.out.println("优化 解法:  " + trailingZeroes(n4));
    }
}
```
