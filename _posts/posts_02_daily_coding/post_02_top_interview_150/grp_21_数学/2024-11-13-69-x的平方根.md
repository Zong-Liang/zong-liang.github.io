---
title: 69. x的平方根
date: 2024-11-13 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 数学]
tags: [数学]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121235500903.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个非负整数 `x`，计算并返回 `x` 的 **算术平方根**。

由于返回类型是整数，结果只保留 **整数部分**，小数部分将被 **舍去**。

**注意：** 不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5`。

**示例 1:**

- **输入:** `x = 4`
- **输出:** 2

**示例 2:**

- **输入:** `x = 8`
- **输出:** 2
- **解释:** 8 的算术平方根是 2.82842...，由于返回类型是整数，小数部分将被舍去。

**提示:**

- `0 <= x <= 2^31 - 1`

## 题解

### 解法一：二分查找 (Binary Search)

**思路：**

由于 $x$ 是非负整数，其平方根必然在 $[0, x]$ 的范围内。且平方函数 $y = k^2$ 在 $k \ge 0$ 时是单调递增的。这满足了二分查找的单调性条件。

我们的目标是找到一个整数 $k$，使得 $k^2 \le x$，且 $(k+1)^2 > x$。这等价于在有序区间内查找最后一个满足“平方小于等于 $x$”的数。

1.  **初始化**：

    - `left = 0`
    - `right = x`

2.  **二分过程**：

    - 取中间值 `mid`。
    - 计算 `mid` 的平方。**注意**：`mid * mid` 可能会超过 `int` 的范围，因此需要将其转换为 `long` 类型进行计算，或者使用除法 `mid <= x / mid` 来避免溢出。
    - 如果 $mid^2 \le x$，说明 `mid` 可能是答案，或者答案在 `mid` 的右边。我们记下 `ans = mid`，并将左边界右移 `left = mid + 1`。
    - 如果 $mid^2 > x$，说明 `mid` 太大了，答案肯定在 `mid` 的左边。我们将右边界左移 `right = mid - 1`。

3.  **返回结果**：

    - 循环结束后的 `ans` (或者 `right`) 即为结果。

**复杂度分析：**

- **时间复杂度：** $O(\log x)$，利用二分查找，每次将搜索范围减半。
- **空间复杂度：** $O(1)$，仅使用常数级变量。

**代码片段：**

```java
public int mySqrt(int x) {
    int left = 0;
    int right = x;
    int ans = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        // 使用 long 防止乘法溢出
        if ((long) mid * mid <= x) {
            ans = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return ans;
}
```

### 解法二：牛顿迭代法 (Newton's Method)

**思路：**

这是一个数学方法，用于快速求解方程的近似根。

求解 $\sqrt{x}$ 实际上是求解方程 $f(k) = k^2 - x = 0$ 的正根。

根据牛顿迭代公式 $x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}$，代入得：

$$k_{n+1} = \frac{1}{2}(k_n + \frac{x}{k_n})$$

我们选取一个初始值（例如 $x$），不断迭代上述公式，直到 $k_{n+1}$ 和 $k_n$ 非常接近（即收敛），取整数部分即可。

**复杂度分析：**

- **时间复杂度：** $O(\log x)$，牛顿迭代法具有二次收敛性，速度非常快。
- **空间复杂度：** $O(1)$。

**代码片段：**

```java
public int mySqrtNewton(int x) {
    if (x == 0) return 0;
    long k = x;
    while (k * k > x) {
        k = (k + x / k) / 2;
    }
    return (int) k;
}
```

### 完整代码

```java
public class Main {

    /**
     * 69. x 的平方根 - 二分查找法
     */
    public static int mySqrt(int x) {
        int left = 0;
        int right = x;
        int ans = -1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            // 关键点：使用 long 避免 (mid * mid) 溢出 int 范围
            // 或者使用 if (mid <= x / mid) 来判断
            if ((long) mid * mid <= x) {
                ans = mid;      // mid 是潜在的答案，记录下来
                left = mid + 1; // 尝试寻找更大的答案
            } else {
                right = mid - 1; // mid 太大了
            }
        }
        return ans;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int x1 = 4;
        System.out.println("示例 1 输入: x = " + x1);
        System.out.println("示例 1 输出: " + mySqrt(x1));
        // 解释: 2 * 2 = 4
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int x2 = 8;
        System.out.println("示例 2 输入: x = " + x2);
        System.out.println("示例 2 输出: " + mySqrt(x2));
        // 解释: 2 * 2 = 4 < 8, 3 * 3 = 9 > 8, 所以结果是 2
        System.out.println("-----------------------------");

        // --- 边界测试 ---
        int x3 = 0;
        System.out.println("示例 3 (边界 0) 输入: x = " + x3);
        System.out.println("示例 3 输出: " + mySqrt(x3));

        int x4 = 1;
        System.out.println("示例 4 (边界 1) 输入: x = " + x4);
        System.out.println("示例 4 输出: " + mySqrt(x4));

        int x5 = 2147395600; // 接近 Integer.MAX_VALUE 的大数
        System.out.println("示例 5 (大数) 输入: x = " + x5);
        System.out.println("示例 5 输出: " + mySqrt(x5));
        // 46340 * 46340 = 2147395600
    }
}
```
