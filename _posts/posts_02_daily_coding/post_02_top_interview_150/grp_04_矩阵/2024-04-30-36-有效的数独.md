---
title: 36. 有效的数独
date: 2024-04-30 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 矩阵]
tags: [矩阵]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121224717757.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

请你判断一个 `9 x 9` 的数独是否有效。只需要 **根据以下规则** ，验证已经填入的数字是否有效即可。

1.  数字 `1-9` 在每一行只能出现一次。
2.  数字 `1-9` 在每一列只能出现一次。
3.  数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。(请参考示例图)

**注意：**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 空白格用 `'.'` 表示。

**示例 1:**

- **输入:** `board` (一个有效的 9x9 数独板)
- **输出:** `true`

**示例 2:**

- **输入:** `board` (一个无效的 9x9 数独板，左上角 3x3 宫内有两个 8)
- **输出:** `false`

**提示：**

- `board.length == 9`
- `board[i].length == 9`
- `board[i][j]` 是一位数字（`1-9`）或者 `.`

## 题解

### 解法：一次遍历 + 哈希表（或辅助数组）

**思路：**

我们要验证数独的有效性，实际上就是检查数字 `1-9` 是否在三个维度上出现了重复：

1.  **行**：每一行中没有重复数字。
2.  **列**：每一列中没有重复数字。
3.  **3x3 宫**：每一个子宫内没有重复数字。

由于数独大小固定为 `9x9`，我们可以使用三个二维数组（或哈希表数组）来记录状态：

- `rows[i][num]`：表示第 `i` 行是否出现过数字 `num`。
- `cols[j][num]`：表示第 `j` 列是否出现过数字 `num`。
- `boxes[k][num]`：表示第 `k` 个子宫是否出现过数字 `num`。

**关键点：如何计算子宫的索引 `k`？**
对于坐标 `(i, j)`，它所处的子宫索引为 `(i / 3) * 3 + j / 3`。
例如：`(0, 0)` -> `0`，`(0, 3)` -> `1`，`(3, 0)` -> `3`。

**算法流程：**

1.  初始化三个 `9x9` 的布尔数组（或整型数组）。
2.  遍历数独的每一个格子 `(i, j)`。
3.  如果格子是 `'.'`，跳过。
4.  如果格子是数字，计算其对应的数值索引 `index`（`'1'` 对应 `0` ... `'9'` 对应 `8`）和子宫索引 `boxIndex`。
5.  检查该数字在当前行、当前列、当前子宫是否已经标记为 `true`。

    - 如果是，说明重复，返回 `false`。
    - 如果否，将对应的三个位置标记为 `true`。

6.  遍历结束如果没有发现冲突，返回 `true`。

**复杂度分析：**

- **时间复杂度：** $O(1)$。因为数独的大小固定为 $9 \times 9$，我们只对这 81 个格子进行常数次操作。如果视为 $N \times N$ 的板，则为 $O(N^2)$。
- **空间复杂度：** $O(1)$。我们需要常数大小的空间（$3 \times 9 \times 9$ 个布尔值）来存储状态。

**代码片段：**

```java
public boolean isValidSudoku(char[][] board) {
    // 记录某行、某列、某宫中，数字 0-8 (对应 1-9) 是否出现过
    boolean[][] rows = new boolean[9][9];
    boolean[][] cols = new boolean[9][9];
    boolean[][] boxes = new boolean[9][9];

    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (board[i][j] != '.') {
                int num = board[i][j] - '1'; // 将字符 '1'-'9' 映射为索引 0-8
                int boxIndex = (i / 3) * 3 + j / 3; // 计算宫格索引

                // 检查是否重复
                if (rows[i][num] || cols[j][num] || boxes[boxIndex][num]) {
                    return false;
                }

                // 标记状态
                rows[i][num] = true;
                cols[j][num] = true;
                boxes[boxIndex][num] = true;
            }
        }
    }
    return true;
}
```

### 完整代码

```java
public class Main {

    // 核心算法实现
    public static boolean isValidSudoku(char[][] board) {
        // rows[i][x] 表示第 i 行是否出现过数字 x+1
        boolean[][] rows = new boolean[9][9];
        // cols[j][x] 表示第 j 列是否出现过数字 x+1
        boolean[][] cols = new boolean[9][9];
        // boxes[k][x] 表示第 k 个 3x3 宫内是否出现过数字 x+1
        boolean[][] boxes = new boolean[9][9];

        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                // 跳过空格
                if (c == '.') {
                    continue;
                }

                int num = c - '1'; // 映射 '1'->0, '2'->1 ...

                // 计算 3x3 宫的索引 (0~8)
                int boxIndex = (i / 3) * 3 + j / 3;

                // 如果任何一个维度已经存在该数字，则无效
                if (rows[i][num] || cols[j][num] || boxes[boxIndex][num]) {
                    return false;
                }

                // 标记出现过的数字
                rows[i][num] = true;
                cols[j][num] = true;
                boxes[boxIndex][num] = true;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        // --- 示例 1: 有效的数独 ---
        char[][] board1 = {
            {'5','3','.','.','7','.','.','.','.'},
            {'6','.','.','1','9','5','.','.','.'},
            {'.','9','8','.','.','.','.','6','.'},
            {'8','.','.','.','6','.','.','.','3'},
            {'4','.','.','8','.','3','.','.','1'},
            {'7','.','.','.','2','.','.','.','6'},
            {'.','6','.','.','.','.','2','8','.'},
            {'.','.','.','4','1','9','.','.','5'},
            {'.','.','.','.','8','.','.','7','9'}
        };

        System.out.println("示例 1 输出: " + isValidSudoku(board1)); // 预期: true
        System.out.println("-----------------------------");

        // --- 示例 2: 无效的数独 ---
        // 第一行的第一个和第二个宫格内都有 '8'，或者同一行有重复
        // 这里构造一个简单的无效案例：第一行有两个 '5'
        char[][] board2 = {
            {'5','3','.','.','7','.','.','.','5'}, // 注意：最后一个变成了 5
            {'6','.','.','1','9','5','.','.','.'},
            {'.','9','8','.','.','.','.','6','.'},
            {'8','.','.','.','6','.','.','.','3'},
            {'4','.','.','8','.','3','.','.','1'},
            {'7','.','.','.','2','.','.','.','6'},
            {'.','6','.','.','.','.','2','8','.'},
            {'.','.','.','4','1','9','.','.','5'},
            {'.','.','.','.','8','.','.','7','9'}
        };

        System.out.println("示例 2 输出: " + isValidSudoku(board2)); // 预期: false
    }
}
```
