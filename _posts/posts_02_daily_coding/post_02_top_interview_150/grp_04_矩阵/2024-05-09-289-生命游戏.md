---
title: 289. 生命游戏
date: 2024-05-09 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 矩阵]
tags: [矩阵]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121225003491.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

根据 [百度百科](https://baike.baidu.com/item/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/2916262)，**生命游戏** ，简称为 **生命** ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。

给定一个包含 `m x n` 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： `1` 即为 **活细胞** (live)，或 `0` 即为 **死细胞** (dead)。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：

1.  如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
2.  如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
3.  如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
4.  如果死细胞周围正好有三个活细胞，则该位置死细胞复活；

下一个状态是通过将上述规则 **同时** 应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是 **同时** 发生的。给你 `m x n` 网格面板 `board` 的当前状态，请你 **原地** 更新 `board` 到下一个状态。

**注意** 你不需要返回任何东西。

**示例 1:**

- **输入:** `board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]`
- **输出:** `[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]`

**示例 2:**

- **输入:** `board = [[1,1],[1,0]]`
- **输出:** `[[1,1],[1,1]]`

**提示:**

- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 25`
- `board[i][j]` 为 `0` 或 `1`

**进阶:**

- 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。

## 题解

### 解法一：复制数组法（标准解法）

**思路：**

题目要求细胞的状态更新是**同时**进行的。这意味着在更新位置 `(i, j)` 的时候，需要参考周围邻居的**原始状态**，而不是已经更新过的状态。

如果我们直接在原数组上修改，那么修改后的 `(i, j)` 可能会影响计算 `(i, j+1)` 时的邻居数量，导致结果错误。因此，最直观的方法是创建一个大小相同的复制数组 `copyBoard`。

1.  将 `board` 的内容完整复制到 `copyBoard` 中。
2.  遍历 `board` 的每一个格子：

    - 统计该格子在 `copyBoard` 中周围 8 个邻居的活细胞数量。
    - 根据题目给出的 4 条规则，计算该格子的新状态，并直接修改 `board`。

**复杂度分析：**

- **时间复杂度：** $O(m \times n)$，其中 $m$ 和 $n$ 分别是面板的行数和列数。我们需要遍历整个面板。
- **空间复杂度：** $O(m \times n)$，需要创建一个额外的数组来保存面板的原始状态。

**代码片段：**

```java
public void gameOfLife(int[][] board) {
    int m = board.length;
    int n = board[0].length;
    // 1. 复制原数组
    int[][] copyBoard = new int[m][n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            copyBoard[i][j] = board[i][j];
        }
    }

    // 2. 遍历每个细胞，根据 copyBoard 计算新状态并更新 board
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            // 计算邻居数量
            int liveNeighbors = 0;
            // 遍历周围 8 个方向
            for (int x = -1; x <= 1; x++) {
                for (int y = -1; y <= 1; y++) {
                    if (x == 0 && y == 0) continue; // 跳过自己
                    int r = i + x;
                    int c = j + y;
                    // 检查边界
                    if (r >= 0 && r < m && c >= 0 && c < n && copyBoard[r][c] == 1) {
                        liveNeighbors++;
                    }
                }
            }

            // 应用规则
            if (copyBoard[i][j] == 1) {
                // 规则 1 & 3: 活细胞死亡
                if (liveNeighbors < 2 || liveNeighbors > 3) {
                    board[i][j] = 0;
                }
                // 规则 2: 活细胞存活 (无需操作，board 默认为 1)
            } else {
                // 规则 4: 死细胞复活
                if (liveNeighbors == 3) {
                    board[i][j] = 1;
                }
            }
        }
    }
}
```

### 解法二：原地状态机法（进阶解法）

**思路：**

题目进阶要求使用原地算法（$O(1)$ 空间）。问题的核心在于：**如何在一个格子中同时存储“当前状态”和“下一状态”**，以便在更新后续格子时，依然能读取到当前格子的旧状态。

我们可以利用额外的状态值或位运算来解决。因为输入的细胞状态只有 0 和 1，我们可以引入新的状态码：

- **状态 0**：死细胞转为死细胞（0 -> 0）
- **状态 1**：活细胞转为死细胞（1 -> 0）
- **状态 2**：死细胞转为活细胞（0 -> 1）
- **状态 3**：活细胞转为活细胞（1 -> 1）

**技巧：**

我们可以使用二进制位来理解：**最低位表示当前状态，倒数第二位表示下一状态**。

- `00` (0)：当前死，下一次死
- `01` (1)：当前活，下一次死
- `10` (2)：当前死，下一次活
- `11` (3)：当前活，下一次活

**步骤：**

1.  **第一次遍历**：计算每个细胞的周围邻居数。

    - 注意：在统计邻居时，我们只关心**当前状态**（最低位）。因此使用 `board[r][c] & 1` 来获取该细胞现在的死活。
    - 根据规则判断**下一状态**。如果下一状态是活（1），则将该位置的值设为对应的复合状态（例如：原本是 0 变为 1，设为 2；原本是 1 变为 1，设为 3）。

2.  **第二次遍历**：将所有格子的状态右移一位 `board[i][j] >> 1`，得到最终状态。

**复杂度分析：**

- **时间复杂度：** $O(m \times n)$，遍历矩阵两次。
- **空间复杂度：** $O(1)$，直接在原数组上修改，不使用额外空间。

**代码片段：**

```java
public void gameOfLife(int[][] board) {
    int m = board.length;
    int n = board[0].length;

    // 方向数组
    int[] neighbors = {0, 1, -1};

    // 1. 遍历面板，计算下一状态并记录复合状态
    for (int row = 0; row < m; row++) {
        for (int col = 0; col < n; col++) {
            int liveNeighbors = 0;

            // 统计 8 个邻居
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    if (!(neighbors[i] == 0 && neighbors[j] == 0)) {
                        int r = row + neighbors[i];
                        int c = col + neighbors[j];

                        // 检查边界，并查看邻居的最低位（当前状态）
                        if (r >= 0 && r < m && c >= 0 && c < n && (board[r][c] & 1) == 1) {
                            liveNeighbors++;
                        }
                    }
                }
            }

            // 规则处理
            // 只需要处理下一状态变成 1 的情况（因为默认位运算操作后高位是 0）
            // 状态 1 (01) -> 状态 3 (11): 活细胞继续存活
            if ((board[row][col] == 1) && (liveNeighbors == 2 || liveNeighbors == 3)) {
                board[row][col] = 3;
            }
            // 状态 0 (00) -> 状态 2 (10): 死细胞复活
            if ((board[row][col] == 0) && (liveNeighbors == 3)) {
                board[row][col] = 2;
            }
        }
    }

    // 2. 第二次遍历，通过右移操作更新为最终状态
    for (int row = 0; row < m; row++) {
        for (int col = 0; col < n; col++) {
            board[row][col] >>= 1; // 11->1, 10->1, 01->0, 00->0
        }
    }
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现（进阶解法：O(1) 空间）
    public static void gameOfLife(int[][] board) {
        int m = board.length;
        int n = board[0].length;

        // 遍历每个格子，计算周围存活细胞数，并用位标记新状态
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int liveNeighbors = countLiveNeighbors(board, i, j, m, n);

                // 规则 1: 活细胞 -> 死 (默认不需要处理，只要不标记为活即可)
                // 规则 2: 活细胞 -> 活 (周围有 2 或 3 个活邻居)
                if ((board[i][j] & 1) == 1) {
                    if (liveNeighbors == 2 || liveNeighbors == 3) {
                        // 标记为 3 (二进制 11)，表示当前是 1，下次也是 1
                        board[i][j] = 3;
                    }
                    // 否则保持为 1 (二进制 01)，表示当前是 1，下次是 0（规则 1 和 3）
                } else {
                    // 规则 4: 死细胞 -> 活 (周围有 3 个活邻居)
                    if (liveNeighbors == 3) {
                        // 标记为 2 (二进制 10)，表示当前是 0，下次是 1
                        board[i][j] = 2;
                    }
                }
            }
        }

        // 更新整个面板状态
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 右移一位，获取下一状态
                board[i][j] >>= 1;
            }
        }
    }

    // 辅助函数：统计周围活细胞数量（基于当前状态即最低位）
    private static int countLiveNeighbors(int[][] board, int row, int col, int m, int n) {
        int count = 0;
        // 遍历周围 8 个方向
        for (int i = row - 1; i <= row + 1; i++) {
            for (int j = col - 1; j <= col + 1; j++) {
                // 跳过自己
                if (i == row && j == col) continue;

                // 边界检查
                if (i >= 0 && i < m && j >= 0 && j < n) {
                    // 只看最低位，判断当前是否是活细胞
                    if ((board[i][j] & 1) == 1) {
                        count++;
                    }
                }
            }
        }
        return count;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[][] board1 = {
            {0, 1, 0},
            {0, 0, 1},
            {1, 1, 1},
            {0, 0, 0}
        };

        System.out.println("示例 1 输入:");
        printMatrix(board1);

        gameOfLife(board1);

        System.out.println("示例 1 输出:");
        printMatrix(board1);
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[][] board2 = {
            {1, 1},
            {1, 0}
        };

        System.out.println("示例 2 输入:");
        printMatrix(board2);

        gameOfLife(board2);

        System.out.println("示例 2 输出:");
        printMatrix(board2);
    }

    // 辅助函数：打印矩阵
    private static void printMatrix(int[][] matrix) {
        System.out.println("[");
        for (int[] row : matrix) {
            System.out.println("  " + Arrays.toString(row));
        }
        System.out.println("]");
    }
}
```
