---
title: 48. 旋转图像
date: 2024-05-04 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 矩阵]
tags: [矩阵]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121224834821.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：48. 旋转图像

**描述：**

给定一个 _n_ × _n_ 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 **原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

**示例 1:**

- **输入:** `matrix = [[1,2,3],[4,5,6],[7,8,9]]`
- **输出:** `[[7,4,1],[8,5,2],[9,6,3]]`

**示例 2:**

- **输入:** `matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]`
- **输出:** `[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]`

**提示:**

- `n == matrix.length == matrix[i].length`
- `1 <= n <= 20`
- `-1000 <= matrix[i][j] <= 1000`

## 题解

### 解法：数学代数法（转置 + 翻转）

**思路：**

要在**原地**旋转图像，直接模拟旋转轨迹（四个位置循环交换）虽然可行，但下标计算较为复杂，容易出错。

利用线性代数的性质，我们可以将顺时针旋转 90 度分解为两个简单的步骤：

1.  **转置矩阵**：将矩阵的行列互换。即 `matrix[i][j]` 与 `matrix[j][i]` 互换。
2.  **水平翻转**：将每一行的元素进行左右翻转。即 `matrix[i][j]` 与 `matrix[i][n-1-j]` 互换。

**图示：**

```
原始矩阵：
1 2 3
4 5 6
7 8 9

步骤 1：转置（沿主对角线对称交换）
1 4 7
2 5 8
3 6 9

步骤 2：水平翻转（每一行左右逆序）
7 4 1
8 5 2
9 6 3  <-- 结果即为顺时针旋转 90 度
```

**复杂度分析：**

- **时间复杂度：** $O(N^2)$，其中 $N$ 是矩阵的边长。转置需要遍历约 $N^2/2$ 次，翻转需要遍历约 $N^2/2$ 次，总操作次数与矩阵元素个数成正比。
- **空间复杂度：** $O(1)$，在原矩阵上修改，只需要常数级别的临时变量。

**代码片段：**

```java
public void rotate(int[][] matrix) {
    int n = matrix.length;

    // 1. 转置矩阵
    for (int i = 0; i < n; i++) {
        // 注意 j 从 i 开始，否则会重复交换变回原样
        for (int j = i; j < n; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }

    // 2. 翻转每一行
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n / 2; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[i][n - 1 - j];
            matrix[i][n - 1 - j] = temp;
        }
    }
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现：转置 + 翻转
    public static void rotate(int[][] matrix) {
        int n = matrix.length;

        // Step 1: 转置 (Transpose)
        // 将 matrix[i][j] 与 matrix[j][i] 交换
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }

        // Step 2: 水平翻转 (Reflect)
        // 将每一行左右倒序
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n / 2; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][n - 1 - j];
                matrix[i][n - 1 - j] = temp;
            }
        }
    }

    // 辅助方法：打印矩阵
    public static void printMatrix(int[][] matrix) {
        System.out.println("[");
        for (int[] row : matrix) {
            System.out.println("  " + Arrays.toString(row));
        }
        System.out.println("]");
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[][] matrix1 = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };

        System.out.println("示例 1 输入:");
        printMatrix(matrix1);

        rotate(matrix1);

        System.out.println("示例 1 输出:");
        printMatrix(matrix1);
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[][] matrix2 = {
            {5, 1, 9, 11},
            {2, 4, 8, 10},
            {13, 3, 6, 7},
            {15, 14, 12, 16}
        };

        System.out.println("示例 2 输入:");
        printMatrix(matrix2);

        rotate(matrix2);

        System.out.println("示例 2 输出:");
        printMatrix(matrix2);
    }
}
```
