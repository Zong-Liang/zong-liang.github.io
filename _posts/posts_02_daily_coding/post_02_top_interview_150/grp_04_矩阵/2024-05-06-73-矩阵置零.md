---
title: 73. 矩阵置零
date: 2024-05-06 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 矩阵]
tags: [矩阵]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121224930993.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：73. 矩阵置零

**描述：**

给定一个 `m x n` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **原地** 算法。

**示例 1:**

- **输入:** `matrix = [[1,1,1],[1,0,1],[1,1,1]]`
- **输出:** `[[1,0,1],[0,0,0],[1,0,1]]`

**示例 2:**

- **输入:** `matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]`
- **输出:** `[[0,0,0,0],[0,4,5,0],[0,3,1,0]]`

**提示:**

- `m == matrix.length`
- `n == matrix[0].length`
- `1 <= m, n <= 200`
- `-2^31 <= matrix[i][j] <= 2^31 - 1`

**进阶:**

- 一个直观的解决方案是使用 `O(mn)` 的额外空间，但这并不是一个好的解决方案。
- 一个简单的改进方案是使用 `O(m + n)` 的额外空间，但这仍然不是最好的解决方案。
- 你能想出一个仅使用常量空间的解决方案吗？

## 题解

### 解法一：标记数组法（$O(m+n)$ 空间）

**思路：**

最直观的方法是使用两个辅助数组来记录哪些行和哪些列需要被置零。

1.  创建两个布尔数组 `rowFlags` 和 `colFlags`，长度分别等于矩阵的行数和列数。
2.  遍历整个矩阵：

    - 如果 `matrix[i][j] == 0`，则将 `rowFlags[i]` 和 `colFlags[j]` 设为 `true`。

3.  再次遍历整个矩阵：

    - 如果 `rowFlags[i]` 或 `colFlags[j]` 为 `true`，则将 `matrix[i][j]` 设为 `0`。

**复杂度分析：**

- **时间复杂度：** $O(mn)$，其中 $m$ 是行数，$n$ 是列数。我们需要遍历矩阵两次。
- **空间复杂度：** $O(m + n)$，需要额外的两个数组来存储标记。

**代码片段：**

```java
public void setZeroes(int[][] matrix) {
    int m = matrix.length;
    int n = matrix[0].length;
    boolean[] rowFlags = new boolean[m];
    boolean[] colFlags = new boolean[n];

    // 1. 扫描矩阵，标记需要置零的行和列
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (matrix[i][j] == 0) {
                rowFlags[i] = true;
                colFlags[j] = true;
            }
        }
    }

    // 2. 根据标记置零
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (rowFlags[i] || colFlags[j]) {
                matrix[i][j] = 0;
            }
        }
    }
}
```

### 解法二：利用首行首列标记（$O(1)$ 空间）

**思路：**

题目要求使用 $O(1)$ 的空间，我们可以利用矩阵本身的**第一行**和**第一列**来代替上述解法中的辅助数组。

但是，直接使用第一行和第一列会有一个冲突问题：`matrix[0][0]` 既属于第一行也属于第一列。如果它变成了 0，我们不知道是因为第一行本来有 0，还是第一列本来有 0。

为了解决这个问题，我们需要额外定义两个变量单独记录第一行和第一列的初始状态。

**具体步骤：**

1.  定义两个变量 `firstRowHasZero` 和 `firstColHasZero`，分别记录第一行和第一列是否原本包含 0。
2.  遍历矩阵的其他部分（下标从 1 开始），如果 `matrix[i][j] == 0`，则将对应的首行位置 `matrix[i][0]` 和首列位置 `matrix[0][j]` 置为 0。
3.  再次遍历矩阵的其他部分（下标从 1 开始），如果对应的首行或首列位置为 0，则将当前元素 `matrix[i][j]` 置为 0。
4.  最后，根据 `firstRowHasZero` 和 `firstColHasZero` 的状态，决定是否将第一行和第一列全部置零。

**复杂度分析：**

- **时间复杂度：** $O(mn)$，遍历矩阵两次。
- **空间复杂度：** $O(1)$，只使用了两个布尔变量，利用矩阵原地存储标记。

**代码片段：**

```java
public void setZeroes(int[][] matrix) {
    int m = matrix.length;
    int n = matrix[0].length;
    boolean firstRowHasZero = false;
    boolean firstColHasZero = false;

    // 1. 检查第一行是否有 0
    for (int j = 0; j < n; j++) {
        if (matrix[0][j] == 0) {
            firstRowHasZero = true;
            break;
        }
    }

    // 2. 检查第一列是否有 0
    for (int i = 0; i < m; i++) {
        if (matrix[i][0] == 0) {
            firstColHasZero = true;
            break;
        }
    }

    // 3. 使用第一行和第一列作为标记位
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (matrix[i][j] == 0) {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }

    // 4. 根据标记位将内部元素置零
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                matrix[i][j] = 0;
            }
        }
    }

    // 5. 处理第一行和第一列
    if (firstRowHasZero) {
        for (int j = 0; j < n; j++) {
            matrix[0][j] = 0;
        }
    }
    if (firstColHasZero) {
        for (int i = 0; i < m; i++) {
            matrix[i][0] = 0;
        }
    }
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现（进阶解法：O(1) 空间）
    public static void setZeroes(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        boolean firstRowHasZero = false;
        boolean firstColHasZero = false;

        // 1. 判断第一行是否包含 0
        for (int j = 0; j < n; j++) {
            if (matrix[0][j] == 0) {
                firstRowHasZero = true;
                break;
            }
        }

        // 2. 判断第一列是否包含 0
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                firstColHasZero = true;
                break;
            }
        }

        // 3. 遍历其余元素，若为 0，则将对应的首行和首列元素置 0
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }

        // 4. 根据首行首列的标记，将对应的行列置 0
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }

        // 5. 如果第一行原本有 0，将第一行全部置 0
        if (firstRowHasZero) {
            for (int j = 0; j < n; j++) {
                matrix[0][j] = 0;
            }
        }

        // 6. 如果第一列原本有 0，将第一列全部置 0
        if (firstColHasZero) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[][] matrix1 = {
            {1, 1, 1},
            {1, 0, 1},
            {1, 1, 1}
        };

        System.out.println("示例 1 输入:");
        printMatrix(matrix1);

        setZeroes(matrix1);

        System.out.println("示例 1 输出:");
        printMatrix(matrix1);
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[][] matrix2 = {
            {0, 1, 2, 0},
            {3, 4, 5, 2},
            {1, 3, 1, 5}
        };

        System.out.println("示例 2 输入:");
        printMatrix(matrix2);

        setZeroes(matrix2);

        System.out.println("示例 2 输出:");
        printMatrix(matrix2);
    }

    // 辅助函数：打印矩阵
    private static void printMatrix(int[][] matrix) {
        System.out.println("[");
        for (int[] row : matrix) {
            System.out.println("  " + Arrays.toString(row));
        }
        System.out.println("]");
    }
}
```
