---
title: 76. 最小覆盖子串
date: 2024-04-29 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 滑动窗口]
tags: [滑动窗口]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121224629744.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1:**

- **输入:** `s = "ADOBECODEBANC"`, `t = "ABC"`
- **输出:** `"BANC"`
- **解释:** 最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。

**示例 2:**

- **输入:** `s = "a"`, `t = "a"`
- **输出:** `"a"`
- **解释:** 整个字符串 s 是最小覆盖子串。

**示例 3:**

- **输入:** `s = "a"`, `t = "aa"`
- **输出:** `""`
- **解释:** t 中两个字符 'a' 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。

**提示:**

- `m == s.length`
- `n == t.length`
- `1 <= m, n <= 10^5`
- `s` 和 `t` 由英文字母组成

**进阶：** 你能设计一个在 `o(m+n)` 时间内解决此问题的算法吗？

## 题解

### 标准解法：滑动窗口 + 哈希表

**思路：**

本题是滑动窗口的经典应用。我们需要维护一个窗口 `[left, right]`，使其包含 `t` 中所有的字符。

1.  **统计需求**：首先使用一个哈希表 `need` 统计 `t` 中每个字符出现的次数。
2.  **扩张窗口**：移动 `right` 指针，将字符加入当前窗口。同时维护一个 `window` 哈希表记录窗口内字符的频率。
3.  **判断有效性**：定义一个变量 `valid`，表示窗口中满足 `need` 条件的字符个数。当 `window` 中某字符的数量等于 `need` 中该字符的数量时，`valid` 加 1。
4.  **收缩窗口**：当 `valid` 等于 `need` 的大小时（即找到了一个可行解），说明当前窗口已覆盖 `t`。

    - 此时尝试更新最小子串的长度和起始位置。
    - 移动 `left` 指针，将字符移出窗口，并更新 `window` 和 `valid`，直到窗口不再满足条件。

5.  **循环**：重复上述过程直到 `right` 到达字符串末尾。

**复杂度分析：**

- **时间复杂度：** $O(m + n)$。其中 $m$ 是 `s` 的长度，$n$ 是 `t` 的长度。虽然有两层循环，但 `left` 和 `right` 指针都只遍历一次数组。哈希表的操作可视作 $O(1)$。
- **空间复杂度：** $O(C)$。$C$ 为字符集的大小（如英文字母 52 个），需要两个哈希表存储字符频率。

**代码片段：**

```java
public String minWindow(String s, String t) {
    if (s == null || t == null || s.length() == 0 || t.length() == 0) return "";

    Map<Character, Integer> need = new HashMap<>();
    Map<Character, Integer> window = new HashMap<>();

    // 统计 t 中字符频数
    for (char c : t.toCharArray()) {
        need.put(c, need.getOrDefault(c, 0) + 1);
    }

    int left = 0, right = 0;
    int valid = 0; // 记录满足要求的字符个数
    int start = 0, len = Integer.MAX_VALUE; // 记录最小覆盖子串的起始和长度

    while (right < s.length()) {
        char c = s.charAt(right);
        right++; // 扩大窗口

        // 更新窗口数据
        if (need.containsKey(c)) {
            window.put(c, window.getOrDefault(c, 0) + 1);
            if (window.get(c).equals(need.get(c))) {
                valid++;
            }
        }

        // 当窗口满足条件时，尝试收缩
        while (valid == need.size()) {
            if (right - left < len) {
                start = left;
                len = right - left;
            }

            char d = s.charAt(left);
            left++; // 收缩窗口

            if (need.containsKey(d)) {
                if (window.get(d).equals(need.get(d))) {
                    valid--;
                }
                window.put(d, window.get(d) - 1);
            }
        }
    }
    return len == Integer.MAX_VALUE ? "" : s.substring(start, start + len);
}
```

### 进阶解法：滑动窗口 + 数组优化（$O(1)$ 空间常数）

**思路：**

虽然哈希表的逻辑清晰，但在高频操作下，`HashMap` 的自动装箱和哈希计算会有一定的性能开销。考虑到题目提示字符由英文字母组成，我们可以直接使用 **数组** 代替哈希表（类似于 ASCII 码表映射）。

1.  使用一个长度为 128 的整型数组 `need`。
2.  先遍历 `t`，将对应的字符位置 `need[c]++`，表示需要的数量。
3.  遍历 `s` 时：

    - 如果 `need[c] > 0`，说明该字符是 `t` 中需要的，计数器 `count` 加 1。
    - 无论该字符是否在 `t` 中，都将 `need[c]--`。这里巧妙的地方在于：如果 `c` 在 `t` 中，`need` 会从正数减小；如果不在，`need` 会变成负数，表示“多余”或“无关”的字符。

4.  当 `count == t.length()` 时，说明窗口已覆盖所有字符。

    - 尝试更新最小长度。
    - 移动 `left` 指针收缩：将 `need[s[left]]++`。如果增加后 `need[s[left]] > 0`，说明我们移除了一个必须的字符，导致窗口失效，此时 `count--`。

这种方法避免了 `HashMap` 的开销，且逻辑更加紧凑。

**复杂度分析：**

- **时间复杂度：** $O(m + n)$。
- **空间复杂度：** $O(1)$。数组长度固定为 128，不随输入规模变化。

**代码片段：**

```java
public String minWindow(String s, String t) {
    if (s == null || s.length() == 0 || t == null || t.length() == 0) return "";

    int[] need = new int[128];
    // 记录 t 中每个字符需要的数量
    for (char c : t.toCharArray()) {
        need[c]++;
    }

    int left = 0, right = 0;
    int count = 0; // 记录当前窗口中已经匹配到的 t 中的字符数量
    int minLen = Integer.MAX_VALUE;
    int start = 0;

    while (right < s.length()) {
        char c = s.charAt(right);
        // 如果 need[c] > 0，说明 c 是 t 中需要的字符
        if (need[c] > 0) {
            count++;
        }
        // 无论是否需要，都减 1。
        // 如果是需要的字符，变为 0 或更小；如果是不需要的，变为负数。
        need[c]--;
        right++;

        // 当窗口包含 t 所有字符时
        while (count == t.length()) {
            if (right - left < minLen) {
                minLen = right - left;
                start = left;
            }

            char d = s.charAt(left);
            // 恢复 need 数组
            need[d]++;
            // 如果恢复后 need[d] > 0，说明刚才移除的是一个必须的字符
            // 且移除前窗口中该字符数量刚好够用（没有多余的）
            if (need[d] > 0) {
                count--;
            }
            left++;
        }
    }

    return minLen == Integer.MAX_VALUE ? "" : s.substring(start, start + minLen);
}
```

### 完整代码

```java
public class Main {

    // 进阶解法：使用数组优化的滑动窗口
    public static String minWindow(String s, String t) {
        if (s == null || s.length() == 0 || t == null || t.length() == 0) {
            return "";
        }

        // 使用数组代替 Map，128 覆盖了所有标准 ASCII 字符
        int[] need = new int[128];

        // 初始化 t 的字符需求表
        for (char c : t.toCharArray()) {
            need[c]++;
        }

        int left = 0, right = 0;
        int count = 0; // 已经匹配的目标字符总数
        int minLen = Integer.MAX_VALUE;
        int start = 0;
        int tLen = t.length();

        while (right < s.length()) {
            char c = s.charAt(right);

            // 步骤 1：入窗
            // 如果当前字符 c 是 t 需要的（即 need[c] > 0），则匹配数 count + 1
            if (need[c] > 0) {
                count++;
            }
            // 消耗该字符（计数减一），非目标字符会变成负数
            need[c]--;
            right++;

            // 步骤 2：出窗
            // 当匹配数等于 t 的长度时，说明当前窗口合法
            while (count == tLen) {
                // 更新最小子串记录
                if (right - left < minLen) {
                    minLen = right - left;
                    start = left;
                }

                char d = s.charAt(left);
                // 释放该字符（计数加一）
                need[d]++;

                // 如果释放后 need[d] > 0，说明这个字符是必须的，且窗口内已不足
                // 导致窗口不再合法
                if (need[d] > 0) {
                    count--;
                }
                left++;
            }
        }

        return minLen == Integer.MAX_VALUE ? "" : s.substring(start, start + minLen);
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        String s1 = "ADOBECODEBANC";
        String t1 = "ABC";
        System.out.println("示例 1 输入: s = \"" + s1 + "\", t = \"" + t1 + "\"");
        System.out.println("示例 1 输出: \"" + minWindow(s1, t1) + "\"");
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        String s2 = "a";
        String t2 = "a";
        System.out.println("示例 2 输入: s = \"" + s2 + "\", t = \"" + t2 + "\"");
        System.out.println("示例 2 输出: \"" + minWindow(s2, t2) + "\"");
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        String s3 = "a";
        String t3 = "aa";
        System.out.println("示例 3 输入: s = \"" + s3 + "\", t = \"" + t3 + "\"");
        System.out.println("示例 3 输出: \"" + minWindow(s3, t3) + "\"");
    }
}
```
