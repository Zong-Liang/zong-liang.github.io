---
title: 76. 最小覆盖子串
date: 2024-04-29 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 滑动窗口]
tags: [滑动窗口]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121224629744.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


## 题目：76. 最小覆盖子串

**描述**

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1:**

- **输入:** `s = "ADOBECODEBANC"`, `t = "ABC"`
- **输出:** `"BANC"`
- **解释:** 最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。

**示例 2:**

- **输入:** `s = "a"`, `t = "a"`
- **输出:** `"a"`
- **解释:** 整个字符串 s 是最小覆盖子串。

**示例 3:**

- **输入:** `s = "a"`, `t = "aa"`
- **输出:** `""`
- **解释:** t 中两个字符 'a' 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。

**提示:**

- `m == s.length`
- `n == t.length`
- `1 <= m, n <= 10^5`
- `s` 和 `t` 由英文字母组成

**进阶：** 你能设计一个在 `o(m+n)` 时间内解决此问题的算法吗？



## Java 代码

```java
import java.util.HashMap;
import java.util.Map;

public class Main {

    /**
     * 找出 s 中涵盖 t 所有字符的最小子串。
     * 采用滑动窗口算法。
     *
     * @param s 源字符串
     * @param t 目标字符串
     * @return 最小覆盖子串
     */
    public static String minWindow(String s, String t) {
        if (s == null || t == null || s.length() < t.length()) {
            return "";
        }

        // `needs` 哈希表记录 t 中每个字符需要的数量
        Map<Character, Integer> needs = new HashMap<>();
        for (char c : t.toCharArray()) {
            needs.put(c, needs.getOrDefault(c, 0) + 1);
        }

        // `window` 哈希表记录当前窗口内包含 t 中字符的数量
        Map<Character, Integer> window = new HashMap<>();

        int left = 0, right = 0; // 滑动窗口的左右指针
        int valid = 0; // 记录窗口中满足 `needs` 要求的字符种类数

        // 记录最小覆盖子串的起始索引和长度
        int start = 0;
        int minLen = Integer.MAX_VALUE;

        // 移动右指针，扩大窗口
        while (right < s.length()) {
            char c = s.charAt(right);
            right++;

            // 如果当前字符是 t 中需要的字符
            if (needs.containsKey(c)) {
                window.put(c, window.getOrDefault(c, 0) + 1);
                // 如果窗口中该字符的数量刚好满足需要
                if (window.get(c).equals(needs.get(c))) {
                    valid++;
                }
            }

            // 当窗口中的有效字符数等于 t 中所需字符的总类数时，开始收缩窗口
            while (valid == needs.size()) {
                // 更新最小子串
                if (right - left < minLen) {
                    start = left;
                    minLen = right - left;
                }

                // 准备移出窗口最左边的字符
                char d = s.charAt(left);
                left++;

                // 如果移出的字符是 t 中需要的
                if (needs.containsKey(d)) {
                    // 如果移出前，该字符的数量刚好等于所需数量，那么 valid 数需要减 1
                    if (window.get(d).equals(needs.get(d))) {
                        valid--;
                    }
                    // 窗口中该字符数量减 1
                    window.put(d, window.get(d) - 1);
                }
            }
        }

        // 如果 minLen 未被更新过，说明没有找到覆盖子串
        return minLen == Integer.MAX_VALUE ? "" : s.substring(start, start + minLen);
    }

    public static void main(String[] args) {
        // 示例 1
        String s1 = "ADOBECODEBANC";
        String t1 = "ABC";
        System.out.println("输入: s = \"" + s1 + "\", t = \"" + t1 + "\"");
        System.out.println("输出: \"" + minWindow(s1, t1) + "\""); // 预期: "BANC"
        System.out.println("---");

        // 示例 2
        String s2 = "a";
        String t2 = "a";
        System.out.println("输入: s = \"" + s2 + "\", t = \"" + t2 + "\"");
        System.out.println("输出: \"" + minWindow(s2, t2) + "\""); // 预期: "a"
        System.out.println("---");

        // 示例 3
        String s3 = "a";
        String t3 = "aa";
        System.out.println("输入: s = \"" + s3 + "\", t = \"" + t3 + "\"");
        System.out.println("输出: \"" + minWindow(s3, t3) + "\""); // 预期: ""
        System.out.println("---");
    }
}
```
