---
title: 30. 串联所有单词的子串
date: 2024-04-28 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 滑动窗口]
tags: [滑动窗口]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121224543874.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个字符串 `s` 和一个字符串数组 `words` 。`words` 中所有字符串 **长度相同** 。

`s` 中的 **串联子串** 是指一个包含 `words` 中所有字符串以任意顺序排列连接起来的子串。

- 例如，如果 `words = ["ab","cd","ef"]`， 那么 `"abcdef"`， `"abefcd"`，`"cdabef"`， `"cdefab"`，`"efabcd"`， 和 `"efcdab"` 都是串联子串。`"acdbef"` 不是串联子串，因为它不是 `words` 中任何排列的连接。

返回所有串联子串在 `s` 中的开始索引。你可以以 **任意顺序** 返回答案。

**示例 1:**

- **输入:** `s = "barfoothefoobarman"`, `words = ["foo","bar"]`
- **输出:** `[0,9]`
- **解释:**

  因为 `words.length == 2` 同时 `words[i].length == 3`，连接的子字符串的长度必须为 6。

  子串 `"barfoo"` 开始位置是 0。它是 `words` 中以 `["bar","foo"]` 顺序排列的连接。

  子串 `"foobar"` 开始位置是 9。它是 `words` 中以 `["foo","bar"]` 顺序排列的连接。

  输出顺序无关紧要。返回 `[9,0]` 也是可以的。

**示例 2:**

- **输入:** `s = "wordgoodgoodgoodbestword"`, `words = ["word","good","best","word"]`
- **输出:** `[]`

**示例 3:**

- **输入:** `s = "barfoofoobarthefoobarman"`, `words = ["bar","foo","the"]`
- **输出:** `[6,9,12]`

**提示:**

- `1 <= s.length <= 10^4`
- `1 <= words.length <= 5000`
- `1 <= words[i].length <= 30`
- `words[i]` 和 `s` 由小写英文字母组成

## 题解

### 解法：滑动窗口（多起点优化）

**思路：**

这道题是“滑动窗口”类问题的进阶版。普通的滑动窗口通常每次移动一个字符，但本题中所有单词长度固定且相同（假设为 `w`），我们可以将字符串 `s` 看作是由长度为 `w` 的单词块组成的。

如果我们直接每次移动 1 个字符，那么每次都需要重新划分单词，效率较低。

更高效的方法是：**每次移动一个单词的长度 `w`**。

但是，只从下标 0 开始每隔 `w` 取词会遗漏情况（例如单词长度为 3，从下标 1 或 2 开始的子串也可能是解）。

因此，我们需要**分情况遍历**：

1.  从下标 `0` 开始，每次移动 `w`。
2.  从下标 `1` 开始，每次移动 `w`。
3.  ...
4.  从下标 `w-1` 开始，每次移动 `w`。

只要覆盖了这 `w` 种起始位置，就能覆盖所有可能的子串情况。

**具体步骤：**

1.  使用哈希表 `totalMap` 统计 `words` 中每个单词出现的次数。
2.  外层循环 `i` 从 `0` 到 `w-1`，代表不同的起点。
3.  内层循环使用**滑动窗口**：

    - 维护 `left` 和 `right` 指针，以及当前窗口内的单词统计 `currentMap` 和计数器 `count`。
    - `right` 每次向右移动 `w` 长度，截取一个单词 `word`。
    - 如果 `word` 不在 `words` 中：说明当前窗口断了，直接清空 `currentMap`，重置 `count`，并将 `left` 移到 `right` 的位置。
    - 如果 `word` 在 `words` 中：加入 `currentMap`，`count++`。
    - **收缩窗口**：如果 `currentMap` 中该单词的数量超过了 `totalMap` 中的数量，说明窗口包含了多余的该单词，需要不断移动 `left`（每次右移 `w`），并将移出的单词从 `currentMap` 扣除，直到数量恢复正常。
    - **记录结果**：如果 `count` 等于 `words` 数组的长度，说明找到一个合法子串，记录 `left`。

**复杂度分析：**

- **时间复杂度：** $O(n \times w)$，其中 $n$ 是字符串 `s` 的长度，$w$ 是单个单词的长度。外层循环执行 $w$ 次，内层循环 `right` 指针每次移动 $w$，相当于遍历整个字符串的 $1/w$。总得来说每个字符被访问常数次。相比暴力法的 $O(n \times m \times w)$ 有显著提升。
- **空间复杂度：** $O(m \times w)$，其中 $m$ 是单词的数量。哈希表需要存储 `words` 中的所有单词。

**代码片段：**

```java
public List<Integer> findSubstring(String s, String[] words) {
    List<Integer> res = new ArrayList<>();
    if (s == null || s.length() == 0 || words == null || words.length == 0) return res;

    int oneWordLen = words[0].length();
    int wordNum = words.length;
    int allLen = oneWordLen * wordNum;

    // 统计目标单词数量
    Map<String, Integer> totalMap = new HashMap<>();
    for (String word : words) {
        totalMap.put(word, totalMap.getOrDefault(word, 0) + 1);
    }

    // 遍历所有可能的起始偏移量 (0 到 oneWordLen - 1)
    for (int i = 0; i < oneWordLen; i++) {
        int left = i, right = i, count = 0;
        Map<String, Integer> currentMap = new HashMap<>();

        // 开始滑动窗口
        while (right + oneWordLen <= s.length()) {
            // 获取右边的单词
            String w = s.substring(right, right + oneWordLen);
            right += oneWordLen; // 指针右移

            if (!totalMap.containsKey(w)) {
                // 如果遇到不在词表里的词，窗口彻底作废
                currentMap.clear();
                count = 0;
                left = right;
            } else {
                // 单词有效，加入当前统计
                currentMap.put(w, currentMap.getOrDefault(w, 0) + 1);
                count++;

                // 如果当前单词数量超标，需要收缩左边界
                while (currentMap.get(w) > totalMap.get(w)) {
                    String leftWord = s.substring(left, left + oneWordLen);
                    currentMap.put(leftWord, currentMap.get(leftWord) - 1);
                    count--;
                    left += oneWordLen;
                }

                // 如果数量达标，记录结果
                if (count == wordNum) {
                    res.add(left);
                    // 找到一个后，左边需向右移一步以继续寻找下一个可能的匹配
                    // 实际上就是把最左边那个单词移除，腾出位置
                    String leftWord = s.substring(left, left + oneWordLen);
                    currentMap.put(leftWord, currentMap.get(leftWord) - 1);
                    count--;
                    left += oneWordLen;
                }
            }
        }
    }
    return res;
}
```

### 完整代码

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Main {

    // 核心算法实现
    public static List<Integer> findSubstring(String s, String[] words) {
        List<Integer> res = new ArrayList<>();
        // 边界条件判断
        if (s == null || s.length() == 0 || words == null || words.length == 0) {
            return res;
        }

        int oneWordLen = words[0].length();
        int wordNum = words.length;
        // 检查字符串长度是否足够容纳所有单词
        if (s.length() < oneWordLen * wordNum) {
            return res;
        }

        // 1. 构建目标单词的频率 Map
        Map<String, Integer> totalMap = new HashMap<>();
        for (String word : words) {
            totalMap.put(word, totalMap.getOrDefault(word, 0) + 1);
        }

        // 2. 只需要遍历 oneWordLen 次，因为移动步长是 oneWordLen
        // 例如 word 长度为 3，我们只需要从 0, 1, 2 开始滑动，
        // 从 3 开始的情况其实包含在从 0 开始的滑动过程中了。
        for (int i = 0; i < oneWordLen; i++) {
            int left = i;
            int right = i;
            int count = 0; // 记录当前窗口内有效匹配的单词个数
            Map<String, Integer> currentMap = new HashMap<>();

            // 窗口右边界不能超过字符串总长度
            while (right + oneWordLen <= s.length()) {
                // 截取右侧新进来的单词
                String w = s.substring(right, right + oneWordLen);
                right += oneWordLen; // 移动右指针

                // 情况 A: 这个单词压根不在 words 里
                if (!totalMap.containsKey(w)) {
                    // 整个窗口断裂，重置所有状态
                    currentMap.clear();
                    count = 0;
                    left = right; // 左指针直接跳到右指针位置
                }
                // 情况 B: 这个单词是有效的
                else {
                    currentMap.put(w, currentMap.getOrDefault(w, 0) + 1);
                    count++;

                    // 如果当前单词数量超过了目标数量，需要缩减左边界
                    while (currentMap.get(w) > totalMap.get(w)) {
                        String leftWord = s.substring(left, left + oneWordLen);
                        currentMap.put(leftWord, currentMap.get(leftWord) - 1);
                        count--;
                        left += oneWordLen;
                    }

                    // 如果匹配数量等于单词总数，记录答案
                    if (count == wordNum) {
                        res.add(left);

                        // 记录完之后，模拟滑动：移除最左边的一个单词，继续向右寻找
                        String leftWord = s.substring(left, left + oneWordLen);
                        currentMap.put(leftWord, currentMap.get(leftWord) - 1);
                        count--;
                        left += oneWordLen;
                    }
                }
            }
        }
        return res;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        String s1 = "barfoothefoobarman";
        String[] words1 = {"foo", "bar"};

        System.out.println("示例 1 输入: s = \"" + s1 + "\", words = [\"foo\", \"bar\"]");
        System.out.println("示例 1 输出: " + findSubstring(s1, words1));
        // 解释: [0, 9]
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        String s2 = "wordgoodgoodgoodbestword";
        String[] words2 = {"word", "good", "best", "word"};

        System.out.println("示例 2 输入: s = \"" + s2 + "\", words = [\"word\", \"good\", \"best\", \"word\"]");
        System.out.println("示例 2 输出: " + findSubstring(s2, words2));
        // 解释: [] (因为中间有连续的 good，导致结构破坏)
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        String s3 = "barfoofoobarthefoobarman";
        String[] words3 = {"bar", "foo", "the"};

        System.out.println("示例 3 输入: s = \"" + s3 + "\", words = [\"bar\", \"foo\", \"the\"]");
        System.out.println("示例 3 输出: " + findSubstring(s3, words3));
        // 解释: [6, 9, 12]
    }
}
```
