---
title: 30. 串联所有单词的子串
date: 2024-04-28 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 滑动窗口]
tags: [滑动窗口]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121224543874.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：30. 串联所有单词的子串

**描述**

给定一个字符串 `s` 和一个字符串数组 `words` 。`words` 中所有字符串 **长度相同** 。

`s` 中的 **串联子串** 是指一个包含 `words` 中所有字符串以任意顺序排列连接起来的子串。

- 例如，如果 `words = ["ab","cd","ef"]`， 那么 `"abcdef"`， `"abefcd"`，`"cdabef"`， `"cdefab"`，`"efabcd"`， 和 `"efcdab"` 都是串联子串。`"acdbef"` 不是串联子串，因为它不是 `words` 中任何排列的连接。

返回所有串联子串在 `s` 中的开始索引。你可以以 **任意顺序** 返回答案。

**示例 1:**

- **输入:** `s = "barfoothefoobarman"`, `words = ["foo","bar"]`
- **输出:** `[0,9]`
- **解释:**
  因为 `words.length == 2` 同时 `words[i].length == 3`，连接的子字符串的长度必须为 6。
  子串 `"barfoo"` 开始位置是 0。它是 `words` 中以 `["bar","foo"]` 顺序排列的连接。
  子串 `"foobar"` 开始位置是 9。它是 `words` 中以 `["foo","bar"]` 顺序排列的连接。
  输出顺序无关紧要。返回 `[9,0]` 也是可以的。

**示例 2:**

- **输入:** `s = "wordgoodgoodgoodbestword"`, `words = ["word","good","best","word"]`
- **输出:** `[]`

**示例 3:**

- **输入:** `s = "barfoofoobarthefoobarman"`, `words = ["bar","foo","the"]`
- **输出:** `[6,9,12]`

**提示:**

- `1 <= s.length <= 10^4`
- `1 <= words.length <= 5000`
- `1 <= words[i].length <= 30`
- `words[i]` 和 `s` 由小写英文字母组成

## Java 代码

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Main {

    /**
     * 找出 s 中所有串联子串的起始索引。
     *
     * @param s     源字符串
     * @param words 单词数组
     * @return 所有起始索引的列表
     */
    public static List<Integer> findSubstring(String s, String[] words) {
        List<Integer> result = new ArrayList<>();
        if (s == null || s.length() == 0 || words == null || words.length == 0) {
            return result;
        }

        // 单词数组中单词的个数
        int wordCount = words.length;
        // 每个单词的长度（所有单词长度相同）
        int wordLen = words[0].length();
        // 串联子串的总长度
        int totalLen = wordCount * wordLen;

        // 如果 s 的长度小于串联子串的总长度，不可能找到
        if (s.length() < totalLen) {
            return result;
        }

        // `wordFreq` 用于存储 words 数组中每个单词的出现频率
        Map<String, Integer> wordFreq = new HashMap<>();
        for (String word : words) {
            wordFreq.put(word, wordFreq.getOrDefault(word, 0) + 1);
        }

        // 遍历 s，寻找可能的起始点
        for (int i = 0; i <= s.length() - totalLen; i++) {
            // 截取一个与串联子串等长的子串
            String sub = s.substring(i, i + totalLen);

            // `seenWords` 用于记录在当前子串 sub 中看到的单词频率
            Map<String, Integer> seenWords = new HashMap<>();

            // 将子串 sub 按 wordLen 切分成单词进行检查
            int j = 0;
            for (; j < wordCount; j++) {
                int start = j * wordLen;
                String currentWord = sub.substring(start, start + wordLen);

                // 如果这个单词不在 `wordFreq` 中，说明这个子串不可能是串联子串
                if (!wordFreq.containsKey(currentWord)) {
                    break;
                }

                seenWords.put(currentWord, seenWords.getOrDefault(currentWord, 0) + 1);

                // 如果当前单词出现的次数超过了 `wordFreq` 中记录的次数，也不匹配
                if (seenWords.get(currentWord) > wordFreq.get(currentWord)) {
                    break;
                }
            }

            // 如果 j 成功遍历完了所有单词，说明找到了一个匹配的串联子串
            if (j == wordCount) {
                result.add(i);
            }
        }

        return result;
    }

    public static void main(String[] args) {
        // 示例 1
        String s1 = "barfoothefoobarman";
        String[] words1 = {"foo", "bar"};
        System.out.println("输入: s = \"" + s1 + "\", words = " + java.util.Arrays.toString(words1));
        System.out.println("输出: " + findSubstring(s1, words1)); // 预期: [0, 9] 或 [9, 0]
        System.out.println("---");

        // 示例 2
        String s2 = "wordgoodgoodgoodbestword";
        String[] words2 = {"word", "good", "best", "word"};
        System.out.println("输入: s = \"" + s2 + "\", words = " + java.util.Arrays.toString(words2));
        System.out.println("输出: " + findSubstring(s2, words2)); // 预期: []
        System.out.println("---");

        // 示例 3
        String s3 = "barfoofoobarthefoobarman";
        String[] words3 = {"bar", "foo", "the"};
        System.out.println("输入: s = \"" + s3 + "\", words = " + java.util.Arrays.toString(words3));
        System.out.println("输出: " + findSubstring(s3, words3)); // 预期: [6, 9, 12] (顺序不定)
        System.out.println("---");
    }
}
```
