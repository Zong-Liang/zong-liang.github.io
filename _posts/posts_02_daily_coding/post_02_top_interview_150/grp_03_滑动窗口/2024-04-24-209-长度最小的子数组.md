---
title: 209. 长度最小的子数组
date: 2024-04-24 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 滑动窗口]
tags: [滑动窗口]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121224048763.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


## 题目：209. 长度最小的子数组

**描述**

给定一个含有 `n` 个正整数的数组和一个正整数 `target` 。

找出该数组中满足其总和大于等于 `target` 的长度最小的 **子数组** `[nums[l], nums[l+1], ..., nums[r-1], nums[r]]` ，并返回其长度。如果不存在符合条件的子数组，返回 `0` 。

**示例 1:**

- **输入:** `target = 7`, `nums = [2,3,1,2,4,3]`
- **输出:** 2
- **解释:** 子数组 `[4,3]` 是该条件下的长度最小的子数组。

**示例 2:**

- **输入:** `target = 4`, `nums = [1,4,4]`
- **输出:** 1

**示例 3:**

- **输入:** `target = 11`, `nums = [1,1,1,1,1,1,1,1,1,1]`
- **输出:** 0

**提示:**

- `1 <= target <= 10^9`
- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^4`

**进阶：**

- 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。



## Java 代码 (O(n) 滑动窗口解法)

```java
import java.util.Arrays;

public class Main {

    /**
     * 找出和大于等于 target 的长度最小的子数组。
     * 采用滑动窗口算法，时间复杂度为 O(n)。
     *
     * @param target 目标和
     * @param nums   正整数数组
     * @return 满足条件的最小子数组长度，不存在则返回 0
     */
    public static int minSubArrayLen(int target, int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        // minLength 用于记录最小长度，初始化为一个不可能达到的最大值
        int minLength = Integer.MAX_VALUE;
        // left 是滑动窗口的左边界
        int left = 0;
        // currentSum 记录当前窗口内所有元素的和
        int currentSum = 0;

        // right 是滑动窗口的右边界，不断向右扩展窗口
        for (int right = 0; right < nums.length; right++) {
            // 将新元素加入窗口
            currentSum += nums[right];

            // 当窗口内的和大于等于 target 时，尝试收缩窗口
            while (currentSum >= target) {
                // 更新最小长度
                minLength = Math.min(minLength, right - left + 1);

                // 将窗口左边的元素移出窗口
                currentSum -= nums[left];
                // 左边界右移
                left++;
            }
        }

        // 如果 minLength 没有被更新过，说明没有找到符合条件的子数组
        return minLength == Integer.MAX_VALUE ? 0 : minLength;
    }

    public static void main(String[] args) {
        // 示例 1
        int target1 = 7;
        int[] nums1 = {2, 3, 1, 2, 4, 3};
        System.out.println("输入: target = " + target1 + ", nums = " + Arrays.toString(nums1));
        System.out.println("输出: " + minSubArrayLen(target1, nums1)); // 预期: 2
        System.out.println("---");

        // 示例 2
        int target2 = 4;
        int[] nums2 = {1, 4, 4};
        System.out.println("输入: target = " + target2 + ", nums = " + Arrays.toString(nums2));
        System.out.println("输出: " + minSubArrayLen(target2, nums2)); // 预期: 1
        System.out.println("---");

        // 示例 3
        int target3 = 11;
        int[] nums3 = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
        System.out.println("输入: target = " + target3 + ", nums = " + Arrays.toString(nums3));
        System.out.println("输出: " + minSubArrayLen(target3, nums3)); // 预期: 0
        System.out.println("---");
    }
}
```
