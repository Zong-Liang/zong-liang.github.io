---
title: 209. 长度最小的子数组
date: 2024-04-24 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 滑动窗口]
tags: [滑动窗口]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121224048763.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个含有 `n` 个正整数的数组和一个正整数 `target` 。

找出该数组中满足其总和大于等于 `target` 的长度最小的 **子数组** `[nums[l], nums[l+1], ..., nums[r-1], nums[r]]` ，并返回其长度。如果不存在符合条件的子数组，返回 `0` 。

**示例 1:**

- **输入:** `target = 7`, `nums = [2,3,1,2,4,3]`
- **输出:** 2
- **解释:** 子数组 `[4,3]` 是该条件下的长度最小的子数组。

**示例 2:**

- **输入:** `target = 4`, `nums = [1,4,4]`
- **输出:** 1

**示例 3:**

- **输入:** `target = 11`, `nums = [1,1,1,1,1,1,1,1,1,1]`
- **输出:** 0

**提示:**

- `1 <= target <= 10^9`
- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^4`

**进阶：**

- 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。

## 题解

### 解法一：滑动窗口（双指针）

**思路：**

由于题目要求寻找**连续**子数组，且数组元素均为**正整数**（这意味着子数组越长，和越大），我们可以使用滑动窗口（双指针）的方法来解决。

1.  定义两个指针 `left` 和 `right`，分别表示滑动窗口的起始和结束位置，初始都为 `0`。
2.  定义 `sum` 记录当前窗口内的元素和。
3.  **扩展窗口**：移动 `right` 指针，将 `nums[right]` 加入 `sum`。
4.  **收缩窗口**：当 `sum >= target` 时，说明找到了一个满足条件的子数组。

    - 尝试更新最小长度：`minLen = min(minLen, right - left + 1)`。
    - 将 `nums[left]` 从 `sum` 中减去，并右移 `left`，看是否能找到更短的满足条件的子数组。

5.  重复上述过程直到 `right` 遍历完数组。

**复杂度分析：**

- **时间复杂度：** $O(n)$。虽然有两层循环（外层 `right`，内层 `while`），但每个元素最多被 `right` 指针访问一次，也被 `left` 指针访问一次，总操作次数是线性的。
- **空间复杂度：** $O(1)$。只需要常数级的额外空间。

**代码片段：**

```java
public int minSubArrayLen(int target, int[] nums) {
    int left = 0;
    int sum = 0;
    int minLen = Integer.MAX_VALUE;

    for (int right = 0; right < nums.length; right++) {
        sum += nums[right];
        // 当窗口和满足条件时，尝试收缩窗口以找到最小长度
        while (sum >= target) {
            minLen = Math.min(minLen, right - left + 1);
            sum -= nums[left];
            left++;
        }
    }

    return minLen == Integer.MAX_VALUE ? 0 : minLen;
}
```

### 解法二：前缀和 + 二分查找（进阶要求）

**思路：**

题目进阶要求 $O(n \log n)$ 的解法。通常在处理子数组和问题时，**前缀和**是一个常用的技巧。

1.  构建前缀和数组 `sums`，其中 `sums[i]` 表示 `nums[0]` 到 `nums[i-1]` 的和。`sums[0] = 0`。
2.  因为 `nums` 元素均为正数，所以 `sums` 是**严格单调递增**的，这就满足了二分查找的条件。
3.  对于每一个开始位置 `i`，我们想要找到一个结束位置 `bound`，使得 `nums[i] + ... + nums[bound-1] >= target`。
    - 利用前缀和转换公式：`sums[bound] - sums[i] >= target`。
    - 即查找 `sums` 数组中第一个大于等于 `target + sums[i]` 的位置 `bound`。
4.  我们可以遍历 `i`，然后对 `sums` 数组进行二分查找。

**复杂度分析：**

- **时间复杂度：** $O(n \log n)$。外层遍历需要 $O(n)$，内部二分查找需要 $O(\log n)$。
- **空间复杂度：** $O(n)$。需要额外的数组来存储前缀和。

**代码片段：**

```java
public int minSubArrayLenBinarySearch(int target, int[] nums) {
    int n = nums.length;
    int[] sums = new int[n + 1];
    // 计算前缀和：sums[i] 表示 nums 前 i 个元素的和
    for (int i = 1; i <= n; i++) {
        sums[i] = sums[i - 1] + nums[i - 1];
    }

    int minLen = Integer.MAX_VALUE;

    for (int i = 0; i <= n; i++) {
        int targetSum = target + sums[i];
        // 在 sums 数组中寻找第一个大于等于 targetSum 的值的索引
        // Arrays.binarySearch 如果没找到会返回 -(插入点) - 1
        int bound = java.util.Arrays.binarySearch(sums, targetSum);

        if (bound < 0) {
            bound = -bound - 1; // 转换为插入点索引
        }

        // 如果 bound 越界，说明后面没有足够大的和了
        if (bound <= n) {
            minLen = Math.min(minLen, bound - i);
        }
    }

    return minLen == Integer.MAX_VALUE ? 0 : minLen;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现：滑动窗口 (最优解 O(n))
    public static int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int sum = 0;
        int minLen = Integer.MAX_VALUE;

        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];

            // 当 sum 足够大时，尝试缩小窗口
            while (sum >= target) {
                int currentLen = right - left + 1;
                if (currentLen < minLen) {
                    minLen = currentLen;
                }
                // 移除左边元素，尝试更小的长度
                sum -= nums[left];
                left++;
            }
        }

        return minLen == Integer.MAX_VALUE ? 0 : minLen;
    }

    // 进阶算法实现：前缀和 + 二分查找 (O(n log n))
    // 仅作演示，实际应用中首选滑动窗口
    public static int minSubArrayLenBinarySearch(int target, int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;

        int[] sums = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            sums[i] = sums[i - 1] + nums[i - 1];
        }

        int minLen = Integer.MAX_VALUE;

        // 遍历每一个可能的起始位置 i
        for (int i = 0; i < n; i++) {
            int required = target + sums[i];
            // 在 sums 数组中查找第一个 >= required 的位置
            int bound = Arrays.binarySearch(sums, required);

            if (bound < 0) {
                bound = -bound - 1; // 没找到精确值时，获取插入点
            }

            if (bound <= n) {
                minLen = Math.min(minLen, bound - i);
            }
        }
        return minLen == Integer.MAX_VALUE ? 0 : minLen;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int target1 = 7;
        int[] nums1 = new int[]{2, 3, 1, 2, 4, 3};

        System.out.println("示例 1 输入: target = " + target1 + ", nums = " + Arrays.toString(nums1));
        int result1 = minSubArrayLen(target1, nums1);
        System.out.println("示例 1 输出: " + result1);
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int target2 = 4;
        int[] nums2 = new int[]{1, 4, 4};

        System.out.println("示例 2 输入: target = " + target2 + ", nums = " + Arrays.toString(nums2));
        int result2 = minSubArrayLen(target2, nums2);
        System.out.println("示例 2 输出: " + result2);
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        int target3 = 11;
        int[] nums3 = new int[]{1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

        System.out.println("示例 3 输入: target = " + target3 + ", nums = " + Arrays.toString(nums3));
        int result3 = minSubArrayLen(target3, nums3);
        System.out.println("示例 3 输出: " + result3);
    }
}
```
