---
title: 3. 无重复字符的最长子串
date: 2024-04-27 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 滑动窗口]
tags: [滑动窗口]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121224500831.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

- **输入:** `s = "abcabcbb"`
- **输出:** 3
- **解释:** 因为无重复字符的最长子串是 `"abc"`，所以其长度为 3。注意 `"bca"` 和 `"cab"` 也是正确答案。

**示例 2:**

- **输入:** `s = "bbbbb"`
- **输出:** 1
- **解释:** 因为无重复字符的最长子串是 `"b"`，所以其长度为 1。

**示例 3:**

- **输入:** `s = "pwwkew"`
- **输出:** 3
- **解释:** 因为无重复字符的最长子串是 `"wke"`，所以其长度为 3。请注意，你的答案必须是 **子串** 的长度，`"pwke"` 是一个子序列，不是子串。

**提示:**

- `0 <= s.length <= 5 * 10^4`
- `s` 由英文字母、数字、符号和空格组成

## 题解

### 解法：滑动窗口（双指针 + 哈希表）

**思路：**

我们要寻找的是一个**连续**的子串，且不能包含重复字符。这非常适合使用**滑动窗口**的方法。

1.  定义一个滑动窗口 `[left, right]`，初始时 `left = 0`。
2.  我们需要一个哈希表（`HashMap`）来记录当前窗口内出现的字符及其**最新的下标位置**。
3.  遍历字符串，移动右指针 `right`：

    - 获取当前字符 `c`。
    - **判断重复**：如果哈希表中已经存在字符 `c`，说明遇到了重复字符。此时，我们需要将左指针 `left` 向右跳跃。
    - **更新 left**：为了保证窗口内无重复，`left` 应该跳到 `map.get(c) + 1` 的位置。

      - _注意_：需要取 `Math.max(left, map.get(c) + 1)`，防止 `left` 指针回退（因为哈希表中可能存储的是窗口左侧之外的旧索引）。

    - **更新哈希表**：将字符 `c` 的位置更新为当前的 `right`。
    - **计算长度**：当前有效窗口长度为 `right - left + 1`，更新全局最大值。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是字符串的长度。我们要遍历字符串一次。
- **空间复杂度：** $O(\Sigma)$，其中 $\Sigma$ 是字符集的大小（如 ASCII 为 128）。哈希表存储出现的字符及其下标，最坏情况下需要存储所有不同的字符。

**代码片段：**

```java
public int lengthOfLongestSubstring(String s) {
    // 存储字符上次出现的索引位置
    Map<Character, Integer> map = new HashMap<>();
    int maxLen = 0;
    int left = 0;

    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);
        // 如果当前字符之前出现过，更新左边界 left
        if (map.containsKey(c)) {
            // left 只能向右移动，不能回头，所以取 max
            left = Math.max(left, map.get(c) + 1);
        }
        // 更新字符最后出现的位置
        map.put(c, right);
        // 更新最大长度
        maxLen = Math.max(maxLen, right - left + 1);
    }
    return maxLen;
}
```

### 完整代码

```java
import java.util.HashMap;
import java.util.Map;

public class Main {

    // 核心算法实现：滑动窗口 + 哈希表
    public static int lengthOfLongestSubstring(String s) {
        // key: 字符, value: 该字符最近一次出现的下标
        Map<Character, Integer> map = new HashMap<>();
        int maxLen = 0;
        int left = 0; // 滑动窗口左边界

        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);

            // 发现重复字符
            if (map.containsKey(c)) {
                // 将左指针直接跳到重复字符的下一位
                // 使用 Math.max 是为了防止 left 回退
                // 例如 "abba"，当遍历到第二个 a 时，map.get('a') 是 0，+1 是 1
                // 但此时 left 已经是 2 了，不能退回到 1
                left = Math.max(left, map.get(c) + 1);
            }

            // 更新字符位置
            map.put(c, right);

            // 更新最大长度
            maxLen = Math.max(maxLen, right - left + 1);
        }
        return maxLen;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        String s1 = "abcabcbb";
        System.out.println("示例 1 输入: s = \"" + s1 + "\"");
        System.out.println("示例 1 输出: " + lengthOfLongestSubstring(s1));
        // 解释: "abc", 长度 3
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        String s2 = "bbbbb";
        System.out.println("示例 2 输入: s = \"" + s2 + "\"");
        System.out.println("示例 2 输出: " + lengthOfLongestSubstring(s2));
        // 解释: "b", 长度 1
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        String s3 = "pwwkew";
        System.out.println("示例 3 输入: s = \"" + s3 + "\"");
        System.out.println("示例 3 输出: " + lengthOfLongestSubstring(s3));
        // 解释: "wke", 长度 3
    }
}
```
