---
title: 150. 逆波兰表达式求值
date: 2024-06-18 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 栈]
tags: [栈]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230206909.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：150. 逆波兰表达式求值

**描述：**

给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437) (Reverse Polish Notation) 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意:**

- 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
- 每个操作数（运算对象）都可能是一个整数，或者另一个表达式。
- 两个整数之间的除法总是 **向零截断** 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 **32 位** 整数表示。

**示例 1:**

- **输入:** `tokens = ["2","1","+","3","*"]`
- **输出:** 9
- **解释:** 该算式转化为常见的中缀算术表达式为：`((2 + 1) * 3) = 9`

**示例 2:**

- **输入:** `tokens = ["4","13","5","/","+"]`
- **输出:** 6
- **解释:** 该算式转化为常见的中缀算术表达式为：`(4 + (13 / 5)) = 6`

**示例 3:**

- **输入:** `tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]`
- **输出:** 22

**提示:**

- `1 <= tokens.length <= 10^4`
- `tokens[i]` 是一个算符（`"+"、"-"、"*" 或 "/"`），或是在范围 `[-200, 200]` 内的一个整数

## 题解

### 解法：栈 (Stack)

**思路：**

逆波兰表达式（后缀表达式）非常适合使用 **栈（Stack）** 来计算。

1.  **遍历数组**：依次遍历 `tokens` 数组中的每一个字符串。
2.  **遇到数字**：直接解析为整数，并压入栈顶。
3.  **遇到运算符**：

    - 从栈中连续弹出两个数字。
    - **注意顺序**：先弹出的是右操作数（`num2`），后弹出的是左操作数（`num1`）。
    - 根据当前运算符（`+`, `-`, `*`, `/`）对这两个数字进行计算。
    - 将计算结果压入栈顶。

4.  **返回结果**：遍历结束后，栈中仅剩的一个数字即为最终结果。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是数组 `tokens` 的长度。我们需要遍历数组一次，每个元素的操作（入栈、出栈、计算）都是常数时间的。
- **空间复杂度：** $O(n)$。在最坏情况下（例如输入全是数字），栈中需要存储 $O(n)$ 个数字。

**代码片段：**

```java
public int evalRPN(String[] tokens) {
    Deque<Integer> stack = new ArrayDeque<>();

    for (String token : tokens) {
        // 判断是否为运算符
        if (isOperator(token)) {
            // 注意：先弹出的是右操作数，后弹出的是左操作数
            int num2 = stack.pop();
            int num1 = stack.pop();
            int res = 0;
            switch (token) {
                case "+": res = num1 + num2; break;
                case "-": res = num1 - num2; break;
                case "*": res = num1 * num2; break;
                case "/": res = num1 / num2; break;
            }
            stack.push(res);
        } else {
            // 是数字，解析并入栈
            stack.push(Integer.parseInt(token));
        }
    }
    return stack.pop();
}

private boolean isOperator(String s) {
    return s.equals("+") || s.equals("-") || s.equals("*") || s.equals("/");
}
```

### 完整代码

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class Main {

    // 核心算法实现
    public static int evalRPN(String[] tokens) {
        Deque<Integer> stack = new ArrayDeque<>();

        for (String token : tokens) {
            // 检查当前 token 是否为运算符
            if ("+".equals(token) || "-".equals(token) || "*".equals(token) || "/".equals(token)) {
                // 如果是运算符，弹出栈顶的两个元素
                // 关键点：栈是后进先出，所以第一个弹出的是算式的“后面”那个数
                int num2 = stack.pop(); // 右操作数
                int num1 = stack.pop(); // 左操作数

                int res = 0;
                switch (token) {
                    case "+":
                        res = num1 + num2;
                        break;
                    case "-":
                        res = num1 - num2;
                        break;
                    case "*":
                        res = num1 * num2;
                        break;
                    case "/":
                        // Java 的整数除法默认就是向零截断，符合题目要求
                        res = num1 / num2;
                        break;
                }
                // 将计算结果压回栈中
                stack.push(res);
            } else {
                // 如果不是运算符，则是数字，直接转换并入栈
                stack.push(Integer.parseInt(token));
            }
        }

        // 最终栈里剩下的唯一元素就是结果
        return stack.pop();
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        String[] tokens1 = {"2", "1", "+", "3", "*"};
        System.out.println("示例 1 输入: [\"2\",\"1\",\"+\",\"3\",\"*\"]");
        int res1 = evalRPN(tokens1);
        System.out.println("示例 1 输出: " + res1);
        // 解释: ((2 + 1) * 3) = 9
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        String[] tokens2 = {"4", "13", "5", "/", "+"};
        System.out.println("示例 2 输入: [\"4\",\"13\",\"5\",\"/\",\"+\"]");
        int res2 = evalRPN(tokens2);
        System.out.println("示例 2 输出: " + res2);
        // 解释: (4 + (13 / 5)) = 4 + 2 = 6
        System.out.println("-----------------------------");

        // --- 示例 3 测试 ---
        String[] tokens3 = {"10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"};
        System.out.println("示例 3 输入: [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]");
        int res3 = evalRPN(tokens3);
        System.out.println("示例 3 输出: " + res3);
        // 预期: 22
    }
}
```
