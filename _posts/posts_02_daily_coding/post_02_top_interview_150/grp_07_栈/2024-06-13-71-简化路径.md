---
title: 71-简化路径
date: 2024-06-13 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 栈]
tags: [栈]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121225930620.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

好的，这是图片中问题的整理以及符合要求的 Java 8 解答。

### 题目：71. 简化路径

**描述**
给你一个字符串 `path` ，表示指向某一文件或目录的 Unix 风格 **绝对路径** （以 `'/'` 开头），请你将其转化为更加简洁的 **规范路径** 。

在 Unix 风格的文件系统中，一个点 `.` 表示当前目录本身；此外，两个点 `..` 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，`'//'` 或 `'///'` 等）都被视为单个斜杠 `'/'` 。对于此问题，任何其他格式的点（例如，`'...'`）均被视为有效的文件/目录名称。

返回的 **简化路径** 必须遵循如下格式：

- 始终以斜杠 `'/'` 开头。
- 两个目录名之间必须只有一个斜杠 `'/'` 。
- 最后一个目录名（如果存在）**不能** 以 `'/'` 结尾。
- 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 `.` 或 `..` ）。

返回简化后得到的 **规范路径** 。

**示例 1:**

- **输入:** `path = "/home/"`
- **输出:** `"/home"`
- **解释:** 应删除尾随斜杠。

**示例 2:**

- **输入:** `path = "/home//foo/"`
- **输出:** `"/home/foo"`
- **解释:** 多个连续的斜杠被单个斜杠替换。

**示例 3:**

- **输入:** `path = "/home/user/Documents/../Pictures"`
- **输出:** `"/home/user/Pictures"`
- **解释:** 两个点 `..` 表示上一级目录（父目录）。

**示例 4:**

- **输入:** `path = "/../"`
- **输出:** `"/"`
- **解释:** 不可能从根目录上升一级目录。

**示例 5:**

- **输入:** `path = "/.../a/../b/c/../d/./"`
- **输出:** `"/.../b/d"`
- **解释:** `...` 在这个问题中是一个合法的目录名。

**提示:**

- `1 <= path.length <= 3000`
- `path` 由英文字母，数字，`.`，`/` 或 `_` 组成。
- `path` 是一个有效的 Unix 风格绝对路径。

---

### 赛码网格式 Java 8 代码

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class Main {

    /**
     * 将 Unix 风格的绝对路径转化为简洁的规范路径。
     *
     * @param path 原始路径字符串
     * @return 简化后的规范路径
     */
    public static String simplifyPath(String path) {
        // 使用 Deque 作为栈来处理路径组件
        Deque<String> stack = new ArrayDeque<>();

        // 按照 "/" 分割路径
        String[] components = path.split("/");

        // 遍历分割后的组件
        for (String component : components) {
            if (component.equals("..")) {
                // 如果是 ".."，则弹出栈顶元素（如果栈不为空）
                if (!stack.isEmpty()) {
                    stack.pop();
                }
            } else if (!component.isEmpty() && !component.equals(".")) {
                // 如果是有效目录名（非空且非 "."），则入栈
                stack.push(component);
            }
            // 忽略空字符串 "" 和当前目录 "."
        }

        // 如果栈为空，说明路径为根目录
        if (stack.isEmpty()) {
            return "/";
        }

        // 使用 StringBuilder 从栈底到栈顶构建最终路径
        StringBuilder result = new StringBuilder();
        while (!stack.isEmpty()) {
            // 从栈底开始拼接，所以每次插入到开头
            result.insert(0, "/" + stack.pop());
        }

        return result.toString();
    }

    public static void main(String[] args) {
        // 示例 1
        String path1 = "/home/";
        System.out.println("输入: " + path1);
        System.out.println("输出: " + simplifyPath(path1)); // 预期: /home

        // 示例 2
        String path2 = "/home//foo/";
        System.out.println("输入: " + path2);
        System.out.println("输出: " + simplifyPath(path2)); // 预期: /home/foo

        // 示例 3
        String path3 = "/home/user/Documents/../Pictures";
        System.out.println("输入: " + path3);
        System.out.println("输出: " + simplifyPath(path3)); // 预期: /home/user/Pictures

        // 示例 4
        String path4 = "/../";
        System.out.println("输入: " + path4);
        System.out.println("输出: " + simplifyPath(path4)); // 预期: /

        // 示例 5
        String path5 = "/.../a/../b/c/../d/./";
        System.out.println("输入: " + path5);
        System.out.println("输出: " + simplifyPath(path5)); // 预期: /.../b/d
    }
}
```
