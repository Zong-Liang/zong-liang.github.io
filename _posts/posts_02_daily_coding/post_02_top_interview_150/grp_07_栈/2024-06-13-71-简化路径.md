---
title: 71. 简化路径
date: 2024-06-13 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 栈]
tags: [栈]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121225930620.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：71. 简化路径

**描述：**

给你一个字符串 `path` ，表示指向某一文件或目录的 Unix 风格 **绝对路径** （以 `'/'` 开头），请你将其转化为更加简洁的 **规范路径** 。

在 Unix 风格的文件系统中，一个点 `.` 表示当前目录本身；此外，两个点 `..` 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，`'//'` 或 `'///'` 等）都被视为单个斜杠 `'/'` 。对于此问题，任何其他格式的点（例如，`'...'`）均被视为有效的文件/目录名称。

返回的 **简化路径** 必须遵循如下格式：

- 始终以斜杠 `'/'` 开头。
- 两个目录名之间必须只有一个斜杠 `'/'` 。
- 最后一个目录名（如果存在）**不能** 以 `'/'` 结尾。
- 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 `.` 或 `..` ）。

返回简化后得到的 **规范路径** 。

**示例 1:**

- **输入:** `path = "/home/"`
- **输出:** `"/home"`
- **解释:** 应删除尾随斜杠。

**示例 2:**

- **输入:** `path = "/home//foo/"`
- **输出:** `"/home/foo"`
- **解释:** 多个连续的斜杠被单个斜杠替换。

**示例 3:**

- **输入:** `path = "/home/user/Documents/../Pictures"`
- **输出:** `"/home/user/Pictures"`
- **解释:** 两个点 `..` 表示上一级目录（父目录）。

**示例 4:**

- **输入:** `path = "/../"`
- **输出:** `"/"`
- **解释:** 不可能从根目录上升一级目录。

**示例 5:**

- **输入:** `path = "/.../a/../b/c/../d/./"`
- **输出:** `"/.../b/d"`
- **解释:** `...` 在这个问题中是一个合法的目录名。

**提示:**

- `1 <= path.length <= 3000`
- `path` 由英文字母，数字，`.`，`/` 或 `_` 组成。
- `path` 是一个有效的 Unix 风格绝对路径。

## 题解

### 解法：栈 (Stack) + 字符串分割

**思路：**

简化路径的核心在于处理目录的“层级”关系，特别是 `..`（返回上一级）的操作。这种“后进先出”的逻辑非常适合使用 **栈** 来解决。

1.  **分割字符串**：首先根据斜杠 `/` 将路径字符串分割成若干个部分（字符串数组）。

    - 例如 `"/a//b/../../c/"` 分割后会得到 `["", "a", "", "b", "..", "..", "c", ""]`。
    - 注意：分割会产生空字符串（对应连续斜杠 `//`）和点 `.`（对应当前目录），我们需要在遍历时过滤掉这些无效元素。

2.  **遍历与入栈/出栈**：

    - 遍历分割后的每一个片段 `part`。
    - 如果 `part` 是 `..`：表示返回上一级。如果此时栈不为空，则弹出栈顶元素（即移除当前的最后一级目录）；如果栈为空（已经在根目录），则忽略，保持原状。
    - 如果 `part` 是 `.` 或 **空字符串**：不做任何操作，直接跳过。
    - 如果不满足以上情况（即 `part` 是有效的目录名，如 `abc` 或 `...`）：将其推入栈中。

3.  **重组路径**：

    - 遍历结束后，栈中保留的就是简化后的有效目录层级。
    - 我们需要将栈底到栈顶的元素用 `/` 连接起来。
    - 如果栈为空，说明路径回到了根目录，返回 `"/"`。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是字符串的长度。我们需要对字符串进行分割和遍历，分割和重组也是线性时间的。
- **空间复杂度：** $O(n)$。我们需要存储分割后的字符串数组以及栈结构，最坏情况下（例如 `/a/b/c/d`）空间与输入长度成正比。

**代码片段：**

```java
public String simplifyPath(String path) {
    // 1. 根据 '/' 分割路径
    String[] parts = path.split("/");

    // 使用 Deque 作为栈
    Deque<String> stack = new ArrayDeque<>();

    // 2. 遍历每个部分
    for (String part : parts) {
        if ("..".equals(part)) {
            // 如果是 ".."，且栈不为空，则返回上一级（出栈）
            if (!stack.isEmpty()) {
                stack.pollLast();
            }
        } else if (part.length() > 0 && !".".equals(part)) {
            // 如果不是空字符串，也不是 "."，则认为是有效目录名（入栈）
            stack.offerLast(part);
        }
    }

    // 3. 重组路径
    StringBuilder result = new StringBuilder();
    if (stack.isEmpty()) {
        return "/";
    }

    // 遍历栈中剩余元素拼接（ArrayDeque 迭代顺序是从头到尾，即栈底到栈顶）
    for (String dir : stack) {
        result.append("/").append(dir);
    }

    return result.toString();
}
```

### 完整代码

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class Main {

    // 核心算法实现
    public static String simplifyPath(String path) {
        String[] parts = path.split("/");
        Deque<String> stack = new ArrayDeque<>();

        for (String part : parts) {
            // 遇到 ".." 时，尝试回退目录
            if ("..".equals(part)) {
                if (!stack.isEmpty()) {
                    stack.pollLast();
                }
            }
            // 过滤掉空字符串（由 "//" 产生）和当前目录标识 "."
            else if (part.length() > 0 && !".".equals(part)) {
                stack.offerLast(part);
            }
        }

        // 构造结果
        StringBuilder result = new StringBuilder();
        // 如果栈为空，直接返回根目录
        if (stack.isEmpty()) {
            return "/";
        }

        // 从栈底到栈顶拼接路径
        for (String dir : stack) {
            result.append("/");
            result.append(dir);
        }

        return result.toString();
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        String path1 = "/home/";
        System.out.println("示例 1 输入: " + path1);
        String res1 = simplifyPath(path1);
        System.out.println("示例 1 输出: " + res1); // 预期: "/home"
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        String path2 = "/home//foo/";
        System.out.println("示例 2 输入: " + path2);
        String res2 = simplifyPath(path2);
        System.out.println("示例 2 输出: " + res2); // 预期: "/home/foo"
        System.out.println("-----------------------------");

        // --- 示例 3 测试 ---
        String path3 = "/home/user/Documents/../Pictures";
        System.out.println("示例 3 输入: " + path3);
        String res3 = simplifyPath(path3);
        System.out.println("示例 3 输出: " + res3); // 预期: "/home/user/Pictures"
        System.out.println("-----------------------------");

        // --- 示例 4 测试 ---
        String path4 = "/../";
        System.out.println("示例 4 输入: " + path4);
        String res4 = simplifyPath(path4);
        System.out.println("示例 4 输出: " + res4); // 预期: "/"
        System.out.println("-----------------------------");

        // --- 示例 5 测试 ---
        String path5 = "/.../a/../b/c/../d/./";
        System.out.println("示例 5 输入: " + path5);
        String res5 = simplifyPath(path5);
        System.out.println("示例 5 输出: " + res5); // 预期: "/.../b/d"
    }
}
```
