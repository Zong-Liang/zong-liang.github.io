---
title: 224. 基本计算器
date: 2024-06-19 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 栈]
tags: [栈]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230246168.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。

注意: 不允许使用任何将字符串作为数学表达式计算的内置函数，比如 `eval()` 。

**示例 1:**

- **输入:** `s = "1 + 1"`
- **输出:** 2

**示例 2:**

- **输入:** `s = " 2-1 + 2 "`
- **输出:** 3

**示例 3:**

- **输入:** `s = "(1+(4+5+2)-3)+(6+8)"`
- **输出:** 23

**提示:**

- `1 <= s.length <= 3 * 10^5`
- `s` 由数字、`'+'`、`'-'`、`'('`、`')'`、和 `' '` 组成
- `s` 表示一个有效的表达式
- `'+'` 不能用作一元运算 (例如， `"+1"` 和 `"+(2 + 3)"` 无效)
- `'-'` 可以用作一元运算 (即 `"-1"` 和 `"-(2 + 3)"` 是有效的)
- 输入中不存在两个连续的操作符
- 每个数字和运行的计算将适合于一个有符号的 32 位整数

## 题解

### 解法：栈 + 符号记录（迭代法）

**思路：**

由于题目中只包含加减法 `+`、`-` 和括号 `(`, `)`，我们可以将表达式看作是一系列数字的代数和。核心在于正确处理括号对符号的影响以及括号内的计算结果。

我们可以维护两个变量：

1.  `res`：记录当前层级的计算结果。
2.  `sign`：记录当前数字前的符号（`1` 代表加，`-1` 代表减）。

当遇到不同的字符时：

- **数字**：解析完整的数字（处理多位数），将其乘以当前的 `sign` 并加到 `res` 中。
- **`+` 或 `-`**：更新 `sign` 变量（`+` 为 1，`-` 为 -1）。
- **`(`**：说明进入了下一层级。我们需要将当前层级的 `res` 和 `sign` 压入栈保存，然后重置 `res` 为 0，`sign` 为 1，开始计算括号内部的值。
- **`)`**：说明当前括号结束。取出栈顶保存的 `sign`（这是括号外的符号）和 `res`（这是括号外的结果），将当前括号内计算出的结果与外部结合：`res = 外部res + 外部sign * 内部res`。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是字符串的长度。我们需要遍历整个字符串一次。
- **空间复杂度：** $O(n)$。在最坏情况下（例如多重嵌套括号 `((...))`），栈的深度与字符串长度呈线性关系。

**代码片段：**

```java
public int calculate(String s) {
    Deque<Integer> stack = new ArrayDeque<>();
    int sign = 1; // 1 表示正，-1 表示负
    int res = 0;
    int n = s.length();

    for (int i = 0; i < n; i++) {
        char ch = s.charAt(i);

        if (Character.isDigit(ch)) {
            // 解析多位数字
            int num = 0;
            while (i < n && Character.isDigit(s.charAt(i))) {
                num = num * 10 + (s.charAt(i) - '0');
                i++;
            }
            res += sign * num;
            i--; // 因为循环里 i 多加了一次，退回去让外层循环正常处理
        } else if (ch == '+') {
            sign = 1;
        } else if (ch == '-') {
            sign = -1;
        } else if (ch == '(') {
            // 遇到左括号，将当前结果和符号入栈保存
            stack.push(res);
            stack.push(sign);
            // 重置状态，准备计算括号里面的内容
            res = 0;
            sign = 1;
        } else if (ch == ')') {
            // 遇到右括号，结束当前括号内的计算
            int prevSign = stack.pop();
            int prevRes = stack.pop();
            // 当前结果 = 栈中保存的外部结果 + (栈中保存的外部符号 * 当前括号内计算结果)
            res = prevRes + prevSign * res;
        }
    }
    return res;
}
```

### 完整代码

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class Main {

    // 核心算法实现
    public static int calculate(String s) {
        // 使用栈来保存进入括号前的状态
        Deque<Integer> stack = new ArrayDeque<>();

        // sign: 代表当前数字前的符号，1 为正，-1 为负
        int sign = 1;
        // res: 记录当前层级的累加结果
        int res = 0;

        int length = s.length();

        for (int i = 0; i < length; i++) {
            char ch = s.charAt(i);

            if (Character.isDigit(ch)) {
                // 如果是数字，可能有多位，需要连续读取
                int num = 0;
                // 注意边界检查和字符判断
                while (i < length && Character.isDigit(s.charAt(i))) {
                    num = num * 10 + (s.charAt(i) - '0');
                    i++;
                }
                // 把这个数根据符号加到结果里
                res += sign * num;
                // 因为 while 循环中 i 多自增了一次，所以这里要减回去，
                // 否则外层 for 循环的 i++ 会导致跳过一个字符
                i--;
            } else if (ch == '+') {
                sign = 1;
            } else if (ch == '-') {
                sign = -1;
            } else if (ch == '(') {
                // 遇到左括号：
                // 1. 把括号外的结果 res 压栈
                // 2. 把括号前的符号 sign 压栈
                stack.push(res);
                stack.push(sign);
                // 重置环境，开始计算括号内部
                res = 0;
                sign = 1;
            } else if (ch == ')') {
                // 遇到右括号，说明当前子表达式结束
                // 弹出括号前的符号
                int prevSign = stack.pop();
                // 弹出括号前的结果
                int prevRes = stack.pop();

                // 将括号内的结果 (res) 乘以括号前的符号 (prevSign)，再加到括号前的结果 (prevRes) 上
                res = prevRes + prevSign * res;
            }
            // 如果是空格 ' '，直接忽略，不做处理
        }

        return res;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        String s1 = "1 + 1";
        System.out.println("示例 1 输入: \"" + s1 + "\"");
        int res1 = calculate(s1);
        System.out.println("示例 1 输出: " + res1); // 预期: 2
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        String s2 = " 2-1 + 2 ";
        System.out.println("示例 2 输入: \"" + s2 + "\"");
        int res2 = calculate(s2);
        System.out.println("示例 2 输出: " + res2); // 预期: 3
        System.out.println("-----------------------------");

        // --- 示例 3 测试 ---
        String s3 = "(1+(4+5+2)-3)+(6+8)";
        System.out.println("示例 3 输入: \"" + s3 + "\"");
        int res3 = calculate(s3);
        System.out.println("示例 3 输出: " + res3); // 预期: 23
        System.out.println("-----------------------------");

        // --- 示例 4 (一元负号) 测试 ---
        String s4 = "- (3 + (4 - 5))";
        System.out.println("示例 4 输入: \"" + s4 + "\"");
        int res4 = calculate(s4);
        System.out.println("示例 4 输出: " + res4); // 预期: -2
    }
}
```
