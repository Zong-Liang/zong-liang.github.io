---
title: 155. 最小栈
date: 2024-06-16 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 栈]
tags: [栈]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230116487.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素 val 推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

**示例 1:**

- **输入:**

  `["MinStack","push","push","push","getMin","pop","top","getMin"]`

  `[[],[-2],[0],[-3],[],[],[],[]]`

- **输出:**

  `[null,null,null,null,-3,null,0,-2]`

- **解释:**

  `MinStack minStack = new MinStack();`

  `minStack.push(-2);`

  `minStack.push(0);`

  `minStack.push(-3);`

  `minStack.getMin();` `--> 返回 -3.`

  `minStack.pop();`

  `minStack.top();` `--> 返回 0.`

  `minStack.getMin();` `--> 返回 -2.`

**提示:**

- `-2^31 <= val <= 2^31 - 1`
- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用
- `push`, `pop`, `top`, and `getMin` 最多被调用 `3 * 10^4` 次

## 题解

### 解法一：辅助栈法（双栈）

**思路：**

要在常数时间 $O(1)$ 内获取最小元素，我们不能在每次调用 `getMin` 时都遍历整个栈。我们需要在 `push` 入栈时就记录下当前的最小值。

最直观的方法是使用两个栈：

1.  **数据栈 (`stack`)**：用于存储所有元素，保证正常的 `push`、`pop`、`top` 功能。
2.  **辅助栈 (`minStack`)**：用于存储当前状态下的最小值。`minStack` 的栈顶永远是当前 `stack` 中所有元素的最小值。

**逻辑流程：**

1.  **Push(val)**：

    - 将 `val` 推入 `stack`。
    - 判断 `minStack` 是否为空，或者 `val` 是否 **小于等于** `minStack` 的栈顶元素。如果是，则将 `val` 也推入 `minStack`。
    - **注意**：这里必须是“小于等于”，防止有重复的最小值被弹出后，找不到次小的最小值。

2.  **Pop()**：

    - 从 `stack` 弹出元素，记为 `poppedVal`。
    - 如果 `poppedVal` 等于 `minStack` 的栈顶元素，说明弹出的这个数是当前的最小值，因此也要将 `minStack` 的栈顶弹出。

3.  **Top()**：

    - 直接返回 `stack` 的栈顶。

4.  **GetMin()**：

    - 直接返回 `minStack` 的栈顶。

**复杂度分析：**

- **时间复杂度：** $O(1)$。`push`, `pop`, `top`, `getMin` 所有操作都只需要对栈顶进行操作。
- **空间复杂度：** $O(n)$。在最坏情况下（例如数组是降序排列），辅助栈存储的元素数量与数据栈相同。

**代码片段：**

```java
class MinStack {
    private Deque<Integer> stack;
    private Deque<Integer> minStack;

    public MinStack() {
        stack = new ArrayDeque<>();
        minStack = new ArrayDeque<>();
    }

    public void push(int val) {
        stack.push(val);
        // 如果辅助栈为空，或者新元素 <= 当前最小值，则入辅助栈
        if (minStack.isEmpty() || val <= minStack.peek()) {
            minStack.push(val);
        }
    }

    public void pop() {
        // 弹出数据栈元素
        int val = stack.pop();
        // 如果弹出的元素等于当前最小值，辅助栈也要弹出
        // 注意：这里使用的是 int 基本类型比较，如果用 Integer 对象需用 equals
        if (val == minStack.peek()) {
            minStack.pop();
        }
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}
```

### 解法二：单栈存储差值（进阶优化空间）

**思路：**

虽然双栈法很清晰，但使用了一个额外的 $O(n)$ 空间。如果想要节省空间，可以在栈中存储 **当前值与最小值的差值**。

1.  用一个变量 `minVal` 记录当前最小值。
2.  **Push(val)**：入栈的是 `val - minVal`（差值）。如果 `val < minVal`，说明产生了新的最小值，更新 `minVal`。
3.  **Pop()**：弹出栈顶差值 `diff`。

    - 如果 `diff < 0`，说明入栈时更新了最小值（因为只有 `val < minVal` 才会产生负差值）。还原上一个最小值为 `minVal = minVal - diff`。

4.  **GetMin()**：直接返回 `minVal`。
5.  **注意**：由于差值可能溢出 `int` 范围（例如 `val` 是 `Integer.MAX_VALUE`, `minVal` 是 `Integer.MIN_VALUE`），栈需要存储 `long` 类型。

**复杂度分析：**

- **时间复杂度：** $O(1)$。
- **空间复杂度：** $O(1)$（不计算原本存储数据的栈空间，这里指没有使用额外的辅助栈结构）。

_(注：由于此方法涉及类型转换和溢出处理，面试中最推荐且最稳妥的仍是解法一的双栈法。下方的完整代码将采用双栈法实现。)_

### 完整代码

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class Main {

    // 定义 MinStack 类 (采用双栈法)
    static class MinStack {
        // 数据栈
        private Deque<Integer> stack;
        // 辅助栈（存最小值）
        private Deque<Integer> minStack;

        public MinStack() {
            // 使用 ArrayDeque 作为栈实现，性能优于 java.util.Stack
            stack = new ArrayDeque<>();
            minStack = new ArrayDeque<>();
        }

        public void push(int val) {
            stack.push(val);
            // 关键点：当 val <= 当前最小值时，才推入辅助栈
            // 这样保证 minStack 的栈顶始终是 stack 中的最小值
            // 使用 <= 是为了处理重复的最小值
            if (minStack.isEmpty() || val <= minStack.peek()) {
                minStack.push(val);
            }
        }

        public void pop() {
            if (stack.isEmpty()) return;

            int popVal = stack.pop();
            // 如果弹出的值等于当前的最小值，辅助栈也要弹出
            if (popVal == minStack.peek()) {
                minStack.pop();
            }
        }

        public int top() {
            return stack.peek();
        }

        public int getMin() {
            return minStack.peek();
        }
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        System.out.println("示例 1 开始测试:");

        MinStack minStack = new MinStack();

        System.out.println("push(-2)");
        minStack.push(-2);

        System.out.println("push(0)");
        minStack.push(0);

        System.out.println("push(-3)");
        minStack.push(-3);

        System.out.println("getMin() --> " + minStack.getMin()); // 预期: -3

        System.out.println("pop()");
        minStack.pop();

        System.out.println("top() --> " + minStack.top());       // 预期: 0

        System.out.println("getMin() --> " + minStack.getMin()); // 预期: -2

        System.out.println("-----------------------------");
        System.out.println("测试完成");
    }
}
```
