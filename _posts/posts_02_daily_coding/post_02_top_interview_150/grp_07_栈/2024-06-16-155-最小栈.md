---
title: 155-最小栈
date: 2024-06-16 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 栈]
tags: [栈]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121230116487.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


### 题目：155. 最小栈

**描述**
设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素 val 推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

**示例 1:**

- **输入:**
  `["MinStack","push","push","push","getMin","pop","top","getMin"]`
  `[[],[-2],[0],[-3],[],[],[],[]]`
- **输出:**
  `[null,null,null,null,-3,null,0,-2]`
- **解释:**
  `MinStack minStack = new MinStack();`
  `minStack.push(-2);`
  `minStack.push(0);`
  `minStack.push(-3);`
  `minStack.getMin();` `--> 返回 -3.`
  `minStack.pop();`
  `minStack.top();` `--> 返回 0.`
  `minStack.getMin();` `--> 返回 -2.`

**提示:**

- `-2^31 <= val <= 2^31 - 1`
- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用
- `push`, `pop`, `top`, and `getMin` 最多被调用 `3 * 10^4` 次

---

### 赛码网格式 Java 8 代码

_注意：本题要求实现一个类。为了符合赛码网的格式要求，我们将 `MinStack` 实现为一个独立的类，并在 `Main` 类的 `main` 方法中调用它来展示测试用例。_

```java
import java.util.Stack;

/**
 * MinStack 类，支持在常数时间内检索到最小元素的栈。
 * 为了符合题目要求，将 MinStack 定义为独立的公开类。
 */
class MinStack {
    // dataStack 用于存储所有元素
    private Stack<Integer> dataStack;
    // minStack 作为辅助栈，栈顶始终是当前 dataStack 中的最小值
    private Stack<Integer> minStack;

    /**
     * 初始化堆栈对象。
     */
    public MinStack() {
        dataStack = new Stack<>();
        minStack = new Stack<>();
    }

    /**
     * 将元素 val 推入堆栈。
     * @param val 要推入的元素
     */
    public void push(int val) {
        dataStack.push(val);
        // 如果辅助栈为空，或者新元素小于等于辅助栈的栈顶元素，则将新元素也推入辅助栈
        if (minStack.isEmpty() || val <= minStack.peek()) {
            minStack.push(val);
        }
    }

    /**
     * 删除堆栈顶部的元素。
     */
    public void pop() {
        Integer poppedValue = dataStack.pop();
        // 如果弹出的元素等于辅助栈的栈顶元素，则辅助栈也要弹出
        if (poppedValue.equals(minStack.peek())) {
            minStack.pop();
        }
    }

    /**
     * 获取堆栈顶部的元素。
     * @return 堆栈顶部的元素
     */
    public int top() {
        return dataStack.peek();
    }

    /**
     * 获取堆栈中的最小元素。
     * @return 堆栈中的最小元素
     */
    public int getMin() {
        return minStack.peek();
    }
}

public class Main {
    // main 方法放最下面
    public static void main(String[] args) {
        // 示例 1 测试
        System.out.println("--- 运行示例 1 ---");
        MinStack minStack = new MinStack();
        System.out.println("执行: MinStack()");

        minStack.push(-2);
        System.out.println("执行: push(-2)");

        minStack.push(0);
        System.out.println("执行: push(0)");

        minStack.push(-3);
        System.out.println("执行: push(-3)");

        int min1 = minStack.getMin();
        System.out.println("执行: getMin() -> 返回: " + min1); // 预期: -3

        minStack.pop();
        System.out.println("执行: pop()");

        int top = minStack.top();
        System.out.println("执行: top() -> 返回: " + top); // 预期: 0

        int min2 = minStack.getMin();
        System.out.println("执行: getMin() -> 返回: " + min2); // 预期: -2
    }
}
```
