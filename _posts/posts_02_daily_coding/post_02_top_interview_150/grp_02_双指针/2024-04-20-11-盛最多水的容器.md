---
title: 11. 盛最多水的容器
date: 2024-04-20 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 双指针]
tags: [双指针]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121223915220.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：** 你不能倾斜容器。

**示例 1:**

- **输入:** `[1,8,6,2,5,4,8,3,7]`
- **输出:** 49
- **解释:** 图中垂直线代表输入数组 `[1,8,6,2,5,4,8,3,7]`。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

**示例 2:**

- **输入:** `height = [1,1]`
- **输出:** 1

**提示:**

- `n == height.length`
- `2 <= n <= 10^5`
- `0 <= height[i] <= 10^4`

## 题解

### 解法：双指针法（贪心策略）

**思路：**

这是一道经典的双指针题目。决定容器容积的因素有两个：**两线之间的距离（宽度）** 和 **两线中较短的那条线的高度（高度）**。即 `Area = (right - left) * min(height[left], height[right])`。

我们希望找到最大的 Area。

1.  **初始化**：定义两个指针 `left` 指向数组开头，`right` 指向数组结尾。此时宽度最大。
2.  **移动策略**：

    - 计算当前面积，更新最大值。
    - 我们需要决定移动哪个指针。
    - 如果移动**较高**的那条线：宽度减小，而新的高度不可能超过原来的短板（受限于短板原理），所以面积**一定变小**。
    - 如果移动**较矮**的那条线：宽度减小，但新遇到的线可能更高，从而弥补宽度的损失，面积**可能变大**。
    - **结论**：每次都移动高度较小的那一端的指针。

通过不断向内收缩，直到两个指针相遇，我们就能遍历所有“可能成为最大面积”的情况。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是数组的长度。双指针总共遍历一次数组。
- **空间复杂度：** $O(1)$，只需要常数级别的额外空间。

**代码片段：**

```java
public int maxArea(int[] height) {
    int left = 0, right = height.length - 1;
    int maxArea = 0;

    while (left < right) {
        // 计算当前面积：宽 * 高（取决于短板）
        int currentArea = (right - left) * Math.min(height[left], height[right]);
        maxArea = Math.max(maxArea, currentArea);

        // 移动较矮的那一端
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    return maxArea;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现：双指针法
    public static int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int maxArea = 0;

        while (left < right) {
            // 计算面积 = 宽度 * 最短的高度
            int h = Math.min(height[left], height[right]);
            int w = right - left;
            int area = h * w;

            maxArea = Math.max(maxArea, area);

            // 贪心策略：谁矮谁移动
            // 因为如果移动高的一端，宽度变小，高度限制依然是原来的矮端（甚至更矮），面积只会减小
            // 只有移动矮的一端，才有可能找到更高的线来提升短板高度
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return maxArea;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] height1 = new int[]{1, 8, 6, 2, 5, 4, 8, 3, 7};

        System.out.println("示例 1 输入:");
        System.out.println("height = " + Arrays.toString(height1));

        int result1 = maxArea(height1);

        System.out.println("示例 1 输出: " + result1);
        // 解释: max(8, 7) * dist(index 1 to 8) = 7 * 7 = 49
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] height2 = new int[]{1, 1};

        System.out.println("示例 2 输入:");
        System.out.println("height = " + Arrays.toString(height2));

        int result2 = maxArea(height2);

        System.out.println("示例 2 输出: " + result2);
    }
}
```
