---
title: 167. 两数之和II-输入有序数组
date: 2024-04-18 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 双指针]
tags: [双指针]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121223824449.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。

以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。

你可以假设每种输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。

你所设计的解决方案必须只使用常数级的额外空间。

**示例 1:**

- **输入:** `numbers = [2,7,11,15]`, `target = 9`
- **输出:** `[1,2]`
- **解释:** 2 与 7 之和等于目标数 9 。因此 index₁ = 1, index₂ = 2 。返回 `[1, 2]` 。

**示例 2:**

- **输入:** `numbers = [2,3,4]`, `target = 6`
- **输出:** `[1,3]`
- **解释:** 2 与 4 之和等于目标数 6 。因此 index₁ = 1, index₂ = 3 。返回 `[1, 3]` 。

**示例 3:**

- **输入:** `numbers = [-1,0]`, `target = -1`
- **输出:** `[1,2]`
- **解释:** -1 与 0 之和等于目标数 -1 。因此 index₁ = 1, index₂ = 2 。返回 `[1, 2]` 。

**提示:**

- `2 <= numbers.length <= 3 * 10^4`
- `-1000 <= numbers[i] <= 1000`
- `numbers` 按 **非递减顺序** 排列
- `-1000 <= target <= 1000`
- **仅存在一个有效答案**

## 题解

### 解法：双指针法

**思路：**

由于数组已经按 **非递减顺序**（升序）排列，我们可以利用这一特性使用 **双指针**（对撞指针）来解决问题，从而避免使用 $O(n^2)$ 的暴力解法或 $O(n)$ 空间的哈希表解法。

1.  定义两个指针：

    - `left` 指向数组头部（最小元素）。
    - `right` 指向数组尾部（最大元素）。

2.  计算当前两个指针指向元素的和 `sum = numbers[left] + numbers[right]`：

    - 如果 `sum == target`：说明找到了目标组合。由于题目要求返回下标从 1 开始，所以返回 `[left + 1, right + 1]`。
    - 如果 `sum < target`：说明当前的和太小了。因为 `numbers[right]` 已经是当前范围内最大的数了，所以我们必须让 `left` 指针向右移动，以获得更大的数。
    - 如果 `sum > target`：说明当前的和太大了。因为 `numbers[left]` 已经是当前范围内最小的数了，所以我们必须让 `right` 指针向左移动，以获得更小的数。

3.  重复上述步骤，直到找到答案（题目保证一定存在唯一解）。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是数组的长度。两个指针移动的总次数最多为 $n$ 次。
- **空间复杂度：** $O(1)$，只需要常数级别的额外空间用于存储指针变量。

**代码片段：**

```java
public int[] twoSum(int[] numbers, int target) {
    int left = 0;
    int right = numbers.length - 1;

    while (left < right) {
        int sum = numbers[left] + numbers[right];
        if (sum == target) {
            // 题目要求下标从 1 开始
            return new int[]{left + 1, right + 1};
        } else if (sum < target) {
            // 和太小，左指针右移变大
            left++;
        } else {
            // 和太大，右指针左移变小
            right--;
        }
    }
    return new int[]{-1, -1}; // 理论上不会执行到这里，因为题目保证有解
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现：双指针法
    public static int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;

        while (left < right) {
            int sum = numbers[left] + numbers[right];

            if (sum == target) {
                // 找到了目标，返回下标（注意题目要求下标从 1 开始）
                return new int[]{left + 1, right + 1};
            } else if (sum < target) {
                // 当前和小于目标值，需要更大的数，左指针右移
                left++;
            } else {
                // 当前和大于目标值，需要更小的数，右指针左移
                right--;
            }
        }

        // 题目保证有唯一解，所以这里实际上不会执行到
        return new int[]{-1, -1};
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] numbers1 = new int[]{2, 7, 11, 15};
        int target1 = 9;

        System.out.println("示例 1 输入:");
        System.out.println("numbers = " + Arrays.toString(numbers1) + ", target = " + target1);

        int[] result1 = twoSum(numbers1, target1);

        System.out.println("示例 1 输出: " + Arrays.toString(result1));
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] numbers2 = new int[]{2, 3, 4};
        int target2 = 6;

        System.out.println("示例 2 输入:");
        System.out.println("numbers = " + Arrays.toString(numbers2) + ", target = " + target2);

        int[] result2 = twoSum(numbers2, target2);

        System.out.println("示例 2 输出: " + Arrays.toString(result2));
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        int[] numbers3 = new int[]{-1, 0};
        int target3 = -1;

        System.out.println("示例 3 输入:");
        System.out.println("numbers = " + Arrays.toString(numbers3) + ", target = " + target3);

        int[] result3 = twoSum(numbers3, target3);

        System.out.println("示例 3 输出: " + Arrays.toString(result3));
    }
}
```
