---
title: 167-两数之和II-输入有序数组
date: 2024-04-18 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 双指针]
tags: [双指针]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121223824449.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

好的，这是图片中问题的整理以及符合要求的 Java 8 解答。

### 题目：167. 两数之和 II - 输入有序数组

**描述**
给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。

以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。

你可以假设每种输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。

你所设计的解决方案必须只使用常数级的额外空间。

**示例 1:**

- **输入:** `numbers = [2,7,11,15]`, `target = 9`
- **输出:** `[1,2]`
- **解释:** 2 与 7 之和等于目标数 9 。因此 index₁ = 1, index₂ = 2 。返回 `[1, 2]` 。

**示例 2:**

- **输入:** `numbers = [2,3,4]`, `target = 6`
- **输出:** `[1,3]`
- **解释:** 2 与 4 之和等于目标数 6 。因此 index₁ = 1, index₂ = 3 。返回 `[1, 3]` 。

**示例 3:**

- **输入:** `numbers = [-1,0]`, `target = -1`
- **输出:** `[1,2]`
- **解释:** -1 与 0 之和等于目标数 -1 。因此 index₁ = 1, index₂ = 2 。返回 `[1, 2]` 。

**提示:**

- `2 <= numbers.length <= 3 * 10^4`
- `-1000 <= numbers[i] <= 1000`
- `numbers` 按 **非递减顺序** 排列
- `-1000 <= target <= 1000`
- **仅存在一个有效答案**

---

### 赛码网格式 Java 8 代码

````java
import java.util.Arrays;

public class Main {

    /**
     * 在有序数组中找出和为目标值的两个数的下标。
     * 采用双指针法，时间复杂度 O(n)，空间复杂度 O(1)。
     *
     * @param numbers 有序整数数组（下标从1开始）
     * @param target  目标值
     * @return 包含两个整数下标（从1开始）的数组
     */
    public static int[] twoSum(int[] numbers, int target) {
        // left 指针从数组头部开始
        int left = 0;
        // right 指针从数组尾部开始
        int right = numbers.length - 1;

        // 当左右指针相遇前，持续搜索
        while (left < right) {
            int sum = numbers[left] + numbers[right];

            if (sum == target) {
                // 找到了目标和，返回 1-based 的索引
                return new int[]{left + 1, right + 1};
            } else if (sum < target) {
                // 如果和太小，移动左指针以增大和
                left++;
            } else { // sum > target
                // 如果和太大，移动右指针以减小和
                right--;
            }
        }

        // 根据题目提示，保证有解，所以这里理论上不会被执行
        return new int[]{-1, -1};
    }

    public static void main(String[] args) {
        // 示例 1
        int[] numbers1 = {2, 7, 11, 15};
        int target1 = 9;
        System.out.println("输入: numbers = " + Arrays.toString(numbers1) + ", target = " + target1);
        int[] result1 = twoSum(numbers1, target1);
        System.out.println("输出: " + Arrays.toString(result1)); // 预期: [1, 2]
        System.out.println("---");

        // 示例 2
        int[] numbers2 = {2, 3, 4};
        int target2 = 6;
        System.out.println("输入: numbers = " + Arrays.toString(numbers2) + ", target = " + target2);
        int[] result2 = twoSum(numbers2, target2);
        System.out.println("输出: " + Arrays.toString(result2)); // 预期: [1, 3]
        System.out.println("---");

        // 示例 3
        int[] numbers3 = {-1, 0};
        int target3 = -1;
        System.out.println("输入: numbers = " + Arrays.toString(numbers3) + ", target = " + target3);
        int[] result3 = twoSum(numbers3, target3);
        System.out.println("输出: " + Arrays.toString(result3)); // 预期: [1, 2]
        System.out.println("---");
    }
}```
````
