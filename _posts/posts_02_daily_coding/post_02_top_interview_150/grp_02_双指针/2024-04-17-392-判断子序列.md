---
title: 392. 判断子序列
date: 2024-04-17 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 双指针]
tags: [双指针]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121223734636.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。

**进阶:**
如果有大量输入的 S，称作 S1, S2, ..., Sk 其中 k >= 10 亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

**示例 1:**

- **输入:** `s = "abc"`, `t = "ahbgdc"`
- **输出:** `true`

**示例 2:**

- **输入:** `s = "axc"`, `t = "ahbgdc"`
- **输出:** `false`

**提示:**

- `0 <= s.length <= 100`
- `0 <= t.length <= 10^4`
- 两个字符串都只由小写字母组成。

## 题解

### 解法一：双指针（标准解法）

**思路：**

这是最基础的贪心匹配思路。我们需要在 `t` 中按顺序找到 `s` 的所有字符。

1.  定义两个指针 `i` 和 `j`，分别指向 `s` 和 `t` 的开头。
2.  遍历字符串 `t`（即 `j` 不断向后移动）：

    - 如果 `s[i]` 和 `t[j]` 相等，说明找到了一个匹配字符，此时 `s` 的指针 `i` 向后移动一位。
    - 无论是否匹配，`t` 的指针 `j` 都要向后移动，继续寻找下一个机会。

3.  检查结果：如果 `i` 移动到了 `s` 的末尾（即 `i == s.length()`），说明 `s` 的所有字符都在 `t` 中按顺序找到了。

**复杂度分析：**

- **时间复杂度：** $O(n)$，其中 $n$ 是字符串 `t` 的长度。我们只需要遍历一次 `t`。
- **空间复杂度：** $O(1)$，只使用了两个指针变量。

**代码片段：**

```java
public boolean isSubsequence(String s, String t) {
    int n = s.length(), m = t.length();
    int i = 0, j = 0;
    while (i < n && j < m) {
        if (s.charAt(i) == t.charAt(j)) {
            i++;
        }
        j++;
    }
    return i == n;
}
```

### 解法二：进阶解法（预处理 + 二分查找）

**思路：**

针对**进阶问题**：如果有大量输入的 `S`（比如 10 亿个），但 `t` 是固定的。使用解法一的话，每次查询都要遍历 `t`，总耗时极高。

我们可以对 `t` 进行预处理，以加速对每一个 `s` 的查询。

1.  **预处理**：构建一个哈希表或数组（大小 26），记录 `t` 中每个字符出现的所有下标位置。例如 `t = "bahbgdca"`，则 `'a'` 对应的下标列表为 `[1, 7]`。
2.  **查询**：

    - 遍历 `s` 中的每个字符。
    - 维护一个变量 `currentIdx`（初始为 -1），表示上一个字符在 `t` 中匹配到的位置。
    - 对于当前字符，我们需要在它的下标列表中，找到**第一个大于** `currentIdx` 的下标。
    - 由于下标列表是有序的，可以使用 **二分查找** 来快速定位。
    - 如果找不到符合条件的下标，说明无法形成子序列，返回 `false`。
    - 如果找到，更新 `currentIdx` 为找到的下标，继续处理下一个字符。

**复杂度分析：**

- **时间复杂度：**

  - 预处理：$O(n)$，遍历一次 `t`。
  - 单次查询：$O(m \log n)$，其中 $m$ 是 `s` 的长度。对于 `s` 的每个字符，在长度不超过 $n$ 的列表中进行二分查找。

- **空间复杂度：** $O(n)$，用于存储字符索引列表。

**代码片段：**

```java
// 预处理部分
List<Integer>[] indexMap = new ArrayList[26];
for (int i = 0; i < 26; i++) indexMap[i] = new ArrayList<>();
for (int i = 0; i < t.length(); i++) {
    indexMap[t.charAt(i) - 'a'].add(i);
}

// 查询部分 (针对某一个 s)
int currentIdx = -1;
for (char c : s.toCharArray()) {
    List<Integer> list = indexMap[c - 'a'];
    // 使用二分查找寻找 list 中第一个大于 currentIdx 的元素
    // 这里简化为手写二分，或者使用 Collections.binarySearch 后处理
    int left = 0, right = list.size() - 1;
    int foundIdx = -1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (list.get(mid) > currentIdx) {
            foundIdx = list.get(mid);
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    if (foundIdx == -1) return false;
    currentIdx = foundIdx;
}
return true;
```

### 完整代码

这里提供最通用的**解法一（双指针）** 的可运行代码。

```java
public class Main {

    // 核心算法实现：双指针法
    public static boolean isSubsequence(String s, String t) {
        // 如果 s 比 t 长，肯定不是子序列
        if (s.length() > t.length()) {
            return false;
        }
        // 如果 s 为空，空串是任何字符串的子序列
        if (s.length() == 0) {
            return true;
        }

        int i = 0; // 指向 s
        int j = 0; // 指向 t

        while (i < s.length() && j < t.length()) {
            // 如果字符匹配，s 的指针向后移
            if (s.charAt(i) == t.charAt(j)) {
                i++;
            }
            // t 的指针始终向后移
            j++;
        }

        // 如果 i 走到了 s 的末尾，说明 s 的所有字符都匹配成功
        return i == s.length();
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        String s1 = "abc";
        String t1 = "ahbgdc";

        System.out.println("示例 1 输入: s = \"" + s1 + "\", t = \"" + t1 + "\"");
        System.out.println("示例 1 输出: " + isSubsequence(s1, t1));
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        String s2 = "axc";
        String t2 = "ahbgdc";

        System.out.println("示例 2 输入: s = \"" + s2 + "\", t = \"" + t2 + "\"");
        System.out.println("示例 2 输出: " + isSubsequence(s2, t2));
    }
}
```
