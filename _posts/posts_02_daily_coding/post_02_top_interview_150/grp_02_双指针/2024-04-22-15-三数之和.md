---
title: 15. 三数之和
date: 2024-04-22 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 双指针]
tags: [双指针]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121223947093.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：** 答案中不可以包含重复的三元组。

**示例 1:**

- **输入:** `nums = [-1,0,1,2,-1,-4]`
- **输出:** `[[-1,-1,2],[-1,0,1]]`
- **解释:**

  - `nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0` 。
  - `nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0` 。
  - `nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0` 。
  - 不同的三元组是 `[-1,0,1]` 和 `[-1,-1,2]` 。
  - 注意，输出的顺序和三元组的顺序并不重要。

**示例 2:**

- **输入:** `nums = [0,1,1]`
- **输出:** `[]`
- **解释:** 唯一可能的三元组和不为 0 。

**示例 3:**

- **输入:** `nums = [0,0,0]`
- **输出:** `[[0,0,0]]`
- **解释:** 唯一可能的三元组和为 0 。

**提示:**

- `3 <= nums.length <= 3000`
- `-10^5 <= nums[i] <= 10^5`

## 题解

### 解法：排序 + 双指针

**思路：**

这是一道经典的数组题目，旨在寻找满足特定条件的三个数。暴力遍历三个数的时间复杂度为 $O(N^3)$，对于数据规模 $N=3000$ 来说会超时。我们可以利用**排序**和**双指针**将时间复杂度降低到 $O(N^2)$。

1.  **排序**：首先将数组从小到大排序。排序是为了方便后续去重和使用双指针移动。
2.  **遍历**：遍历数组，固定第一个数 `nums[i]`。

    - 如果 `nums[i] > 0`，由于数组有序，后面的数肯定都大于 0，不可能相加为 0，直接结束遍历。
    - **去重（关键）**：如果 `i > 0` 且 `nums[i] == nums[i-1]`，说明这个数作为第一个数已经处理过，为了避免重复结果，跳过当前循环。

3.  **双指针寻找**：对于固定的 `nums[i]`，在剩余数组 `[i+1, n-1]` 区间内寻找两个数 `nums[L]` 和 `nums[R]`，使得 `nums[i] + nums[L] + nums[R] == 0`。

    - 令 `L = i + 1`，`R = n - 1`。
    - 当 `L < R` 时，计算 `sum = nums[i] + nums[L] + nums[R]`：

      - 若 `sum == 0`：找到一组解，加入结果集。同时将 `L` 右移，`R` 左移。

        - **内部去重**：移动后，如果 `nums[L] == nums[L-1]`，继续右移；如果 `nums[R] == nums[R+1]`，继续左移，直到指向不重复的元素。

      - 若 `sum < 0`：说明和太小，需要更大的数，`L` 右移。
      - 若 `sum > 0`：说明和太大，需要更小的数，`R` 左移。

**复杂度分析：**

- **时间复杂度：** $O(N^2)$。排序的时间复杂度为 $O(N \log N)$，遍历数组需要 $O(N)$，双指针遍历需要 $O(N)$，总计 $O(N^2)$。
- **空间复杂度：** $O(\log N)$ 或 $O(N)$，取决于排序算法的空间消耗。我们忽略存储答案的空间。

**代码片段：**

```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> ans = new ArrayList<>();
    if (nums == null || nums.length < 3) return ans;

    Arrays.sort(nums); // 1. 排序

    for (int i = 0; i < nums.length; i++) {
        // 如果第一个数已经大于 0，后面不可能凑出 0
        if (nums[i] > 0) break;

        // 2. 对第一个数去重
        if (i > 0 && nums[i] == nums[i - 1]) continue;

        int L = i + 1;
        int R = nums.length - 1;

        // 3. 双指针寻找
        while (L < R) {
            int sum = nums[i] + nums[L] + nums[R];
            if (sum == 0) {
                ans.add(Arrays.asList(nums[i], nums[L], nums[R]));
                // 找到答案后，先移动指针
                L++;
                R--;
                // 4. 对第二、第三个数去重
                while (L < R && nums[L] == nums[L - 1]) L++;
                while (L < R && nums[R] == nums[R + 1]) R--;
            } else if (sum < 0) {
                L++;
            } else {
                R--;
            }
        }
    }
    return ans;
}
```

### 完整代码

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Main {

    // 核心算法实现：排序 + 双指针
    public static List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        // 边界条件判断
        if (nums == null || nums.length < 3) return ans;

        // 步骤 1: 排序
        Arrays.sort(nums);

        for (int i = 0; i < nums.length; i++) {
            // 优化：如果当前数字大于 0，则三数之和一定大于 0，直接结束
            if (nums[i] > 0) break;

            // 步骤 2: 第一个数去重
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            int L = i + 1;
            int R = nums.length - 1;

            // 步骤 3: 双指针寻找另外两个数
            while (L < R) {
                int sum = nums[i] + nums[L] + nums[R];

                if (sum == 0) {
                    ans.add(Arrays.asList(nums[i], nums[L], nums[R]));

                    // 移动指针，准备寻找下一组
                    L++;
                    R--;

                    // 步骤 4: 第二个数和第三个数去重
                    while (L < R && nums[L] == nums[L - 1]) L++;
                    while (L < R && nums[R] == nums[R + 1]) R--;
                }
                else if (sum < 0) {
                    // 和小于 0，说明 L 太小，需要右移
                    L++;
                }
                else {
                    // 和大于 0，说明 R 太大，需要左移
                    R--;
                }
            }
        }
        return ans;
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1 = {-1, 0, 1, 2, -1, -4};
        System.out.println("示例 1 输入: " + Arrays.toString(nums1));
        List<List<Integer>> res1 = threeSum(nums1);
        System.out.println("示例 1 输出: " + res1);
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums2 = {0, 1, 1};
        System.out.println("示例 2 输入: " + Arrays.toString(nums2));
        List<List<Integer>> res2 = threeSum(nums2);
        System.out.println("示例 2 输出: " + res2);
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        int[] nums3 = {0, 0, 0};
        System.out.println("示例 3 输入: " + Arrays.toString(nums3));
        List<List<Integer>> res3 = threeSum(nums3);
        System.out.println("示例 3 输出: " + res3);
    }
}
```
