---
title: 918. 环形子数组的最大和
date: 2024-10-04 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, Kadane算法]
tags: [Kadane算法]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234234163.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个长度为 `n` 的 **环形** 整数数组 `nums`，返回 `nums` 的非空 **子数组** 的最大可能和。

**环形数组** 意味着数组的末端将会与开头相连呈环状。形式上，`nums[i]` 的下一个元素是 `nums[(i + 1) % n]`，`nums[i]` 的前一个元素是 `nums[(i - 1 + n) % n]`。

**子数组** 最多只能包含固定缓冲区 `nums` 中的每个元素一次。形式上，对于子数组 `nums[i], nums[i + 1], ..., nums[j]`，不存在 `i <= k1, k2 <= j` 其中 `k1 % n == k2 % n`。

**示例 1:**

- **输入:** `nums = [1,-2,3,-2]`
- **输出:** 3
- **解释:** 从子数组 `[3]` 得到最大和 3

**示例 2:**

- **输入:** `nums = [5,-3,5]`
- **输出:** 10
- **解释:** 从子数组 `[5,5]` 得到最大和 5 + 5 = 10

**示例 3:**

- **输入:** `nums = [3,-2,2,-3]`
- **输出:** 3
- **解释:** 从子数组 `[3]` 和 `[3,-2,2]` 都可以得到最大和 3

**提示:**

- `n == nums.length`
- `1 <= n <= 3 * 10^4`
- `-3 * 10^4 <= nums[i] <= 3 * 10^4`

## 题解

### 解法：Kadane 算法变体 (Kadane's Algorithm Variant)

**思路：**

我们要找的环形子数组最大和，实际上只有两种情况：

1.  **情况一：最大子数组没有跨越边界（没有成环）。**

    这种情况就是普通的“最大子数组和”问题，可以直接使用 **Kadane 算法** 求解。

    - 我们计算普通的最大子数组和，记为 `maxSum`。

2.  **情况二：最大子数组跨越了边界（成环）。**

    如果最大子数组一部分在数组头部，一部分在数组尾部，那么剩下的**中间部分**就是一个连续的子数组。

    - 要让“首尾两段之和”最大，等价于让“中间这段子数组之和”最小。
    - 即：`环形最大和 = 数组总和 - 最小子数组和`。
    - 我们需要计算数组的总和 `totalSum`，以及普通的最小子数组和 `minSum`。

**最终结果：**

一般情况下，结果是 `Math.max(maxSum, totalSum - minSum)`。

**特殊情况处理：**

如果数组全是负数（例如 `[-3, -2, -3]`）：

- `maxSum` 会是 `-2`（最大的那个负数）。
- `minSum` 会是 `-8`（也就是 `totalSum`）。
- `totalSum - minSum` 会是 `0`。
- 我们不能返回 0，因为题目要求子数组**非空**。
- 因此，如果 `maxSum < 0`，说明所有数都是负数，直接返回 `maxSum` 即可。

**复杂度分析：**

- **时间复杂度：** $O(N)$，只需要遍历一次数组，同时计算最大子数组和、最小子数组和以及总和。
- **空间复杂度：** $O(1)$，只需要常数个变量。

**代码片段：**

```java
public int maxSubarraySumCircular(int[] nums) {
    int totalSum = 0;
    int curMax = 0, maxSum = nums[0];
    int curMin = 0, minSum = nums[0];

    for (int num : nums) {
        // 计算最大子数组和 (Kadane)
        curMax = Math.max(curMax + num, num);
        maxSum = Math.max(maxSum, curMax);

        // 计算最小子数组和 (Kadane 变体)
        curMin = Math.min(curMin + num, num);
        minSum = Math.min(minSum, curMin);

        // 计算总和
        totalSum += num;
    }

    // 特殊情况：如果全是负数，maxSum 会小于 0，此时直接返回 maxSum
    // 否则比较 "不跨越边界的最大值" 和 "跨越边界的最大值 (总和 - 最小值)"
    if (maxSum < 0) {
        return maxSum;
    } else {
        return Math.max(maxSum, totalSum - minSum);
    }
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    /**
     * 求解环形子数组的最大和
     */
    public static int maxSubarraySumCircular(int[] nums) {
        if (nums == null || nums.length == 0) return 0;

        int totalSum = 0;

        // 初始化最大和与最小和相关变量
        // curMax/curMin 表示以当前元素结尾的连续子数组的最大/最小和
        int curMax = 0;
        int maxSum = nums[0];

        int curMin = 0;
        int minSum = nums[0];

        for (int num : nums) {
            // 1. 标准 Kadane 算法求最大子数组和
            curMax = Math.max(num, curMax + num);
            maxSum = Math.max(maxSum, curMax);

            // 2. 标准 Kadane 算法求最小子数组和
            curMin = Math.min(num, curMin + num);
            minSum = Math.min(minSum, curMin);

            // 3. 累加总和
            totalSum += num;
        }

        // 边界情况处理：
        // 如果 maxSum < 0，说明数组中所有元素都是负数。
        // 此时 totalSum - minSum 必然为 0（因为 minSum 等于 totalSum），
        // 这意味着我们减去了整个数组，导致子数组为空，不符合题目"非空"要求。
        // 所以这种情况下，直接返回 maxSum（即数组中最大的单个元素）。
        if (maxSum < 0) {
            return maxSum;
        }

        // 结果取两种情况的最大值：
        // 1. 不成环：maxSum
        // 2. 成环：totalSum - minSum
        return Math.max(maxSum, totalSum - minSum);
    }

    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1 = {1, -2, 3, -2};
        System.out.println("示例 1 输入: " + Arrays.toString(nums1));
        System.out.println("示例 1 输出: " + maxSubarraySumCircular(nums1));
        // 解释: 子数组 [3] 最大，为 3。注意如果跨越边界 [3, -2, 1] 和为 2，不如直接取 3。
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums2 = {5, -3, 5};
        System.out.println("示例 2 输入: " + Arrays.toString(nums2));
        System.out.println("示例 2 输出: " + maxSubarraySumCircular(nums2));
        // 解释: 跨越边界 [5, 5] 和为 10。
        // 计算过程: total=7, minSum=-3 (中间那个), maxResult = 7 - (-3) = 10。
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        int[] nums3 = {3, -2, 2, -3};
        System.out.println("示例 3 输入: " + Arrays.toString(nums3));
        System.out.println("示例 3 输出: " + maxSubarraySumCircular(nums3));
        // 解释: 最大子数组为 [3] 或 [3, -2, 2]，结果为 3。
        System.out.println("-----------------------------");

        // --- 额外示例：全负数 ---
        int[] nums4 = {-3, -2, -3};
        System.out.println("示例 4 (全负数) 输入: " + Arrays.toString(nums4));
        System.out.println("示例 4 输出: " + maxSubarraySumCircular(nums4));
        // 解释: total=-8, minSum=-8, total-min=0。但在全负数情况下应返回 -2。
    }
}
```
