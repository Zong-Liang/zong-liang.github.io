---
title: 918. 环形子数组的最大和
date: 2024-10-04 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, Kadane算法]
tags: [Kadane算法]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234234163.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：918. 环形子数组的最大和

给定一个长度为 `n` 的 **环形** 整数数组 `nums`，返回 `nums` 的非空 **子数组** 的最大可能和。

**环形数组** 意味着数组的末端将会与开头相连呈环状。形式上，`nums[i]` 的下一个元素是 `nums[(i + 1) % n]`，`nums[i]` 的前一个元素是 `nums[(i - 1 + n) % n]`。

**子数组** 最多只能包含固定缓冲区 `nums` 中的每个元素一次。形式上，对于子数组 `nums[i], nums[i + 1], ..., nums[j]`，不存在 `i <= k1, k2 <= j` 其中 `k1 % n == k2 % n`。

**示例 1:**

- **输入:** `nums = [1,-2,3,-2]`
- **输出:** 3
- **解释:** 从子数组 `[3]` 得到最大和 3

**示例 2:**

- **输入:** `nums = [5,-3,5]`
- **输出:** 10
- **解释:** 从子数组 `[5,5]` 得到最大和 5 + 5 = 10

**示例 3:**

- **输入:** `nums = [3,-2,2,-3]`
- **输出:** 3
- **解释:** 从子数组 `[3]` 和 `[3,-2,2]` 都可以得到最大和 3

**提示:**

- `n == nums.length`
- `1 <= n <= 3 * 10^4`
- `-3 * 10^4 <= nums[i] <= 3 * 10^4`

## 题解

**算法思路：(Kadane's 算法变体)**

环形数组的最大子数组和存在两种情况：

1.  **情况一：最大子数组位于数组中间，不跨越边界。**

    - 这种情况就是标准的“最大子数组和”问题，可以直接使用 **Kadane's 算法** 求解。

2.  **情况二：最大子数组跨越了数组的头尾。**
    - 例如 `[5, -3, 5]` 中的 `[5, 5]`。
    - 这种跨越头尾的最大和，等价于 **数组的总和** 减去 **数组中间部分的最小子数组和**。
    - 例如，`[5, -3, 5]` 的总和是 `7`，中间的最小子数组是 `[-3]`，其和为 `-3`。最大和就是 `7 - (-3) = 10`。
    - 最小子数组和也可以通过 Kadane's 算法的变体来求解（在每一步取 `min` 而不是 `max`）。

**综合与特殊情况：**

- 最终的结果就是上述两种情况中的较大值：`max(情况一的最大和, 总和 - 情况二的最小和)`。
- 需要注意一个特殊情况：如果数组中所有元素都是负数，那么情况一会得到最大的那个负数（正确的），而情况二的 `总和 - 最小和` 会是 `0`（因为最小子数组就是整个数组本身）。在这种情况下，我们应该返回情况一的结果。我们可以通过判断 `情况一的最大和` 是否小于 0 来处理这个边界。

```java
import java.util.Arrays;


public class Main {

    /**
     * 返回环形子数组的最大可能和。
     *
     * @param nums 环形整数数组
     * @return 非空子数组的最大可能和
     */
    public static int maxSubarraySumCircular(int[] nums) {
        int totalSum = 0;

        // 使用 Kadane's 算法计算标准最大子数组和
        int currentMax = 0;
        int globalMax = Integer.MIN_VALUE;

        // 同时计算最小子数组和
        int currentMin = 0;
        int globalMin = Integer.MAX_VALUE;

        for (int num : nums) {
            // 计算最大子数组和
            currentMax = Math.max(num, currentMax + num);
            globalMax = Math.max(globalMax, currentMax);

            // 计算最小子数组和
            currentMin = Math.min(num, currentMin + num);
            globalMin = Math.min(globalMin, currentMin);

            // 计算数组总和
            totalSum += num;
        }

        // 判断结果
        // 如果 globalMax < 0，说明数组中所有元素都是负数。
        // 此时，最大子数组就是数组中最大的那个负数，即 globalMax。
        // 并且，最小子数组就是整个数组，totalSum == globalMin，
        // 导致 totalSum - globalMin = 0，这是错误的。
        if (globalMax < 0) {
            return globalMax;
        }

        // 比较两种情况：不跨越边界的最大和 vs 跨越边界的最大和
        return Math.max(globalMax, totalSum - globalMin);
    }


    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[] nums1 = {1, -2, 3, -2};
        System.out.println("输入: nums = " + Arrays.toString(nums1));
        int result1 = maxSubarraySumCircular(nums1);
        System.out.println("输出: " + result1); // 预期输出: 3
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[] nums2 = {5, -3, 5};
        System.out.println("输入: nums = " + Arrays.toString(nums2));
        int result2 = maxSubarraySumCircular(nums2);
        System.out.println("输出: " + result2); // 预期输出: 10
        System.out.println();

        System.out.println("--- 示例 3 ---");
        int[] nums3 = {3, -2, 2, -3};
        System.out.println("输入: nums = " + Arrays.toString(nums3));
        int result3 = maxSubarraySumCircular(nums3);
        System.out.println("输出: " + result3); // 预期输出: 3
        System.out.println();

        System.out.println("--- 特殊情况测试 ---");
        int[] nums4 = {-2, -3, -1};
        System.out.println("输入: nums = " + Arrays.toString(nums4));
        int result4 = maxSubarraySumCircular(nums4);
        System.out.println("输出: " + result4); // 预期输出: -1
    }
}
```
