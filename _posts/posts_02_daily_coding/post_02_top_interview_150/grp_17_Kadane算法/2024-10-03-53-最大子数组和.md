---
title: 53. 最大子数组和
date: 2024-10-03 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, Kadane算法]
tags: [Kadane算法]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234207752.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：53. 最大子数组和

给你一个整数数组 `nums`，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

**示例 1:**

- **输入:** `nums = [-2,1,-3,4,-1,2,1,-5,4]`
- **输出:** 6
- **解释:** 连续子数组 `[4,-1,2,1]` 的和最大，为 6。

**示例 2:**

- **输入:** `nums = [1]`
- **输出:** 1

**示例 3:**

- **输入:** `nums = [5,4,-1,7,8]`
- **输出:** 23

**提示:**

- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`

**进阶：** 如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。

## Java 代码

**算法思路：(动态规划 / Kadane's 算法)**

这是一个经典的动态规划问题，可以使用 Kadane's 算法在线性时间 O(n) 内解决。

我们遍历数组，维护两个变量：

1.  `currentMax`：表示以 **当前元素结尾** 的最大子数组和。
2.  `globalMax`：表示到目前为止找到的 **全局最大** 子数组和。

对于数组中的每一个元素 `num`，我们更新 `currentMax`：

- 要么将 `num` 接到之前的子数组上 (`currentMax + num`)。
- 要么从 `num` 开始一个新的子数组 (`num`)。
  我们取这两者中的较大值：`currentMax = Math.max(num, currentMax + num)`。

每更新完 `currentMax`，我们都用它来更新 `globalMax`：`globalMax = Math.max(globalMax, currentMax)`。

这个逻辑的核心是，如果以 `i-1` 结尾的子数组和为负数，那么它对以 `i` 结尾的子数组和只会产生负贡献，所以我们不如从 `i` 重新开始。

```java
import java.util.Arrays;


public class Main {

    /**
     * 找出具有最大和的连续子数组，返回其最大和。
     *
     * @param nums 整数数组
     * @return 最大子数组和
     */
    public static int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            // 根据题目限制，数组长度至少为1，但作为健壮性检查
            return 0;
        }

        // currentMax: 以当前元素结尾的最大子数组和
        // globalMax: 遍历至今找到的全局最大子数组和
        int currentMax = nums[0];
        int globalMax = nums[0];

        // 从第二个元素开始遍历
        for (int i = 1; i < nums.length; i++) {
            int num = nums[i];

            // 决定是延续前面的子数组，还是从当前元素开始一个新的子数组
            currentMax = Math.max(num, currentMax + num);

            // 更新全局最大值
            globalMax = Math.max(globalMax, currentMax);
        }

        return globalMax;
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        System.out.println("--- 示例 1 ---");
        int[] nums1 = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        System.out.println("输入: nums = " + Arrays.toString(nums1));
        int result1 = maxSubArray(nums1);
        System.out.println("输出: " + result1); // 预期输出: 6
        System.out.println();

        System.out.println("--- 示例 2 ---");
        int[] nums2 = {1};
        System.out.println("输入: nums = " + Arrays.toString(nums2));
        int result2 = maxSubArray(nums2);
        System.out.println("输出: " + result2); // 预期输出: 1
        System.out.println();

        System.out.println("--- 示例 3 ---");
        int[] nums3 = {5, 4, -1, 7, 8};
        System.out.println("输入: nums = " + Arrays.toString(nums3));
        int result3 = maxSubArray(nums3);
        System.out.println("输出: " + result3); // 预期输出: 23
        System.out.println();
    }
}
```
