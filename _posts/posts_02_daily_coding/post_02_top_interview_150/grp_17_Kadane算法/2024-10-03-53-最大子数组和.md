---
title: 53. 最大子数组和
date: 2024-10-03 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, Kadane算法]
tags: [Kadane算法]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121234207752.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个整数数组 `nums`，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

**示例 1:**

- **输入:** `nums = [-2,1,-3,4,-1,2,1,-5,4]`
- **输出:** 6
- **解释:** 连续子数组 `[4,-1,2,1]` 的和最大，为 6。

**示例 2:**

- **输入:** `nums = [1]`
- **输出:** 1

**示例 3:**

- **输入:** `nums = [5,4,-1,7,8]`
- **输出:** 23

**提示:**

- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`

**进阶：** 如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。

## 题解

### 解法一：动态规划 (Kadane 算法)

**思路：**

这是解决最大子数组和问题的**最优解法**，也被称为 Kadane 算法。

核心思想是遍历数组，判断：**“是保留之前的累加和，还是重新开始？”**

1.  定义一个变量 `pre`，表示**以当前元素结尾**的最大连续子数组和。
2.  遍历数组中的每个元素 `x`：

    - 如果 `pre` 大于 0，说明之前的累加对当前元素有增益，因此我们将当前元素加入之前的子数组：`pre = pre + x`。
    - 如果 `pre` 小于等于 0，说明之前的累加是负累赘或无增益，不如从当前元素重新开始：`pre = x`。

3.  在遍历过程中，用一个变量 `maxAns` 记录出现过的最大 `pre` 值。

**复杂度分析：**

- **时间复杂度：** $O(n)$，解释：只需要遍历一次数组。
- **空间复杂度：** $O(1)$，只需要常数个变量存储当前状态。

**代码片段：**

```java
public int maxSubArray(int[] nums) {
    int pre = 0;
    int maxAns = nums[0];
    for (int x : nums) {
        // 状态转移：取 "当前值" 和 "前缀和+当前值" 的较大者
        pre = Math.max(pre + x, x);
        // 更新全局最大值
        maxAns = Math.max(maxAns, pre);
    }
    return maxAns;
}
```

### 解法二：分治法 (Divide and Conquer) - 进阶解法

**思路：**

这个解法采用了类似**线段树**的思想。对于一个区间 `[l, r]`，我们维护四个量：

1.  `lSum`: 以区间左端点为起点的最大子段和。
2.  `rSum`: 以区间右端点为终点的最大子段和。
3.  `mSum`: 区间内的最大子段和（即答案）。
4.  `iSum`: 区间总和。

**如何合并两个子区间（左区间 `l` 和 右区间 `r`）？**

- `iSum`: 等于左区间的总和 + 右区间的总和。
- `lSum`: 要么是左区间的 `lSum`，要么是左区间的全部 `iSum` + 右区间的 `lSum`（跨越中点）。
- `rSum`: 要么是右区间的 `rSum`，要么是右区间的全部 `iSum` + 左区间的 `rSum`（跨越中点）。
- `mSum`: 可能是左区间的 `mSum`，可能是右区间的 `mSum`，也可能是跨越中点的部分（左区间的 `rSum` + 右区间的 `lSum`）。取这三者的最大值。

> **注意：** 虽然此方法的时间复杂度也是 $O(n)$，但在常数上比 Kadane 算法大，且空间复杂度较高（递归栈）。它的意义在于可以解决更复杂的区间查询问题（如 LeetCode 上的线段树题目）。

**复杂度分析：**

- **时间复杂度：** $O(n)$，递归方程为 $T(n) = 2T(n/2) + O(1)$，根据主定理，结果为 $O(n)$。
- **空间复杂度：** $O(\log n)$，递归栈的深度。

**代码片段：**

```java
public class Status {
    public int lSum, rSum, mSum, iSum;

    public Status(int lSum, int rSum, int mSum, int iSum) {
        this.lSum = lSum;
        this.rSum = rSum;
        this.mSum = mSum;
        this.iSum = iSum;
    }
}

public int maxSubArrayDivideConquer(int[] nums) {
    return getInfo(nums, 0, nums.length - 1).mSum;
}

private Status getInfo(int[] a, int l, int r) {
    if (l == r) {
        return new Status(a[l], a[l], a[l], a[l]);
    }
    int m = (l + r) >> 1;
    Status lSub = getInfo(a, l, m);
    Status rSub = getInfo(a, m + 1, r);
    return pushUp(lSub, rSub);
}

private Status pushUp(Status l, Status r) {
    int iSum = l.iSum + r.iSum;
    int lSum = Math.max(l.lSum, l.iSum + r.lSum);
    int rSum = Math.max(r.rSum, r.iSum + l.rSum);
    int mSum = Math.max(Math.max(l.mSum, r.mSum), l.rSum + r.lSum);
    return new Status(lSum, rSum, mSum, iSum);
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // --- 解法一：动态规划 (Kadane) ---
    public static int maxSubArray(int[] nums) {
        int pre = 0;
        int maxAns = nums[0];
        for (int x : nums) {
            // 如果前缀和大于0，则保留，否则舍弃
            pre = Math.max(pre + x, x);
            maxAns = Math.max(maxAns, pre);
        }
        return maxAns;
    }

    // --- 解法二：分治法 (线段树思路) ---
    static class Status {
        int lSum, rSum, mSum, iSum;
        // lSum: 以左端点为起点的最大子段和
        // rSum: 以右端点为终点的最大子段和
        // mSum: 区间内最大的子段和
        // iSum: 区间和

        public Status(int lSum, int rSum, int mSum, int iSum) {
            this.lSum = lSum;
            this.rSum = rSum;
            this.mSum = mSum;
            this.iSum = iSum;
        }
    }

    public static int maxSubArrayDivideConquer(int[] nums) {
        return getInfo(nums, 0, nums.length - 1).mSum;
    }

    private static Status getInfo(int[] a, int l, int r) {
        if (l == r) {
            return new Status(a[l], a[l], a[l], a[l]);
        }
        int m = (l + r) >> 1; // 右移一位，相当于除以2
        Status lSub = getInfo(a, l, m);
        Status rSub = getInfo(a, m + 1, r);
        return pushUp(lSub, rSub);
    }

    private static Status pushUp(Status l, Status r) {
        int iSum = l.iSum + r.iSum;
        // 新区间的 lSum 要么是左边的 lSum，要么是 左边全长 + 右边的 lSum
        int lSum = Math.max(l.lSum, l.iSum + r.lSum);
        // 新区间的 rSum 同理
        int rSum = Math.max(r.rSum, r.iSum + l.rSum);
        // 新区间的最大子段和，可能是左边的 mSum，右边的 mSum，或者跨越中间(左 rSum + 右 lSum)
        int mSum = Math.max(Math.max(l.mSum, r.mSum), l.rSum + r.lSum);
        return new Status(lSum, rSum, mSum, iSum);
    }


    public static void main(String[] args) {
        // --- 示例 1 ---
        int[] nums1 = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        System.out.println("示例 1 输入: " + Arrays.toString(nums1));
        System.out.println("DP 解法输出: " + maxSubArray(nums1));
        System.out.println("分治解法输出: " + maxSubArrayDivideConquer(nums1));
        System.out.println("-----------------------------");

        // --- 示例 2 ---
        int[] nums2 = {1};
        System.out.println("示例 2 输入: " + Arrays.toString(nums2));
        System.out.println("DP 解法输出: " + maxSubArray(nums2));
        System.out.println("分治解法输出: " + maxSubArrayDivideConquer(nums2));
        System.out.println("-----------------------------");

        // --- 示例 3 ---
        int[] nums3 = {5, 4, -1, 7, 8};
        System.out.println("示例 3 输入: " + Arrays.toString(nums3));
        System.out.println("DP 解法输出: " + maxSubArray(nums3));
        System.out.println("分治解法输出: " + maxSubArrayDivideConquer(nums3));
    }
}
```
