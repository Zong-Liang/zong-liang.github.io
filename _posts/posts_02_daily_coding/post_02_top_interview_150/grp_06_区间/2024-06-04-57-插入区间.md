---
title: 57. 插入区间
date: 2024-06-04 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 区间]
tags: [区间]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121225715612.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：57. 插入区间

**描述：**

给你一个 **无重叠** 的 ，按照区间起始端点排序的区间列表 `intervals` ，其中 `intervals[i] = [start_i, end_i]` 表示第 `i` 个区间的开始和结束，并且 `intervals` 按照 `start_i` **升序排列** 。

同样给定一个区间 `newInterval = [start, end]` 表示另一个区间的开始和结束。

在 `intervals` 中插入区间 `newInterval`，使得 `intervals` 依然按照 `start_i` 升序排列，且区间之间不重叠（如果有必要的话，可以合并区间）。

返回插入之后的 `intervals`。

**注意** 你不需要原地修改 `intervals`。你可以创建一个新数组然后返回它。

**示例 1:**

- **输入:** `intervals = [[1,3],[6,9]]`, `newInterval = [2,5]`
- **输出:** `[[1,5],[6,9]]`

**示例 2:**

- **输入:** `intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]]`, `newInterval = [4,8]`
- **输出:** `[[1,2],[3,10],[12,16]]`
- **解释:** 这是因为新的区间 `[4,8]` 与 `[3,5],[6,7],[8,10]` 重叠。

**提示:**

- `0 <= intervals.length <= 10^4`
- `intervals[i].length == 2`
- `0 <= start_i <= end_i <= 10^5`
- `intervals` 根据 `start_i` 按 **升序** 排列
- `newInterval.length == 2`
- `0 <= start <= end <= 10^5`

## 题解

### 解法：模拟（三阶段遍历）

**思路：**

由于原数组 `intervals` 已经是 **有序** 且 **无重叠** 的，我们不需要像“合并区间”题目那样对整个数组进行排序。我们可以利用这一特性，将整个处理过程分为三个阶段进行一次线性扫描：

1.  **左侧不重叠部分**：

    遍历数组，将所有结束位置小于 `newInterval` 开始位置的区间直接加入结果集。这些区间完全在 `newInterval` 的左边。

2.  **重叠合并部分**：

    继续遍历，如果当前区间的开始位置小于等于 `newInterval` 的结束位置，说明这两个区间发生了重叠。

    此时，我们不需要将当前区间加入结果集，而是更新 `newInterval` 的范围：

    - 新起点为两者起点的最小值：`min(current.start, newInterval.start)`
    - 新终点为两者终点的最大值：`max(current.end, newInterval.end)`
      重复此步骤直到没有重叠为止。循环结束后，将合并完成后的 `newInterval` 加入结果集。

3.  **右侧不重叠部分**：

    将剩余的所有区间（此时它们一定在 `newInterval` 的右边且无重叠）直接加入结果集。

**复杂度分析：**

- **时间复杂度：** $O(n)$。我们只需要遍历一次 `intervals` 数组。
- **空间复杂度：** $O(1)$。除了存储最终结果的列表外，我们只需要常数级别的额外空间来维护指针和更新区间范围。

**代码片段：**

```java
public int[][] insert(int[][] intervals, int[] newInterval) {
    List<int[]> result = new ArrayList<>();
    int i = 0;
    int n = intervals.length;

    // 1. 处理左边不重叠的区间
    // 如果当前区间的结束位置 < 新区间的开始位置，说明在左边且无交集
    while (i < n && intervals[i][1] < newInterval[0]) {
        result.add(intervals[i]);
        i++;
    }

    // 2. 处理重叠区间，进行合并
    // 只要当前区间的开始位置 <= 新区间的结束位置，说明有重叠（因为前面已经排除了完全在左边的情况）
    while (i < n && intervals[i][0] <= newInterval[1]) {
        // 更新新区间的范围
        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
        i++;
    }
    // 将合并后的新区间加入结果
    result.add(newInterval);

    // 3. 处理右边不重叠的区间
    while (i < n) {
        result.add(intervals[i]);
        i++;
    }

    return result.toArray(new int[result.size()][]);
}
```

### 完整代码

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Main {

    // 核心算法实现
    public static int[][] insert(int[][] intervals, int[] newInterval) {
        List<int[]> result = new ArrayList<>();
        int i = 0;
        int n = intervals.length;

        // 阶段 1: 将所有在 newInterval 左侧且无重叠的区间加入结果
        // 条件: current.end < new.start
        while (i < n && intervals[i][1] < newInterval[0]) {
            result.add(intervals[i]);
            i++;
        }

        // 阶段 2: 处理重叠区间，不断扩展 newInterval 的边界
        // 条件: current.start <= new.end (因为阶段1已保证 current.end >= new.start)
        while (i < n && intervals[i][0] <= newInterval[1]) {
            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
            i++;
        }
        // 将合并完成的 newInterval 加入
        result.add(newInterval);

        // 阶段 3: 将剩余在 newInterval 右侧的区间加入结果
        while (i < n) {
            result.add(intervals[i]);
            i++;
        }

        return result.toArray(new int[result.size()][]);
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int[][] intervals1 = {{1, 3}, {6, 9}};
        int[] newInterval1 = {2, 5};

        System.out.println("示例 1 输入:");
        System.out.println("intervals = " + Arrays.deepToString(intervals1));
        System.out.println("newInterval = " + Arrays.toString(newInterval1));

        int[][] res1 = insert(intervals1, newInterval1);
        System.out.println("示例 1 输出: " + Arrays.deepToString(res1));
        // 预期: [[1, 5], [6, 9]]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        int[][] intervals2 = {{1, 2}, {3, 5}, {6, 7}, {8, 10}, {12, 16}};
        int[] newInterval2 = {4, 8};

        System.out.println("示例 2 输入:");
        System.out.println("intervals = " + Arrays.deepToString(intervals2));
        System.out.println("newInterval = " + Arrays.toString(newInterval2));

        int[][] res2 = insert(intervals2, newInterval2);
        System.out.println("示例 2 输出: " + Arrays.deepToString(res2));
        // 预期: [[1, 2], [3, 10], [12, 16]]
        System.out.println("-----------------------------");

        // --- 示例 3 测试 (新区间在最前面) ---
        int[][] intervals3 = {{2, 3}, {5, 7}};
        int[] newInterval3 = {0, 1};

        System.out.println("示例 3 输入:");
        System.out.println("intervals = " + Arrays.deepToString(intervals3));
        System.out.println("newInterval = " + Arrays.toString(newInterval3));

        int[][] res3 = insert(intervals3, newInterval3);
        System.out.println("示例 3 输出: " + Arrays.deepToString(res3));
        // 预期: [[0, 1], [2, 3], [5, 7]]
    }
}
```
