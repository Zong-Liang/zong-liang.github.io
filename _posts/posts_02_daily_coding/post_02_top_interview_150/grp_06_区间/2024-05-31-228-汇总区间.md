---
title: 228. 汇总区间
date: 2024-05-31 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 区间]
tags: [区间]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121225620732.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给定一个 **无重复元素** 的 **有序** 整数数组 `nums` 。

区间 `[a,b]` 是从 `a` 到 `b` (包含) 的所有整数的集合。

返回 **恰好覆盖** 数组中所有数字的 **最小有序** 区间范围列表。也就是说，`nums` 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个区间但不属于 `nums` 的数字 `x` 。

列表中的每个区间范围 `[a,b]` 应该按如下格式输出：

- `"a->b"` ，如果 `a != b`
- `"a"` ，如果 `a == b`

**示例 1:**

- **输入:** `nums = [0,1,2,4,5,7]`
- **输出:** `["0->2","4->5","7"]`
- **解释:** 区间范围是:

  - `[0,2] --> "0->2"`
  - `[4,5] --> "4->5"`
  - `[7,7] --> "7"`

**示例 2:**

- **输入:** `nums = [0,2,3,4,6,8,9]`
- **输出:** `["0","2->4","6","8->9"]`
- **解释:** 区间范围是:

  - `[0,0] --> "0"`
  - `[2,4] --> "2->4"`
  - `[6,6] --> "6"`
  - `[8,9] --> "8->9"`

**提示:**

- `0 <= nums.length <= 20`
- `-2^31 <= nums[i] <= 2^31 - 1`
- `nums` 中的所有值都 **互不相同**
- `nums` 按 **升序** 排列

## 题解

### 解法：一次遍历（双指针/分组循环）

**思路：**

由于数组已经是 **有序** 且 **无重复** 的，连续的整数在数组下标上也是连续的。我们可以通过一次遍历，找出所有连续的子序列。

1.  **外层循环**：使用指针 `i` 遍历数组，每次循环开始时，`i` 指向当前区间的 **起点**（记为 `low`）。
2.  **内层查找**：向后移动 `i`，检查 `nums[i]` 和 `nums[i-1]` 是否满足 `nums[i] == nums[i-1] + 1`。

    - 如果满足，说明当前数字依然连续，继续后移。
    - 如果不满足（或者到达数组末尾），说明当前区间结束。此时 `i-1` 即为区间的 **终点**（记为 `high`）。

3.  **格式化输出**：

    - 如果 `low == high`，说明该区间只有一个数字，输出 `"low"`。
    - 如果 `low < high`，说明是一个范围，输出 `"nums[low]->nums[high]"`。

4.  **继续遍历**：内层查找结束后，`i` 已经指向了下一个新区间的起点，继续外层循环。

**复杂度分析：**

- **时间复杂度：** $O(n)$，虽然有双重循环，但在整个过程中，指针 `i` 只会从 0 增加到 $n$，每个元素只被访问一次。
- **空间复杂度：** $O(1)$，除了用于存储结果的列表外，不需要额外的辅助空间。

**代码片段：**

```java
public List<String> summaryRanges(int[] nums) {
    List<String> result = new ArrayList<>();
    int n = nums.length;
    int i = 0;

    while (i < n) {
        int low = i;
        i++; // 先移动到下一个位置

        // 寻找连续序列的结束位置
        // 如果当前数字等于前一个数字 + 1，则继续向后找
        while (i < n && nums[i] == nums[i - 1] + 1) {
            i++;
        }

        // 循环结束时，i 指向的是“不连续”的那个数（或者越界），所以区间的结尾是 i-1
        int high = i - 1;

        StringBuilder sb = new StringBuilder();
        sb.append(nums[low]);
        if (low < high) {
            sb.append("->");
            sb.append(nums[high]);
        }
        result.add(sb.toString());
    }

    return result;
}
```

### 完整代码

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Main {

    // 核心算法实现
    public static List<String> summaryRanges(int[] nums) {
        List<String> result = new ArrayList<>();
        int n = nums.length;
        int i = 0;

        while (i < n) {
            // 记录当前区间的起始下标
            int low = i;
            i++;

            // 只要当前元素等于前一个元素 + 1，就说明还在同一个区间内
            while (i < n && nums[i] == nums[i - 1] + 1) {
                i++;
            }

            // 此时 nums[i] 已经不连续了，或者 i == n
            // 区间的结束下标是 i - 1
            int high = i - 1;

            StringBuilder sb = new StringBuilder();
            sb.append(nums[low]);
            // 如果起始和结束下标不同，拼接 "->结尾"
            if (low < high) {
                sb.append("->");
                sb.append(nums[high]);
            }
            result.add(sb.toString());
        }

        return result;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int[] nums1 = {0, 1, 2, 4, 5, 7};
        System.out.println("示例 1 输入: " + Arrays.toString(nums1));
        List<String> res1 = summaryRanges(nums1);
        System.out.println("示例 1 输出: " + res1);
        // 预期: ["0->2", "4->5", "7"]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        int[] nums2 = {0, 2, 3, 4, 6, 8, 9};
        System.out.println("示例 2 输入: " + Arrays.toString(nums2));
        List<String> res2 = summaryRanges(nums2);
        System.out.println("示例 2 输出: " + res2);
        // 预期: ["0", "2->4", "6", "8->9"]
        System.out.println("-----------------------------");

        // --- 示例 3 (空数组) 测试 ---
        int[] nums3 = {};
        System.out.println("示例 3 输入: " + Arrays.toString(nums3));
        List<String> res3 = summaryRanges(nums3);
        System.out.println("示例 3 输出: " + res3);
        // 预期: []
        System.out.println("-----------------------------");

        // --- 示例 4 (单元素) 测试 ---
        int[] nums4 = {-1};
        System.out.println("示例 4 输入: " + Arrays.toString(nums4));
        List<String> res4 = summaryRanges(nums4);
        System.out.println("示例 4 输出: " + res4);
        // 预期: ["-1"]
    }
}
```
