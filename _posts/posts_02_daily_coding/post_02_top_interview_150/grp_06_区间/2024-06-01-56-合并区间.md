---
title: 56. 合并区间
date: 2024-06-01 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 区间]
tags: [区间]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121225648473.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：56. 合并区间

**描述：**

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start_i, end_i]` 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

**示例 1:**

- **输入:** `intervals = [[1,3],[2,6],[8,10],[15,18]]`
- **输出:** `[[1,6],[8,10],[15,18]]`
- **解释:** 区间 `[1,3]` 和 `[2,6]` 重叠, 将它们合并为 `[1,6]`。

**示例 2:**

- **输入:** `intervals = [[1,4],[4,5]]`
- **输出:** `[[1,5]]`
- **解释:** 区间 `[1,4]` 和 `[4,5]` 可被视为重叠区间。

**示例 3:**

- **输入:** `intervals = [[4,7],[1,4]]`
- **输出:** `[[1,7]]`
- **解释:** 区间 `[1,4]` 和 `[4,7]` 可被视为重叠区间。

**提示:**

- `1 <= intervals.length <= 10^4`
- `intervals[i].length == 2`
- `0 <= start_i <= end_i <= 10^4`

## 题解

### 解法：排序 + 贪心（一次遍历）

**思路：**

如果我们按照区间的左端点进行排序，那么在排完序的列表中，可以合并的区间一定是连续的。我们可以利用这个特性进行一次遍历来合并区间。

1.  **排序**：首先将列表中的区间按照左端点（`start`）升序排序。
2.  **初始化**：创建一个列表 `merged` 用于存储最终结果。将第一个区间加入 `merged` 列表。
3.  **遍历与合并**：从第二个区间开始遍历输入数组：

    - 取出 `merged` 列表中最后一个区间，记为 `last`（即当前合并到的最新结果）。
    - 取出当前遍历到的区间，记为 `curr`。
    - **检查重叠**：

      - 如果 `curr.start <= last.end`，说明两个区间有重叠（因为已经按 `start` 排序，`curr.start` 一定大于等于 `last.start`，只需检查是否在 `last` 的范围内）。此时，我们需要更新 `last` 的右边界：`last.end = Math.max(last.end, curr.end)`。
      - 如果 `curr.start > last.end`，说明没有重叠，`curr` 是一个新的独立区间。将其加入 `merged` 列表。

**复杂度分析：**

- **时间复杂度：** $O(n \log n)$。主要是排序的开销。遍历只需要 $O(n)$。
- **空间复杂度：** $O(\log n)$。主要是排序算法（如快速排序）所需要的递归栈空间。如果考虑存储结果的数组，则是 $O(n)$。

**代码片段：**

```java
public int[][] merge(int[][] intervals) {
    if (intervals.length == 0) return new int[0][2];

    // 1. 按左端点升序排序
    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

    List<int[]> result = new ArrayList<>();
    // 将第一个区间先加入结果集
    result.add(intervals[0]);

    for (int i = 1; i < intervals.length; i++) {
        // 获取结果集中最后一个区间（当前正在处理的合并区间）
        int[] last = result.get(result.size() - 1);
        int[] current = intervals[i];

        // 2. 如果当前区间的左端点 <= 结果集最后区间的右端点，说明重叠
        if (current[0] <= last[1]) {
            // 合并：更新右端点为两者中的较大值
            last[1] = Math.max(last[1], current[1]);
        } else {
            // 不重叠，直接加入结果集
            result.add(current);
        }
    }

    return result.toArray(new int[result.size()][]);
}
```

### 完整代码

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Main {

    // 核心算法实现
    public static int[][] merge(int[][] intervals) {
        if (intervals.length == 0) {
            return new int[0][2];
        }

        // 1. 按照区间的起始位置进行排序
        // 使用 Integer.compare 避免潜在的整数溢出问题（虽然本题范围不大）
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

        List<int[]> merged = new ArrayList<>();
        // 将第一个区间放入 merged 数组中
        merged.add(intervals[0]);

        for (int i = 1; i < intervals.length; i++) {
            int[] currentInterval = intervals[i];
            // 获取结果集中最后一个区间
            int[] lastInterval = merged.get(merged.size() - 1);

            // 2. 如果当前区间的起始位置 <= 最后一个区间的结束位置，说明重叠
            if (currentInterval[0] <= lastInterval[1]) {
                // 合并区间，更新结束位置
                lastInterval[1] = Math.max(lastInterval[1], currentInterval[1]);
            } else {
                // 不重叠，将当前区间直接加入结果集
                merged.add(currentInterval);
            }
        }

        // 将 List 转换为 int[][] 数组返回
        return merged.toArray(new int[merged.size()][]);
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int[][] intervals1 = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};
        System.out.println("示例 1 输入: " + Arrays.deepToString(intervals1));
        int[][] res1 = merge(intervals1);
        System.out.println("示例 1 输出: " + Arrays.deepToString(res1));
        // 预期: [[1, 6], [8, 10], [15, 18]]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        int[][] intervals2 = {{1, 4}, {4, 5}};
        System.out.println("示例 2 输入: " + Arrays.deepToString(intervals2));
        int[][] res2 = merge(intervals2);
        System.out.println("示例 2 输出: " + Arrays.deepToString(res2));
        // 预期: [[1, 5]]
        System.out.println("-----------------------------");

        // --- 示例 3 测试 (乱序输入) ---
        int[][] intervals3 = {{4, 7}, {1, 4}};
        System.out.println("示例 3 输入: " + Arrays.deepToString(intervals3));
        int[][] res3 = merge(intervals3);
        System.out.println("示例 3 输出: " + Arrays.deepToString(res3));
        // 预期: [[1, 7]]
    }
}
```
