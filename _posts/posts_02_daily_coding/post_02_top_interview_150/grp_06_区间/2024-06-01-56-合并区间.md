---
title: 56. 合并区间
date: 2024-06-01 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 区间]
tags: [区间]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121225648473.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


## 题目：56. 合并区间

**描述**

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start_i, end_i]` 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

**示例 1:**

- **输入:** `intervals = [[1,3],[2,6],[8,10],[15,18]]`
- **输出:** `[[1,6],[8,10],[15,18]]`
- **解释:** 区间 `[1,3]` 和 `[2,6]` 重叠, 将它们合并为 `[1,6]`。

**示例 2:**

- **输入:** `intervals = [[1,4],[4,5]]`
- **输出:** `[[1,5]]`
- **解释:** 区间 `[1,4]` 和 `[4,5]` 可被视为重叠区间。

**示例 3:**

- **输入:** `intervals = [[4,7],[1,4]]`
- **输出:** `[[1,7]]`
- **解释:** 区间 `[1,4]` 和 `[4,7]` 可被视为重叠区间。

**提示:**

- `1 <= intervals.length <= 10^4`
- `intervals[i].length == 2`
- `0 <= start_i <= end_i <= 10^4`



## Java 代码

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Main {

    /**
     * 合并所有重叠的区间。
     *
     * @param intervals 区间数组
     * @return 合并后的不重叠区间数组
     */
    public static int[][] merge(int[][] intervals) {
        // 如果区间数量小于等于1，无需合并
        if (intervals.length <= 1) {
            return intervals;
        }

        // 1. 核心步骤：按照区间的起始点进行升序排序
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

        List<int[]> merged = new ArrayList<>();
        // 将第一个区间加入结果集
        merged.add(intervals[0]);

        // 2. 遍历排序后的区间，进行合并
        for (int i = 1; i < intervals.length; i++) {
            int[] currentInterval = intervals[i];
            // 获取结果集中最后一个区间
            int[] lastInterval = merged.get(merged.size() - 1);

            // 检查当前区间是否与最后一个区间重叠
            // 重叠条件：current.start <= last.end
            if (currentInterval[0] <= lastInterval[1]) {
                // 如果重叠，更新最后一个区间的结束点
                // 新的结束点是两者结束点中的较大值
                lastInterval[1] = Math.max(lastInterval[1], currentInterval[1]);
            } else {
                // 如果不重叠，直接将当前区间加入结果集
                merged.add(currentInterval);
            }
        }

        // 3. 将列表转换为二维数组并返回
        return merged.toArray(new int[merged.size()][]);
    }

    public static void main(String[] args) {
        // 示例 1
        int[][] intervals1 = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};
        System.out.println("输入: " + Arrays.deepToString(intervals1));
        int[][] result1 = merge(intervals1);
        System.out.println("输出: " + Arrays.deepToString(result1)); // 预期: [[1, 6], [8, 10], [15, 18]]
        System.out.println("---");

        // 示例 2
        int[][] intervals2 = {{1, 4}, {4, 5}};
        System.out.println("输入: " + Arrays.deepToString(intervals2));
        int[][] result2 = merge(intervals2);
        System.out.println("输出: " + Arrays.deepToString(result2)); // 预期: [[1, 5]]
        System.out.println("---");

        // 示例 3
        int[][] intervals3 = {{4, 7}, {1, 4}};
        System.out.println("输入: " + Arrays.deepToString(intervals3));
        int[][] result3 = merge(intervals3);
        System.out.println("输出: " + Arrays.deepToString(result3)); // 预期: [[1, 7]]
        System.out.println("---");
    }
}
```
