---
title: 452. 用最少数量的箭引爆气球
date: 2024-06-07 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 区间]
tags: [区间]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121225744773.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [x_start, x_end]` 表示水平直径在 `x_start` 和 `x_end` 之间的气球。你不知道气球的精确 y 坐标。

一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x_start`，`x_end`， 且满足 `x_start ≤ x ≤ x_end`，则该气球会被引爆。可以射出的弓箭的数量 **没有限制** 。弓箭一旦被射出之后，可以无限地前进。

给你一个数组 `points` ，返回引爆所有气球所必须射出的 **最小** 弓箭数。

**示例 1:**

- **输入:** `points = [[10,16],[2,8],[1,6],[7,12]]`
- **输出:** 2
- **解释:** 气球可以用 2 支箭来爆破:

  - 在 x = 6 处射出箭，击破气球 和。
  - 在 x = 11 处发射箭，击破气球 和。

**示例 2:**

- **输入:** `points = [[1,2],[3,4],[5,6],[7,8]]`
- **输出:** 4
- **解释:** 每个气球需要射出一支箭，总共需要 4 支箭。

**示例 3:**

- **输入:** `points = [[1,2],[2,3],[3,4],[4,5]]`
- **输出:** 2
- **解释:** 气球可以用 2 支箭来爆破:

  - 在 x = 2 处发射箭，击破气球 和。
  - 在 x = 4 处射出箭，击破气球 和。

**提示:**

- `1 <= points.length <= 10^5`
- `points[i].length == 2`
- `-2^31 <= x_start < x_end <= 2^31 - 1`

## 题解

### 解法：贪心算法（按右边界排序）

**思路：**

这是一个经典的“区间调度”或“区间覆盖”问题。我们要用最少的箭引爆所有气球，实际上就是找最少的点，使得每个区间（气球）都至少包含一个点。

我们可以使用贪心策略：**为了让一支箭引爆尽可能多的气球，我们应该尽可能晚地射出这支箭。**

1.  **排序**：首先将气球按照 **右边界（结束位置）** 进行升序排序。

    - 为什么要按右边界排序？因为对于第一个结束的气球（假设结束位置为 `end1`），我们必须在 `end1` 之前（含 `end1`）射出一支箭，否则这个气球就漏掉了。
    - 为了这支箭能覆盖后面更多的气球，我们应该把箭恰好射在 `end1` 处。这样能覆盖的范围最广。

2.  **遍历**：

    - 初始化箭的数量 `count = 1`（只要有气球，至少需要一支箭）。
    - 记录当前箭的射击位置 `axis = points[0][1]`（即第一个气球的右边界）。
    - 从第二个气球开始遍历：

      - 如果当前气球的 **左边界** 大于 `axis`，说明当前这支箭无法覆盖该气球（气球在箭的右侧）。我们需要射出一支新箭。
      - 更新箭的数量 `count++`。
      - 更新当前箭的射击位置 `axis` 为当前气球的 **右边界**。
      - 如果当前气球的左边界小于等于 `axis`，说明这支箭可以顺便引爆它，无需操作，继续检查下一个。

**注意**：在排序比较时，直接使用 `a[1] - b[1]` 可能会导致整数溢出（因为坐标范围可达 $-2^{31}$ 到 $2^{31}-1$），应使用 `Integer.compare(a[1], b[1])`。

**复杂度分析：**

- **时间复杂度：** $O(n \log n)$。主要是排序的时间开销。遍历过程只需要 $O(n)$。
- **空间复杂度：** $O(\log n)$。主要是排序算法（Java 的 `Arrays.sort` 使用双轴快速排序）所需要的递归栈空间。

**代码片段：**

```java
public int findMinArrowShots(int[][] points) {
    if (points.length == 0) return 0;

    // 1. 按右边界升序排序
    // 使用 Integer.compare 避免差值运算导致的 int 溢出
    Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));

    int arrows = 1;
    int currentArrowPos = points[0][1];

    for (int i = 1; i < points.length; i++) {
        // 2. 如果当前气球的左边界 > 当前箭的位置，说明无法引爆
        if (points[i][0] > currentArrowPos) {
            arrows++; // 需要一支新箭
            currentArrowPos = points[i][1]; // 新箭射在这个气球的右边界
        }
    }

    return arrows;
}
```

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现
    public static int findMinArrowShots(int[][] points) {
        // 虽然题目提示 length >= 1，但做个判空是个好习惯
        if (points.length == 0) {
            return 0;
        }

        // 1. 按照气球的右边界进行升序排序
        // 注意：不能使用 a[1] - b[1]，因为坐标可能是负数且跨度很大，会溢出
        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));

        int arrows = 1; // 至少需要一支箭
        int currentArrowPos = points[0][1]; // 第一支箭射在第一个气球的尽头

        // 2. 遍历剩余的气球
        for (int i = 1; i < points.length; i++) {
            // 如果当前气球的开始位置大于当前箭的位置
            // 说明这支箭够不着当前气球了
            if (points[i][0] > currentArrowPos) {
                arrows++; // 增加一支箭
                currentArrowPos = points[i][1]; // 更新箭的位置为当前气球的尽头
            }
            // 否则，说明当前气球已经被这支箭穿透了，忽略即可
        }

        return arrows;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int[][] points1 = {{10, 16}, {2, 8}, {1, 6}, {7, 12}};
        System.out.println("示例 1 输入: " + Arrays.deepToString(points1));
        int res1 = findMinArrowShots(points1);
        System.out.println("示例 1 输出: " + res1);
        // 预期: 2
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        int[][] points2 = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
        System.out.println("示例 2 输入: " + Arrays.deepToString(points2));
        int res2 = findMinArrowShots(points2);
        System.out.println("示例 2 输出: " + res2);
        // 预期: 4
        System.out.println("-----------------------------");

        // --- 示例 3 测试 ---
        int[][] points3 = {{1, 2}, {2, 3}, {3, 4}, {4, 5}};
        System.out.println("示例 3 输入: " + Arrays.deepToString(points3));
        int res3 = findMinArrowShots(points3);
        System.out.println("示例 3 输出: " + res3);
        // 预期: 2 (箭射在 x=2 和 x=4)
        System.out.println("-----------------------------");

        // --- 示例 4 (溢出边界测试) ---
        // 假如不使用 Integer.compare，这里可能会出错
        int[][] points4 = {{-2147483646, -2147483645}, {2147483646, 2147483647}};
        System.out.println("示例 4 输入: " + Arrays.deepToString(points4));
        int res4 = findMinArrowShots(points4);
        System.out.println("示例 4 输出: " + res4);
        // 预期: 2
    }
}
```
