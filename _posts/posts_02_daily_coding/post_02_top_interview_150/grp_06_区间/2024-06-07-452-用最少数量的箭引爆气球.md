---
title: 452-用最少数量的箭引爆气球
date: 2024-06-07 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 区间]
tags: [区间]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121225744773.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


### 题目：452. 用最少数量的箭引爆气球

**描述**
有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [x_start, x_end]` 表示水平直径在 `x_start` 和 `x_end` 之间的气球。你不知道气球的精确 y 坐标。

一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x_start`，`x_end`， 且满足 `x_start ≤ x ≤ x_end`，则该气球会被引爆。可以射出的弓箭的数量 **没有限制** 。弓箭一旦被射出之后，可以无限地前进。

给你一个数组 `points` ，返回引爆所有气球所必须射出的 **最小** 弓箭数。

**示例 1:**

- **输入:** `points = [[10,16],[2,8],[1,6],[7,12]]`
- **输出:** 2
- **解释:** 气球可以用 2 支箭来爆破:
  - 在 x = 6 处射出箭，击破气球 和。
  - 在 x = 11 处发射箭，击破气球 和。

**示例 2:**

- **输入:** `points = [[1,2],[3,4],[5,6],[7,8]]`
- **输出:** 4
- **解释:** 每个气球需要射出一支箭，总共需要 4 支箭。

**示例 3:**

- **输入:** `points = [[1,2],[2,3],[3,4],[4,5]]`
- **输出:** 2
- **解释:** 气球可以用 2 支箭来爆破:
  - 在 x = 2 处发射箭，击破气球 和。
  - 在 x = 4 处射出箭，击破气球 和。

**提示:**

- `1 <= points.length <= 10^5`
- `points[i].length == 2`
- `-2^31 <= x_start < x_end <= 2^31 - 1`

---

### 赛码网格式 Java 8 代码

```java
import java.util.Arrays;
import java.util.Comparator;

public class Main {

    /**
     * 计算引爆所有气球所必须射出的最小弓箭数。
     * 这是一个贪心算法问题。
     *
     * @param points 气球的坐标数组
     * @return 最小弓箭数
     */
    public static int findMinArrowShots(int[][] points) {
        // 如果没有气球，就不需要箭
        if (points == null || points.length == 0) {
            return 0;
        }

        // 核心思想：贪心算法
        // 1. 将所有气球按照它们的结束坐标 (x_end) 升序排序。
        //    使用 Integer.compare 来避免潜在的整数溢出问题。
        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));

        // 2. 初始化箭的数量为 1，因为至少需要一支箭。
        int arrows = 1;
        // 3. 第一支箭的位置选择在第一个气球的末尾，这是最优选择，
        //    因为它有最大的可能去覆盖后续的气球。
        int arrowPosition = points[0][1];

        // 4. 遍历排序后的气球
        for (int i = 1; i < points.length; i++) {
            // 如果当前气球的开始位置 (x_start) 在上一支箭的位置之后，
            // 说明这支箭无法引爆当前气球。
            if (points[i][0] > arrowPosition) {
                // 因此，需要一支新的箭。
                arrows++;
                // 更新箭的位置到当前气球的末尾。
                arrowPosition = points[i][1];
            }
            // 否则，如果 points[i][0] <= arrowPosition，说明当前气球
            // 可以被之前的箭引爆，我们不需要做任何事，继续检查下一个气球。
        }

        return arrows;
    }

    public static void main(String[] args) {
        // 示例 1
        int[][] points1 = {{10, 16}, {2, 8}, {1, 6}, {7, 12}};
        System.out.println("输入: " + Arrays.deepToString(points1));
        System.out.println("输出: " + findMinArrowShots(points1)); // 预期: 2

        // 示例 2
        int[][] points2 = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
        System.out.println("输入: " + Arrays.deepToString(points2));
        System.out.println("输出: " + findMinArrowShots(points2)); // 预期: 4

        // 示例 3
        int[][] points3 = {{1, 2}, {2, 3}, {3, 4}, {4, 5}};
        System.out.println("输入: " + Arrays.deepToString(points3));
        System.out.println("输出: " + findMinArrowShots(points3)); // 预期: 2
    }
}
```
