---
title: 210. 课程表II
date: 2024-08-29 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 图]
tags: [图]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232643114.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

现在你总共有 `numCourses` 门课需要选，记为 `0` 到 `numCourses - 1`。给你一个数组 `prerequisites`，其中 `prerequisites[i] = [ai, bi]`，表示在选修课程 `ai` 前 **必须** 先选修 `bi`。

- 例如，想要学习课程 `0`，你需要先完成课程 `1`，我们用一个匹配来表示：`[0,1]`。

返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 **任意一种** 就可以了。如果不可能完成所有课程，返回一个 **空数组**。

**示例 1:**

- **输入:** `numCourses = 2`, `prerequisites = [[1,0]]`
- **输出:** `[0,1]`
- **解释:** 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 `[0,1]`。

**示例 2:**

- **输入:** `numCourses = 4`, `prerequisites = [[1,0],[2,0],[3,1],[3,2]]`
- **输出:** `[0,2,1,3]`
- **解释:** 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 `[0,1,2,3]`。另一个正确的排序是 `[0,2,1,3]`。

**示例 3:**

- **输入:** `numCourses = 1`, `prerequisites = []`
- **输出:** `[0]`

**提示:**

- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= numCourses * (numCourses - 1)`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- `ai != bi`
- 所有 `[ai, bi]` **互不相同**

## 题解

### 解法一：广度优先搜索 (BFS) - Kahn 算法

**思路：**

这道题是典型的 **拓扑排序** 问题。我们可以将课程看作图的节点，依赖关系看作有向边。如果课程 `a` 依赖课程 `b`，则存在边 `b -> a`。

问题的目标是找到一个线性顺序，使得对于所有的边 `b -> a`，`b` 都排在 `a` 前面。这正是拓扑排序的定义。

Kahn 算法是解决此类问题的常用方法，利用 **入度 (Indegree)** 的概念：

1.  **入度**：指向该节点的边的数量。在这里，表示一门课有多少门**先修课**还没完成。
2.  **核心逻辑**：

    - 如果一门课的入度为 0，说明它不需要先修课（或先修课已修完），可以立即学习。
    - 每修完一门课，它指向的后续课程的入度就减 1。
    - 如果某后续课程入度减为 0，则它也变成了可以学习的状态，加入队列。

**算法流程：**

1.  **建图**：使用邻接表存储图结构，同时用数组统计每个节点的入度。
2.  **初始化队列**：将所有 **入度为 0** 的节点加入队列。
3.  **BFS 遍历**：

    - 从队列中取出节点 `u`，将其加入结果数组。
    - 遍历 `u` 的所有邻居 `v`，将 `v` 的入度减 1。
    - 如果 `v` 的入度变为 0，将 `v` 加入队列。

4.  **环检测**：

    - 如果最终结果数组的长度等于 `numCourses`，说明所有课程都能完成，返回结果数组。
    - 否则，说明图中存在环（某些课程的入度永远无法变为 0），返回空数组 `new int[0]`。

**复杂度分析：**

- **时间复杂度：** $O(V + E)$，其中 $V$ 是课程数（节点数），$E$ 是依赖关系数（边数）。

  - 建图需要遍历所有边：$O(E)$。
  - 每个节点入队出队一次：$O(V)$。
  - 遍历所有邻居相当于遍历所有边：$O(E)$。

- **空间复杂度：** $O(V + E)$。

  - 邻接表存储边：$O(E)$。
  - 入度数组、结果数组、队列：$O(V)$。

**代码片段：**

```java
public int[] findOrder(int numCourses, int[][] prerequisites) {
    // 1. 初始化
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < numCourses; i++) {
        graph.add(new ArrayList<>());
    }
    int[] indegree = new int[numCourses];

    // 2. 建图并计算入度
    for (int[] p : prerequisites) {
        int cur = p[0];
        int pre = p[1];
        graph.get(pre).add(cur); // pre -> cur
        indegree[cur]++;
    }

    // 3. 将入度为0的节点入队
    Queue<Integer> queue = new LinkedList<>();
    for (int i = 0; i < numCourses; i++) {
        if (indegree[i] == 0) queue.offer(i);
    }

    // 4. BFS
    int[] res = new int[numCourses];
    int idx = 0;
    while (!queue.isEmpty()) {
        int u = queue.poll();
        res[idx++] = u; // 记录学习顺序

        for (int v : graph.get(u)) {
            indegree[v]--;
            if (indegree[v] == 0) {
                queue.offer(v);
            }
        }
    }

    // 5. 检查是否有环
    return idx == numCourses ? res : new int[0];
}
```

### 解法二：深度优先搜索 (DFS) - 三色标记法

**思路：**

DFS 也可以用来进行拓扑排序。其核心在于：**当一个节点的所有邻居都被访问完后，该节点才能被认为是“完成”的，并加入结果集**（这实际上产生的是逆序的拓扑序列，我们需要用栈来存储，或者最后反转结果）。

为了检测环，我们需要记录每个节点的访问状态（三色标记）：

- **0 (未搜索)**：还没有被访问过。
- **1 (搜索中)**：正在访问该节点或其后代节点。如果 DFS 过程中遇到状态为 1 的节点，说明存在环。
- **2 (已完成)**：该节点及其所有后代节点都已访问完毕，已加入结果集。

**算法流程：**

1.  建图。
2.  遍历所有节点，如果节点状态为 0，则调用 DFS。
3.  **DFS 逻辑**：

    - 将当前节点标记为 1（搜索中）。
    - 遍历邻居：

      - 如果邻居状态为 1，说明有环，返回 `false`。
      - 如果邻居状态为 0，递归 DFS。如果不通过，返回 `false`。

    - 所有邻居处理完，将当前节点标记为 2（已完成）。
    - **关键点**：将当前节点加入栈（或结果数组的末尾倒序填充）。因为这是“后序遍历”，最深层的依赖会最先进入栈底，最外层的先修课会在最后处理完，所以我们要用栈来实现“先进后出”，或者填充数组时从后往前填。
    - 由于题目要求先修课在前，如果我们用栈存储，栈顶就是先修课；如果用数组倒序填，数组头就是先修课。

**复杂度分析：**

- **时间复杂度：** $O(V + E)$。
- **空间复杂度：** $O(V + E)$。递归栈深度最坏为 $O(V)$。

**代码片段：**

```java
// 全局变量
int[] visited;
List<List<Integer>> graph;
int[] result;
int index; // 用于倒序填充 result
boolean valid = true;

public int[] findOrder(int numCourses, int[][] prerequisites) {
    graph = new ArrayList<>();
    for (int i = 0; i < numCourses; i++) graph.add(new ArrayList<>());
    visited = new int[numCourses];
    result = new int[numCourses];
    index = numCourses - 1; // 从数组末尾开始填

    for (int[] p : prerequisites) {
        graph.get(p[1]).add(p[0]);
    }

    for (int i = 0; i < numCourses && valid; i++) {
        if (visited[i] == 0) {
            dfs(i);
        }
    }

    return valid ? result : new int[0];
}

private void dfs(int u) {
    visited[u] = 1; // 标记为搜索中
    for (int v : graph.get(u)) {
        if (visited[v] == 1) {
            valid = false; // 发现环
            return;
        }
        if (visited[v] == 0) {
            dfs(v);
            if (!valid) return;
        }
    }
    visited[u] = 2; // 标记为已完成
    result[index--] = u; // 后序遍历位置，加入结果集
}
```

### 完整代码

这里提供最常用且直观的 **解法一（BFS / Kahn 算法）** 的完整代码。

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class Main {

    // 核心算法实现：BFS 拓扑排序
    public static int[] findOrder(int numCourses, int[][] prerequisites) {
        // 1. 初始化邻接表和入度数组
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            graph.add(new ArrayList<>());
        }
        int[] indegree = new int[numCourses];

        // 2. 构建图
        // prerequisites[i] = [cur, pre] 表示 pre -> cur
        for (int[] p : prerequisites) {
            int cur = p[0];
            int pre = p[1];
            graph.get(pre).add(cur);
            indegree[cur]++;
        }

        // 3. 将所有入度为 0 的课程加入队列（起始节点）
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (indegree[i] == 0) {
                queue.offer(i);
            }
        }

        // 4. BFS 处理
        int[] result = new int[numCourses];
        int idx = 0; // 结果数组的索引

        while (!queue.isEmpty()) {
            int u = queue.poll();
            result[idx++] = u; // 将课程加入结果

            // 遍历该课程的后续课程
            for (int v : graph.get(u)) {
                indegree[v]--; // 后续课程入度 -1
                if (indegree[v] == 0) {
                    // 如果入度变为 0，说明先修课都已修完，可以入队
                    queue.offer(v);
                }
            }
        }

        // 5. 检查是否包含所有课程（是否有环）
        if (idx == numCourses) {
            return result;
        } else {
            // 如果存在环，无法完成所有课程
            return new int[0];
        }
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int numCourses1 = 2;
        int[][] prerequisites1 = {{1, 0}};
        System.out.println("示例 1 输入: numCourses = 2, prerequisites = [[1,0]]");
        int[] res1 = findOrder(numCourses1, prerequisites1);
        System.out.println("示例 1 输出: " + Arrays.toString(res1)); // 预期: [0, 1]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        int numCourses2 = 4;
        int[][] prerequisites2 = {{1, 0}, {2, 0}, {3, 1}, {3, 2}};
        System.out.println("示例 2 输入: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]");
        int[] res2 = findOrder(numCourses2, prerequisites2);
        System.out.println("示例 2 输出: " + Arrays.toString(res2));
        // 预期: [0, 1, 2, 3] 或 [0, 2, 1, 3]
        System.out.println("-----------------------------");

        // --- 示例 3 测试 (空依赖) ---
        int numCourses3 = 1;
        int[][] prerequisites3 = {};
        System.out.println("示例 3 输入: numCourses = 1, prerequisites = []");
        int[] res3 = findOrder(numCourses3, prerequisites3);
        System.out.println("示例 3 输出: " + Arrays.toString(res3)); // 预期: [0]
        System.out.println("-----------------------------");

        // --- 示例 4 测试 (有环) ---
        int numCourses4 = 2;
        int[][] prerequisites4 = {{1, 0}, {0, 1}};
        System.out.println("示例 4 输入: numCourses = 2, prerequisites = [[1,0],[0,1]]");
        int[] res4 = findOrder(numCourses4, prerequisites4);
        System.out.println("示例 4 输出: " + Arrays.toString(res4)); // 预期: []
    }
}
```
