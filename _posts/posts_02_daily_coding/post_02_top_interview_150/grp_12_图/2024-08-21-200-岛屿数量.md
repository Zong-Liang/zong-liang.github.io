---
title: 200. 岛屿数量
date: 2024-08-21 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 图]
tags: [图]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232402346.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1:**

- **输入:** `grid = [
["1","1","1","1","0"],
["1","1","0","1","0"],
["1","1","0","0","0"],
["0","0","0","0","0"]
]`
- **输出:** 1

**示例 2:**

- **输入:** `grid = [
["1","1","0","0","0"],
["1","1","0","0","0"],
["0","0","1","0","0"],
["0","0","0","1","1"]
]`
- **输出:** 3

**提示:**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` 的值为 `'0'` 或 `'1'`

## 题解

### 解法一：深度优先搜索 (DFS)

**思路：**

我们可以将二维网格看作一个无向图，竖直或水平相邻的 `1` 之间有边相连。

为了统计岛屿数量，我们遍历整个网格。如果当前位置是 `1`（陆地），说明我们发现了一个新的岛屿，岛屿数量 `count` 加 1。然后，为了避免重复计算这个岛屿的其他部分，我们需要将与这个 `1` 相连的所有陆地都标记为水（`0`）。

我们可以使用 **DFS** 来实现这个“沉岛”过程：

1.  遍历网格的每个格子 `(i, j)`。
2.  如果 `grid[i][j] == '1'`：

    - 岛屿计数加 1。
    - 调用 DFS 函数，传入坐标 `(i, j)`。

3.  **DFS 函数逻辑**：

    - **终止条件**：如果坐标 `(r, c)` 超出网格边界，或者 `grid[r][c] == '0'`，直接返回。
    - **标记**：将当前格子 `grid[r][c]` 置为 `0`（表示已访问/已沉没）。
    - **递归**：向上下左右四个方向递归调用 DFS。

**复杂度分析：**

- **时间复杂度：** $O(M \times N)$，其中 $M$ 和 $N$ 分别为行数和列数。每个格子最多被访问两次（一次是主循环遍历，一次是 DFS 递归）。
- **空间复杂度：** $O(M \times N)$。最坏情况下（整个网格都是陆地），递归栈的深度达到 $M \times N$。

**代码片段：**

```java
public int numIslands(char[][] grid) {
    if (grid == null || grid.length == 0) return 0;

    int count = 0;
    int m = grid.length;
    int n = grid[0].length;

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == '1') {
                count++;
                dfs(grid, i, j);
            }
        }
    }
    return count;
}

private void dfs(char[][] grid, int r, int c) {
    int m = grid.length;
    int n = grid[0].length;

    // 越界或遇到水，直接返回
    if (r < 0 || c < 0 || r >= m || c >= n || grid[r][c] == '0') {
        return;
    }

    // 将当前陆地沉没（标记为 '0'）
    grid[r][c] = '0';

    // 向四个方向扩散
    dfs(grid, r - 1, c); // 上
    dfs(grid, r + 1, c); // 下
    dfs(grid, r, c - 1); // 左
    dfs(grid, r, c + 1); // 右
}
```

### 解法二：广度优先搜索 (BFS)

**思路：**

思路与 DFS 类似，同样是遍历网格，遇到 `1` 就计数并启动搜索。区别在于搜索方式改为 **BFS**，使用 **队列** 来存储待访问的节点。

1.  遍历网格，当遇到 `grid[i][j] == '1'` 时，计数加 1。
2.  将该坐标加入队列，并将该位置的值修改为 `0`（防止重复加入队列）。
3.  **BFS 循环**：

    - 从队列取出当前坐标。
    - 检查其上下左右四个邻居。
    - 如果邻居是 `1`，将其修改为 `0` 并加入队列。

**复杂度分析：**

- **时间复杂度：** $O(M \times N)$。
- **空间复杂度：** $O(\min(M, N))$。在 BFS 中，队列中最多同时存储网格对角线长度或者是较短边长度数量级的节点。

**代码片段：**

```java
public int numIslandsBFS(char[][] grid) {
    if (grid == null || grid.length == 0) return 0;

    int count = 0;
    int m = grid.length;
    int n = grid[0].length;

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == '1') {
                count++;
                // 启动 BFS
                grid[i][j] = '0'; // 标记为已访问
                Queue<int[]> queue = new LinkedList<>();
                queue.offer(new int[]{i, j});

                while (!queue.isEmpty()) {
                    int[] curr = queue.poll();
                    int r = curr[0], c = curr[1];

                    // 检查上下左右四个方向
                    int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
                    for (int[] d : directions) {
                        int nr = r + d[0];
                        int nc = c + d[1];
                        if (nr >= 0 && nr < m && nc >= 0 && nc < n && grid[nr][nc] == '1') {
                            queue.offer(new int[]{nr, nc});
                            grid[nr][nc] = '0'; // 入队时立即标记，防止重复入队
                        }
                    }
                }
            }
        }
    }
    return count;
}
```

### 完整代码

```java
import java.util.LinkedList;
import java.util.Queue;

public class Main {

    // 核心算法实现：解法一（DFS）
    public static int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }

        int count = 0;
        int m = grid.length;
        int n = grid[0].length;

        // 遍历每一个网格点
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 如果发现陆地 ('1')
                if (grid[i][j] == '1') {
                    // 岛屿数量 +1
                    count++;
                    // 使用 DFS 将当前岛屿所有相连的陆地都变为水 ('0')
                    dfs(grid, i, j);
                }
            }
        }
        return count;
    }

    // 辅助 DFS 方法
    private static void dfs(char[][] grid, int r, int c) {
        int m = grid.length;
        int n = grid[0].length;

        // 边界检查：如果越界或者是水，直接停止
        if (r < 0 || c < 0 || r >= m || c >= n || grid[r][c] == '0') {
            return;
        }

        // 将当前位置标记为水（'0'），避免重复访问
        grid[r][c] = '0';

        // 递归访问上下左右四个邻居
        dfs(grid, r - 1, c); // 上
        dfs(grid, r + 1, c); // 下
        dfs(grid, r, c - 1); // 左
        dfs(grid, r, c + 1); // 右
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        char[][] grid1 = {
            {'1', '1', '1', '1', '0'},
            {'1', '1', '0', '1', '0'},
            {'1', '1', '0', '0', '0'},
            {'0', '0', '0', '0', '0'}
        };

        System.out.println("示例 1 输入:");
        printGrid(grid1);
        // 注意：dfs 会修改原数组，所以这里调用后 grid1 会全变成 '0'
        int res1 = numIslands(grid1);
        System.out.println("示例 1 输出: " + res1); // 预期: 1
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        char[][] grid2 = {
            {'1', '1', '0', '0', '0'},
            {'1', '1', '0', '0', '0'},
            {'0', '0', '1', '0', '0'},
            {'0', '0', '0', '1', '1'}
        };

        System.out.println("示例 2 输入:");
        printGrid(grid2);
        int res2 = numIslands(grid2);
        System.out.println("示例 2 输出: " + res2); // 预期: 3
    }

    // 辅助方法：打印网格状态（用于调试）
    private static void printGrid(char[][] grid) {
        for (char[] row : grid) {
            System.out.print("[");
            for (int i = 0; i < row.length; i++) {
                System.out.print("'" + row[i] + "'");
                if (i < row.length - 1) System.out.print(",");
            }
            System.out.println("]");
        }
    }
}
```
