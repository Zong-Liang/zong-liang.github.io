---
title: 130. 被围绕的区域
date: 2024-08-23 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 图]
tags: [图]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232429496.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---


## 题目：130. 被围绕的区域

给你一个 `m x n` 的矩阵 `board`，由若干字符 `'X'` 和 `'O'` 组成，捕获所有 **被围绕的区域**：

- **连接：** 一个单元格与水平或垂直方向上相邻的单元格连接。
- **区域：** 连接所有 `'O'` 的单元格来形成一个区域。
- **围绕：** 如果您可以用 `'X'` 单元格 **连接** 这个区域，并且区域中没有任何单元格位于 `board` **边缘**，则该区域被 `'X'` 单元格围绕。

通过 **原地** 将输入矩阵中的所有 `'O'` 替换为 `'X'` 来捕获被围绕的区域。你不需要返回任何值。



**示例 1:**![示例1图片](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)

- **输入:** `board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]`
- **输出:** `[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]`



**示例 2:**

- **输入:** `board = [["X"]]`
- **输出:** `[["X"]]`



**提示:**

- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 200`
- `board[i][j]` 为 `'X'` 或 `'O'`



## Java 代码

**算法思路：(反向思维 + DFS/BFS)**
直接寻找被 `'X'` 包围的 `'O'` 比较复杂。一个更巧妙的方法是 **反向思考**：找到所有 **不被** 包围的 `'O'`，然后将剩下的所有 `'O'` 变成 `'X'`。

哪些 `'O'` 是肯定不会被包围的呢？
答案是那些位于 **棋盘边缘** 的 `'O'`，以及 **与边缘'O'直接或间接相连** 的所有 `'O'`。

1.  **从边缘出发:**
    - 遍历棋盘的四条边（第一行、最后一行、第一列、最后一列）。
    - 如果发现边缘上有一个 `'O'`，就从这个 `'O'` 开始进行深度优先搜索（DFS）或广度优先搜索（BFS）。
2.  **标记不被包围的'O':**
    - 在 DFS/BFS 过程中，将所有能访问到的 `'O'` 都标记成一个临时字符，比如 `'A'`。这表示这些 `'O'` 是与边缘连通的，因此不应被捕获。
3.  **捕获与恢复:**
    - 再次遍历整个棋盘。
    - 如果一个单元格是 `'O'`，说明它与任何边缘的 `'O'` 都不连通，因此是“被围绕的”，将其变为 `'X'`。
    - 如果一个单元格是 `'A'`，说明它是我们之前标记过的、不应被捕获的 `'O'`，将其恢复为 `'O'`。

这种方法将问题简化为从边缘开始的图遍历问题。

```java
import java.util.Arrays;


public class Main {

    public void solve(char[][] board) {
        if (board == null || board.length == 0) {
            return;
        }
        int rows = board.length;
        int cols = board[0].length;

        // 1. 遍历第一行和最后一行
        for (int j = 0; j < cols; j++) {
            if (board[0][j] == 'O') {
                dfs(board, 0, j);
            }
            if (board[rows - 1][j] == 'O') {
                dfs(board, rows - 1, j);
            }
        }

        // 2. 遍历第一列和最后一列
        for (int i = 0; i < rows; i++) {
            if (board[i][0] == 'O') {
                dfs(board, i, 0);
            }
            if (board[i][cols - 1] == 'O') {
                dfs(board, i, cols - 1);
            }
        }

        // 3. 遍历整个棋盘，进行替换
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (board[i][j] == 'O') {
                    board[i][j] = 'X'; // 捕获
                } else if (board[i][j] == 'A') {
                    board[i][j] = 'O'; // 恢复
                }
            }
        }
    }

    /**
     * 深度优先搜索，标记与边缘连通的 'O'
     */
    private void dfs(char[][] board, int row, int col) {
        // 边界检查或当前不是 'O'
        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length || board[row][col] != 'O') {
            return;
        }

        // 标记为 'A'
        board[row][col] = 'A';

        // 向四个方向递归
        dfs(board, row + 1, col);
        dfs(board, row - 1, col);
        dfs(board, row, col + 1);
        dfs(board, row, col - 1);
    }

    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        char[][] board1 = {
            {'X', 'X', 'X', 'X'},
            {'X', 'O', 'O', 'X'},
            {'X', 'X', 'O', 'X'},
            {'X', 'O', 'X', 'X'}
        };
        System.out.println("输入:");
        for(char[] row : board1) System.out.println(Arrays.toString(row));

        solution.solve(board1);

        System.out.println("输出:");
        for(char[] row : board1) System.out.println(Arrays.toString(row));
        System.out.println();

        System.out.println("--- 示例 2 ---");
        char[][] board2 = {{'X'}};
        System.out.println("输入:");
        for(char[] row : board2) System.out.println(Arrays.toString(row));

        solution.solve(board2);

        System.out.println("输出:");
        for(char[] row : board2) System.out.println(Arrays.toString(row));
    }
}
```
