---
title: 130. 被围绕的区域
date: 2024-08-23 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 图]
tags: [图]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232429496.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个 `m x n` 的矩阵 `board`，由若干字符 `'X'` 和 `'O'` 组成，捕获所有 **被围绕的区域**：

- **连接：** 一个单元格与水平或垂直方向上相邻的单元格连接。
- **区域：** 连接所有 `'O'` 的单元格来形成一个区域。
- **围绕：** 如果您可以用 `'X'` 单元格 **连接** 这个区域，并且区域中没有任何单元格位于 `board` **边缘**，则该区域被 `'X'` 单元格围绕。

通过 **原地** 将输入矩阵中的所有 `'O'` 替换为 `'X'` 来捕获被围绕的区域。你不需要返回任何值。

**示例 1:**![示例1图片](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)

- **输入:** `board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]`
- **输出:** `[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]`

**示例 2:**

- **输入:** `board = [["X"]]`
- **输出:** `[["X"]]`

**提示:**

- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 200`
- `board[i][j]` 为 `'X'` 或 `'O'`

## 题解

### 解法一：深度优先搜索 (DFS) - 从边界向内延伸

**思路：**

这道题的核心在于：**与边界相连的 `'O'` 是不会被填充的，只有被 `'X'` 完全包围（不与边界连通）的 `'O'` 才会被填充。**

与其寻找哪些 `'O'` 被包围（这很难），不如寻找哪些 `'O'` **没有** 被包围（这很简单，因为它们一定直接或间接连接到边界）。

我们可以采用“逆向思维”：

1.  **标记安全区**：从矩阵的 **四条边** 出发，寻找所有的 `'O'`。对于每一个边界上的 `'O'`，我们进行 **深度优先搜索 (DFS)**，找到所有与它相连的 `'O'`。我们将这些“安全的” `'O'` 暂时标记为一个特殊字符（例如 `'A'`，代表 Alive/Safe）。
2.  **替换包围区**：遍历整个矩阵。

    - 如果遇到 `'O'`：说明这个 `'O'` 没有在第一步被遍历到，意味着它不与边界连通，它是被包围的。将其修改为 `'X'`。
    - 如果遇到 `'A'`：说明这是我们第一步标记出来的安全节点。将其还原回 `'O'`。

**算法流程：**

1.  遍历矩阵的左右两列、上下两行。如果发现 `'O'`，则启动 DFS，将其及其连通的 `'O'` 全部标记为 `'A'`。
2.  双重循环遍历整个矩阵：

    - `'A' -> 'O'`
    - `'O' -> 'X'`

**复杂度分析：**

- **时间复杂度：** $O(M \times N)$，其中 $M$ 是行数，$N$ 是列数。每个单元格最多被访问一次。
- **空间复杂度：** $O(M \times N)$。主要开销在于递归栈的深度。在最坏情况下（例如整个矩阵都是 `'O'` 且呈蛇形排列），递归深度可能达到 $M \times N$。

**代码片段：**

```java
public void solve(char[][] board) {
    if (board == null || board.length == 0) return;
    int m = board.length;
    int n = board[0].length;

    // 1. 遍历左右两列边界
    for (int i = 0; i < m; i++) {
        dfs(board, i, 0);
        dfs(board, i, n - 1);
    }
    // 2. 遍历上下两行边界
    for (int j = 1; j < n - 1; j++) {
        dfs(board, 0, j);
        dfs(board, m - 1, j);
    }

    // 3. 遍历全图，根据标记进行替换
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (board[i][j] == 'A') {
                board[i][j] = 'O'; // 还原安全的 O
            } else if (board[i][j] == 'O') {
                board[i][j] = 'X'; // 捕获被围绕的 O
            }
        }
    }
}

private void dfs(char[][] board, int x, int y) {
    // 边界检查，且只有是 'O' 才继续递归
    if (x < 0 || x >= board.length || y < 0 || y >= board[0].length || board[x][y] != 'O') {
        return;
    }

    // 标记为 'A' (Alive/Safe)
    board[x][y] = 'A';

    // 向四个方向扩散
    dfs(board, x + 1, y);
    dfs(board, x - 1, y);
    dfs(board, x, y + 1);
    dfs(board, x, y - 1);
}
```

### 解法二：广度优先搜索 (BFS)

**思路：**

思路与 DFS 完全一致，只是遍历方式改为 BFS。我们使用一个队列来存储边界上的 `'O'`，然后不断取出节点，将其周围的 `'O'` 加入队列并标记。

相比 DFS，BFS 可以避免在极端情况下（如过深的递归路径）导致的栈溢出问题，但在本题的数据规模（200x200）下，DFS 通常也是安全的。

**复杂度分析：**

- **时间复杂度：** $O(M \times N)$。
- **空间复杂度：** $O(M \times N)$。队列中最多存储的节点数。

_(代码逻辑与 DFS 类似，为保持简洁，下方完整代码采用 DFS 实现)_

### 完整代码

```java
import java.util.Arrays;

public class Main {

    // 核心算法实现：DFS
    public static void solve(char[][] board) {
        if (board == null || board.length == 0) {
            return;
        }

        int m = board.length;
        int n = board[0].length;

        // 步骤 1: 寻找所有与边界相连的 'O'，将其标记为 'A'

        // 遍历第一列和最后一列
        for (int i = 0; i < m; i++) {
            dfs(board, i, 0);
            dfs(board, i, n - 1);
        }

        // 遍历第一行和最后一行
        for (int j = 1; j < n - 1; j++) {
            dfs(board, 0, j);
            dfs(board, m - 1, j);
        }

        // 步骤 2: 再次遍历整个矩阵
        // 如果是 'O'，说明它没有连接到边界，变成 'X'
        // 如果是 'A'，说明它是安全的，还原为 'O'
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                } else if (board[i][j] == 'A') {
                    board[i][j] = 'O';
                }
            }
        }
    }

    // 深度优先搜索
    private static void dfs(char[][] board, int r, int c) {
        // 越界检查
        if (r < 0 || c < 0 || r >= board.length || c >= board[0].length) {
            return;
        }
        // 如果不是 'O' (可能是 'X' 或 已经是 'A')，停止递归
        if (board[r][c] != 'O') {
            return;
        }

        // 将当前 'O' 标记为 'A'
        board[r][c] = 'A';

        // 递归上下左右四个方向
        dfs(board, r - 1, c);
        dfs(board, r + 1, c);
        dfs(board, r, c - 1);
        dfs(board, r, c + 1);
    }

    // 辅助方法：打印矩阵
    public static void printBoard(char[][] board) {
        for (char[] row : board) {
            System.out.println(Arrays.toString(row));
        }
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        char[][] board1 = {
            {'X', 'X', 'X', 'X'},
            {'X', 'O', 'O', 'X'},
            {'X', 'X', 'O', 'X'},
            {'X', 'O', 'X', 'X'}
        };

        System.out.println("示例 1 输入:");
        printBoard(board1);

        solve(board1);

        System.out.println("示例 1 输出:");
        printBoard(board1);
        // 预期输出:
        // [X, X, X, X]
        // [X, X, X, X]
        // [X, X, X, X]
        // [X, O, X, X]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        char[][] board2 = {
            {'X'}
        };

        System.out.println("示例 2 输入:");
        printBoard(board2);

        solve(board2);

        System.out.println("示例 2 输出:");
        printBoard(board2);
        // 预期输出: [X]
        System.out.println("-----------------------------");

        // --- 示例 3 测试 (全 O 情况) ---
        char[][] board3 = {
            {'O', 'O', 'O'},
            {'O', 'O', 'O'},
            {'O', 'O', 'O'}
        };
        System.out.println("示例 3 输入 (全 O):");
        printBoard(board3);

        solve(board3);

        System.out.println("示例 3 输出 (应全为 O):");
        printBoard(board3);
    }
}
```
