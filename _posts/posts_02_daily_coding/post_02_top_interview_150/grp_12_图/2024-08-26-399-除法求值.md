---
title: 399-除法求值
date: 2024-08-26 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 图]
tags: [图]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232527104.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

好的，这是从图片中整理出的题目描述和解答代码。

### 题目：399. 除法求值

给你一个变量对数组 `equations` 和一个实数值数组 `values` 作为已知条件，其中 `equations[i] = [Ai, Bi]` 和 `values[i]` 共同表示等式 `Ai / Bi = values[i]`。每个 `Ai` 或 `Bi` 是一个表示单个变量的字符串。

另有一些以数组 `queries` 表示的问题，其中 `queries[j] = [Cj, Dj]` 表示第 `j` 个问题，请你根据已知条件找出 `Cj / Dj = ?` 的结果作为答案。

返回 **所有问题的答案**。如果存在某个无法确定的答案，则用 `-1.0` 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 `-1.0` 替代这个答案。

**注意：** 输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。
**注意：** 未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。

---

**示例 1:**

- **输入:** `equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]`
- **输出:** `[6.00000,0.50000,-1.00000,1.00000,-1.00000]`

---

**示例 2:**

- **输入:** `equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]`
- **输出:** `[3.75000,0.40000,5.00000,0.20000]`

---

**提示:**

- `1 <= equations.length <= 20`
- `1 <= queries.length <= 20`
- 变量由小写英文字母与数字组成

---

### Java 8 解答 (赛码网格式)

**算法思路：(带权并查集 或 图的 DFS/BFS)**
这个问题可以被完美地抽象成一个图论问题。每个变量是一个图中的节点。一个等式 `A / B = k` 可以看作是从节点 `A` 到节点 `B` 的一条权重为 `k` 的有向边，同时也是从 `B` 到 `A` 的一条权重为 `1/k` 的有向边。

一个查询 `C / D = ?` 就变成了在图中寻找从节点 `C` 到节点 `D` 的路径，并将路径上所有边的权重相乘。

我们可以使用 **深度优先搜索 (DFS)** 或 **广度优先搜索 (BFS)** 来寻找这条路径。

1.  **构建图:**
    - 创建一个邻接表 `graph`，`Map<String, Map<String, Double>>`。
    - `graph.get(A)` 会返回一个映射，其中包含了所有与 `A` 直接相连的节点 `B` 以及对应的 `A / B` 的值。
    - 遍历 `equations`，对于 `A / B = k`，在图中添加两条边：`A -> B` (权重 `k`) 和 `B -> A` (权重 `1/k`)。
2.  **处理查询:**
    - 对于每个查询 `[C, D]`，我们从 `C` 开始进行图的遍历（DFS 或 BFS），目标是找到 `D`。
    - 在遍历过程中，我们需要累积路径上的权重乘积。
    - 为了防止在图中走回头路或无限循环，我们需要一个 `visited` 集合来记录当前查询中已经访问过的节点。
    - 如果找到了从 `C` 到 `D` 的路径，就返回累积的乘积。
    - 如果在图中找不到 `C` 或 `D`，或者它们之间不连通，则返回 `-1.0`。

```java
import java.util.*;

/**
 * 赛码网要求的标准类名是 Main
 */
public class Main {

    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        // 1. 构建图
        Map<String, Map<String, Double>> graph = buildGraph(equations, values);

        double[] results = new double[queries.size()];

        // 2. 处理查询
        for (int i = 0; i < queries.size(); i++) {
            String start = queries.get(i).get(0);
            String end = queries.get(i).get(1);
            results[i] = findPath(graph, start, end, new HashSet<>());
        }

        return results;
    }

    private Map<String, Map<String, Double>> buildGraph(List<List<String>> equations, double[] values) {
        Map<String, Map<String, Double>> graph = new HashMap<>();
        for (int i = 0; i < equations.size(); i++) {
            String u = equations.get(i).get(0);
            String v = equations.get(i).get(1);
            double value = values[i];

            graph.computeIfAbsent(u, k -> new HashMap<>()).put(v, value);
            graph.computeIfAbsent(v, k -> new HashMap<>()).put(u, 1.0 / value);
        }
        return graph;
    }

    /**
     * 使用 DFS 在图中查找路径并计算结果
     */
    private double findPath(Map<String, Map<String, Double>> graph, String start, String end, Set<String> visited) {
        // 如果图中不包含起点或终点，直接返回 -1.0
        if (!graph.containsKey(start) || !graph.containsKey(end)) {
            return -1.0;
        }

        // 如果起点和终点相同
        if (start.equals(end)) {
            return 1.0;
        }

        visited.add(start);
        Map<String, Double> neighbors = graph.get(start);

        for (Map.Entry<String, Double> entry : neighbors.entrySet()) {
            String neighbor = entry.getKey();
            if (!visited.contains(neighbor)) {
                double pathValue = findPath(graph, neighbor, end, visited);
                // 如果找到了从邻居到终点的路径
                if (pathValue != -1.0) {
                    return entry.getValue() * pathValue;
                }
            }
        }

        // 如果所有邻居都无法到达终点
        return -1.0;
    }


    /**
     * 主函数，包含题目给出的测试用例。
     * @param args 命令行参数（未使用）。
     */
    public static void main(String[] args) {
        Main solution = new Main();

        System.out.println("--- 示例 1 ---");
        List<List<String>> equations1 = Arrays.asList(Arrays.asList("a", "b"), Arrays.asList("b", "c"));
        double[] values1 = {2.0, 3.0};
        List<List<String>> queries1 = Arrays.asList(
            Arrays.asList("a", "c"), Arrays.asList("b", "a"),
            Arrays.asList("a", "e"), Arrays.asList("a", "a"),
            Arrays.asList("x", "x")
        );
        System.out.println("输入: equations = ..., values = ..., queries = ...");
        double[] result1 = solution.calcEquation(equations1, values1, queries1);
        System.out.println("输出: " + Arrays.toString(result1));
        System.out.println();

        System.out.println("--- 示例 2 ---");
        List<List<String>> equations2 = Arrays.asList(Arrays.asList("a", "b"), Arrays.asList("b", "c"), Arrays.asList("bc", "cd"));
        double[] values2 = {1.5, 2.5, 5.0};
        List<List<String>> queries2 = Arrays.asList(
            Arrays.asList("a", "c"), Arrays.asList("c", "b"),
            Arrays.asList("bc", "cd"), Arrays.asList("cd", "bc")
        );
        System.out.println("输入: equations = ..., values = ..., queries = ...");
        double[] result2 = solution.calcEquation(equations2, values2, queries2);
        System.out.println("输出: " + Arrays.toString(result2));
    }
}
```
