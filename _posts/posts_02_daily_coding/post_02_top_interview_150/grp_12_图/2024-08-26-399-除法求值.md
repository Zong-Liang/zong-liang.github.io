---
title: 399. 除法求值
date: 2024-08-26 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 图]
tags: [图]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232527104.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你一个变量对数组 `equations` 和一个实数值数组 `values` 作为已知条件，其中 `equations[i] = [Ai, Bi]` 和 `values[i]` 共同表示等式 `Ai / Bi = values[i]`。每个 `Ai` 或 `Bi` 是一个表示单个变量的字符串。

另有一些以数组 `queries` 表示的问题，其中 `queries[j] = [Cj, Dj]` 表示第 `j` 个问题，请你根据已知条件找出 `Cj / Dj = ?` 的结果作为答案。

返回 **所有问题的答案**。如果存在某个无法确定的答案，则用 `-1.0` 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 `-1.0` 替代这个答案。

**注意：** 输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。

**注意：** 未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。

**示例 1:**

- **输入:** `equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]`
- **输出:** `[6.00000,0.50000,-1.00000,1.00000,-1.00000]`

**示例 2:**

- **输入:** `equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]`
- **输出:** `[3.75000,0.40000,5.00000,0.20000]`

**提示:**

- `1 <= equations.length <= 20`
- `1 <= queries.length <= 20`
- 变量由小写英文字母与数字组成

## 题解

### 解法一：图的构建与深度优先搜索 (DFS)

**思路：**

我们可以将这个问题建模为一个 **有向带权图** 的问题。

1.  **建模**：

    - 图中的 **节点** 表示变量（如 `"a"`, `"b"`）。
    - 图中的 **边** 表示两个变量之间的除法关系。
    - 如果已知 `a / b = 2.0`，则表示有一条从 `a` 指向 `b` 的边，权重为 `2.0`。
    - 同时，这也隐含了 `b / a = 1 / 2.0 = 0.5`，即有一条从 `b` 指向 `a` 的边，权重为 `0.5`。

2.  **问题转化**：

    - 对于查询 `C / D`，实际上就是寻找从节点 `C` 到节点 `D` 的一条路径。
    - 路径上所有边权重的 **乘积** 即为结果。
    - 例如：已知 `a / b = 2.0`，`b / c = 3.0`，求 `a / c`。路径为 `a -> b -> c`，结果为 `2.0 * 3.0 = 6.0`。

3.  **算法流程**：

    - **构图**：使用邻接表（`HashMap<String, HashMap<String, Double>>`）存储图结构。遍历 `equations`，对于每个等式 `Ai / Bi = val`，添加边 `Ai -> Bi` (权重 `val`) 和 `Bi -> Ai` (权重 `1.0/val`)。
    - **处理查询**：遍历 `queries`。

      - **边界检查**：如果查询中的变量不存在于图中，直接返回 `-1.0`。
      - **特殊情况**：如果查询 `X / X` 且 `X` 存在于图中，返回 `1.0`。
      - **搜索 (DFS)**：从起点出发进行 DFS。维护当前的累积乘积。使用 `visited` 集合防止环路（如 `a -> b -> a`）。如果找到终点，返回累积乘积；如果遍历完所有路径仍未找到，返回 `-1.0`。

**复杂度分析：**

- **时间复杂度：** $O(N \cdot M)$。

  - 构建图需要遍历所有等式，复杂度为 $O(N)$，其中 $N$ 是 `equations` 的长度。
  - 对于每个查询，最坏情况下 DFS 需要遍历整个图。假设图中不同变量个数为 $V$（$V \le 2N$），则单次查询为 $O(V)$。如果有 $M$ 个查询，总复杂度为 $O(M \cdot V)$，即 $O(M \cdot N)$。

- **空间复杂度：** $O(N)$。需要存储图的结构，图中最多有 $2N$ 个节点和 $2N$ 条边。递归栈的深度最大为 $O(N)$。

**代码片段：**

```java
// 核心 DFS 方法
private double dfs(String curr, String target, double value, Set<String> visited, Map<String, Map<String, Double>> graph) {
    // 如果当前节点就是目标节点，返回当前累积的 value
    if (curr.equals(target)) {
        return value;
    }

    visited.add(curr);

    // 遍历邻居
    Map<String, Double> neighbors = graph.get(curr);
    for (String nextNode : neighbors.keySet()) {
        if (!visited.contains(nextNode)) {
            double weight = neighbors.get(nextNode);
            // 继续搜索，路径权重累乘
            double result = dfs(nextNode, target, value * weight, visited, graph);
            // 如果找到了路径，直接返回结果
            if (result != -1.0) {
                return result;
            }
        }
    }

    // 回溯（本题不需要显式回溯移除 visited，因为我们要找的是任意一条简单路径）
    // 没找到路径
    return -1.0;
}
```

### 解法二：广度优先搜索 (BFS)

**思路：**

思路与 DFS 基本一致，只是在搜索路径时使用 BFS。BFS 适合寻找最短路径（即经过边数最少的除法链），在某些情况下可能比 DFS 更快找到目标节点，但在本题规模下两者效率相当。

1.  构建图（同 DFS）。
2.  对于每个查询 `start / end`，使用队列进行 BFS。
3.  队列中存储对象包含：`{当前节点, 从起点到当前的累积乘积}`。
4.  每次出队，检查是否到达 `end`，如果到达则返回乘积；否则将未访问的邻居入队，并更新乘积。

**复杂度分析：**

- **时间复杂度：** $O(M \cdot N)$。
- **空间复杂度：** $O(N)$。

_(由于代码结构相似，核心差异仅在于使用 Queue 代替递归栈，此处略去 BFS 代码片段，完整代码展示 DFS)_

### 完整代码

```java
import java.util.*;

public class Main {

    // 核心算法实现：DFS
    public static double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        // 1. 构建图
        // graphMap: startNode -> {endNode -> value}
        Map<String, Map<String, Double>> graph = new HashMap<>();

        for (int i = 0; i < equations.size(); i++) {
            String u = equations.get(i).get(0);
            String v = equations.get(i).get(1);
            double val = values[i];

            // 添加 u -> v 的边，权重为 val
            graph.putIfAbsent(u, new HashMap<>());
            graph.get(u).put(v, val);

            // 添加 v -> u 的边，权重为 1.0 / val
            graph.putIfAbsent(v, new HashMap<>());
            graph.get(v).put(u, 1.0 / val);
        }

        // 2. 处理查询
        double[] results = new double[queries.size()];
        for (int i = 0; i < queries.size(); i++) {
            String start = queries.get(i).get(0);
            String end = queries.get(i).get(1);

            // 2.1 边界情况：如果图中不包含查询的变量
            if (!graph.containsKey(start) || !graph.containsKey(end)) {
                results[i] = -1.0;
            }
            // 2.2 特殊情况：除数和被除数相同
            else if (start.equals(end)) {
                results[i] = 1.0;
            }
            // 2.3 启动 DFS 搜索
            else {
                Set<String> visited = new HashSet<>();
                results[i] = dfs(start, end, 1.0, visited, graph);
            }
        }

        return results;
    }

    /**
     * DFS 搜索路径
     * @param curr 当前节点
     * @param target 目标节点
     * @param accValue 从起点到当前节点的累积乘积
     * @param visited 已访问节点集合，防止死循环
     * @param graph 图结构
     * @return 最终乘积，如果不可达返回 -1.0
     */
    private static double dfs(String curr, String target, double accValue, Set<String> visited, Map<String, Map<String, Double>> graph) {
        // 标记当前节点已访问
        visited.add(curr);

        Map<String, Double> neighbors = graph.get(curr);

        // 如果邻居中直接包含目标节点，直接返回结果
        if (neighbors.containsKey(target)) {
            return accValue * neighbors.get(target);
        }

        // 遍历所有未访问的邻居
        for (Map.Entry<String, Double> entry : neighbors.entrySet()) {
            String nextNode = entry.getKey();
            if (!visited.contains(nextNode)) {
                double result = dfs(nextNode, target, accValue * entry.getValue(), visited, graph);
                // 如果找到了一条有效路径（result != -1.0），直接逐层返回
                if (result != -1.0) {
                    return result;
                }
            }
        }

        // 所有路径都走不通
        return -1.0;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        // equations = [["a","b"],["b","c"]], values = [2.0,3.0]
        List<List<String>> equations1 = new ArrayList<>();
        equations1.add(Arrays.asList("a", "b"));
        equations1.add(Arrays.asList("b", "c"));
        double[] values1 = {2.0, 3.0};

        // queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
        List<List<String>> queries1 = new ArrayList<>();
        queries1.add(Arrays.asList("a", "c"));
        queries1.add(Arrays.asList("b", "a"));
        queries1.add(Arrays.asList("a", "e"));
        queries1.add(Arrays.asList("a", "a"));
        queries1.add(Arrays.asList("x", "x"));

        System.out.println("示例 1 输入:");
        System.out.println("Equations: " + equations1);
        System.out.println("Values: " + Arrays.toString(values1));

        double[] res1 = calcEquation(equations1, values1, queries1);
        System.out.println("示例 1 输出: " + Arrays.toString(res1));
        // 预期: [6.0, 0.5, -1.0, 1.0, -1.0]
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        // equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0]
        List<List<String>> equations2 = new ArrayList<>();
        equations2.add(Arrays.asList("a", "b"));
        equations2.add(Arrays.asList("b", "c"));
        equations2.add(Arrays.asList("bc", "cd"));
        double[] values2 = {1.5, 2.5, 5.0};

        List<List<String>> queries2 = new ArrayList<>();
        queries2.add(Arrays.asList("a", "c"));
        queries2.add(Arrays.asList("c", "b"));
        queries2.add(Arrays.asList("bc", "cd"));
        queries2.add(Arrays.asList("cd", "bc"));

        System.out.println("示例 2 输入:");
        System.out.println("Equations: " + equations2);

        double[] res2 = calcEquation(equations2, values2, queries2);
        System.out.println("示例 2 输出: " + Arrays.toString(res2));
        // 预期: [3.75, 0.4, 5.0, 0.2]
    }
}
```
