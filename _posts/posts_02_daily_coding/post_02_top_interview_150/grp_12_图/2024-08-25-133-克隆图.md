---
title: 133. 克隆图
date: 2024-08-25 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 图]
tags: [图]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232455743.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

给你无向 **连通** 图中一个节点的引用，请你返回该图的 **深拷贝**（克隆）。

图中的每个节点都包含它的值 `val` (`int`) 和其邻居的列表 (`list[Node]`)。

```java
class Node {
    public int val;
    public List<Node> neighbors;
}
```

**测试用例格式：**

简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1 (`val = 1`)，第二个节点值为 2 (`val = 2`)，以此类推。该图在测试用例中使用邻接列表表示。

**邻接列表** 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。

给定节点将始终是图中的第一个节点（值为 1）。你必须将 **给定节点的拷贝** 作为对克隆图的引用返回。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png)

- **输入:** `adjList = [[2,4],[1,3],[2,4],[1,3]]`
- **输出:** `[[2,4],[1,3],[2,4],[1,3]]`

**示例 2:**

- **输入:** `adjList = [[]]`
- **输出:** `[[]]`

**提示:**

- 这张图中的节点数在 `[0, 100]` 之间。
- `1 <= Node.val <= 100`
- 每个节点值 `Node.val` 都是唯一的。
- 图中没有重复的边，也没有自环。
- 图是连通图，你可以从给定节点访问到所有节点。

## 题解

### 解法一：深度优先搜索 (DFS) - 递归

**思路：**

克隆图的核心难点在于处理**无向图**中的**环**以及**重复访问**的问题。为了实现深拷贝，我们需要遍历图中的每一个节点，并为每一个原节点创建一个对应的克隆节点。

为了避免陷入死循环（因为图中有环）以及避免重复创建节点，我们需要使用一个 **哈希表 (HashMap)** 来存储已经访问过的节点。

- **Key**: 原节点 (Original Node)
- **Value**: 克隆节点 (Cloned Node)

**算法流程：**

1.  **终止条件**：如果输入节点为空，返回 `null`。
2.  **查表**：检查当前节点是否已经在哈希表中。如果存在，说明该节点已经被克隆过，直接返回哈希表中存储的克隆节点。
3.  **克隆**：如果不在哈希表中，创建一个新的节点（值与原节点相同），并将 `<原节点, 新节点>` 放入哈希表。
4.  **递归构建邻居**：遍历原节点的邻居列表，对每个邻居递归调用 DFS 函数，并将返回的克隆邻居加入到当前新节点的邻居列表中。
5.  **返回**：返回当前创建的新节点。

**复杂度分析：**

- **时间复杂度：** $O(N + E)$，其中 $N$ 是节点数，$E$ 是边数。每个节点和每条边只会被访问一次。
- **空间复杂度：** $O(N)$。哈希表需要存储 $N$ 个节点，递归调用栈在最坏情况下（链状图）深度为 $N$。

**代码片段：**

```java
private Map<Node, Node> visited = new HashMap<>();

public Node cloneGraph(Node node) {
    if (node == null) {
        return null;
    }

    // 如果该节点已经被访问过，直接从 map 中取出对应的克隆节点返回
    if (visited.containsKey(node)) {
        return visited.get(node);
    }

    // 克隆当前节点（先不克隆邻居，防止死循环）
    Node cloneNode = new Node(node.val, new ArrayList<>());
    // 哈希表记录：原节点 -> 克隆节点
    visited.put(node, cloneNode);

    // 遍历原节点的邻居
    for (Node neighbor : node.neighbors) {
        // 递归克隆邻居，并添加到克隆节点的邻居列表中
        cloneNode.neighbors.add(cloneGraph(neighbor));
    }

    return cloneNode;
}
```

### 解法二：广度优先搜索 (BFS) - 迭代

**思路：**

如果不喜欢递归，或者担心递归栈溢出，可以使用 BFS。同样需要借助 **哈希表** 来记录已克隆的节点。

1.  **初始化**：创建一个队列，将起始节点加入队列。同时创建起始节点的克隆节点，并将映射关系存入哈希表。
2.  **循环**：当队列不为空时，取出队头节点 `n`。
3.  **遍历邻居**：遍历 `n` 的所有邻居 `neighbor`。

    - 如果 `neighbor` **不在** 哈希表中：说明还没被克隆过。创建一个新的克隆节点，存入哈希表，并将 `neighbor` 加入队列。
    - **构建连接**：无论 `neighbor` 是新克隆的还是之前克隆的，都要将其对应的克隆节点添加到 `n` 的克隆节点的邻居列表中。

**复杂度分析：**

- **时间复杂度：** $O(N + E)$。
- **空间复杂度：** $O(N)$。哈希表存储所有节点，BFS 队列在最坏情况下需要存储 $O(N)$ 的节点（例如星形图）。

**代码片段：**

```java
public Node cloneGraph(Node node) {
    if (node == null) return null;

    Map<Node, Node> visited = new HashMap<>();
    Queue<Node> queue = new LinkedList<>();

    // 初始化
    Node cloneNode = new Node(node.val, new ArrayList<>());
    visited.put(node, cloneNode);
    queue.offer(node);

    while (!queue.isEmpty()) {
        Node curr = queue.poll();
        // 遍历当前节点的所有邻居
        for (Node neighbor : curr.neighbors) {
            if (!visited.containsKey(neighbor)) {
                // 如果邻居没被访问过，克隆它，并加入队列
                visited.put(neighbor, new Node(neighbor.val, new ArrayList<>()));
                queue.offer(neighbor);
            }
            // 将克隆的邻居添加到当前克隆节点的邻居列表中
            // visited.get(curr) 是当前节点的克隆
            // visited.get(neighbor) 是邻居的克隆
            visited.get(curr).neighbors.add(visited.get(neighbor));
        }
    }
    return visited.get(node);
}
```

### 完整代码

```java
import java.util.*;

public class Main {

    // 题目提供的 Node 定义
    static class Node {
        public int val;
        public List<Node> neighbors;

        public Node() {
            val = 0;
            neighbors = new ArrayList<Node>();
        }

        public Node(int _val) {
            val = _val;
            neighbors = new ArrayList<Node>();
        }

        public Node(int _val, ArrayList<Node> _neighbors) {
            val = _val;
            neighbors = _neighbors;
        }
    }

    // 用于 DFS 的全局哈希表
    private Map<Node, Node> visited = new HashMap<>();

    // 核心算法实现：DFS 递归解法
    public Node cloneGraph(Node node) {
        if (node == null) {
            return null;
        }

        // 1. 如果已经克隆过，直接返回
        if (visited.containsKey(node)) {
            return visited.get(node);
        }

        // 2. 创建当前节点的克隆（只复制值）
        Node cloneNode = new Node(node.val, new ArrayList<>());
        // 3. 记录映射关系，防止死循环
        visited.put(node, cloneNode);

        // 4. 递归处理所有邻居
        for (Node neighbor : node.neighbors) {
            cloneNode.neighbors.add(cloneGraph(neighbor));
        }

        return cloneNode;
    }

    // --- 辅助方法：打印图（BFS遍历） ---
    public static void printGraph(Node node) {
        if (node == null) return;
        Set<Node> visitedPrint = new HashSet<>();
        Queue<Node> queue = new LinkedList<>();
        queue.offer(node);
        visitedPrint.add(node);

        while (!queue.isEmpty()) {
            Node curr = queue.poll();
            System.out.print("Node " + curr.val + " neighbors: [");
            for (int i = 0; i < curr.neighbors.size(); i++) {
                System.out.print(curr.neighbors.get(i).val);
                if (i < curr.neighbors.size() - 1) System.out.print(", ");
            }
            System.out.println("]");

            for (Node neighbor : curr.neighbors) {
                if (!visitedPrint.contains(neighbor)) {
                    visitedPrint.add(neighbor);
                    queue.offer(neighbor);
                }
            }
        }
    }

    public static void main(String[] args) {
        Main solution = new Main();

        // --- 示例 1 测试 ---
        // 构建图: 1--2, 2--3, 3--4, 4--1 (一个环)
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        Node n4 = new Node(4);

        n1.neighbors.add(n2); n1.neighbors.add(n4);
        n2.neighbors.add(n1); n2.neighbors.add(n3);
        n3.neighbors.add(n2); n3.neighbors.add(n4);
        n4.neighbors.add(n1); n4.neighbors.add(n3);

        System.out.println("示例 1 原图结构:");
        printGraph(n1);

        // 执行克隆
        Node clonedGraph1 = solution.cloneGraph(n1);

        System.out.println("\n示例 1 克隆图结构:");
        printGraph(clonedGraph1);

        System.out.println("\n验证是否为深拷贝 (检查对象引用):");
        System.out.println("n1 == clonedGraph1? " + (n1 == clonedGraph1)); // 预期: false
        System.out.println("-----------------------------");

        // --- 示例 2 测试 (空图) ---
        Main solution2 = new Main(); //以此重置 visited map
        Node emptyResult = solution2.cloneGraph(null);
        System.out.println("示例 2 (空图) 输出: " + emptyResult); // 预期: null
    }
}
```
