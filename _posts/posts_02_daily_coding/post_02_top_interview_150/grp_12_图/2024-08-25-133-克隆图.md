---
title: 133. 克隆图
date: 2024-08-25 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 图]
tags: [图]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232455743.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目：133. 克隆图

给你无向 **连通** 图中一个节点的引用，请你返回该图的 **深拷贝**（克隆）。

图中的每个节点都包含它的值 `val` (`int`) 和其邻居的列表 (`list[Node]`)。

```java
class Node {
    public int val;
    public List<Node> neighbors;
}
```

**测试用例格式：**

简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1 (`val = 1`)，第二个节点值为 2 (`val = 2`)，以此类推。该图在测试用例中使用邻接列表表示。

**邻接列表** 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。

给定节点将始终是图中的第一个节点（值为 1）。你必须将 **给定节点的拷贝** 作为对克隆图的引用返回。

**示例 1:**

![示例1图片](https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png)

- **输入:** `adjList = [[2,4],[1,3],[2,4],[1,3]]`
- **输出:** `[[2,4],[1,3],[2,4],[1,3]]`

**示例 2:**

- **输入:** `adjList = [[]]`
- **输出:** `[[]]`

**提示:**

- 这张图中的节点数在 `[0, 100]` 之间。
- `1 <= Node.val <= 100`
- 每个节点值 `Node.val` 都是唯一的。
- 图中没有重复的边，也没有自环。
- 图是连通图，你可以从给定节点访问到所有节点。

## Java 代码

**算法思路：(图的遍历 + 哈希表)**

克隆一个图的关键在于处理好节点之间的连接关系，同时避免因为图中的环而陷入无限循环。我们可以使用图的遍历算法（DFS 或 BFS）结合一个哈希表来完成这个任务。

1.  **哈希表 `visited`:** 我们需要一个哈希表（`Map<Node, Node>`）来存储 **原始节点** 到 **克隆节点** 的映射。这个哈希表有两个核心作用：
    - **防止重复克隆：** 如果一个原始节点已经在哈希表中，说明它已经被访问并克隆过了，我们直接从哈希表中获取其克隆节点即可。
    - **存储映射关系：** 用于后续建立克隆节点之间的邻居关系。
2.  **深度优先搜索 (DFS) - 递归实现:**
    - 定义一个递归函数 `clone(Node node)`。
    - **递归基:** 如果 `node` 为 `null`，直接返回 `null`。
    - **检查是否已克隆:** 如果 `visited` 中已经包含了 `node`，直接返回 `visited.get(node)`。
    - **克隆当前节点:**
      a. 创建一个新的节点 `cloneNode`，其 `val` 与 `node.val` 相同。
      b. 将这个映射关系 `(node, cloneNode)` 存入 `visited` 哈希表。 **这一步非常关键**，必须在递归调用其邻居之前完成，以防止死循环。
    - **克隆邻居:** 遍历 `node` 的所有邻居 `neighbor`。对于每个 `neighbor`，递归调用 `clone(neighbor)`，并将返回的克隆邻居节点添加到 `cloneNode` 的邻居列表中。
    - 返回 `cloneNode`。

通过这种方式，我们确保每个节点只被创建一次，并且正确地复制了所有的连接关系。

```java
import java.util.*;

// LeetCode 提供的 Node 类定义
class Node {
    public int val;
    public List<Node> neighbors;
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}


public class Main {

    // 哈希表，用于存储 <原始节点, 克隆节点> 的映射
    private Map<Node, Node> visited = new HashMap<>();

    public Node cloneGraph(Node node) {
        if (node == null) {
            return null;
        }

        // 如果节点已经被克隆过，直接返回克隆后的节点
        if (visited.containsKey(node)) {
            return visited.get(node);
        }

        // 克隆当前节点
        Node cloneNode = new Node(node.val, new ArrayList<>());
        // 将新创建的节点放入哈希表中
        visited.put(node, cloneNode);

        // 递归克隆所有邻居
        for (Node neighbor : node.neighbors) {
            cloneNode.neighbors.add(cloneGraph(neighbor));
        }

        return cloneNode;
    }


    public static void main(String[] args) {
        Main solution = new Main();

        // --- 构建示例 1 的图 ---
        Node node1 = new Node(1);
        Node node2 = new Node(2);
        Node node3 = new Node(3);
        Node node4 = new Node(4);
        node1.neighbors.addAll(Arrays.asList(node2, node4));
        node2.neighbors.addAll(Arrays.asList(node1, node3));
        node3.neighbors.addAll(Arrays.asList(node2, node4));
        node4.neighbors.addAll(Arrays.asList(node1, node3));

        System.out.println("--- 示例 1 ---");
        System.out.println("输入: adjList = [[2,4],[1,3],[2,4],[1,3]]");
        Node clonedNode1 = solution.cloneGraph(node1);
        // 此处应有验证克隆图结构的逻辑，为简化，仅打印调用成功
        System.out.println("输出: (克隆图已生成，结构与输入相同)");
        System.out.println();
    }
}
```
