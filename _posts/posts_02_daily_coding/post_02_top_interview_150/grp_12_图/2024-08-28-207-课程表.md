---
title: 207. 课程表
date: 2024-08-28 06:00:00 +0800
categories: [Daily Coding, Top Interview 150, 图]
tags: [图]
toc: true
math: true
pin: false
render_with_liquid: false
image:
  path: https://cdn.jsdelivr.net/gh/Zong-Liang/blog_images/blog/2024/daily_coding/20251121232556557.png
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
---

## 题目

**描述：**

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1`。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]`，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi`。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0`，你需要先完成课程 `1`。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true`；否则，返回 `false`。

**示例 1:**

- **输入:** `numCourses = 2`, `prerequisites = [[1,0]]`
- **输出:** `true`
- **解释:** 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。这是可能的。

**示例 2:**

- **输入:** `numCourses = 2`, `prerequisites = [[1,0],[0,1]]`
- **输出:** `false`
- **解释:** 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。

**提示:**

- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= 5000`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- `prerequisites[i]` 中的所有课程对 **互不相同**

## 题解

### 解法一：广度优先搜索 (BFS) - Kahn 算法

**思路：**

这是一个典型的 **拓扑排序** 问题。我们可以将课程看作图中的节点，先修关系看作有向边。

例如 `[a, b]` 表示有一条从 `b` 指向 `a` 的有向边（`b -> a`）。

只有当一个节点的 **入度（Indegree）** 为 0 时，表示它没有任何先修课程（或者先修课程已经完成），我们才能学习这门课。

**算法流程：**

1.  **建图与计算入度**：

    - 使用邻接表（`List<List<Integer>>`）存储图结构。
    - 使用数组 `indegrees` 记录每个节点的入度。
    - 遍历 `prerequisites`，对于 `[a, b]`，在邻接表中添加 `b -> a`，并将 `a` 的入度加 1。

2.  **入队**：

    - 将所有 **入度为 0** 的节点加入队列。

3.  **BFS 搜索**：

    - 当队列不为空时，取出队头节点 `pre`（代表这门课修完了）。
    - 记录已修课程数量 `count++`。
    - 遍历 `pre` 的所有邻居节点 `cur`（即依赖 `pre` 的课程）：

      - 将 `cur` 的入度减 1。
      - 如果 `cur` 的入度变为 0，说明它的所有先修课都已完成，将其加入队列。

4.  **判断结果**：

    - 如果最终 `count` 等于 `numCourses`，说明所有课程都能完成，返回 `true`。
    - 否则，说明图中存在环（环内的节点入度永远无法减为 0），返回 `false`。

**复杂度分析：**

- **时间复杂度：** $O(N + M)$，其中 $N$ 为课程数（节点数），$M$ 为先修课程的要求数（边数）。我们需要遍历所有的节点和边。
- **空间复杂度：** $O(N + M)$。邻接表存储边需要 $O(M)$，入度数组和队列需要 $O(N)$。

**代码片段：**

```java
public boolean canFinish(int numCourses, int[][] prerequisites) {
    int[] indegrees = new int[numCourses];
    List<List<Integer>> adjacency = new ArrayList<>();
    for(int i = 0; i < numCourses; i++) adjacency.add(new ArrayList<>());

    // 1. 建图并统计入度
    for(int[] cp : prerequisites) {
        indegrees[cp[0]]++;
        adjacency.get(cp[1]).add(cp[0]);
    }

    // 2. 将所有入度为 0 的节点入队
    Queue<Integer> queue = new LinkedList<>();
    for(int i = 0; i < numCourses; i++) {
        if(indegrees[i] == 0) queue.offer(i);
    }

    // 3. BFS
    int count = 0;
    while(!queue.isEmpty()) {
        int pre = queue.poll();
        count++;
        for(int cur : adjacency.get(pre)) {
            indegrees[cur]--;
            if(indegrees[cur] == 0) queue.offer(cur);
        }
    }

    return count == numCourses;
}
```

### 解法二：深度优先搜索 (DFS) - 检测环

**思路：**

另一种思路是通过 DFS 判断图中是否存在 **环**。如果存在环，则无法完成课程。

为了区分节点的访问状态，我们使用一个 `flags` 数组记录状态：

- `0`：未被访问。
- `1`：正在访问（当前递归栈中）。
- `-1`：已被访问（且确认无环）。

**算法流程：**

1.  对每个未访问过的节点调用 DFS。
2.  在 DFS 中：

    - 将当前节点标记为 `1`。
    - 遍历该节点的邻居：

      - 如果邻居状态为 `1`，说明回到了正在递归路径上的节点，**发现环**，返回 `false`。
      - 如果邻居状态为 `0`，递归访问。如果递归返回 `false`，则向上返回 `false`。

    - 所有邻居访问结束无异常，将当前节点标记为 `-1`，返回 `true`。

**复杂度分析：**

- **时间复杂度：** $O(N + M)$。
- **空间复杂度：** $O(N + M)$。

**代码片段：**

```java
public boolean canFinish(int numCourses, int[][] prerequisites) {
    List<List<Integer>> adjacency = new ArrayList<>();
    for(int i = 0; i < numCourses; i++) adjacency.add(new ArrayList<>());
    for(int[] cp : prerequisites) adjacency.get(cp[1]).add(cp[0]);

    int[] flags = new int[numCourses];
    for(int i = 0; i < numCourses; i++) {
        if(!dfs(adjacency, flags, i)) return false;
    }
    return true;
}

private boolean dfs(List<List<Integer>> adjacency, int[] flags, int i) {
    if(flags[i] == 1) return false; // 遇到正在访问的节点，说明有环
    if(flags[i] == -1) return true; // 遇到已完成访问的节点，无需再访

    flags[i] = 1; // 标记为正在访问
    for(Integer j : adjacency.get(i)) {
        if(!dfs(adjacency, flags, j)) return false;
    }
    flags[i] = -1; // 标记为已完成
    return true;
}
```

### 完整代码

这里提供 **解法一（BFS / Kahn 算法）** 的完整代码，因为这种写法不仅能判断是否可以完成，稍微修改一下就能直接输出拓扑排序的结果（即学习顺序），在面试中更为通用。

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class Main {

    // 核心算法实现：BFS 拓扑排序
    public static boolean canFinish(int numCourses, int[][] prerequisites) {
        // 1. 初始化入度数组和邻接表
        int[] indegrees = new int[numCourses];
        List<List<Integer>> adjacency = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            adjacency.add(new ArrayList<>());
        }

        // 2. 构建图
        // prerequisites[i] = [a, b] 表示 b -> a
        for (int[] cp : prerequisites) {
            int course = cp[0];
            int prerequisite = cp[1];

            // prerequisite 指向 course
            adjacency.get(prerequisite).add(course);
            // course 的入度 +1
            indegrees[course]++;
        }

        // 3. 将所有入度为 0 的节点加入队列
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (indegrees[i] == 0) {
                queue.offer(i);
            }
        }

        // 4. 开始 BFS
        int visitedCount = 0;
        while (!queue.isEmpty()) {
            int pre = queue.poll();
            visitedCount++;

            // 遍历当前课程的所有后续课程
            for (int cur : adjacency.get(pre)) {
                // 后续课程入度减 1
                indegrees[cur]--;
                // 如果入度变为 0，说明依赖已全部解决，加入队列
                if (indegrees[cur] == 0) {
                    queue.offer(cur);
                }
            }
        }

        // 5. 如果访问过的节点数等于课程总数，说明没有环
        return visitedCount == numCourses;
    }

    public static void main(String[] args) {
        // --- 示例 1 测试 ---
        int numCourses1 = 2;
        int[][] prerequisites1 = {{1, 0}};

        System.out.println("示例 1 输入: numCourses = 2, prerequisites = [[1,0]]");
        boolean res1 = canFinish(numCourses1, prerequisites1);
        System.out.println("示例 1 输出: " + res1); // 预期: true
        System.out.println("-----------------------------");

        // --- 示例 2 测试 ---
        int numCourses2 = 2;
        int[][] prerequisites2 = {{1, 0}, {0, 1}};

        System.out.println("示例 2 输入: numCourses = 2, prerequisites = [[1,0],[0,1]]");
        boolean res2 = canFinish(numCourses2, prerequisites2);
        System.out.println("示例 2 输出: " + res2); // 预期: false
        System.out.println("-----------------------------");

        // --- 示例 3 测试 (更复杂的环) ---
        // 0->1, 1->2, 2->0
        int numCourses3 = 3;
        int[][] prerequisites3 = {{1, 0}, {2, 1}, {0, 2}};

        System.out.println("示例 3 输入: numCourses = 3, prerequisites = [[1,0], [2,1], [0,2]]");
        boolean res3 = canFinish(numCourses3, prerequisites3);
        System.out.println("示例 3 输出: " + res3); // 预期: false
        System.out.println("-----------------------------");

        // --- 示例 4 测试 (无依赖) ---
        int numCourses4 = 3;
        int[][] prerequisites4 = {};

        System.out.println("示例 4 输入: numCourses = 3, prerequisites = []");
        boolean res4 = canFinish(numCourses4, prerequisites4);
        System.out.println("示例 4 输出: " + res4); // 预期: true
    }
}
```
