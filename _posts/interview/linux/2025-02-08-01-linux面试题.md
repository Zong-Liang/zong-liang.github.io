---
title: "01-Linux面试题"
date: 2025-02-08 18:58:48 +0800
categories: [面试题, Linux面试题]
tags: [面试八股, Linux面试题]
pin: false
toc: true
math: true
---

## 说说 Linux 常用命令?

关于 Linux 常用命令，可以将其分为几个类别来介绍，这样会更有条理：

### 1. 文件和目录管理

这是在 Linux 系统中最基本也是最频繁的操作。

- **ls (list)**: 这是我首先想到的命令，用于列出目录中的文件和子目录。通过不同的选项，可以实现更多的功能，例如 `ls -l` 会以长格式显示详细信息，而 `ls -a` 则会显示包括隐藏文件在内的所有文件。
- **cd (change directory)**: 用于切换当前工作目录。比如 `cd /home` 会进入 home 目录，`cd ..` 会返回上一级目录。
- **pwd (print working directory)**: 这个命令很简单，就是显示当前所在的目录路径。
- **mkdir (make directory)**: 用于创建一个新的目录。例如 `mkdir new_folder`。
- **rm (remove)**: 用于删除文件或目录。删除文件可以直接使用 `rm file.txt`，但删除目录需要加上 `-r` 参数，即 `rm -r directory`。使用 `rm` 命令时我会特别小心，因为删除后很难恢复。
- **cp (copy)**: 用于复制文件或目录。例如 `cp source.txt destination.txt` 是复制文件，`cp -r source_dir destination_dir` 是复制目录。
- **mv (move)**: 用于移动或重命名文件和目录。例如 `mv old_name.txt new_name.txt` 是重命名，`mv file.txt /new_directory/` 是将文件移动到新的目录。
- **touch**: 主要用于创建新的空文件，或者更新已有文件的时间戳。

### 2. 文件内容查看和处理

- **cat (concatenate)**: 用于查看文件的全部内容，一次性将内容输出到终端。对于大文件，我通常会使用 `less`。
- **less**: 这是一个非常方便的分页查看器，允许您前后滚动浏览文件内容，并且支持搜索。
- **head / tail**: 这两个命令用于查看文件的开头或结尾部分，默认是 10 行。例如，`tail -f log.txt` 是一个我经常用来实时监控日志文件更新的命令。
- **grep (global regular expression print)**: 这是一个强大的文本搜索工具，可以使用正则表达式在文件中查找匹配的行。例如，`grep "error" log.txt` 可以找出日志文件中所有包含 "error" 的行。
- **find**: 用于在指定目录中查找文件。它的功能非常强大，可以根据文件名、大小、修改时间等多种条件进行搜索。例如 `find / -name "*.log"` 会在整个系统中查找以 .log 结尾的文件。

### 3. 系统管理和监控

- **ps (process status)**: 用于查看当前系统中运行的进程。我通常会使用 `ps aux` 或者 `ps -ef` 来获取更详细的进程信息。
- **top / htop**: `top` 是一个动态的实时进程查看器，可以显示系统资源的使用情况和正在运行的进程。`htop` 是一个交互性更强、更易用的 `top` 替代品。
- **df (disk free)**: 用于查看文件系统的磁盘空间占用情况。我常用 `df -h`，它会以更易读的格式（例如 GB、MB）显示大小。
- **du (disk usage)**: 用于估算文件或目录的磁盘使用空间。`du -sh /path/to/directory` 可以方便地查看一个目录的总大小。
- **kill**: 用于向进程发送信号，最常用的是终止进程。例如 `kill 12345`。如果进程无法正常终止，我会使用 `kill -9 12345` 发送 SIGKILL 信号来强制终止。
- **chmod (change mode)**: 用于修改文件或目录的访问权限。
- **chown (change owner)**: 用于更改文件或目录的所有者和所属组。

### 4. 网络命令

- **ping**: 用于测试与另一台主机之间的网络连接。
- **ifconfig / ip**: `ifconfig` (在较新的系统中逐渐被 `ip` 命令取代) 用于查看和配置网络接口。`ip addr` 是我现在更常用的命令。
- **netstat / ss**: 用于显示网络连接、路由表、接口统计等信息。`ss` 是 `netstat` 的一个更快、信息更丰富的替代品。
- **curl / wget**: 这两个命令都用于从网络上下载文件。`curl` 功能更强大，不仅可以下载，还可以发送各种 HTTP 请求，常用于 API 测试。

### 5. 其他常用命令

- **sudo (superuser do)**: 允许普通用户以超级用户（root）的权限执行命令。
- **man (manual)**: 当我不确定一个命令的用法时，`man` 命令是我的好帮手，它会显示命令的手册页。
- **history**: 显示在终端中执行过的历史命令。
- **tar**: 用于文件的打包和解包，通常与 `gzip` 或 `bzip2` 结合使用进行压缩和解压，例如 `tar -czvf archive.tar.gz /path/to/dir`。

---

## 文件操作的命令有哪些？

以下是我归纳的文件操作相关命令：

### 1. 创建文件 (Creating Files)

- **touch**: 这是创建空文件的标准命令。如果文件已存在，它会更新该文件的访问和修改时间戳。
  - **示例**: `touch new_file.txt` 创建一个名为 `new_file.txt` 的空文件。
- **重定向操作符 `>` 和 `>>`**: 虽然不是一个独立的命令，但重定向是创建并写入文件内容的极其常用的方法。
  - **示例**: `echo "Hello, World" > file.txt` 会创建一个名为 `file.txt` 的文件，并将 "Hello, World" 写入其中。如果文件已存在，原有内容会被覆盖。
  - **示例**: `echo "Append this line" >> file.txt` 会将新内容追加到文件的末尾，而不会覆盖原有内容。
- **cat > [filename]**: 这也是一种利用 `cat` 命令和重定向来创建文件的方式，可以让你直接在终端输入多行内容，并以 `Ctrl+D` 结束输入并保存。
  - **示例**:
    ```bash
    cat > multi_line_file.txt
    This is the first line.
    This is the second line.
    (按 Ctrl+D 保存)
    ```

### 2. 查看文件内容 (Viewing Files)

- **cat (concatenate)**: 用于一次性显示文件的全部内容。适合查看内容较少的文件。
  - **示例**: `cat /etc/hosts`
- **less**: 这是一个功能强大的分页查看器，特别适用于大文件。它允许你自由地向上或向下滚动，进行文本搜索 (`/` 后跟关键词)，并且退出后不会在终端留下文件内容。
  - **示例**: `less /var/log/syslog`
- **more**: 与 `less` 类似，但功能相对较少，例如它只支持向下翻页。在现代系统中，`less` 更为常用。
- **head**: 查看文件的开头部分，默认显示前 10 行。
  - **示例**: `head -n 20 error.log` 显示 `error.log` 文件的前 20 行。
- **tail**: 查看文件的结尾部分，默认显示末尾 10 行。这是监控日志文件更新的利器。
  - **示例**: `tail -n 50 access.log` 显示 `access.log` 文件的末尾 50 行。
  - **示例**: `tail -f access.log` 会持续显示追加到 `access.log` 文件的新内容，直到手动停止 (`Ctrl+C`)。

### 3. 编辑文件 (Editing Files)

- **nano**: 一款非常适合新手的文本编辑器，界面直观，操作简单，快捷键在屏幕下方有提示。
- **vim / vi (Vi IMproved)**: 这是 Linux 系统中最强大、最高效的文本编辑器之一，虽然学习曲线比较陡峭，但熟练掌握后可以极大地提升工作效率。它有多种模式，如命令模式、插入模式和可视模式。

### 4. 复制、移动和重命名文件 (Copying, Moving, and Renaming)

- **cp (copy)**: 用于复制文件。
  - **示例**: `cp source.txt destination.txt` 将 `source.txt` 复制为 `destination.txt`。
  - **示例**: `cp /path/to/source.txt /path/to/destination_directory/` 将文件复制到另一个目录下。
- **mv (move)**: 用于移动文件或重命名文件。在同一个目录下操作时，其效果就是重命名。
  - **示例 (重命名)**: `mv old_filename.txt new_filename.txt`
  - **示例 (移动)**: `mv important.doc /mnt/backup/`

### 5. 删除文件 (Deleting Files)

- **rm (remove)**: 用于删除文件。这是一个需要谨慎使用的命令，因为默认情况下文件删除后无法恢复。
  - **示例**: `rm old_file.txt`
  - **示例**: `rm -i *.tmp` 在删除每个匹配 `.tmp` 的文件前都会进行提示确认。
  - **示例**: `rm -f data.dat` 强制删除文件，不进行任何提示，即使文件是只读的。

### 6. 搜索文件 (Searching for Files)

- **find**: 一个功能非常强大的文件搜索工具，可以根据名称、类型、大小、修改时间等多种属性进行搜索。
  - **示例**: `find /home/user -name "*.java"` 在 `/home/user` 目录及其子目录下查找所有以 `.java` 结尾的文件。
  - **示例**: `find /tmp -type f -size +10M` 在 `/tmp` 目录中查找所有大于 10MB 的普通文件。
- **locate**: 通过一个预先构建的数据库来快速查找文件，速度比 `find` 快得多，但可能无法找到最新创建的文件（除非手动更新数据库 `updatedb`）。
  - **示例**: `locate my_config.conf`

### 7. 文件权限和所有权 (File Permissions and Ownership)

- **chmod (change mode)**: 用于修改文件的读、写、执行权限。
  - **示例**: `chmod 755 script.sh` (数字模式) 赋予所有者读/写/执行权限，同组用户和其他用户读/执行权限。
  - **示例**: `chmod u+x script.sh` (符号模式) 为文件所有者（user）增加执行（execute）权限。
- **chown (change owner)**: 用于更改文件的所有者和所属组。
  - **示例**: `chown newuser:newgroup file.txt` 将 `file.txt` 的所有者改为 `newuser`，所属组改为 `newgroup`。

### 8. 其他相关命令

- **file**: 用于确定文件类型（例如文本文件、可执行文件、图片等）。
  - **示例**: `file my_script.sh` 可能会输出 `my_script.sh: Bourne-Again shell script, ASCII text executable`。
- **wc (word count)**: 用于统计文件的行数、单词数和字节数。
  - **示例**: `wc -l file.txt` 只统计文件的行数。

---

## 系统管理的命令有哪些？

当谈到 Linux 的**系统管理**命令时，我们关注的是维护系统健康、监控性能、管理用户和软件等宏观层面的操作。这些命令是系统管理员日常工作的核心工具。

我可以将它们分为以下几类来详细说明：

### 1. 进程管理 (Process Management)

管理系统中运行的程序和服务是系统管理的首要任务。

- **ps (process status)**: 显示当前用户的活动进程。为了获得系统上所有进程的快照，我通常使用 `ps aux` 或 `ps -ef`。
  - `ps aux`: 使用 BSD 风格，显示所有用户的进程，包括没有终端的进程，并显示详细信息。
  - `ps -ef`: 使用 System V 风格，功能与`aux`类似，但列的格式不同，常与 `grep` 结合使用来查找特定进程。
- **top**: 一个动态的、实时的系统监控工具。它会全屏显示一个按 CPU 使用率排序的进程列表，并提供系统负载、内存使用、任务数量等摘要信息。它是一个交互式命令，可以进行排序、杀死进程等操作。
- **htop**: 一个功能更强大、界面更友好的 `top` 替代品。它提供了彩色的输出、更方便的滚动和进程选择、以及直接的树状视图来显示进程的父子关系。
- **kill**: 用于向一个进程发送信号，默认是 `TERM` 信号（终止进程）。
  - **示例**: `kill 12345` 尝试正常终止 PID 为 12345 的进程。
- **killall**: 与 `kill` 类似，但它直接通过进程名来终止所有同名进程。
  - **示例**: `killall firefox` 会终止所有的 Firefox 浏览器进程。
- **pkill**: 功能更强大的 `killall`，可以根据进程名、用户、终端等多种属性来匹配并终止进程。
- **nice / renice**: 用于调整进程的调度优先级。`nice` 在启动新进程时设置其优先级，`renice` 则修改已运行进程的优先级。

### 2. 系统资源监控 (System Resource Monitoring)

了解系统资源的瓶颈和使用情况至关重要。

- **df (disk free)**: 查看文件系统的磁盘空间使用情况。我常用 `df -h`（human-readable），它会以 GB、MB 等易于理解的单位显示大小。
- **du (disk usage)**: 估算文件或目录占用的磁盘空间。`du -sh /path/to/dir` 是一个快速查看特定目录总大小的绝佳方法。
- **free**: 显示系统的内存使用情况，包括物理内存、交换空间（swap）以及内核缓冲区的使用量。`free -h` 同样会提供更友好的单位。
- **uptime**: 显示系统已经运行了多长时间，以及过去 1、5、15 分钟的系统平均负载。这是快速判断系统是否繁忙或刚刚重启的好方法。
- **vmstat**: 报告关于虚拟内存、进程、CPU 活动和 I/O 的统计信息。例如 `vmstat 5` 会每 5 秒更新一次报告。
- **iostat**: 报告 CPU 统计信息和设备、分区的 I/O 统计信息，是排查磁盘 I/O 性能问题的利器。
- **lsof (list open files)**: 一个非常强大的诊断工具，可以列出当前系统打开的所有文件及其归属进程。例如，`lsof -i :80` 可以找出哪个进程占用了 80 端口。

### 3. 用户和组管理 (User and Group Management)

- **useradd / adduser**: 用于创建新用户。`adduser` 是一个更友好、交互性更强的脚本。
- **userdel**: 删除用户。
- **usermod**: 修改已存在用户的属性，如用户名、主目录、用户组等。
- **groupadd**: 创建新的用户组。
- **passwd**: 为用户设置或修改密码。
- **su (switch user)**: 切换到另一个用户账户，默认切换到 root 用户。
- **sudo (superuser do)**: 允许授权用户以其他用户（通常是 root）的身份来执行命令，这是现代 Linux 系统推荐的权限管理方式，比直接使用`su`切换到 root 更安全、可控。

### 4. 服务和启动项管理 (Service and Boot Management)

现代 Linux 系统大多使用 `systemd` 作为初始化系统。

- **systemctl**: 这是管理 `systemd` 服务和单元（unit）的核心命令。
  - **示例**: `systemctl start nginx`: 启动 nginx 服务。
  - **示例**: `systemctl stop nginx`: 停止 nginx 服务。
  - **示例**: `systemctl restart nginx`: 重启 nginx 服务。
  - **示例**: `systemctl status nginx`: 查看 nginx 服务的当前状态。
  - **示例**: `systemctl enable nginx`: 设置 nginx 服务开机自启。
  - **示例**: `systemctl disable nginx`: 禁止 nginx 服务开机自启。
- **journalctl**: 用于查询和显示来自 `systemd` 日志服务（journald）的日志。
  - **示例**: `journalctl -u nginx`: 查看 nginx 服务的所有日志。
  - **示例**: `journalctl -f`: 实时跟踪所有新产生的日志。

### 5. 系统信息查看 (System Information)

- **uname**: 显示系统内核和操作系统信息。`uname -a` 会显示所有可用信息。
- **hostname**: 查看或临时设置系统的主机名。
- **dmesg**: 显示内核环形缓冲区的信息，对于诊断硬件问题和驱动加载问题非常有用。
- **lsb_release -a**: （在基于 LSB 的系统如 Ubuntu/Debian 上）显示 Linux 发行版的具体信息。
- **cat /etc/os-release**: 一个通用的、查看当前发行版信息的方法。

### 6. 软件包管理 (Package Management)

- **Debian/Ubuntu (APT)**:
  - `apt update`: 更新可用软件包列表。
  - `apt upgrade`: 升级所有已安装的软件包。
  - `apt install [package_name]`: 安装一个新的软件包。
  - `apt remove [package_name]`: 卸载一个软件包。
- **Red Hat/CentOS/Fedora (YUM/DNF)**:
  - `yum check-update` / `dnf check-update`: 检查可用的更新。
  - `yum update` / `dnf upgrade`: 更新系统。
  - `yum install [package_name]` / `dnf install [package_name]`: 安装软件包。
  - `yum remove [package_name]` / `dnf remove [package_name]`: 卸载软件包。

---

## 网络管理的命令有哪些？

Linux 的**网络管理**是系统管理中一个至关重要的分支，涉及到网络配置、故障排查、数据传输和安全监控等多个方面。我将常用的网络管理命令分为以下几类来进行阐述：

### 1. 网络接口配置和查看 (Interface Configuration & Viewing)

这是最基础的网络管理操作，用于配置和检查网络接口的状态。

- **ip**: 这是现代 Linux 系统中用于网络配置的首选工具，功能非常强大，整合了之前 `ifconfig`, `route`, `arp` 等多个命令的功能。
  - `ip addr show` (或 `ip a`): 列出所有网络接口及其 IP 地址、MAC 地址和状态。这是我最常用的命令之一，用来快速查看 IP 信息。
  - `ip link set eth0 up/down`: 启用或禁用 `eth0` 网络接口。
  - `ip addr add 192.168.1.100/24 dev eth0`: 为 `eth0` 接口添加一个 IP 地址。
  - `ip route show` (或 `ip r`): 显示内核的路由表。
- **ifconfig**: 在较旧的系统中非常流行，虽然现在已被 `ip` 命令取代，但在很多系统和脚本中仍然可以看到。它用于显示和配置网络接口信息。
  - **示例**: `ifconfig` 会列出所有活动的网络接口信息。
  - **示例**: `ifconfig eth0 192.168.1.100 netmask 255.255.255.0`: 为 `eth0` 配置 IP 地址和子网掩码。

### 2. 网络连接测试和故障排查 (Connectivity Testing & Troubleshooting)

当网络出现问题时，这些命令是诊断和定位问题的关键。

- **ping**: 这是最基本也是最重要的网络诊断工具，用于测试与目标主机之间的连通性。它通过发送 ICMP ECHO_REQUEST 报文并等待回复来工作。
  - **示例**: `ping google.com` 会持续向 `google.com` 发送请求，直到手动停止 (`Ctrl+C`)，并显示往返时间和丢包率。
- **traceroute / tracepath**: 用于追踪数据包从本机到目标主机所经过的路由路径。当遇到网络延迟或连接失败时，`traceroute` 可以帮助定位问题出在哪个网络节点上。`tracepath` 功能类似，且通常无需 root 权限。
  - **示例**: `traceroute google.com`
- **mtr (My Traceroute)**: 这是一个结合了 `ping` 和 `traceroute` 功能的强大工具。它会持续地探测路由路径上的每个节点，并实时显示每个节点的延迟和丢包情况，对于诊断不稳定的网络连接非常有帮助。
- **nslookup**: 一个用于查询 DNS（域名系统）信息的交互式工具，可以将域名解析为 IP 地址，或反向查询。
  - **示例**: `nslookup www.google.com`
- **dig (Domain Information Groper)**: 功能比 `nslookup` 更强大、更灵活的 DNS 查询工具，输出信息也更详尽，深受系统管理员青睐。
  - **示例**: `dig google.com MX` 会查询 `google.com` 的邮件交换（MX）记录。
- **host**: 一个简单易用的 DNS 查询工具，通常用于快速地进行域名和 IP 地址的转换。
  - **示例**: `host www.google.com`

### 3. 网络状态和套接字统计 (Network Status & Socket Statistics)

这些命令用于查看当前系统的网络连接、监听端口等信息。

- **ss**: 这是 `netstat` 的现代替代品，查询速度更快，能提供更详细的 TCP 状态信息。我优先使用 `ss`。
  - **示例**: `ss -tuln`: 显示所有正在监听的 TCP (`-t`) 和 UDP (`-u`) 端口，不解析服务名 (`-n`)。这是检查服务是否成功启动并监听在预期端口上的常用方法。
  - **示例**: `ss -tan`: 显示所有 TCP 连接的状态。
- **netstat**: 一个经典的、功能丰富的网络信息显示工具。
  - **示例**: `netstat -antp`: 显示所有 TCP (`-t`) 连接，不解析名称 (`-n`)，并显示建立连接的程序 PID 和名称 (`-p`)。

### 4. 数据传输和下载 (Data Transfer & Downloading)

- **curl**: 一个功能极其强大的数据传输工具，支持包括 HTTP, HTTPS, FTP 在内的多种协议。它不仅可以下载文件，还能发送 POST 请求、设置 HTTP 头部、进行 API 测试等，是后端开发和运维的瑞士军刀。
  - **示例**: `curl -O http://example.com/file.zip`: 下载文件并以原名保存。
  - **示例**: `curl -X POST -d "param1=value1" http://api.example.com/submit`: 发送一个 POST 请求。
- **wget**: 一个简单、专注的非交互式网络下载工具。它非常适合在后台下载大文件，并支持断点续传和递归下载整个网站。
  - **示例**: `wget -c http://example.com/large_file.iso`: 下载大文件，如果中途中断，下次可以从断点处继续下载。
- **scp (secure copy)**: 基于 SSH 协议的文件传输命令，用于在不同主机之间安全地复制文件。
  - **示例**: `scp user@remote_host:/path/to/remote_file /path/to/local_dir/`
- **rsync**: 一个功能强大的文件同步工具，它可以在本地或远程之间高效地同步文件和目录，因为它只传输有变化的部分。

### 5. 网络流量分析和抓包 (Traffic Analysis & Packet Capturing)

- **tcpdump**: 一个强大的命令行网络抓包工具。它能捕获网络接口上的数据包，并根据过滤规则显示其内容摘要。是深度网络问题分析的终极工具。
  - **示例**: `tcpdump -i eth0 host 192.168.1.1 and port 80`: 捕获 `eth0` 接口上，主机 IP 为 `192.168.1.1` 且端口为 `80` 的所有流量。

---

## 压缩和解压的命令有哪些？

在 Linux 系统中，处理压缩文件是一项非常常见的任务，无论是为了节省磁盘空间，还是为了方便网络传输。相关的命令通常根据压缩算法和归档方式的不同而有所区别。

我可以将它们分为两大类：**归档工具**和**压缩工具**。通常我们会将这两类工具结合使用：先用归档工具将多个文件或目录打包成一个单一的文件（称为 tarball），然后再用压缩工具将这个归档文件进行压缩。

以下是主要的压缩和解压命令：

### 1. `tar`: 归档与压缩/解压的瑞士军刀

`tar` (tape archive) 是 Linux 中最核心的归档工具。它本身只负责打包和解包，不进行压缩。但它可以通过调用其他压缩程序的接口，实现在一条命令里完成打包和压缩（或解压和解包）的流水线操作。这是我最常使用的方式。

`tar` 命令的选项非常关键，我通常会记住以下几个核心选项组合：

- **-c (create)**: 创建一个新的归檔。
- **-x (extract)**: 从归檔中提取文件。
- **-v (verbose)**: 显示详细的操作过程。
- **-f (file)**: 指定归檔文件的名称。这个选项后面必须紧跟文件名。
- **-t (list)**: 列出归檔中的文件内容，但不解压。

**结合压缩工具的选项：**

- **-z**: 通过 **gzip** 算法进行压缩或解压，通常生成 `.tar.gz` 或 `.tgz` 后缀的文件。这是最常见的组合。
- **-j**: 通过 **bzip2** 算法进行压缩或解压，通常生成 `.tar.bz2` 或 `.tbz2` 后缀的文件。它的压缩率比 gzip 高，但速度更慢。
- **-J** (大写的 J): 通过 **xz** 算法进行压缩或解压，通常生成 `.tar.xz` 文件。这是目前压缩率最高的格式之一。

**常用组合示例：**

- **打包并用 gzip 压缩 (创建 .tar.gz):**
  ```bash
  tar -czvf archive_name.tar.gz /path/to/directory_or_file
  ```
- **解压 gzip 压缩的归档 (解压 .tar.gz):**
  ```bash
  tar -xzvf archive_name.tar.gz
  ```
- **打包并用 bzip2 压缩 (创建 .tar.bz2):**
  ```bash
  tar -cjvf archive_name.tar.bz2 /path/to/directory_or_file
  ```
- **解压 bzip2 压缩的归档 (解压 .tar.bz2):**
  ```bash
  tar -xjvf archive_name.tar.bz2
  ```
- **打包并用 xz 压缩 (创建 .tar.xz):**
  ```bash
  tar -cJvf archive_name.tar.xz /path/to/directory_or_file
  ```
- **解压 xz 压缩的归档 (解压 .tar.xz):**
  ```bash
  tar -xJvf archive_name.tar.xz
  ```
- **只查看归档内容，不解压:**
  ```bash
  tar -tvf archive_name.tar.gz
  ```

### 2. 单独的压缩/解压工具

有时候我们只会收到一个已经被压缩的文件（而不是归档），或者只想对单个大文件进行压缩。这时就会用到独立的压缩命令。

- **gzip / gunzip**:

  - **压缩**: `gzip filename`。这会把 `filename` 压缩成 `filename.gz`，并删除原始文件。
  - **解压**: `gunzip filename.gz`。这会把 `filename.gz` 解压成 `filename`，并删除原始的 `.gz` 文件。
  - **保留原文件压缩**: `gzip -c filename > filename.gz`

- **bzip2 / bunzip2**:

  - **压缩**: `bzip2 filename`。生成 `filename.bz2` 并删除原文件。
  - **解压**: `bunzip2 filename.bz2`。解压 `filename.bz2` 并删除原文件。
  - **保留原文件压缩**: `bzip2 -c filename > filename.bz2`

- **xz / unxz**:
  - **压缩**: `xz filename`。生成 `filename.xz` 并删除原文件。
  - **解压**: `unxz filename.xz`。解压 `filename.xz` 并删除原文件。
  - **保留原文件压缩**: `xz -c filename > filename.xz`

### 3. `zip / unzip`: 处理 .zip 文件

`.zip` 格式在 Windows 世界中非常流行，因此在 Linux 中也必须掌握处理它的命令，以便于跨平台文件交换。与 `tar` 不同，`zip` 命令自己就包含了归档和压缩的功能。

- **zip**:
  - **压缩文件**: `zip archive_name.zip file1 file2 ...`
  - **压缩整个目录 (递归)**: `zip -r archive_name.zip /path/to/directory`
- **unzip**:
  - **解压**: `unzip archive_name.zip`。默认解压到当前目录。
  - **解压到指定目录**: `unzip archive_name.zip -d /path/to/destination_directory`
  - **查看 zip 包内容不解压**: `unzip -l archive_name.zip`

总结一下，在日常工作中，我绝大多数时候会使用 `tar` 命令加上 `-z`、`-j` 或 `-J` 参数来一步完成归档和压缩。而 `zip` 和 `unzip` 命令则主要用于处理来自或需要发往 Windows 环境的文件。

---

## 查找文件的命令有哪些？

在 Linux 系统中，高效地查找文件是提升工作效率的关键一环。根据查找目标的不同——是查找文件本身，还是查找文件内容——我会使用不同的命令。我可以将它们分为三大类：按文件名或属性查找、按文件内容查找以及查找可执行文件的路径。

### 1. `find`: 最强大、最灵活的文件查找工具

`find` 命令是我进行文件查找时的首选，因为它提供了极为丰富的查找条件，可以满足各种复杂场景。它通过实时遍历指定的目录树来工作。

**基本语法**: `find [路径] [表达式] [操作]`

**常用示例**:

- **按名称查找**: 这是最常见的用法。

  - `find /home/user -name "config.xml"`: 在 `/home/user` 目录下精确查找名为 `config.xml` 的文件。
  - `find /var/log -name "*.log"`: 使用通配符查找 `/var/log` 目录下所有以 `.log` 结尾的文件。
  - `find . -iname "readme*"`: 在当前目录 (`.`) 中不区分大小写地 (`-iname`) 查找以 `readme` 开头的文件。

- **按类型查找**:

  - `find / -type f`: 查找整个系统中所有的普通文件 (`f`)。
  - `find /tmp -type d`: 查找 `/tmp` 目录下的所有目录 (`d`)。

- **按大小查找**:

  - `find / -size +100M`: 查找系统中所有大于 100MB 的文件。
  - `find /home -size -1k`: 查找 `/home` 目录下所有小于 1KB 的文件。

- **按时间查找**: 对于排查问题非常有用。

  - `find . -mtime -1`: 查找当前目录下 24 小时内被修改过的文件。
  - `find /etc -mmin -60`: 查找 `/etc` 目录下 60 分钟内被修改过的文件。

- **按权限查找**:

  - `find . -perm 777`: 查找当前目录下权限为 `777` 的文件。

- **组合条件与后续操作**: `find` 的强大之处在于可以组合使用条件，并对找到的文件执行操作。
  - `find /tmp -type f -name "*.tmp" -delete`: 查找 `/tmp` 目录中所有以 `.tmp` 结尾的普通文件并直接删除它们。
  - `find . -type f -name "*.sh" -exec chmod +x {} \;`: 查找当前目录下的 `.sh` 文件，并赋予它们可执行权限。

虽然 `find` 功能强大，但由于是实时搜索，在非常大的文件系统中可能会比较慢。

### 2. `locate`: 最快速的文件名查找工具

`locate` 命令通过查询一个预先构建好的文件索引数据库来查找文件，因此它的速度比 `find` 快得多，几乎是瞬间完成。

**工作原理**: 它依赖于一个由 `updatedb` 命令定期更新的数据库。

**常用示例**:

- `locate my_document.pdf`: 快速找出系统中所有路径包含 `my_document.pdf` 的文件。
- `locate -i "*.conf"`: 不区分大小写地查找所有 `.conf` 文件。

**`locate` 的优缺点**:

- **优点**: 速度极快。
- **缺点**: 无法找到最近新建或重命名的文件，因为它依赖的数据库可能不是最新的。在需要时，我可以手动执行 `sudo updatedb` 来强制更新数据库。此外，它的查找条件远不如 `find` 丰富。

### 3. `grep`: 最核心的文件内容查找工具

当我不记得文件名，只记得文件里某个关键词时，`grep` 就是我的利器。它用于在文件中搜索包含指定模式的行。

**基本语法**: `grep [选项] "模式" [文件名]`

**常用示例**:

- `grep "error" /var/log/syslog`: 在 `syslog` 文件中查找所有包含 "error" 字符串的行。
- `grep -r "api_key" /etc/`: 在 `/etc/` 目录及其所有子目录下 (`-r`, 递归) 查找包含 "api_key" 的文件和行。
- `grep -i "hello world" document.txt`: 不区分大小写地 (`-i`) 查找。
- `grep -v "debug" application.log`: 反向查找 (`-v`)，显示所有不包含 "debug" 的行。
- `grep -l "main" *.c`: 只列出 (`-l`) 包含 "main" 的 C 源码文件名，而不显示匹配的行内容。

我经常将 `grep` 与其他命令通过管道结合使用，例如：`ps aux | grep "nginx"`，这可以从进程列表中筛选出 `nginx` 相关的进程。

### 4. `which` 和 `whereis`: 查找可执行文件的路径

这类命令专门用于查找二进制可执行文件、源代码和手册页的位置。

- **`which`**: 在用户的 `$PATH` 环境变量所定义的路径中，查找并显示指定命令的绝对路径。
  - `which ls` 可能会输出 `/bin/ls`。这对于确定当前执行的到底是哪个版本的命令非常有用。
- **`whereis`**: 功能更广，它不仅查找二进制文件，还会同时查找该命令的源代码和帮助手册页面的位置。
  - `whereis python` 可能会输出 `python: /usr/bin/python3.8 /usr/lib/python3.8 ... /usr/share/man/man1/python.1.gz`。

**总结**:

- 对于**复杂的、按属性查找**，我会用 `find`。
- 对于**快速的、仅按文件名查找**，我会用 `locate`。
- 对于**查找文件内容**，我会用 `grep`。
- 对于**定位一个命令的路径**，我会用 `which` 或 `whereis`。

---

## 用户和用户组有什么区别？

可以从**定义、关系、和功用**三个层面来清晰地阐述它们的区别。

### 1. 定义上的区别：个体 vs. 集合

- **用户 (User)**: 在 Linux 系统中，用户是**一个独立的、可识别的实体**。它代表一个可以登录系统并与之交互的身份，这个身份可以是一个具体的人，也可以是一个运行服务的程序（这种被称为系统用户或伪用户，如 `www-data`, `mysql`）。

  - 每个用户都有一个唯一的**用户 ID (UID)**。
  - 每个用户都有自己的**家目录 (Home Directory)**，例如 `/home/username`。
  - 每个用户都有一个默认的**登录 Shell** (如 `/bin/bash`)。

- **用户组 (User Group)**: 用户组是**一个或多个用户的集合**。它本身不是一个可以登录的实体，而是一个逻辑上的容器，主要目的是为了简化权限管理。
  - 每个用户组都有一个唯一的**组 ID (GID)**。

**核心区别**: **用户是操作的主体，是“谁”在操作；而用户组是为了方便地对一批用户进行统一授权，是“哪一类人”可以操作。**

### 2. 关系上的区别：从属与归类

用户和用户组之间存在着一种“多对多”的从属关系，但这种关系中有两个重要的概念：**主组 (Primary Group)** 和 **附加组 (Supplementary Groups)**。

- **主组**: 每个用户都**必须**属于且**只能**属于一个主组。通常，在创建用户时，系统会自动创建一个与用户名同名的组作为其主组。当一个用户创建新文件时，该文件的所属组默认就是该用户的主组。
- **附加组**: 一个用户可以同时属于**零个或多个**附加组。这使得用户可以获得这些附加组所拥有的权限，从而能够访问或操作不属于其主组的资源。

**举例**:
假设有一个用户 `jason`，他属于 `jason` 组（主组），同时为了参与项目，他还被加入了 `developers` 组和 `testers` 组（附加组）。

- 当 `jason` 创建一个新文件时，这个文件默认的所有者是 `jason`，所属组是 `jason`。
- `jason` 可以访问被授权给 `developers` 组的共享目录。
- `jason` 也可以访问被授权给 `testers` 组的测试工具。

### 3. 功用上的区别：权限管理的核心

这才是用户和用户组设计的最根本原因——**高效、灵活地管理文件和资源的访问权限**。

Linux 的文件权限分为三段：**所有者 (Owner)**、**所属组 (Group)** 和 **其他 (Others)**。

```
-rwxr-x--- 1 jason developers 4096 Aug 14 10:00 project_plan.txt
```

我们来解析这个例子：

- **所有者 (User)**: `jason`。他拥有对这个文件的读、写、执行 (`rwx`) 权限。
- **所属组 (Group)**: `developers`。所有属于 `developers` 组的用户（无论他们的主组是什么），都对这个文件拥有读、执行 (`r-x`) 权限，但没有写的权限。
- **其他 (Others)**: 不属于 `jason` 用户，也不在 `developers` 组里的任何其他用户，对这个文件没有任何权限 (`---`)。

**这套机制的优势**:

- **简化管理**: 假设一个项目目录需要授权给 20 个开发者。如果没有用户组，管理员需要为这 20 个用户逐一设置权限。有了用户组，管理员只需创建一个 `developers` 组，将 20 个用户加入该组，然后对项目目录进行一次性的授权给 `developers` 组即可。
- **灵活性和安全性**: 当有新开发者加入时，只需将其加入 `developers` 组，他便自动获得了所有相关权限。当有开发者离职时，将他从组中移除，相关的权限也就自动回收了。这比修改大量文件和目录的权限要高效和安全得多。

### 总结

为了让您更清晰，我用一个表格来总结：

| 特性     | 用户 (User)                               | 用户组 (User Group)                      |
| :------- | :---------------------------------------- | :--------------------------------------- |
| **本质** | 操作系统的独立实体，是权限的**赋予对象**  | 用户的逻辑集合，是**权限的载体**         |
| **目的** | 标识身份，进行登录和操作                  | 简化权限分配，实现资源共享               |
| **标识** | UID (用户 ID)，唯一的数字                 | GID (组 ID)，唯一的数字                  |
| **关系** | 每个用户必须有 1 个主组，可以有多个附加组 | 一个组可以包含多个用户成员               |
| **比喻** | 公司里的一个**员工**                      | 公司里的一个**部门**（如研发部、市场部） |

这个员工（用户）一定属于一个主要部门（主组），但可能也同时是某个项目组（附加组）的成员。部门（用户组）本身不能工作，但加入这个部门的员工（用户）可以访问这个部门的办公室和资料（共享资源）。

---

## 如何用 linux 命令去查找某个 qps?

这是一个非常实际且具有代表性的运维问题，因为它没有一个唯一的标准答案，而是需要根据具体场景和可用工具来灵活应对。"QPS"（Queries Per Second，每秒查询率）是一个衡量服务负载的关键指标，而找到它的方法取决于我们衡量的是**什么服务**的 QPS。

我的回答思路是，首先明确 QPS 的通用计算原理，然后针对几种最常见的服务类型（如 Web 服务、数据库服务）提供具体的命令行解决方案。

### 核心原理：在单位时间内统计请求数量

无论用什么命令，计算 QPS 的基本逻辑都是一样的：

**QPS = 请求总数 / 时间（秒）**

所以，关键在于如何**获取请求总数**。

### 场景一：查找 Web 服务器的 QPS (例如 Nginx)

这是最常见的场景。通常，我会利用 Web 服务器的访问日志（access log）来计算。

#### 方法 1：实时估算（Quick & Dirty）

这种方法适合快速瞥一眼当前的流量状况。

1.  **实时监控日志增量**:
    使用 `tail -f` 持续监控日志文件。

2.  **结合 `pv` 命令 (如果已安装)**:
    `pv` (Pipe Viewer) 可以测量数据通过管道的速率。我们可以用它来估算日志行的增长速率，而每行通常代表一个请求。
    ```bash
    tail -f /var/log/nginx/access.log | pv --line-mode --rate > /dev/null
    ```
    `pv` 会实时显示一个速率（例如 `[ 25.3/s]`），这个数字就可以近似看作是当前的 QPS。

#### 方法 2：基于特定时间窗口的精确计算

这种方法更精确，适合需要具体数值的场景。

1.  **提取特定时间内的日志**:
    我通常会使用 `grep` 或 `awk` 来提取最近一分钟或几分钟的日志。Nginx 的默认日志格式中包含了时间。

2.  **构造命令**:
    假设现在是 `14/Aug/2025:11:30`，我想计算过去一分钟（`11:29`）的 QPS。

    ```bash
    # 1. 统计上一分钟的请求总数
    REQUEST_COUNT=$(grep "14/Aug/2025:11:29" /var/log/nginx/access.log | wc -l)

    # 2. 除以60秒得到QPS
    # 使用 bc 进行浮点数运算
    QPS=$(echo "scale=2; $REQUEST_COUNT / 60" | bc)

    echo "QPS at 11:29 was: $QPS"
    ```

3.  **动态获取时间的脚本**:
    为了更方便，我可以写一个小的 shell 脚本来动态获取当前时间并计算前一分钟的 QPS。

    ```bash
    #!/bin/bash
    # 获取一分钟前的时间，格式需要匹配Nginx日志格式
    TARGET_MINUTE=$(date --date="1 minute ago" "+%d/%b/%Y:%H:%M")

    # 从日志文件中grep出该分钟的所有记录并计数
    REQUEST_COUNT=$(grep "$TARGET_MINUTE" /var/log/nginx/access.log | wc -l)

    # 计算QPS
    QPS=$(echo "scale=2; $REQUEST_COUNT / 60" | bc)

    echo "QPS for minute $TARGET_MINUTE: $QPS"
    ```

### 场景二：查找数据库的 QPS (例如 MySQL)

对于数据库，我们通常不看日志，而是查询其内部的状态变量。

1.  **利用状态计数器**:
    MySQL 有一个全局状态变量叫做 `Questions`，它记录了自服务启动以来执行的查询总数（这里“查询”泛指所有发送到服务端的语句）。

2.  **采样计算**:
    我会取两个时间点的 `Questions` 值，然后用差值除以时间间隔来得到平均 QPS。

    ```bash
    #!/bin/bash
    # 采样间隔（秒）
    INTERVAL=10

    # 获取初始计数值
    # 需要配置好mysql客户端的免密登录，或在命令中加入-u -p参数
    COUNT1=$(mysql -e "SHOW GLOBAL STATUS LIKE 'Questions';" | awk 'NR==2{print $2}')

    # 等待一段时间
    sleep $INTERVAL

    # 获取结束计数值
    COUNT2=$(mysql -e "SHOW GLOBAL STATUS LIKE 'Questions';" | awk 'NR==2{print $2}')

    # 计算差值
    DIFF=$((COUNT2 - COUNT1))

    # 计算QPS
    QPS=$(echo "scale=2; $DIFF / $INTERVAL" | bc)

    echo "Average QPS over the last $INTERVAL seconds: $QPS"
    ```

    `mysqladmin status` 命令也可以提供类似的信息，更简洁一些。

### 场景三：查找任意网络服务的近似 QPS (通用方法)

如果一个服务没有日志，也没有状态接口（比如一个自定义的 TCP 服务），我还可以从网络层面来估算。

1.  **使用 `tcpdump` 抓包**:
    `tcpdump` 可以捕获网络接口上的数据包。我们可以统计在一段时间内到达服务端口的数据包数量。

2.  **结合 `timeout` 和 `wc -l`**:
    `timeout` 命令可以限制一个命令的运行时间，这对于我们的采样计算非常方便。

    ```bash # 估算在 10 秒内到达 8080 端口的请求数 # -i any: 监听所有接口 # 'dst port 8080': 过滤规则，只捕获目标端口是 8080 的包
    PACKET_COUNT=$(timeout 10 tcpdump -i any -n 'dst port 8080' 2>/dev/null | wc -l)

        # 计算近似QPS
        QPS=$(echo "scale=2; $PACKET_COUNT / 10" | bc)

        echo "Approximate QPS on port 8080 over the last 10s: $QPS"
    ```

**重要提示**: 这种方法是**近似**的。因为它计算的是数据包（Packets）的数量，而不是逻辑请求（Queries）的数量。一个复杂的请求可能会被拆分成多个 TCP 包。但它仍然是快速评估一个黑盒服务负载的有效手段。

### 总结

| 场景             | 工具                         | 方法              | 优点                       | 缺点                          |
| :--------------- | :--------------------------- | :---------------- | :------------------------- | :---------------------------- |
| **Web 服务器**   | `grep`, `wc`, `awk`, `date`  | 解析访问日志      | 精确，信息丰富             | 依赖日志格式，日志 I/O 有开销 |
| **数据库**       | `mysql` 客户端, `mysqladmin` | 查询内部状态变量  | 精确，开销小               | 特定于数据库类型              |
| **任意网络服务** | `tcpdump`, `timeout`, `wc`   | 网络抓包计数      | 通用性强，不依赖服务本身   | 近似值，计算的是数据包非请求  |
| **专业监控**     | Prometheus, Grafana          | 服务集成 Exporter | 系统化，可告警，可追溯历史 | 需要搭建和维护监控系统        |

在生产环境中，最可靠的方法是使用像 **Prometheus** 这样的专业监控系统。通过为 Nginx、MySQL 等服务配置相应的 `exporter`，我们可以持续地采集 QPS 以及更多维度的指标，并在 Grafana 中进行可视化展示和告警。但我给出的命令行方法在紧急排查问题或在没有监控系统的环境中，是非常实用和高效的。

---

## Git 常用命令有哪些？⭐⭐⭐⭐⭐

Git 是目前应用最广泛的分布式版本控制系统，熟练掌握其命令是每一位开发者的基本功。我习惯于将 Git 的常用命令按照一个典型的工作流来划分，这样更有助于理解和记忆。

### 1. 初始化与配置 (Setup & Configuration)

这是开始使用 Git 的第一步。

- **`git config`**: 配置 Git 的全局或项目级别的设置。最重要的就是设置你的身份，因为每一次提交都会记录这个信息。
  - **示例**:
    ```bash
    git config --global user.name "Your Name"
    git config --global user.email "your.email@example.com"
    ```

### 2. 获取与创建项目 (Getting a Repository)

- **`git init`**: 在一个现有项目的目录中，初始化一个新的 Git 仓库。这会创建一个 `.git` 子目录，其中包含了仓库的所有元数据。
  - **示例**:
    ```bash
    cd my_project
    git init
    ```
- **`git clone`**: 从一个远程服务器（如 GitHub, GitLab）克隆一个已经存在的仓库到本地。这是参与现有项目最常见的方式。
  - **示例**:
    ```bash
    git clone https://github.com/user/repository.git
    ```

### 3. 日常核心工作流 (The Core Workflow)

这三个命令构成了最基本、最频繁的日常操作循环。

- **`git add`**: 将工作目录中的文件修改添加到**暂存区 (Staging Area)**。暂存区是一个非常重要的概念，它允许你精确地选择哪些改动要包含在下一次提交中。
  - **示例**:
    ```bash
    git add file1.txt          # 暂存单个文件
    git add .                  # 暂存当前目录下所有修改
    git add -p                 # 交互式地选择要暂存的代码块
    ```
- **`git commit`**: 将暂存区中的所有内容生成一次新的**提交 (Commit)**，并永久性地保存在本地仓库的历史记录中。每一次提交都应该是一个逻辑上完整的变更单元，并且附带清晰的提交信息。
  - **示例**:
    ```bash
    git commit -m "Fix: correct the login validation logic"
    git commit                 # 会打开文本编辑器让你输入更详细的提交信息
    ```
- **`git push`**: 将本地仓库的提交推送到远程仓库，以便与团队成员共享。
  - **示例**:
    ```bash
    git push origin main       # 将本地的 main 分支推送到名为 origin 的远程仓库
    ```

### 4. 分支管理 (Branching)

分支是 Git 的精髓，它让并行开发变得简单而安全。

- **`git branch`**: 管理分支的命令。
  - **示例**:
    ```bash
    git branch                 # 列出所有本地分支
    git branch new-feature     # 创建一个名为 new-feature 的新分支
    git branch -d feature-x    # 删除一个已经合并的分支
    ```
- **`git switch`** (推荐) 或 **`git checkout`**: 切换到不同的分支。
  - **示例**:
    ```bash
    git switch main            # 切换到 main 分支
    git switch -c new-feature  # 创建并立即切换到 new-feature 分支 (等同于 git checkout -b)
    ```
- **`git merge`**: 将一个分支的历史记录合并到当前分支。
  - **示例**:
    ```bash
    git switch main            # 首先切换到接受合并的目标分支
    git merge new-feature      # 然后将 new-feature 分支合并进来
    ```
- **`git rebase`**: 变基，是合并的另一种选择。它可以将一系列提交应用到另一个基底上，从而创建更线性的提交历史。我通常用它来在推送前整理我自己的本地提交记录。

### 5. 远程与同步 (Remotes & Syncing)

- **`git pull`**: 从远程仓库拉取最新的变更并自动与本地分支合并。它实际上是 `git fetch` 和 `git merge` 两条命令的快捷方式。
  - **示例**:
    ```bash
    git pull origin main
    ```
- **`git fetch`**: 只从远程仓库下载最新的变更数据，但**不**会自动合并。这给了我机会在合并前先查看远程的变更，是一个更安全的操作。
  - **示例**:
    ```bash
    git fetch origin           # 获取 origin 远程的所有更新
    ```
- **`git remote`**: 管理配置的远程仓库。
  - **示例**:
    ```bash
    git remote -v              # 显示所有远程仓库的详细信息
    git remote add upstream [URL] # 添加一个新的上游远程仓库
    ```

### 6. 查看与检查 (Inspection & History)

- **`git status`**: 显示工作目录和暂存区的状态。这是我用得最多的命令之一，它能清晰地告诉我哪些文件被修改了、哪些文件已暂存。
- **`git log`**: 显示从近到远的提交历史记录。
  - **示例**:
    ```bash
    git log
    git log --oneline --graph --decorate  # 以单行、图形化的方式显示分支和标签
    ```
- **`git diff`**: 显示文件内容的差异。
  - **示例**:
    ```bash
    git diff                   # 查看工作目录中尚未暂存的修改
    git diff --staged          # 查看已暂存但尚未提交的修改
    git diff main..feature     # 比较两个分支之间的差异
    ```

### 7. 撤销操作 (Undoing Changes)

人都会犯错，Git 提供了强大的工具来修正错误。

- **`git restore`** (推荐): 用于撤销工作目录中的修改或者取消暂存。
  - **示例**:
    ```bash
    git restore file.txt       # 丢弃在工作目录中对 file.txt 的修改
    git restore --staged file.txt # 将 file.txt 从暂存区移回工作目录
    ```
- **`git reset`**: 这是一个更强大的命令，可以重置当前分支的指针到指定的提交，同时根据参数 (`--soft`, `--mixed`, `--hard`) 影响暂存区和工作目录。我使用它时会格外小心，特别是 `--hard` 选项会丢失工作。
- **`git revert`**: 创建一个新的提交，用以撤销某一次指定的历史提交。这种方式是安全的，因为它不修改现有的提交历史，非常适合在共享分支上撤销错误。
- **`git stash`**: 当我正在一个分支上工作，但需要紧急切换到另一个分支修复问题时，我会用 `git stash` 将当前未提交的修改（包括暂存的）临时保存起来。处理完紧急问题后，再切回来用 `git stash pop` 恢复之前的工作。
