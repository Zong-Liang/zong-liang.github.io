---
title: "01-设计模式面试题"
date: 2025-04-09 19:28:18 +0800
categories: [面试题, 设计模式面试题]
tags: [面试八股, 设计模式面试题]
pin: false
toc: true
math: true
---

## 设计模式了解吗？

设计模式（Design Pattern）是在软件开发过程中，针对特定问题的一系列行之有效的解决方案和最佳实践。 它并非一种具体的代码或算法，而是一套被反复使用、多数人知晓、经过分类编目的代码设计经验的总结。

**为什么需要设计模式？**

学习和应用设计模式能够带来诸多益处：

- **提高代码质量和效率：** 设计模式提供了经过验证的解决方案，有助于编写出更清晰、更易于维护的代码，同时避免重复“造轮子”，从而加快开发速度。
- **增强代码的可重用性、可读性和可扩展性：** 合理地运用设计模式可以完美地解决很多问题，使代码更易于被他人理解和扩展，从而提高软件的可维护性。
- **促进团队沟通：** 设计模式为开发人员提供了一种通用的设计词汇和概念，当团队成员都熟悉设计模式时，可以更高效地沟通和协作。
- **应对软件变化：** 优秀的设计模式能让代码更容易适应需求的变化，这也是软件开发中不变的挑战。

**设计模式的分类**

根据“四人帮”（GoF）在《设计模式：可复用面向对象软件的基础》一书中提出的分类，设计模式主要分为三大类，共 23 种经典模式：

- **创建型模式 (Creational Patterns):** 这类模式主要关注对象的创建过程，旨在将对象的创建与使用解耦，使得程序在需要创建特定对象时更加灵活。 常见的创建型模式包括：

  - **工厂方法模式 (Factory Method):** 定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。
  - **抽象工厂模式 (Abstract Factory):** 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。
  - **单例模式 (Singleton):** 确保一个类只有一个实例，并提供一个全局访问点。
  - **建造者模式 (Builder):** 将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。
  - **原型模式 (Prototype):** 通过复制现有实例来创建新的实例。

- **结构型模式 (Structural Patterns):** 这类模式关注如何将类和对象组合成更大的结构，同时保持结构的灵活性和高效性。 常见的结构型模式包括：

  - **适配器模式 (Adapter):** 将一个类的接口转换成客户希望的另外一个接口。
  - **桥接模式 (Bridge):** 将抽象部分与它的实现部分分离，使它们都可以独立地变化。
  - **装饰器模式 (Decorator):** 动态地给一个对象添加一些额外的职责。
  - **外观模式 (Facade):** 为子系统中的一组接口提供一个统一的接口。
  - **享元模式 (Flyweight):** 运用共享技术有效地支持大量细粒度的对象。
  - **代理模式 (Proxy):** 为其他对象提供一种代理以控制对这个对象的访问。
  - **组合模式 (Composite):** 将对象组合成树形结构以表示“部分-整体”的层次结构。

- **行为型模式 (Behavioral Patterns):** 这类模式特别关注对象之间的通信，以及如何有效地划分对象之间的职责。 常见的行为型模式包括：
  - **策略模式 (Strategy):** 定义一系列算法，并将每一个算法封装起来，使它们可以相互替换。
  - **模板方法模式 (Template Method):** 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。
  - **观察者模式 (Observer):** 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知并自动更新。
  - **迭代器模式 (Iterator):** 提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。
  - **责任链模式 (Chain of Responsibility):** 为解除请求的发送者和接收者之间的耦合，而将多个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
  - **命令模式 (Command):** 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化。
  - **备忘录模式 (Memento):** 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
  - **状态模式 (State):** 允许一个对象在其内部状态改变时改变它的行为。
  - **访问者模式 (Visitor):** 表示一个作用于某对象结构中的各元素的操作。
  - **中介者模式 (Mediator):** 用一个中介对象来封装一系列的对象交互。
  - **解释器模式 (Interpreter):** 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

除了上述经典的 23 种设计模式，还有一些其他的模式，例如简单工厂模式，它虽然不属于 GoF 总结的范畴，但在实际开发中也应用广泛。

---

## 什么是责任链模式？

责任链模式（Chain of Responsibility Pattern）是一种行为设计模式，它允许您将请求沿着处理者链进行发送。收到请求后，每个处理者都有机会处理请求，或者将其传递给链中的下一个处理者。

**核心思想**

这个模式的核心思想是**解耦请求的发送者和接收者**。发送者不需要知道究竟是哪个对象会处理它的请求，它只需要将请求发送给链中的第一个处理者即可。之后，请求会沿着链自动传递，直到被某个处理者处理或者传递到链的末尾。

您可以把它想象成现实生活中的一条装配线。一个物品在装配线上流动，每个工人（处理者）检查这个物品，如果轮到自己处理，就执行相应操作；否则，就把它传递给下一个工人。

**主要组成部分**

一个典型的责任链模式包含以下几个角色：

1.  **抽象处理者（Handler）：** 定义一个处理请求的接口。这个接口通常会包含一个处理请求的方法，以及一个指向下一个处理者的引用（后继者）。
2.  **具体处理者（Concrete Handler）：** 实现抽象处理者接口。它需要判断自己是否有能力处理当前请求。如果可以，就处理请求；否则，就将请求转发给它的后继者。
3.  **客户端（Client）：** 创建并组装处理者链。客户端会创建一个请求，并将其发送给链上的第一个处理者。

**责任链模式的优缺点**

**优点：**

- **降低耦合度：** 请求的发送者和接收者之间完全解耦。发送者无需知道请求的处理细节和链的结构。
- **增强了系统的可扩展性和灵活性：** 可以随时增加、删除或修改处理者，改变它们在链中的顺序，而无需修改客户端代码。
- **单一职责原则：** 每个处理者都只负责自己的那部分逻辑，职责清晰。

**缺点：**

- **请求不保证被处理：** 请求有可能“石沉大海”，即沿着整条链传递都没有找到合适的处理者。
- **不易观察运行时的特征：** 如果链条比较长，或者处理逻辑复杂，调试时追踪请求的流转过程可能会比较困难。

**应用场景举例**

责任链模式在实际开发中有很多应用，例如：

- **Java Web 中的过滤器链（Filter Chain）：** 在 Servlet 规范中，一个请求在到达目标 Servlet 之前，会经过一系列的 Filter。每个 Filter 都可以对请求进行预处理（如权限检查、日志记录、编码转换等），然后决定是拦截请求还是将其传递给下一个 Filter。这就是一个非常经典的责任链模式应用。
- **异常处理机制：** 编程语言中的 `try-catch` 块可以看作是责任链的一种变体。当一个 `try` 块中抛出异常时，系统会依次检查 `catch` 块，看哪个 `catch` 块能处理该类型的异常。
- **工作流审批系统：** 一个采购申请可能需要经过多个层级的审批，比如组长审批、部门经理审批、财务审批等。这个审批流程就可以用责任链模式来实现，每个审批者都是链上的一个节点。

总而言之，当您有一个请求，并且有多个对象可以处理它，但具体由哪个对象处理在运行时才确定时，或者您想在不明确指定接收者的情况下向多个对象中的一个提交请求时，责任链模式就是一个非常值得考虑的优秀设计方案。

---

## 什么是工厂模式？

工厂模式（Factory Pattern）是创建型设计模式中最常用的一种。它的核心思想是**将对象的创建过程封装起来，由一个专门的“工厂”来负责创建对象，而不是由客户端（使用对象的代码）直接通过 `new` 关键字来创建。**

这样做的主要目的是**将对象的创建与使用相分离**，从而降低系统耦合度，并使得系统的扩展性和可维护性更高。

工厂模式并非指某一种特定的模式，而是一系列相关模式的总称。通常，我们所说的工厂模式主要包含以下三种：

1.  **简单工厂模式 (Simple Factory Pattern)**
2.  **工厂方法模式 (Factory Method Pattern)**
3.  **抽象工厂模式 (Abstract Factory Pattern)**

下面我将逐一介绍这三种模式。

### 1. 简单工厂模式（Simple Factory Pattern）

- **核心：** 简单工厂模式又叫静态工厂方法模式，它定义了一个专门的工厂类，该类根据传入的参数来决定应该创建哪一种产品类的实例。

- **组成角色：**

  - **工厂（Factory）：** 负责实现创建所有实例的内部逻辑。
  - **抽象产品（Product）：** 定义了所创建对象的公共接口。
  - **具体产品（Concrete Product）：** 实现了抽象产品接口，是工厂类创建的目标。

- **举例：** 假设我们有一个快餐店，顾客只需要告诉收银员（工厂）想要“汉堡”还是“薯条”，收银员就会去后厨（具体实现）拿出相应的产品给顾客。顾客不需要关心汉堡和薯条的具体制作过程。

- **优缺点：**
  - **优点：** 结构简单，将对象的创建和使用分离，客户端免除了直接创建对象的责任。
  - **缺点：** **违反了开闭原则**。当需要增加新的产品时（例如增加“鸡块”），就必须修改工厂类的判断逻辑，这在复杂的系统中是不可取的。此外，所有产品的创建逻辑都集中在一个工厂类中，导致其职责过重。

### 2. 工厂方法模式（Factory Method Pattern）

- **核心：** 工厂方法模式是对简单工厂模式的改进，它**定义了一个用于创建对象的接口，但让子类决定实例化哪一个类**。工厂方法使一个类的实例化延迟到其子类。

- **组成角色：**

  - **抽象工厂（Abstract Factory）：** 声明了创建产品的工厂方法，返回一个抽象产品。
  - **具体工厂（Concrete Factory）：** 实现抽象工厂接口，负责创建具体的产品实例。
  - **抽象产品（Abstract Product）：** 定义了产品的公共接口。
  - **具体产品（Concrete Product）：** 实现了抽象产品接口。

- **举例：** 快餐店业务扩大，开了专门生产汉堡的“汉堡工厂”和专门生产薯条的“薯条工厂”。当需要汉堡时，就去找汉堡工厂；需要薯条时，就去找薯条工厂。如果未来要增加“鸡块”产品，只需要再增加一个“鸡块工厂”即可，无需修改原有的工厂。

- **优缺点：**
  - **优点：** **完美遵循了开闭原则**。增加新产品时，只需增加新的具体产品类和对应的具体工厂类即可，无需修改原有代码。耦合度更低，扩展性更好。
  - **缺点：** 每增加一个产品，就需要增加一个具体工厂类，这会增加系统中类的个数，从而增加系统的复杂度和理解成本。

### 3. 抽象工厂模式（Abstract Factory Pattern）

- **核心：** 抽象工厂模式是工厂模式中最为抽象和通用的一种。它提供一个接口，用于**创建一系列相关或相互依赖的对象（即一个产品族）**，而无需指定它们具体的类。

- **组成角色：**

  - **抽象工厂（Abstract Factory）：** 声明了一组用于创建产品族中各个产品的工厂方法。
  - **具体工厂（Concrete Factory）：** 实现抽象工厂接口，负责创建某个具体产品族中的所有产品实例。
  - **抽象产品（Abstract Product）：** 为产品族中的每一种产品定义公共接口。
  - **具体产品（Concrete Product）：** 实现了抽象产品接口。

- **举例：** 假设我们的快餐店现在推出了不同的套餐，比如“肯德基套餐”和“麦当劳套餐”。肯德基套餐里有“香辣鸡腿堡”和“可口可乐”，而麦当劳套餐里有“巨无霸”和“百事可乐”。这里的“套餐”就是一个产品族。我们会有“肯德基工厂”专门生产肯德基产品族里的所有产品，也会有“麦当劳工厂”专门生产麦当劳产品族里的所有产品。客户端只需要选择用哪个工厂，就能得到一整套搭配好的产品，而不需要关心具体是哪个汉堡或哪种可乐。

- **优缺点：**
  - **优点：** 非常适合用于创建产品族。当需要切换整个产品族时，只需要更换具体工厂即可，客户端代码无需改动，这增强了系统的可扩展性和灵活性。
  - **缺点：** **扩展新的产品等级结构困难**。如果要在所有套餐中都增加一个新的产品种类，比如“甜品”，那么就需要修改抽象工厂接口以及所有的具体工厂实现类，这违反了开闭原则。

**总结**

总的来说，工厂模式家族的三种模式，从简单工厂、工厂方法到抽象工厂，抽象程度越来越高，适用的场景也越来越复杂。在实际开发中，我会根据项目的具体需求、复杂度和未来的扩展性来选择最合适的工厂模式。例如，如果产品种类固定且不多，可能会选择简单工厂以求简洁；如果系统需要不断扩展新的产品，工厂方法模式是更好的选择；而当系统需要处理多个相互关联的产品系列时，抽象工厂模式则是最佳方案。

---

## 什么是单例模式？

单例模式（Singleton Pattern）是设计模式中非常基础且常用的一种创建型模式。它的核心思想是**确保一个类在任何情况下都绝对只有一个实例，并提供一个全局的、唯一的访问点来获取这个实例**。

您可以把它想象成现实生活中的一些独一无二的事物，比如一个国家的总统、一个公司的 CEO，或者我们电脑里的回收站、任务管理器。无论我们在何时何地需要访问它们，访问的都是同一个对象。

### 单例模式的主要目的和优点

1.  **保证实例唯一性**：这是单例模式最核心的特点。在某些场景下，例如配置信息类、数据库连接池、日志对象等，拥有多个实例不仅没有必要，还可能导致资源浪费、数据不一致或其他不可预见的错误。
2.  **提供全局访问点**：由于实例是唯一的，我们可以提供一个静态方法（如 `getInstance()`），让系统中的任何部分都可以方便地访问到这个唯一的实例，避免了通过参数传来传去。
3.  **节省系统资源**：由于系统中只存在一个实例，避免了频繁地创建和销毁对象，从而减少了内存开销和 GC 压力，尤其对于那些创建成本较高的对象。

### 实现单例模式的几种常见方式

实现单例模式的关键在于**隐藏类的构造函数**（通常声明为 `private`），并提供一个公共的静态方法来获取唯一的实例。常见的实现方式有以下几种：

#### 1. 饿汉式（Eager Initialization）

- **实现方式**：在类加载的时候就直接创建实例，不管后续是否会用到。它是线程安全的。

  ```java
  public class Singleton {
      // 1. 类加载时就立即创建实例
      private static final Singleton INSTANCE = new Singleton();

      // 2. 私有化构造函数
      private Singleton() {}

      // 3. 提供公共的静态方法返回实例
      public static Singleton getInstance() {
          return INSTANCE;
      }
  }
  ```

- **优点**：实现简单，由于实例是在类加载时创建的，所以天然是线程安全的，没有多线程同步问题。
- **缺点**：如果这个单例对象从未使用过，会造成内存浪费，因为它没有实现懒加载（Lazy Loading）。

#### 2. 懒汉式（Lazy Initialization）

- **实现方式**：在第一次调用获取实例的方法时才创建对象。

- **基础版（线程不安全）**：

  ```java
  public class Singleton {
      private static Singleton instance;

      private Singleton() {}

      public static Singleton getInstance() {
          // 在多线程环境下，这里可能会被多个线程同时进入，从而创建多个实例
          if (instance == null) {
              instance = new Singleton();
          }
          return instance;
      }
  }
  ```

- **同步方法版（线程安全）**：通过 `synchronized` 关键字保证线程安全，但会带来性能开销。

  ```java
  public class Singleton {
      private static Singleton instance;
      private Singleton() {}
      public static synchronized Singleton getInstance() {
          if (instance == null) {
              instance = new Singleton();
          }
          return instance;
      }
  }
  ```

  - **缺点**：每次调用 `getInstance()` 都会加锁，实际上只有第一次创建时需要同步，后续的读操作是不需要同步的，这会导致不必要的性能下降。

#### 3. 双重校验锁（Double-Checked Locking）

- **实现方式**：这是对懒汉式的一种优化，在保证线程安全的同时，兼顾了性能和懒加载。

  ```java
  public class Singleton {
      // 使用 volatile 保证多线程下的可见性和禁止指令重排
      private static volatile Singleton instance;

      private Singleton() {}

      public static Singleton getInstance() {
          // 第一次检查，避免不必要的同步
          if (instance == null) {
              // 同步块，只在实例未创建时进入
              synchronized (Singleton.class) {
                  // 第二次检查，防止多个线程同时通过第一次检查
                  if (instance == null) {
                      instance = new Singleton();
                  }
              }
          }
          return instance;
      }
  }
  ```

- **优点**：实现了懒加载，并且在绝大部分情况下（实例已创建后）获取实例时不会有同步开销，性能较高。这是推荐的实现方式之一。

#### 4. 静态内部类（Static Inner Class）

- **实现方式**：利用了 Java 类加载机制来保证线程安全和懒加载。

  ```java
  public class Singleton {
      private Singleton() {}

      // 静态内部类，只有在调用 getInstance() 时才会被加载
      private static class SingletonHolder {
          private static final Singleton INSTANCE = new Singleton();
      }

      public static Singleton getInstance() {
          return SingletonHolder.INSTANCE;
      }
  }
  ```

- **优点**：实现简单，代码优雅。当 `Singleton` 类加载时，其内部类 `SingletonHolder` 不会被加载，只有当 `getInstance()` 方法第一次被调用时，才会触发 `SingletonHolder` 的加载，从而创建实例。这个过程由 JVM 保证线程安全。这也是一种非常推荐的实现方式。

#### 5. 枚举（Enum）

- **实现方式**：这是《Effective Java》作者极力推荐的方式，也是最简洁、最安全的实现方式。

  ```java
  public enum Singleton {
      INSTANCE;

      public void doSomething() {
          // ...
      }
  }
  ```

- **优点**：代码极其简单，天然支持序列化，可以防止通过反序列化来创建新的实例，并且绝对是线程安全的。在任何情况下，它都是最佳的单例实现方式。

### 单例模式的缺点

- **违反单一职责原则**：一个类既要负责自身的业务逻辑，又要负责保证自己是单例的，这在某种程度上违反了单一职责原则。
- **扩展性差**：由于没有抽象层，单例类的扩展有很大的困难。
- **对测试不友好**：在单元测试时，如果一个类依赖于某个单例对象，那么我们就无法轻易地用一个模拟（Mock）对象来替换它。

---

## 什么是策略模式？

策略模式（Strategy Pattern）是一种行为设计模式，它**定义了一系列算法，将每一个算法封装起来，并使它们可以相互替换。** 策略模式让算法的变化独立于使用算法的客户。

换句话说，当一件事情有多种不同的处理方式（策略）时，我们可以将每一种处理方式都封装成一个独立的对象，然后在运行时根据需要选择并使用其中一种。

### 核心思想与生活化比喻

策略模式的核心思想是 **“分离算法的定义与使用”**。

您可以把它想象成我们去旅游选择交通工具。

- **目的地是固定的** (我们的目标 Context)。
- **出行的策略是多样的**：我们可以选择坐飞机（速度快，价格高）、坐火车（速度和价格适中）、或者自己开车（灵活，但可能劳累）。
- 每一种出行方式都是一个独立的**策略（Strategy）**。
- 我们（客户端 Client）可以根据我们的具体情况（比如时间、预算）来决定今天采用哪种出行策略。做出决定后，我们就执行这个策略。如果情况有变，我们可以随时切换到另一种策略。

### 主要组成部分

策略模式通常包含以下三个角色：

1.  **Context (上下文环境):** 这是使用策略的类。它内部维护一个对抽象策略（Strategy）对象的引用。它不直接实现任何算法，而是把具体的工作委托给所引用的策略对象来执行。在我们的比喻中，这就是“旅行计划”本身。
2.  **Strategy (抽象策略):** 这是一个接口或抽象类，它定义了所有支持的算法的公共接口。在上面的比喻中，这可以是一个叫做 `TravelStrategy` 的接口，里面有一个 `travel()` 方法。
3.  **Concrete Strategy (具体策略):** 这些是实现了抽象策略接口的具体类。每一个具体策略类都封装了一种具体的算法或行为。例如 `PlaneStrategy`, `TrainStrategy`, `CarStrategy`，它们都实现了 `TravelStrategy` 接口，但各自的 `travel()` 方法实现不同。

### 策略模式的优缺点

**优点：**

1.  **完美遵循开闭原则 (Open-Closed Principle):** 当需要增加一种新的处理方式（比如增加“骑自行车”策略）时，我们只需要增加一个新的具体策略类即可，而不需要修改原有的上下文环境类（Context）和任何已有的策略类。这使得系统非常容易扩展。
2.  **避免使用大量的 `if-else` 或 `switch-case` 语句:** 如果没有策略模式，我们可能会在 Context 类中写下大量的 `if-else` 来判断应该使用哪种算法，这会使代码变得臃肿、难以维护。策略模式将这些判断逻辑转移到了客户端，让 Context 类更加简洁。
3.  **策略可以自由切换：** 在运行时，可以动态地改变上下文环境（Context）所引用的策略对象，从而改变其行为。
4.  **职责清晰：** 每个策略类只负责一个具体的算法，职责单一，易于理解和单元测试。

**缺点：**

1.  **类的数量会增多：** 每增加一个策略，就需要增加一个类。如果策略非常多，会导致系统中的类数量膨胀。
2.  **客户端必须了解所有策略：** 客户端需要知道有哪些具体的策略类，并自行决定在何时使用哪一个。这增加了客户端的认知负担。

### 实际应用场景举例

策略模式在实际开发中应用非常广泛：

- **Java 中的`Comparator`接口:** `Collections.sort(list, comparator)` 方法就是一个典型的策略模式应用。`list` 是上下文，`sort` 方法是操作，而 `comparator` 就是一个策略。我们可以传入不同的 `Comparator` 实现（比如按年龄排序、按姓名排序），来改变 `sort` 方法的排序行为。
- **支付系统:** 一个电商网站在结算时，可以选择多种支付方式，如支付宝支付、微信支付、银行卡支付。每种支付方式背后都是一套不同的处理逻辑。这里就可以使用策略模式，将每种支付方式封装成一个独立的策略。
- **文件压缩:** 一个压缩软件可以支持多种压缩算法（ZIP, RAR, 7z）。用户可以选择一种算法来压缩文件。每种压缩算法就是一个策略。
- **表单验证：** 对一个输入框的内容进行验证时，可以有多种验证规则（如“非空验证”、“邮箱格式验证”、“手机号格式验证”）。每条规则都可以是一个策略。
