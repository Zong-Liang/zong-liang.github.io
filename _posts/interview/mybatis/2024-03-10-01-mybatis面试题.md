---
title: "01-MyBatis面试题"
date: 2024-03-10 10:18:22 +0800
categories: [面试题, MyBatis面试题]
tags: [面试八股, MyBatis面试题]
pin: false
toc: true
math: true
---

## 说说什么是 MyBatis？

MyBatis 是一款优秀的数据持久化框架，它在 Java 社区中得到了广泛的应用。它最大的特点是支持定制化的 SQL、存储过程以及高级映射。

简单来说，MyBatis 帮助开发者将数据库中的数据与 Java 对象进行映射，从而将开发者从繁琐的 JDBC（Java Database Connectivity）代码中解放出来，比如手动设置参数、获取结果集等等。

**MyBatis 的核心思想** 是让开发者专注于 SQL 本身。与一些全自动的 ORM（对象关系映射）框架不同，MyBatis 允许开发者编写原生的 SQL 语句，这使得 SQL 的优化和控制变得非常灵活。开发者可以直接在 XML 映射文件或者通过注解的方式编写 SQL，然后 MyBatis 会负责将 SQL 的执行结果映射到 Java 对象上。

**在我看来，MyBatis 主要有以下几个核心优势：**

- **简单易学：** 相对于其他的持久层框架，MyBatis 更加轻量级，学习曲线也比较平缓。
- **灵活性高：** MyBatis 不会对应用程序的整体架构产生影响，并且能够很好地与各种技术（如 Spring、Spring Boot）集成。最重要的是，它让开发者可以完全掌控 SQL，能够应对各种复杂的查询需求，并进行针对性的优化。
- **解除 SQL 与程序代码的耦合：** 通过将 SQL 语句配置在 XML 文件中，实现了 SQL 与 Java 代码的分离，这使得 SQL 的维护和修改变得更加方便，也提升了代码的可维护性。
- **出色的映射功能：** MyBatis 提供了强大的映射机制，能够将复杂的查询结果（包括关联查询、动态 SQL 等）映射到 Java 对象中。

总而言之，MyBatis 是一个半自动的 ORM 框架，它在提供了强大、灵活的 SQL 控制能力的同时，也极大地简化了数据库编程的复杂度，是 Java 开发中一个非常值得信赖和使用的持久层解决方案。

---

## Hibernate 和 MyBatis 有什么区别？

Hibernate 和 MyBatis 都是 Java 领域非常流行的持久层框架，但它们的设计理念和侧重点完全不同。Hibernate 是一个**全自动的 ORM（对象关系映射）框架**，而 MyBatis 是一个**半自动的 SQL 映射框架**。 这句话概括了它们最核心的区别。

下面我将从几个维度来详细阐述它们的差异：

**1. 自动化程度和开发人员的角色**

- **Hibernate (全自动 ORM):** Hibernate 的目标是实现最大程度的自动化，让开发者可以像操作普通 Java 对象一样来操作数据库。 开发者大多数时候不需要编写一句 SQL 语句，Hibernate 会自动生成并执行 SQL。 开发者的重心完全在业务逻辑和对象模型上。
- **MyBatis (半自动 SQL 映射):** MyBatis 采取了截然不同的方式，它不试图完全隐藏 SQL。相反，它让开发者自己编写和控制 SQL 语句，然后框架的核心任务是帮助开发者将 SQL 的参数和查询结果优雅地映射到 Java 对象上。 开发者既要关注业务逻辑，也需要关注 SQL 本身。

**2. 对 SQL 的控制和灵活性**

- **Hibernate:** 由于 SQL 是自动生成的，开发者对 SQL 的直接控制力较弱。虽然可以通过 HQL（Hibernate Query Language）或 Criteria API 进行查询，它们是面向对象的查询语言，但在处理极其复杂的查询或需要进行深度性能优化的场景时，可能会显得力不从心，甚至生成的 SQL 不够高效。
- **MyBatis:** 这是 MyBatis 最大的优势所在。开发者可以直接编写和优化 SQL 语句，可以充分利用数据库的各种特性（如特定函数、索引提示等），实现精细化的查询性能调优。 对于需求多变、数据库模型与对象模型差异较大的项目，这种灵活性至关重要。

**3. 学习曲线和开发效率**

- **Hibernate:** 对于简单的 CRUD 操作，Hibernate 的开发效率非常高，因为几乎不需要写 SQL。 但是，它的学习曲线相对陡峭，需要理解和掌握其庞大的概念体系，如实体生命周期、缓存机制、延迟加载策略等。
- **MyBatis:** MyBatis 更加轻量级，概念也相对简单，更容易上手，特别是对于熟悉 SQL 的开发者来说。 不过，因为所有的 SQL 都需要手动编写，所以在开发工作量上可能会比 Hibernate 多一些，尤其是在需求明确、表结构简单的项目中。

**4. 数据库的可移植性**

- **Hibernate:** 具备很好的数据库移植性。由于 SQL 是自动生成的，当需要更换数据库时（例如从 MySQL 迁移到 Oracle），通常只需要修改一下方言（Dialect）配置，而不需要修改业务代码。
- **MyBatis:** 数据库移植性相对较差。因为 SQL 是手写的，不同数据库的 SQL 语法或函数可能存在差异。当更换数据库时，可能需要修改大量的 XML 映射文件中的 SQL 语句。

**5. 缓存机制**

- 两者都支持一级缓存（会话级别）和二级缓存（全局级别）。
- 不过，通常认为 Hibernate 提供了更强大和完善的二级缓存机制，能够更好地管理缓存对象。 而 MyBatis 的二级缓存配置相对简单，如果使用不当，可能会在频繁更新操作时产生脏数据的问题。

**总结与场景选择**

最后，我想做一个总结：

| 特性             | Hibernate                                                    | MyBatis                                       |
| :--------------- | :----------------------------------------------------------- | :-------------------------------------------- |
| **定位**         | 全自动 ORM 框架                                              | 半自动 SQL 映射框架                           |
| **SQL 控制**     | 自动化生成，控制力弱                                         | 手动编写，控制力强，灵活                      |
| **开发效率**     | 简单场景高，复杂场景低                                       | 相对均衡，SQL 工作量稍大                      |
| **学习难度**     | 门槛较高，概念复杂                                           | 门槛较低，易于掌握                            |
| **数据库移植性** | 好                                                           | 差                                            |
| **适用场景**     | 需求稳定，对象模型与关系模型匹配度高的系统（如后台管理系统） | 需求多变，需要复杂 SQL 和性能优化的互联网项目 |

在实际项目选型中：

- 如果项目是领域驱动设计，对象模型非常清晰且与数据库结构能很好地对应，并且对开发效率要求很高（比如一些企业内部的后台管理系统），那么 **Hibernate** 是一个很好的选择。
- 如果项目是互联网应用，需求变化快，SQL 查询非常复杂多变，对性能有极致的要求，或者需要与一些历史遗留的数据库打交道，那么 **MyBatis** 的灵活性和对 SQL 的强大控制力会让它更具优势。

---

## MyBatis 使用过程？生命周期？

### 第一部分：MyBatis 使用过程

从一个典型的 Java 项目来看，集成和使用 MyBatis 的过程大致可以分为以下几个步骤：

1.  **添加依赖：** 首先，我们需要在项目的构建工具中（如 Maven 或 Gradle）添加 MyBatis 的核心库以及数据库驱动程序的依赖。如果与 Spring 集成，还需要添加 `mybatis-spring` 的依赖。

2.  **创建核心配置文件 (mybatis-config.xml)：** 这是 MyBatis 的全局配置文件，是整个框架的入口。它主要配置了 MyBatis 的运行环境，比如：

    - **数据源 (DataSource)：** 配置数据库的连接信息，如驱动、URL、用户名和密码。在实际项目中，数据源通常会交由 Spring 等容器来管理。
    - **事务管理器 (TransactionManager)：** 配置如何管理数据库事务。
    - **设置 (Settings)：** 一些全局性的配置，例如是否开启驼峰命名自动映射、是否开启缓存等。
    - **类型别名 (TypeAliases)：** 为 Java 类型指定一个更短的名字，以减少在 XML 中书写冗长的完全限定类名。
    - **映射器 (Mappers)：** 告知 MyBatis 去哪里寻找 SQL 映射文件（Mapper XML）或者 Mapper 接口。

3.  **创建实体类 (POJO)：** 根据数据库表结构，创建对应的 Java 对象，也称为 POJO (Plain Old Java Object)。这些对象用于封装数据，并在 Java 代码和数据库记录之间传递。

4.  **创建 Mapper 接口和 XML 映射文件：** 这是 MyBatis 的核心所在，也是我们编写 SQL 的地方。

    - **Mapper 接口：** 定义操作数据库的方法，例如 `User findUserById(int id);`。开发者在代码中直接调用这些接口方法，而不需要关心其实现。
    - **Mapper XML 文件：** 编写与 Mapper 接口中方法对应的具体 SQL 语句。通过 `<select>`, `<insert>`, `<update>`, `<delete>` 等标签来定义增删改查操作。文件名和命名空间（namespace）通常与 Mapper 接口的完全限定名保持一致，XML 中的 SQL 语句 ID 与接口中的方法名也需要一一对应。MyBatis 会通过这种约定将接口与 SQL 动态绑定起来。

5.  **编写代码，加载配置并获取会话：** 在业务代码中，我们需要通过以下步骤来实际执行数据库操作：
    - 加载核心配置文件 `mybatis-config.xml`。
    - 根据配置信息构建一个 `SqlSessionFactory` 对象。
    - 通过 `SqlSessionFactory` 打开一个 `SqlSession`。`SqlSession` 类似于一个数据库连接。
    - 通过 `SqlSession` 获取 Mapper 接口的代理实现对象。
    - 调用 Mapper 接口的方法来执行数据库操作。
    - 提交事务并关闭 `SqlSession`。

以上就是一个完整的使用流程。当然，在与 Spring/Spring Boot 集成后，`SqlSessionFactory` 和 `SqlSession` 的创建、管理以及事务控制都会由框架自动完成，开发过程会得到极大的简化。

### 第二部分：核心对象的生命周期

理解核心对象的生命周期（或者说作用域）是正确使用 MyBatis 的关键，如果使用不当，会导致严重的性能和线程安全问题。MyBatis 中最重要的三个对象是 `SqlSessionFactoryBuilder`、`SqlSessionFactory` 和 `SqlSession`。

1.  **SqlSessionFactoryBuilder (构建器)：**

    - **作用：** 它的唯一作用就是解析 XML 配置文件，然后创建一个 `SqlSessionFactory` 实例。
    - **生命周期：** **方法级别（用完即丢）**。一旦 `SqlSessionFactory` 被创建出来，`SqlSessionFactoryBuilder` 的使命就完成了，它就不再需要存在了。因此，它只应存在于创建 `SqlSessionFactory` 的那个方法中，作为局部变量使用。保留它没有任何意义，反而会占用内存。

2.  **SqlSessionFactory (工厂接口)：**

    - **作用：** 这是一个工厂，它的核心职责是创建 `SqlSession` 实例。可以把它想象成一个数据库连接池。
    - **生命周期：** **应用程序级别（全局唯一，单例）**。`SqlSessionFactory` 是一个线程安全的对象。它的创建过程会解析所有 XML 并构建内部的配置信息，这是一个非常耗费资源的操作。因此，在整个应用程序的运行期间，我们应该只创建一个 `SqlSessionFactory` 实例。多次创建它会严重影响性能。通常，我们会在应用启动时就初始化好这个对象。

3.  **SqlSession (会话)：**
    - **作用：** 这是 MyBatis 中执行数据库操作的核心接口。它包含了所有执行 SQL、获取 Mapper 代理以及管理事务的方法。`SqlSession` 实例封装了底层的 JDBC 连接。
    - **生命周期：** **请求级别或方法级别（线程不安全，绝不能共享）**。每个线程都应该有自己独立的 `SqlSession` 实例。它绝对不是线程安全的，如果多个线程共享同一个 `SqlSession` 实例，会产生各种意想不到的数据混乱。因此，它的最佳实践作用域是**一次请求**或一个**业务方法**。标准的使用模式是：在需要操作数据库时打开它，操作完成后，在 `finally` 块中确保关闭它。这与我们使用数据库连接的模式是完全一致的。在与 Spring 集成时，框架会自动为我们管理 `SqlSession` 的生命周期，确保每个事务都有独立的 `SqlSession`。

**总结一下生命周期：**

- `SqlSessionFactoryBuilder`: 用完就丢。
- `SqlSessionFactory`: 全局唯一，伴随应用整个生命周期。
- `SqlSession`: 随用随关，绝不跨线程共享。

---

## 在 mapper 中如何传递多个参数？

在 Mapper 中传递多个参数主要有以下四种方式：

### 1. 使用 `@Param` 注解 (官方推荐，最常用)

这是最清晰、最直观，也是官方首推的方式。通过在 Mapper 接口的方法参数前使用 `@Param` 注解，可以为每个参数指定一个明确的名称。然后在 XML 文件中，就可以通过这个指定的名称来引用对应的参数。

**优点：**

- **可读性强：** 代码意图非常清晰，直接从方法签名就能看出每个参数在 SQL 中的作用。
- **简单直观：** 无需创建额外的类，对于参数数量不多的情况非常方便。
- **不易出错：** 参数名和 SQL 中的占位符直接对应，不受参数顺序的影响。

**缺点：**

- 当参数数量过多时（比如超过 4、5 个），方法签名会显得冗长。

**示例：**

**Mapper 接口:**

```java
public interface UserMapper {
    User findUserByUsernameAndPassword(
        @Param("username") String username,
        @Param("password") String password
    );
}
```

**Mapper XML:**

```xml
<select id="findUserByUsernameAndPassword" resultType="com.example.model.User">
    SELECT * FROM users
    WHERE username = #{username} AND password = #{password}
</select>
```

在 XML 中，`#{username}` 和 `#{password}` 会被直接替换成通过 `@Param` 注解命名的参数值。

### 2. 使用 POJO (Java Bean)

当传递的参数在业务上是一个整体，或者参数数量较多时，最佳实践是创建一个专门的 POJO（Plain Old Java Object）来封装这些参数。

**优点：**

- **结构清晰，封装性好：** 将相关的参数封装在一个对象中，符合面向对象的思想。
- **可维护性和扩展性强：** 如果需要增加或减少参数，只需要修改 POJO 类，而不需要改变 Mapper 接口的方法签名。
- **使方法签名更简洁：** 无论有多少个查询条件，方法参数都只有一个。

**缺点：**

- 需要额外创建一个类，对于只有两三个简单参数的场景，会显得有些繁琐。

**示例：**

**查询参数类 (POJO):**

```java
public class UserQueryParam {
    private String username;
    private Integer status;
    // Getters and Setters...
}
```

**Mapper 接口:**

```java
public interface UserMapper {
    List<User> findUsersByCriteria(UserQueryParam params);
}
```

**Mapper XML:**

```xml
<select id="findUsersByCriteria" parameterType="com.example.dto.UserQueryParam" resultType="com.example.model.User">
    SELECT * FROM users
    WHERE username = #{username} AND status = #{status}
</select>
```

MyBatis 会自动从传入的 `UserQueryParam` 对象中，根据属性名（`username`, `status`）来获取对应的值。

### 3. 使用 `Map`

我们也可以使用 `Map` 来封装多个参数。键（Key）对应参数名，值（Value）对应参数值。

**优点：**

- **非常灵活：** 无需创建新类，可以动态地向 Map 中增删参数。

**缺点：**

- **可读性差，缺乏类型安全：** 无法从方法签名中直观地看出需要哪些参数，必须去看方法的实现或者 XML。键（Key）是以字符串形式存在的"魔术字符串"，容易写错且编译器无法检查。
- **维护性差：** 在团队协作中，这种方式会造成沟通成本，是一种糟糕的设计。

**示例：**

**Mapper 接口:**

````java
public interface UserMapper {
    User findUserByMap(Map<String, Object> params);
}```

**业务代码调用:**
```java
Map<String, Object> map = new HashMap<>();
map.put("username", "JohnDoe");
map.put("password", "secret123");
User user = userMapper.findUserByMap(map);
````

**Mapper XML:**

```xml
<select id="findUserByMap" resultType="com.example.model.User">
    SELECT * FROM users
    WHERE username = #{username} AND password = #{password}
</select>
```

XML 中的 `#{username}` 会对应 Map 中 key 为 `username` 的值。

### 4. 默认方式 (按参数顺序，不推荐)

在没有使用 `@Param` 注解的情况下，MyBatis 默认会按照参数在方法签名中的顺序来命名，格式为 `#{0}`, `#{1}`... 或者 `#{param1}`, `#{param2}`...

**优点：**

- 无需任何额外注解或类。

**缺点：**

- **可读性极差：** `#{0}` 和 `#{param1}` 这样的名称没有任何业务含义。
- **非常脆弱，极易出错：** 如果调整了 Mapper 接口中方法的参数顺序，SQL 语句就必须同步修改，否则就会在运行时引发错误，这种错误很难排查。

**示例：**

**Mapper 接口:**

```java
public interface UserMapper {
    // 极不推荐这种写法！
    User findUserByPosition(String username, String password);
}
```

**Mapper XML:**

```xml
<select id="findUserByPosition" resultType="com.example.model.User">
    <!-- 写法一：使用索引 -->
    SELECT * FROM users WHERE username = #{0} AND password = #{1}

    <!-- 写法二：使用默认参数名 -->
    SELECT * FROM users WHERE username = #{param1} AND password = #{param2}
</select>
```

### 总结与最佳实践

| 方式         | 优点                           | 缺点                               | 推荐场景                                           |
| :----------- | :----------------------------- | :--------------------------------- | :------------------------------------------------- |
| **@Param**   | 可读性强，简单直观，不易出错   | 参数过多时方法签名冗长             | **强烈推荐**，适用于 2-4 个参数的场景              |
| **POJO**     | 结构清晰，封装性好，易扩展维护 | 需额外创建类                       | **强烈推荐**，适用于参数较多或参数有业务关联的场景 |
| **Map**      | 灵活，无需创建新类             | 可读性差，类型不安全，维护困难     | 仅在参数完全动态、无法提前定义的极端场景下考虑使用 |
| **默认方式** | 无需额外配置                   | 可读性差，极易因参数顺序调整而出错 | **坚决避免**，在现代项目开发中应被禁止             |

在我的实践中，我会遵循以下原则：

- 对于 2 到 4 个参数，我会毫不犹豫地选择 **`@Param`** 注解。
- 当参数超过 4 个，或者这些参数本身就是一个业务实体（如“用户查询条件”），我会创建一个 **POJO** 来封装它们。
- 我会尽量避免使用 `Map`，并且绝对不会使用依赖参数顺序的默认方式。

---

## 实体类属性名和表中字段名不一样 ，怎么办?

这个问题在实际开发中几乎是必然会遇到的，因为数据库的命名规范（通常是下划线命名法，如 `user_name`）和 Java 的命名规范（驼峰命名法，如 `userName`）往往是不同的。MyBatis 提供了三种主要的解决方案来处理这种情况。

### 方式一：在 SQL 语句中起别名

这是最直接、最简单的一种方式。我们可以在 `SELECT` 语句中，使用 `AS` 关键字为数据库字段起一个别名，让这个别名与实体类的属性名完全一致。

**优点：**

- **简单直观：** 不需要任何额外的配置，直接在 SQL 中完成映射，非常容易理解。
- **灵活性高：** 可以在每个查询中按需使用，不会影响其他查询。

**缺点：**

- **存在重复劳动：** 如果多个查询都需要返回这个实体类，那么每个查询语句中都需要写一遍别名，增加了 SQL 的冗余度。
- **可维护性差：** 如果实体类的属性名发生变化，需要去修改所有相关的 SQL 语句。

**示例：**

假设数据库表 `users` 有一个字段 `user_name`，而实体类 `User` 的属性是 `userName`。

**Mapper XML:**

```xml
<select id="findUserById" resultType="com.example.model.User">
    SELECT
        user_id AS userId,
        user_name AS userName,
        user_password AS userPassword
    FROM
        users
    WHERE
        user_id = #{id}
</select>
```

通过 `AS userName`，MyBatis 就知道应该将 `user_name` 字段的值映射到 `userName` 属性上。

### 方式二：使用 `<resultMap>` 结果映射

这是 MyBatis 提供的最强大、最核心的解决方案，也是**官方推荐的最佳实践**。`<resultMap>` 元素专门用于解决字段名和属性名不匹配的问题，并且可以处理复杂的关联关系（如一对一、一对多）。

我们可以在 Mapper XML 文件中定义一个 `<resultMap>`，显式地声明数据库字段和实体类属性之间的映射关系。然后在查询标签（如 `<select>`）中通过 `resultMap` 属性来引用它。

**优点：**

- **一劳永逸，复用性强：** 只需定义一次映射关系，所有引用该 `<resultMap>` 的查询都可以共享这套规则，大大减少了 SQL 中的冗余。
- **功能强大：** 除了解决名称不匹配，还能处理复杂的嵌套查询、关联对象映射等高级场景。
- **解耦和可维护性好：** 将映射逻辑与 SQL 语句分离，结构更清晰。如果实体类属性名变化，只需修改 `<resultMap>` 即可。

**缺点：**

- 需要编写额外的 XML 配置，会增加一些配置工作量。

**示例：**

**Mapper XML:**

```xml
<!-- 定义一个结果映射 -->
<resultMap id="userResultMap" type="com.example.model.User">
    <!-- <id> 用于主键字段的映射 -->
    <id property="userId" column="user_id" />
    <!-- <result> 用于普通字段的映射 -->
    <result property="userName" column="user_name" />
    <result property="userPassword" column="user_password" />
</resultMap>

<!-- 在 select 标签中通过 resultMap 属性引用上面的定义 -->
<select id="findUserById" resultMap="userResultMap">
    SELECT user_id, user_name, user_password FROM users WHERE user_id = #{id}
</select>

<select id="findAllUsers" resultMap="userResultMap">
    SELECT user_id, user_name, user_password FROM users
</select>
```

这样，`findUserById` 和 `findAllUsers` 两个查询都可以复用 `userResultMap` 这套映射规则，SQL 语句也变得更简洁。

### 方式三：开启驼峰命名自动映射

如果项目中数据库字段的命名严格遵循下划线风格（`user_name`），而 Java 实体类的属性名严格遵循驼峰风格（`userName`），那么 MyBatis 提供了一个全局性的“开关”来自动完成这种映射。

我们只需要在 MyBatis 的核心配置文件 `mybatis-config.xml` 中进行一项简单的设置即可。

**优点：**

- **配置极其简单：** 只需一行配置，即可在全局范围内生效，无需为每个查询单独处理。
- **零冗余：** SQL 语句和 `<resultMap>` 都不需要额外编写，非常简洁。

**缺点：**

- **有局限性：** 只适用于“下划线转驼峰”这种固定的命名规则。如果字段名和属性名是完全无规律的不匹配（例如字段是 `uname`，属性是 `userName`），这种方式就无能为力了。

**示例：**

**mybatis-config.xml:**

```xml
<configuration>
    <settings>
        <!-- 开启驼峰命名自动映射 -->
        <setting name="mapUnderscoreToCamelCase" value="true"/>
    </settings>
</configuration>
```

开启这个配置后，对于上面的例子，我们甚至不需要起别名，也不需要定义 `<resultMap>`，直接这样写就可以正常工作：

**Mapper XML:**

```xml
<select id="findUserById" resultType="com.example.model.User">
    SELECT user_id, user_name, user_password FROM users WHERE user_id = #{id}
</select>
```

MyBatis 在处理结果集时，会自动将 `user_name` 映射到 `userName` 属性上。

### 总结与选择建议

| 方式              | 优点                         | 缺点                 | 适用场景                                       |
| :---------------- | :--------------------------- | :------------------- | :--------------------------------------------- |
| **SQL 别名**      | 简单、直接、灵活             | 冗余、维护性差       | 临时的、个别的、简单的查询                     |
| **`<resultMap>`** | 复用性强、功能强大、维护性好 | 配置稍显复杂         | **强烈推荐**，尤其是在复杂查询和需要复用的场景 |
| **驼峰自动映射**  | 全局配置、极其简单、零冗余   | 只适用于固定命名规则 | 普遍推荐开启，作为基础映射方案                 |

在我的项目实践中，通常会采取 **“驼峰自动映射” + “`<resultMap>`”** 相结合的策略：

1.  **首先，在全局配置中开启 `mapUnderscoreToCamelCase`**。这能自动处理掉项目中 90% 以上的简单映射问题，让代码保持整洁。
2.  **其次，当遇到无法通过驼峰规则自动映射的字段，或者需要处理复杂的嵌套查询和关联关系时，再定义专门的 `<resultMap>`** 来进行精确控制。

---

## Mybatis 是否可以映射 Enum 枚举类？

这是一个非常实际的问题，在现代 Java 开发中，使用枚举来表示固定的状态或类型是一种非常普遍且推荐的做法。

**MyBatis 不仅可以映射枚举类，而且提供了多种内置的和可定制的方式来处理枚举，非常灵活。**

处理枚举映射主要有两种内置的处理器（Type Handler），以及一种完全自定义的方式。

### 方式一：使用 `EnumTypeHandler` (默认和推荐)

这是 MyBatis 默认使用的枚举处理器（自 MyBatis 3.4.5 版本起），也是**我首选和强烈推荐的方式**。

- **工作原理：** 它会将枚举实例的**名称**（通过调用 `Enum.name()` 方法）存储到数据库中。
- **数据库字段类型：** 通常是 `VARCHAR` 或 `CHAR`。
- **优点：**
  - **可读性极高：** 数据库中存储的是有意义的字符串，如 "ACTIVE", "INACTIVE", "MALE", "FEMALE"，数据库管理员或开发人员可以直接看懂数据含义。
  - **健壮性强，不易出错：** 即使您在枚举类中调整了枚举常量的顺序，或者在中间插入了新的常量，已经存储到数据库中的数据也不会受到任何影响，因为映射是基于名称的。
- **缺点：**
  - 相比于存储数字，占用的存储空间稍大。
  - 可能存在轻微的性能开销，但对于绝大多数应用来说可以忽略不计。

**示例：**

**Java 枚举类:**

```java
public enum UserStatus {
    ACTIVE, PENDING, INACTIVE
}
```

**数据库存储:**
当保存一个 `UserStatus.ACTIVE` 的枚举实例时，数据库 `status` 字段中存储的值会是字符串 `"ACTIVE"`。

MyBatis 会自动处理这一切，我们无需做任何额外配置。

### 方式二：使用 `EnumOrdinalTypeHandler` (不推荐)

这种方式是基于枚举的**序数**（ordinal）进行映射。

- **工作原理：** 它会将枚举实例的**序数**（通过调用 `Enum.ordinal()` 方法，即枚举常量在定义时的顺序，从 0 开始）存储到数据库中。
- **数据库字段类型：** 通常是 `INT`, `TINYINT` 等数字类型。
- **优点：**
  - 占用存储空间小。
- **缺点：**
  - **可读性差：** 数据库里存储的是 0, 1, 2 这样的魔法数字，如果没有文档或代码对照，完全不知道其代表的业务含义。
  - **极其危险，是潜在的 BUG 温床：** 这是最致命的缺点。如果在 `UserStatus` 枚举中改变了常量的顺序，例如从 `ACTIVE, PENDING, INACTIVE` 改为 `PENDING, ACTIVE, INACTIVE`，那么所有之前存储为 `0` 的数据（原本代表 `ACTIVE`）现在将被错误地解析为 `PENDING`，从而导致严重的线上数据错乱。**这是一种非常脆弱的映射关系，在团队协作和长期项目维护中应该坚决避免。**

**如何配置使用 `EnumOrdinalTypeHandler`？**

如果您确实需要使用它，可以在 MyBatis 全局配置文件 `mybatis-config.xml` 中进行设置：

```xml
<typeHandlers>
    <typeHandler handler="org.apache.ibatis.type.EnumOrdinalTypeHandler" javaType="com.example.enums.UserStatus"/>
</typeHandlers>
```

### 方式三：自定义 `TypeHandler` (最灵活)

当以上两种内置方式都无法满足需求时，MyBatis 允许我们创建自定义的 `TypeHandler`。这在以下场景中非常有用：

- **与遗留系统对接：** 数据库中可能用一些特定的数字（如 1 代表激活，-1 代表禁用）或字符（'A' 代表激活）来表示状态，这些值既不是枚举的名称也不是序数。
- **希望枚举与自定义值关联：** 我们希望在枚举中定义一个 `code` 属性，并将其存入数据库。

**实现步骤：**

1.  **让枚举实现一个接口，包含获取自定义值的方法。**
2.  **创建一个类实现 MyBatis 的 `TypeHandler<T>` 接口。**
3.  **在 MyBatis 配置文件中注册这个自定义的 `TypeHandler`。**

**示例：**

**1. 定义带 `code` 属性的枚举：**

```java
public enum UserStatus {
    ACTIVE(1, "激活"),
    PENDING(0, "待定"),
    INACTIVE(-1, "禁用");

    private final int code;
    private final String description;

    // 构造函数、Getter等...

    public static UserStatus fromCode(int code) {
        for (UserStatus status : values()) {
            if (status.getCode() == code) {
                return status;
            }
        }
        return null;
    }
}
```

**2. 创建自定义 `UserStatusTypeHandler`:**

```java
import org.apache.ibatis.type.JdbcType;
import org.apache.ibatis.type.TypeHandler;
import java.sql.CallableStatement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class UserStatusTypeHandler implements TypeHandler<UserStatus> {

    @Override
    public void setParameter(PreparedStatement ps, int i, UserStatus parameter, JdbcType jdbcType) throws SQLException {
        ps.setInt(i, parameter.getCode());
    }

    @Override
    public UserStatus getResult(ResultSet rs, String columnName) throws SQLException {
        int code = rs.getInt(columnName);
        return UserStatus.fromCode(code);
    }

    // ... 实现另外两个 getResult 方法
}
```

**3. 注册 `TypeHandler`:**
在 `mybatis-config.xml` 中：

```xml
<typeHandlers>
    <typeHandler handler="com.example.typehandler.UserStatusTypeHandler"/>
</typeHandlers>
```

### 总结

- **可以直接映射吗？** **可以。**
- **最佳实践是什么？** 对于新项目，直接使用默认的 **`EnumTypeHandler`**，它将枚举的名称存为字符串。这是最安全、可读性最好的方式。
- **什么时候需要注意？** 坚决避免使用 **`EnumOrdinalTypeHandler`**，除非您有非常特殊且不可抗拒的理由。
- **如果遇到特殊需求怎么办？** 当需要将枚举映射到非名称、非序数的自定义值时，**自定义 `TypeHandler`** 是一个非常强大和优雅的解决方案。

---

## #{} 和 ${} 的区别?

`#{}` 和 `${}` 最本质的区别在于：**`#{}` 是预编译处理，而 `${}` 是字符串替换。**

这个本质区别导致了它们在**安全性、性能和使用场景**上有着天壤之 béi。下面我将详细展开说明。

### 1. `#{}` (参数占位符 - PreparedStatement)

这是我们**首选**并且**绝大多数情况**下都应该使用的方式。

- **工作原理：** 当 MyBatis 处理 `#{}` 时，它会将 SQL 中的 `#{}` 替换为 JDBC 标准的 `?` 占位符，并调用 `PreparedStatement` 的 `set` 方法来安全地设置参数。
- **安全性：** **能够有效防止 SQL 注入攻击**。这是因为它将 SQL 指令和用户传入的数据严格分离开来。数据库会对 SQL 语句的结构进行预编译，无论用户输入什么，都会被当作一个纯粹的字符串数据来处理，而不会被当作 SQL 指令的一部分去执行。
- **性能：** 由于使用了 `PreparedStatement`，数据库可以对 SQL 语句进行预编译和缓存，当相同的 SQL 语句（结构相同，只有参数不同）再次执行时，可以重用已缓存的执行计划，从而提升性能。
- **类型处理：** MyBatis 会根据参数的 Java 类型自动进行相应的 JDBC 类型转换。

**示例：**

**Mapper XML:**

```xml
<select id="findUserById" resultType="com.example.model.User">
    SELECT * FROM users WHERE user_id = #{id}
</select>
```

**MyBatis 执行过程（伪代码）：**

1.  生成的 SQL 语句是：`SELECT * FROM users WHERE user_id = ?`
2.  然后通过 `preparedStatement.setInt(1, id_value)` 来设置参数。

**如何防止 SQL 注入？**
如果一个恶意用户传入的 `id` 是 `"1 OR 1=1"`，那么：

- `#{}` 会将 `"1 OR 1=1"` 整个字符串作为一个值赋给 `?`。数据库会尝试将这个字符串转换为 `user_id` 的类型（比如整型），这很可能会因为类型不匹配而直接报错，或者数据库会去查找 `user_id` 等于字符串 `'1 OR 1=1'` 的记录，这通常是找不到的。恶意 SQL 并没有被执行。

### 2. `${}` (字符串替换 - Statement)

这种方式应该**非常谨慎地使用**，因为它存在安全风险。

- **工作原理：** 当 MyBatis 处理 `${}` 时，它就是**原样**的、**直接**的字符串拼接。它会将 `${}` 中变量的值直接拼接到 SQL 语句中，然后交给数据库执行。这等同于使用了 JDBC 的 `Statement` 对象。
- **安全性：** **无法防止 SQL 注入**。因为用户的输入被直接拼接到了 SQL 语句中，如果输入包含了 SQL 关键字或语法，它就会成为 SQL 指令的一部分被数据库执行。
- **性能：** 每次执行都是一条全新的 SQL 语句，数据库无法利用预编译缓存，可能会导致性能下降。
- **使用场景：** 它的存在是为了解决 `#{}` 无法处理的场景，即需要**动态改变 SQL 结构**本身的情况。例如：
  - 动态指定排序的列名 (`ORDER BY`)
  - 动态指定要查询的表名或列名

**示例：**

**Mapper XML (一个合法的，但需谨慎的用例):**

```xml
<select id="findUsersOrderedBy" resultType="com.example.model.User">
    SELECT * FROM users ORDER BY ${columnName}
</select>
```

**MyBatis 执行过程（伪代码）：**

1.  如果传入的 `columnName` 是 `"create_time"`，那么生成的 SQL 就是：`SELECT * FROM users ORDER BY create_time`
2.  这条 SQL 会被直接执行。

**SQL 注入的风险：**
如果上面例子中的 `columnName` 允许用户输入，一个恶意用户可以传入 `"user_id; DROP TABLE users;"`。

- `${}` 会将这个字符串直接拼接到 SQL 中，最终生成的 SQL 可能是：`SELECT * FROM users ORDER BY user_id; DROP TABLE users;`
- 如果数据库支持多语句执行，这就会导致灾难性的后果——`users` 表被删除了。

### 总结与最佳实践

| 特性         | `#{}` (推荐)                 | `${}` (慎用)                                          |
| :----------- | :--------------------------- | :---------------------------------------------------- |
| **本质**     | 预编译的参数占位符           | 字符串直接拼接、替换                                  |
| **底层实现** | `PreparedStatement`          | `Statement`                                           |
| **安全性**   | **安全**，有效防止 SQL 注入  | **不安全**，有 SQL 注入风险                           |
| **性能**     | 更好，可利用预编译缓存       | 较差，每次都是新 SQL                                  |
| **使用场景** | 所有需要传递**参数值**的地方 | 动态指定**SQL 关键字**，如表名、列名、`ORDER BY` 子句 |
| **数据处理** | 会根据类型进行转换           | 原样输出，不做任何处理                                |

**我的使用原则非常明确：**

1.  **凡是需要传递参数值的地方，永远、必须、只能使用 `#{}`。** 这应该成为一种肌肉记忆。
2.  **只有在需要动态指定表名、列名、排序规则等无法用 `?` 占位符替代的 SQL 组成部分时，才考虑使用 `${}`。**
3.  **当必须使用 `${}` 时，必须在代码层面进行严格的校验和过滤**，例如使用白名单机制，确保传入的值是在一个预期的、安全的集合内，绝对不能将未经验证的用户输入直接用于 `${}` 中。

---

## 模糊查询 like 语句该怎么写?

在 MyBatis 中编写 `LIKE` 模糊查询主要有以下三种方式来实现：

### 方式一：使用数据库的 `CONCAT` 函数 (最推荐，最安全)

这是我**首选并且强烈推荐**的方式。我们利用数据库内置的字符串连接函数（如 MySQL 的 `CONCAT` 或 Oracle 的 `||`），将 `'%'` 拼接在参数的两侧。

- **工作原理：** 这种方式依然使用 `#{}` 来传递参数。这意味着用户输入的关键字本身是作为预编译参数被安全处理的，MyBatis 将其传递给数据库。SQL 注入的风险被完全规避。真正的 `LIKE` 匹配逻辑是完全在数据库服务端执行的。

**优点：**

- **绝对安全：** 完美地防止了 SQL 注入，因为参数值是通过 `PreparedStatement` 设置的。
- **代码清晰：** Mapper XML 中的 SQL 语句意图明确。
- **数据库通用性好：** 大多数主流数据库都支持 `CONCAT` 函数或类似的字符串拼接语法。

**缺点：**

- 需要知道并使用特定数据库的字符串连接函数。

**示例 (以 MySQL 为例):**

```xml
<select id="findUsersByName" resultType="com.example.model.User">
    SELECT * FROM users
    WHERE user_name LIKE CONCAT('%', #{username}, '%')
</select>
```

- 如果想实现“左模糊”，就是 `CONCAT(#{username}, '%')`。
- 如果想实现“右模糊”，就是 `CONCAT('%', #{username})`。

### 方式二：在 Java 代码中拼接百分号

这种方式是在调用 Mapper 方法之前，在业务逻辑层或服务层手动为参数字符串添加 `'%'`。

- **工作原理：** 将拼接好的完整 `LIKE` 模式字符串（例如 `"%keyword%"`）传递给 Mapper 方法。XML 中依然使用 `#{}` 来接收这个完整的字符串。由于整个 `"%keyword%"` 字符串还是通过 `PreparedStatement` 设置的，所以它同样是安全的。

**优点：**

- **同样安全：** 也能有效防止 SQL 注入。
- **SQL 语句最简洁：** XML 中的 `LIKE` 子句看起来非常标准。

**缺点：**

- **业务逻辑与数据访问逻辑耦合：** 将数据匹配的格式化逻辑（添加 `%`）暴露到了业务代码中，这在某种程度上违反了分层设计的原则。业务层应该只关心传递业务参数，而不应该关心这些参数在数据库中如何被格式化用于查询。

**示例：**

**Java Service/Controller 代码:**

```java
String searchName = "%" + name + "%";
List<User> users = userMapper.findUsersByName(searchName);
```

**Mapper XML:**

```xml
<select id="findUsersByName" resultType="com.example.model.User">
    SELECT * FROM users
    WHERE user_name LIKE #{username}
</select>
```

### 方式三：使用 `${}` 进行字符串拼接 (不推荐，有注入风险)

这种方式是直接在 XML 中使用 `${}` 来拼接字符串。

- **工作原理：** `${}` 是直接的字符串替换，MyBatis 会将 `#{username}` 的值原样拼接到 SQL 中，然后再把 `'%'` 拼在外面。**这种写法存在严重的 SQL 注入风险，应该坚决避免！**

**错误的、有风险的示例：**

```xml
<!-- 极不推荐！存在 SQL 注入风险！ -->
<select id="findUsersByName" resultType="com.example.model.User">
    SELECT * FROM users
    WHERE user_name LIKE '%${username}%'
</select>
```

**为什么有风险？**
如果一个恶意用户传入的 `username` 是 `' OR '1'='1`，那么拼接后的 SQL 就会变成：
`SELECT * FROM users WHERE user_name LIKE '%' OR '1'='1'%'`
这会导致 `WHERE` 条件恒为真，可能会返回所有用户信息，造成数据泄露。

**如何修正 `${}` 的用法？**
虽然不推荐，但确实有一种相对安全的写法，就是将 `value` 属性与 `#{}` 结合。

```xml
<select id="findUsersByName" resultType="com.example.model.User">
    SELECT * FROM users
    WHERE user_name LIKE "%"#{username}"%"
</select>
```

**注意**：在一些 Mybatis 版本或数据库驱动中，上述写法可能无法正常工作。

### 总结与最佳实践

| 方式              | 优点                   | 缺点                | 安全性   | 推荐度 |
| :---------------- | :--------------------- | :------------------ | :------- | :----- |
| **`CONCAT` 函数** | **安全**，SQL 意图清晰 | 需了解数据库函数    | **高**   | ★★★★★  |
| **Java 代码拼接** | **安全**，XML 简洁     | 业务与数据访问耦合  | **高**   | ★★★☆☆  |
| **`${}` 拼接**    | 语法看似简单           | **有 SQL 注入风险** | **极低** | ☆☆☆☆☆  |

在我的开发实践中，我会遵循以下原则：

1.  **优先使用 `CONCAT` 函数**。这是最能体现专业性和安全意识的做法，将数据处理的逻辑保留在数据访问层。
2.  **绝对禁止直接在 `'%...%'` 中使用 `${}`**。这是安全红线，不可逾越。
3.  如果团队规范或者项目历史原因导致倾向于在 Java 代码中处理，也可以接受，但要明白其分层不清的缺点。

因此，对于“`LIKE` 语句怎么写”这个问题，最佳答案是：**使用 `CONCAT('%', #{param}, '%')`**。

---

## Mybatis 能执行一对一、一对多、多对多的关联查询吗？

**能，而且 MyBatis 提供了非常强大和灵活的机制来处理一对一、一对多以及多对多的关联查询。** 实现这些关联查询的核心工具就是 `<resultMap>` 元素。

在 `<resultMap>` 内部，我们主要使用两个子标签来定义关联关系：

- **`<association>`**：用于处理 **“有一个”** 的关系，即 **一对一** 关联。
- **`<collection>`**：用于处理 **“有很多个”** 的关系，即 **一对多** 或 **多对多** 关联。

实现关联查询主要有两种方式：**嵌套结果映射（Nested ResultMaps）** 和 **嵌套查询（Nested Selects）**。

---

### 一、一对一关联查询 (`<association>`)

**场景**：一个用户（User）对应一个用户详情（UserProfile）。

#### 方式 1：嵌套结果映射 (推荐)

这种方式通过一条 `JOIN` SQL 语句查询出所有需要的数据，然后通过 `<resultMap>` 的嵌套结构将结果集映射到嵌套的对象中。

**Java 实体类:**

```java
public class User {
    private Integer userId;
    private String username;
    private UserProfile profile; // 关联 UserProfile 对象
    // ... getters and setters
}

public class UserProfile {
    private Integer profileId;
    private String email;
    private String phone;
    // ... getters and setters
}
```

**Mapper XML:**

```xml
<resultMap id="userWithProfileMap" type="com.example.model.User">
    <id property="userId" column="user_id"/>
    <result property="username" column="username"/>
    <!-- 使用 association 映射一对一关系 -->
    <association property="profile" javaType="com.example.model.UserProfile">
        <id property="profileId" column="profile_id"/>
        <result property="email" column="email"/>
        <result property="phone" column="phone"/>
    </association>
</resultMap>

<select id="findUserWithProfile" resultMap="userWithProfileMap">
    SELECT
        u.user_id,
        u.username,
        p.profile_id,
        p.email,
        p.phone
    FROM users u
    LEFT JOIN user_profiles p ON u.user_id = p.user_id
    WHERE u.user_id = #{id}
</select>
```

**优点：** 只执行一条 SQL，性能较高。

#### 方式 2：嵌套查询 (慎用)

这种方式会执行多条 SQL。先查询主对象（User），然后根据主对象的 ID，再去执行另一条 SQL 来查询关联的对象（UserProfile）。

**Mapper XML:**

```xml
<!-- 查询 UserProfile 的 SQL -->
<select id="findProfileByUserId" resultType="com.example.model.UserProfile">
    SELECT profile_id, email, phone FROM user_profiles WHERE user_id = #{userId}
</select>

<resultMap id="userWithProfileMapUsingSelect" type="com.example.model.User">
    <id property="userId" column="user_id"/>
    <result property="username" column="username"/>
    <!-- select: 指定要执行的查询ID; column: 将主查询的哪个字段作为参数传递过去 -->
    <association property="profile"
                 select="com.example.mapper.UserProfileMapper.findProfileByUserId"
                 column="user_id"
                 javaType="com.example.model.UserProfile"/>
</resultMap>

<select id="findUserWithProfile" resultMap="userWithProfileMapUsingSelect">
    SELECT user_id, username FROM users WHERE user_id = #{id}
</select>
```

**缺点：** 存在 **“N+1”** 问题。如果查询 10 个用户，会先执行 1 条查询用户的 SQL，然后为每个用户再执行 1 条查询 Profile 的 SQL，总共执行 1 + 10 = 11 条 SQL，性能开销很大。

---

### 二、一对多关联查询 (`<collection>`)

**场景**：一篇文章（Post）有多条评论（Comment）。

**Java 实体类:**

```java
public class Post {
    private Integer postId;
    private String title;
    private List<Comment> comments; // 关联 Comment 列表
    // ... getters and setters
}

public class Comment {
    private Integer commentId;
    private String content;
    // ... getters and setters
}
```

#### 方式 1：嵌套结果映射 (推荐)

同样是使用一条 `JOIN` SQL 语句。

**Mapper XML:**

```xml
<resultMap id="postWithCommentsMap" type="com.example.model.Post">
    <id property="postId" column="post_id"/>
    <result property="title" column="title"/>
    <!-- 使用 collection 映射一对多关系 -->
    <!-- ofType: 指定集合中元素的类型 -->
    <collection property="comments" ofType="com.example.model.Comment">
        <id property="commentId" column="comment_id"/>
        <result property="content" column="content"/>
    </collection>
</resultMap>

<select id="findPostWithComments" resultMap="postWithCommentsMap">
    SELECT
        p.post_id,
        p.title,
        c.comment_id,
        c.content
    FROM posts p
    LEFT JOIN comments c ON p.post_id = c.post_id
    WHERE p.post_id = #{id}
</select>
```

**优点：** 一条 SQL，性能好。

---

### 三、多对多关联查询 (`<collection>`)

**场景**：一个学生（Student）可以选择多门课程（Course），一门课程也可以被多个学生选择。这需要一个中间表（`student_course`）来维护关系。

从一个学生的角度看，他拥有“一个课程的集合”，所以**多对多查询在 MyBatis 中本质上也是通过 `<collection>` 来实现的，与一对多的处理方式非常相似**。

**Java 实体类:**

```java
public class Student {
    private Integer studentId;
    private String studentName;
    private List<Course> courses; // 关联 Course 列表
    // ... getters and setters
}

public class Course {
    private Integer courseId;
    private String courseName;
    // ... getters and setters
}
```

**Mapper XML:**

```xml
<resultMap id="studentWithCoursesMap" type="com.example.model.Student">
    <id property="studentId" column="student_id"/>
    <result property="studentName" column="student_name"/>
    <!-- 同样使用 collection 映射多对多关系 -->
    <collection property="courses" ofType="com.example.model.Course">
        <id property="courseId" column="course_id"/>
        <result property="courseName" column="course_name"/>
    </collection>
</resultMap>

<select id="findStudentWithCourses" resultMap="studentWithCoursesMap">
    SELECT
        s.student_id,
        s.student_name,
        c.course_id,
        c.course_name
    FROM students s
    LEFT JOIN student_course sc ON s.student_id = sc.student_id
    LEFT JOIN courses c ON sc.course_id = c.course_id
    WHERE s.student_id = #{id}
</select>
```

### 总结与最佳实践

| 方式                    | 优点                             | 缺点                                             | 推荐度         |
| :---------------------- | :------------------------------- | :----------------------------------------------- | :------------- |
| **嵌套结果映射 (JOIN)** | **性能好**，只需一次数据库交互。 | SQL 语句相对复杂，可能产生笛卡尔积导致数据冗余。 | ★★★★★ (首选)   |
| **嵌套查询 (N+1)**      | SQL 语句简单，逻辑清晰。         | **存在严重的 N+1 性能问题**。                    | ★☆☆☆☆ (应避免) |

**我的实践原则：**

1.  **始终优先选择“嵌套结果映射”**，即 JOIN 查询的方式。这是解决关联查询性能问题的最有效手段。
2.  **坚决避免“嵌套查询”**，因为它会带来灾难性的 N+1 问题，尤其是在数据量大的时候。
3.  “嵌套查询”唯一可能的使用场景是，结合**延迟加载（Lazy Loading）**。即当 `getProfile()` 或 `getComments()` 方法被显式调用时，才去执行子查询。这可以避免一次性加载过多非必要的数据，但它并没有解决 N+1 的本质，只是将 N 次查询推迟了。在需要延迟加载的场景下，它才是有价值的。

---

## Mybatis 是否支持延迟加载？原理？

**是的，MyBatis 绝对支持延迟加载（Lazy Loading）。** 延迟加载是 MyBatis 中一个非常重要的性能优化特性。

### 第一部分：什么是延迟加载？

延迟加载，顾名思义，就是在需要用到数据的时候才去真正地执行查询、加载数据，而不是在主查询时就立即把所有关联的数据一次性全部加载出来。

**举一个经典的例子：** 查询一个用户（User）和他名下的所有订单（Order）。

- **非延迟加载（即 Eager Loading，渴望加载）：** 当我们查询 User 对象时，MyBatis 会立刻执行一个 `JOIN` 查询或者多条查询，将 User 的基本信息和他名下的所有 Order 信息一次性全部查出来，并组装好对象。
- **延迟加载（Lazy Loading）：** 当我们查询 User 对象时，MyBatis 只会查询并填充 User 的基本信息（如 `userId`, `username`）。它关联的 `orders` 列表此时是一个空的或者特殊的代理对象。**只有当**我们的业务代码第一次真正尝试去访问 `user.getOrders()` 这个列表时，MyBatis 才会去执行查询订单的 SQL 语句，将订单数据加载进来。

**延迟加载的主要优点**是，对于那些我们不一定会用到的关联数据，可以避免进行非必要的查询，从而减少了初始查询的数据库开销和内存占用，提升了应用的响应速度。

### 第二部分：如何开启和使用延迟加载？

要在 MyBatis 中使用延迟加载，需要满足两个核心条件：

1.  **全局配置开启延迟加载。**
2.  **关联查询必须使用“嵌套查询”的方式，而不是“嵌套结果”的方式。**

**具体配置步骤如下：**

**1. 全局配置 (mybatis-config.xml):**
需要在 `<settings>` 标签中配置两个关键参数：

```xml
<settings>
    <!-- 全局性地开启或关闭所有关联对象的延迟加载。默认为 false -->
    <setting name="lazyLoadingEnabled" value="true"/>

    <!--
      当开启时，任何方法的调用都会加载该对象的所有属性。
      否则，每个属性会按需加载。建议设置为 false，实现真正的按需加载。
      默认为 true，设为 false 可以避免访问对象其他属性时触发关联查询。
    -->
    <setting name="aggressiveLazyLoading" value="false"/>
</settings>
```

**2. 在 Mapper XML 中配置关联关系:**
延迟加载只对使用 `select` 属性进行**嵌套查询**的 `<association>` 和 `<collection>` 有效。对于使用 `JOIN` 的嵌套结果映射，因为数据已经一次性查出，所以不存在延迟加载的概念。

**示例 (一对多延迟加载):**

```xml
<!-- 订单查询的 Mapper 方法 -->
<select id="findOrdersByUserId" resultType="com.example.model.Order">
    SELECT * FROM orders WHERE user_id = #{userId}
</select>

<resultMap id="userWithOrdersLazyMap" type="com.example.model.User">
    <id property="userId" column="user_id"/>
    <result property="username" column="username"/>
    <!--
      关键配置：
      1. 使用 collection 进行一对多关联。
      2. 使用 select 指定当需要加载 orders 时，应该去调用哪个查询。
      3. 使用 column 将主查询的 user_id 字段作为参数传递给 findOrdersByUserId 查询。
      4. (可选) fetchType="lazy" 显式指定为延迟加载，覆盖全局配置。
    -->
    <collection property="orders"
                select="com.example.mapper.OrderMapper.findOrdersByUserId"
                column="user_id"
                fetchType="lazy"/>
</resultMap>

<select id="findUserById" resultMap="userWithOrdersLazyMap">
    SELECT user_id, username FROM users WHERE user_id = #{id}
</select>
```

### 第三部分：延迟加载的实现原理

这是这个问题的核心。MyBatis 实现延迟加载的底层技术是**动态代理**。

MyBatis 会使用第三方字节码增强库，如 **CGLIB**（默认）或 **Javassist**，来为需要延迟加载的目标对象动态地创建一个代理对象。

**其工作流程如下：**

1.  当调用 `userMapper.findUserById(1)` 时，MyBatis 执行主查询 `SELECT user_id, username FROM users ...`。
2.  MyBatis 收到数据库返回的结果后，并不会直接创建一个普通的 `User` 对象。相反，它会利用 CGLIB 或 Javassist **动态地创建一个 `User` 类的子类（即代理对象）**，并将查询到的 `userId` 和 `username` 属性填充到这个代理对象中。
3.  这个代理对象中包含了所有原始 `User` 类的信息，但对于需要延迟加载的 `orders` 属性，它只是持有一个标记，知道应该去执行哪个查询（`findOrdersByUserId`）和需要什么参数（`userId=1`）。
4.  当应用程序代码第一次调用 `userProxy.getOrders()` 方法时，这个调用会被代理对象**拦截**。
5.  代理对象的方法拦截器会检查 `orders` 属性是否已经被加载。
6.  如果发现尚未加载，拦截器就会立刻执行在 `<collection>` 标签中配置的 `select` 查询（即 `findOrdersByUserId`），并将查询结果填充到 `orders` 列表中，然后将这个列表设置回代理对象内部的真实 `orders` 属性。
7.  最后，将填充好的 `orders` 列表返回给调用者。
8.  如果之后再次调用 `userProxy.getOrders()`，代理对象会发现数据已经被加载过了，于是直接返回内存中的数据，不会再查询数据库。

**总结一下原理的核心：** 返回给调用者的不是一个原始的 POJO，而是一个**代理对象**。对关联属性的访问会被这个代理对象拦截，从而触发一次额外的数据库查询来实现“按需加载”。

### 延迟加载的风险

需要注意的是，延迟加载虽然是优化手段，但也可能重新引入 **“N+1” 问题**。如果查询了一个包含 10 个用户的列表，并且对每个用户都触发了订单的延迟加载，那么最终会执行 `1` 次用户查询和 `10` 次订单查询，总共 `11` 次数据库交互。在这种场景下，使用 `JOIN` 的嵌套结果映射可能反而性能更好。

---

## MyBatis 如何实现主键回填?

MyBatis **完全支持**主键回填。主键回填，指的是在执行 `INSERT` 语句后，将数据库自动生成的主键（比如 MySQL 的 `AUTO_INCREMENT` 列或 Oracle 的序列 `SEQUENCE`）返回并设置到传入的参数对象中。

MyBatis 主要通过两种方式来实现主键回填，分别应对不同的数据库和场景：

### 方式一：使用 `useGeneratedKeys` (针对支持主键自增的数据库)

这是最常用、最简洁的方式，专门用于像 MySQL, SQL Server, PostgreSQL 等支持主键自增（Auto-increment / Identity）的数据库。

我们只需要在 `<insert>` 标签上添加两个属性即可：

- `useGeneratedKeys="true"`: 告诉 MyBatis 我们需要使用数据库的自增主键功能。这会开启 JDBC 的 `getGeneratedKeys` 方法调用。
- `keyProperty="id"`: 告诉 MyBatis 将返回的主键值，设置到我们传入的参数对象的哪个属性上。这里的 `id` 必须是参数对象的属性名。

**优点：**

- 配置极其简单，与业务代码无耦合。
- 是针对自增主键的标准解决方案。

**示例：**

**Java 实体类 (User.java):**

```java
public class User {
    private Integer id;
    private String username;
    // ... Getters and Setters
}
```

**Mapper XML:**

```xml
<insert id="insertUser" parameterType="com.example.model.User"
        useGeneratedKeys="true" keyProperty="id">
    INSERT INTO users (username) VALUES (#{username})
</insert>
```

**业务代码调用逻辑:**

```java
User user = new User();
user.setUsername("Alice");

// 在调用之前，user.getId() 的值是 null
System.out.println("插入前, user ID: " + user.getId());

userMapper.insertUser(user);

// 在调用之后，MyBatis 已经将数据库生成的 ID 回填到了 user 对象中
System.out.println("插入后, user ID: " + user.getId());
```

执行后，控制台会打印出数据库为 "Alice" 这条记录新生成的 ID。

### 方式二：使用 `<selectKey>` (更通用，适用于所有数据库)

当数据库不支持主键自增时（最典型的例子就是 **Oracle**，它使用 **序列 Sequence** 来生成主键），或者我们需要在插入前生成一个 UUID 作为主键时，`useGeneratedKeys` 就不适用了。这时，我们需要使用 `<selectKey>` 标签。

`<selectKey>` 允许我们执行一个额外的 SQL 语句来生成主键，并可以控制它在 `INSERT` 语句执行之前还是之后运行。

**关键属性：**

- `keyProperty="id"`: 指定将查询结果赋值给参数对象的哪个属性。
- `resultType="..."`: 指定主键的 Java 类型。
- `order="BEFORE|AFTER"`:
  - `BEFORE`: 在执行 `INSERT` 语句**之前**运行 `<selectKey>`。这适用于 Oracle Sequence，因为需要先从序列获取 ID，然后才能插入。
  - `AFTER`: 在执行 `INSERT` 语句**之后**运行 `<selectKey>`。这适用于某些需要后置查询才能获取 ID 的数据库。

**优点：**

- **通用性强：** 适用于任何数据库和任何主键生成策略。
- **灵活性高：** 可以执行复杂的 SQL 来生成主键。

**示例 (Oracle 使用 Sequence):**

假设 Oracle 中有一个名为 `USER_SEQ` 的序列。

**Mapper XML:**

```xml
<insert id="insertUser" parameterType="com.example.model.User">
    <!--
      order="BEFORE": 先执行 selectKey，再执行 insert。
      keyProperty="id": 将查询结果赋给 user 对象的 id 属性。
      resultType="java.lang.Integer": 序列返回的是数字。
    -->
    <selectKey keyProperty="id" resultType="java.lang.Integer" order="BEFORE">
        SELECT USER_SEQ.NEXTVAL FROM DUAL
    </selectKey>

    INSERT INTO users (id, username) VALUES (#{id}, #{username})
</insert>
```

**工作流程：** 当调用 `insertUser(user)` 时，MyBatis 会：

1.  先执行 `<selectKey>` 里的 SQL: `SELECT USER_SEQ.NEXTVAL FROM DUAL`，获取到一个新的序列值，比如 `1001`。
2.  将 `1001` 设置到 `user` 对象的 `id` 属性中。
3.  再执行 `INSERT` 语句，此时 `#{id}` 的值已经是 `1001` 了。
4.  方法返回后，`user` 对象自然就包含了新生成的主键。

### 总结与对比

| 特性           | `useGeneratedKeys`                       | `<selectKey>`                                                              |
| :------------- | :--------------------------------------- | :------------------------------------------------------------------------- |
| **适用场景**   | 支持主键自增的数据库 (MySQL, SQL Server) | 所有数据库，特别是使用序列 (Oracle) 或需要自定义主键生成逻辑 (UUID) 的场景 |
| **执行时机**   | 总是在 `INSERT` 之后通过 JDBC 获取       | 可通过 `order` 属性灵活配置在 `INSERT` 之前或之后                          |
| **配置复杂度** | **非常简单**，只需两个属性               | 相对复杂，需要编写额外的 `<selectKey>` 标签和 SQL                          |
| **推荐用法**   | **是 MySQL 等数据库的首选方案**          | **是 Oracle 等数据库的唯一方案**                                           |

在我的实践中，我会根据项目的数据库类型来选择最合适的方式：如果是 MySQL，我一定会用 `useGeneratedKeys`；如果是 Oracle，我就会用 `<selectKey>`。

---

## MyBatis 支持动态 SQL 吗？

**MyBatis 不仅支持动态 SQL，而且这正是它最强大、最核心、最受欢迎的功能之一。** 动态 SQL 的能力是 MyBatis 相比于原生 JDBC 最大的优势所在，它使得我们能够以一种非常优雅和可维护的方式，根据不同的运行时条件来动态地拼接和组合 SQL 语句。

在没有动态 SQL 的情况下，我们需要在 Java 代码中用大量的 `if-else` 和字符串拼接来构建 SQL，这会导致代码非常混乱、难以阅读且容易出错。MyBatis 通过在 XML 映射文件中提供一系列的标签，将这部分逻辑优雅地封装了起来。

以下是 MyBatis 中最核心的几个动态 SQL 标签：

### 1. `if` 标签

这是最基本、最常用的动态 SQL 标签。它类似于 Java 中的 `if` 语句，用于进行条件判断。如果 `test` 属性中的表达式值为 `true`，那么标签内的 SQL 片段就会被包含到最终的 SQL 语句中。

**场景：** 根据用户是否传入 `username` 来决定是否添加 `AND username = #{username}` 这个查询条件。

**示例：**

```xml
<select id="findActiveUsers" resultType="com.example.model.User">
    SELECT * FROM users WHERE status = 'ACTIVE'
    <if test="username != null and username != ''">
        AND username = #{username}
    </if>
</select>
```

### 2. `choose`, `when`, `otherwise` 标签

这组标签相当于 Java 中的 `switch` 语句或 `if-else if-else` 结构。它允许我们只选择其中一个分支来执行。MyBatis 会从上到下依次判断 `when` 标签的条件，一旦有一个满足，就会采用其内部的 SQL，并忽略所有其他的 `when` 和 `otherwise`。如果所有 `when` 都不满足，则会采用 `otherwise` 中的 SQL。

**场景：** 根据传入的查询类型（`searchType`）来决定是按用户名、邮箱还是电话号码进行查询。

**示例：**

```xml
<select id="findUserByCriteria" resultType="com.example.model.User">
    SELECT * FROM users
    <where>
        <choose>
            <when test="searchType == 'username'">
                username = #{keyword}
            </when>
            <when test="searchType == 'email'">
                email = #{keyword}
            </when>
            <otherwise>
                phone = #{keyword}
            </otherwise>
        </choose>
    </where>
</select>
```

### 3. `where`, `set`, `trim` 标签

这三个标签是用来解决动态 SQL 中常见的语法问题的，比如多余的 `AND`、`OR` 或者逗号。

- **`<where>` 标签：**
  它主要用于 `SELECT` 语句。它知道只有在标签内部有内容输出时，才会生成一个 `WHERE` 关键字。更重要的是，它会自动**去除**标签内 SQL 语句开头多余的 `AND` 或 `OR`。

- **`<set>` 标签：**
  它主要用于 `UPDATE` 语句。它会智能地在前面加上 `SET` 关键字，并**去除**标签内 SQL 语句末尾多余的逗号。

**示例（`where` 和 `set`）：**

````xml
<!-- where 标签示例 -->
<select id="findUsers" resultType="com.example.model.User">
    SELECT * FROM users
    <where>
        <if test="status != null">
            status = #{status}
        </if>
        <if test="username != null and username != ''">
            AND username LIKE #{username}
        </if>
    </where>
</select>
<!-- 如果两个 if 都满足, where 标签会自动处理掉第一个 AND -->

<!-- set 标签示例 -->
<update id="updateUser">
    UPDATE users
    <set>
        <if test="username != null and username != ''">
            username = #{username},
        </if>
        <if test="password != null and password != ''">
            password = #{password},
        </if>
    </set>
    WHERE id = #{id}
</update>
<!-- set 标签会自动处理掉最后一个 if 后面多余的逗号 -->

- **`<trim>` 标签：**
  这是一个更通用的标签，`<where>` 和 `<set>` 的功能都可以通过它来实现。它允许我们自定义前缀（`prefix`）、后缀（`suffix`），以及需要覆盖掉的前缀（`prefixOverrides`）和后缀（`suffixOverrides`）。

### 4. `foreach` 标签

这是一个非常强大的标签，用于对集合（List, Set, Array）或 Map 进行迭代。最常见的用途是在 `IN` 子句中动态地构建条件。

**场景：** 根据传入的用户 ID 列表查询所有匹配的用户。

**示例：**

```xml
<select id="findUsersByIds" resultType="com.example.model.User">
    SELECT * FROM users
    WHERE id IN
    <foreach item="userId" collection="list" open="(" separator="," close=")">
        #{userId}
    </foreach>
</select>
````

上面的代码会根据传入的 `list` 集合，生成类似 `WHERE id IN (1, 2, 3)` 这样的 SQL。

### 5. `<sql>` 与 `<include>` 标签

这两个标签用于提高 SQL 的可复用性。

- **`<sql>`**：用于定义一个可重用的 SQL 片段。
- **`<include>`**：用于在其他语句中引入 `<sql>` 定义的片段。

**场景：** 定义一个通用的列名列表，以便在多个查询中复用。

**示例：**

```xml
<sql id="base_column_list">
    id, username, password, status
</sql>

<select id="findUserById" resultType="com.example.model.User">
    SELECT <include refid="base_column_list" />
    FROM users
    WHERE id = #{id}
</select>

<select id="findAllUsers" resultType="com.example.model.User">
    SELECT <include refid="base_column_list" />
    FROM users
</select>
```

### 总结

MyBatis 的动态 SQL 功能是其设计的核心优势。它通过提供一套丰富的 XML 标签，将 SQL 的构建逻辑从 Java 代码中彻底解放出来，使得 SQL 映射文件更加专注于数据访问本身。这不仅极大地提高了开发的灵活性和效率，也使得 SQL 的维护变得前所未有的简单和清晰。

---

## MyBatis 如何执行批量操作？

**MyBatis 支持批量操作。** 两种主要的方式分别是：

1.  **使用 `<foreach>` 标签拼接一条大的 SQL 语句。**
2.  **使用 `ExecutorType.BATCH` 模式，利用 JDBC 的 `addBatch()` 和 `executeBatch()` 功能。**

这两种方式在原理、性能和使用场景上都有显著的区别。

### 方式一：使用 `<foreach>` 标签 (最常用)

这是最直观、最常用的方式。其核心思想是利用 `<foreach>` 标签遍历一个集合（如 `List`），动态地将多条数据拼接成一条 `INSERT` 语句。

**原理：** 生成一条包含多个 `VALUES` 子句的 `INSERT` 语句，例如 `INSERT INTO users (name, age) VALUES ('A', 1), ('B', 2), ('C', 3);`。数据库只需要解析和执行这一条 SQL 语句。

**优点：**

- **实现简单：** 只需要在 Mapper XML 中编写，业务代码调用时和单个插入没有区别。
- **兼容性好：** 适用于绝大多数数据库。

**缺点：**

- **受限于 SQL 长度：** 数据库对单条 SQL 语句的长度是有限制的（例如 MySQL 的 `max_allowed_packet` 参数）。当批量插入的数据量非常大时，可能会因为拼接出的 SQL 过长而执行失败。
- **并非真正的 JDBC Batch：** 本质上还是一次性向数据库发送一条超长的 SQL 字符串，而不是利用 JDBC 的批量处理通道。

**示例（批量插入）：**

**Mapper 接口:**

```java
public interface UserMapper {
    int batchInsertUsers(List<User> userList);
}
```

**Mapper XML:**

```xml
<insert id="batchInsertUsers">
    INSERT INTO users (username, password)
    VALUES
    <foreach collection="list" item="user" separator=",">
        (#{user.username}, #{user.password})
    </foreach>
</insert>
```

- `collection="list"`: 指定要遍历的集合。当参数是 `List` 类型时，默认就是 `list`。
- `item="user"`: 定义循环中每个元素的别名。
- `separator=","`: 指定每次循环生成的 SQL 片段之间用逗号 `,` 分隔。

**同样的方式也适用于批量删除 (`DELETE ... WHERE id IN (...)`)。**

---

### 方式二：使用 `ExecutorType.BATCH` (更高性能)

这是 MyBatis 官方推荐的、真正意义上的批量操作方式。它利用了 MyBatis 内置的 `BatchExecutor` 来调用 JDBC 的 `addBatch()` 和 `executeBatch()` 方法。

**原理：** 在一个 `SqlSession` 的生命周期内，程序循环调用 Mapper 的单条操作方法。MyBatis 不会立即执行每一条 SQL，而是将它们缓存起来。当调用 `sqlSession.commit()` 或 `sqlSession.flushStatements()` 时，MyBatis 会将缓存的多条 SQL 语句一次性地发送给数据库执行。这极大地减少了网络 I/O 的次数。

**优点：**

- **性能极高：** 对于海量数据，性能远超 `<foreach>` 方式。
- **没有 SQL 长度限制：** 因为发送的是多条独立的 SQL，而不是一条长 SQL。
- **更节省内存：** 可以配合 `sqlSession.clearCache()` 手动清理一级缓存，防止 OOM。

**缺点：**

- **需要手动管理 `SqlSession`：** 编码比 `<foreach>` 方式复杂，需要手动获取 `SqlSession` 并指定 `ExecutorType.BATCH`，并在循环中手动提交和关闭。
- **在 Spring 事务下使用需注意：** 在 Spring 声明式事务中，需要特殊配置才能获取到 `BATCH` 类型的 `SqlSession`。

**示例（批量插入）：**

**Mapper 接口 (与单条插入完全一样):**

```java
public interface UserMapper {
    // 注意：这里是单条插入的接口
    int insertUser(User user);
}
```

**Mapper XML (也是单条插入的 SQL):**

```xml
<insert id="insertUser">
    INSERT INTO users (username, password) VALUES (#{username}, #{password})
</insert>
```

**业务代码（关键在于此）：**

```java
// 1. 从 SqlSessionFactory 获取 SqlSession
SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);
try {
    // 2. 获取 Mapper 代理对象
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

    List<User> userList = ... // 准备好的用户列表
    int batchSize = 1000; // 每 1000 条提交一次

    for (int i = 0; i < userList.size(); i++) {
        userMapper.insertUser(userList.get(i));
        // 3. 达到批次大小，手动提交，清空缓存
        if ((i + 1) % batchSize == 0 || i == userList.size() - 1) {
            sqlSession.commit();
            sqlSession.clearCache(); // 清理缓存，防止 OOM
        }
    }
} finally {
    // 4. 关闭 SqlSession
    sqlSession.close();
}
```

---

### 总结与最佳实践

| 特性             | `<foreach>` 方式                           | `ExecutorType.BATCH` 方式                                  |
| :--------------- | :----------------------------------------- | :--------------------------------------------------------- |
| **原理**         | 拼接单条长 SQL                             | 调用 JDBC `addBatch()`, `executeBatch()`                   |
| **性能**         | 较好，优于单条循环                         | **极高**，海量数据下的不二之选                             |
| **SQL 长度限制** | **有**                                     | **无**                                                     |
| **实现复杂度**   | **简单**                                   | 相对复杂，需手动管理 `SqlSession`                          |
| **适用场景**     | 中小批量的操作（百、千级别），追求开发便捷 | **大批量、海量数据**的操作（万、十万级以上），追求极致性能 |

**我的实践建议：**

- 对于常规的、数据量可控的批量操作（例如一次性插入几百条数据），**优先使用 `<foreach>`**，因为它足够简单、直观，且性能也完全可以接受。
- 对于需要处理上万条甚至更多数据的场景，例如数据迁移、大数据量的定时任务等，**必须使用 `ExecutorType.BATCH`**，这才是专业、高性能的解决方案。

---

## 说说 Mybatis 的一级、二级缓存？

MyBatis 内置了两级缓存，分别是**一级缓存（Local Cache）**和**二级缓存（Global Cache）**。它们的设计目标都是为了减少对数据库的不必要访问，从而提升应用程序的性能。

下面将从它们的定义、作用范围、生命周期和使用场景等方面来详细阐述。

### 一、一级缓存 (Local Cache / SqlSession Level)

#### 1. 核心概念

一级缓存是 **`SqlSession` 级别**的缓存。它在 MyBatis 中是**默认开启**的，而且开发者无法关闭。它本质上是 `SqlSession` 对象内部的一个 `Map` 结构，用于存储查询结果。

#### 2. 作用范围与生命周期

- **范围：** 一级缓存的作用范围仅限于**同一个 `SqlSession` 内部**。不同的 `SqlSession` 之间的一级缓存是相互隔离、互不影响的。
- **生命周期：** 一级缓存的生命周期与 `SqlSession` 的生命周期完全绑定。当 `SqlSession` 被创建时，它的一级缓存就随之诞生；当 `SqlSession` 被关闭（`close()`）或提交（`commit()`）时，它的一级缓存就会被清空。

#### 3. 工作原理

当一个 `SqlSession` 执行一个 `SELECT` 查询时：

1.  MyBatis 会根据查询的 **Statement ID、SQL 语句、参数**等信息生成一个唯一的 `CacheKey`。
2.  MyBatis 会用这个 `CacheKey` 去一级缓存（那个内部的 `Map`）中查找结果。
3.  **如果命中缓存**，则直接从缓存中返回结果，不再查询数据库。
4.  **如果未命中缓存**，则会去查询数据库，并将查询到的结果存入一级缓存中（以 `CacheKey` 为键，查询结果为值），然后再将结果返回给调用者。

#### 4. 缓存失效（Invalidation）

在同一个 `SqlSession` 中，任何 `INSERT`、`UPDATE`、`DELETE` 操作都会导致该 `SqlSession` 的**所有**一级缓存被清空。这是为了确保缓存数据的准确性，防止读到脏数据。此外，手动调用 `sqlSession.clearCache()` 也可以清空一级缓存。

**总结：** 一级缓存是事务级别的缓存，它对于减少同一个请求或事务中重复的数据库查询非常有效，而且对开发者是透明的。在与 Spring 集成后，每个数据库事务都由一个新的 `SqlSession` 来处理，所以一级缓存的作用范围通常就是一个事务方法。

### 二、二级缓存 (Global Cache / Namespace Level)

#### 1. 核心概念

二级缓存是**应用程序级别**的缓存，更准确地说是 **Mapper Namespace 级别**的缓存。它允许多个不同的 `SqlSession` 共享同一份查询结果。

#### 2. 作用范围与生命周期

- **范围：** 二级缓存的作用范围是整个 Mapper Namespace。所有使用该 Mapper 的 `SqlSession` 都可以共享这份缓存。
- **生命周期：** 它的生命周期与应用程序的生命周期相同。当应用启动时，缓存被初始化；当应用停止时，缓存被销毁。

#### 3. 如何开启和使用

二级缓存默认是**关闭**的，需要手动开启：

1.  **全局开启：** 在 `mybatis-config.xml` 中添加设置：
    ```xml
    <settings>
        <setting name="cacheEnabled" value="true"/>
    </settings>
    ```
2.  **Mapper 级别开启：** 在需要开启二级缓存的 Mapper XML 文件中添加 `<cache/>` 标签。
    ```xml
    <mapper namespace="com.example.mapper.UserMapper">
        <cache/>
        <!-- ... other statements ... -->
    </mapper>
    ```
3.  **实体类序列化：** 存入二级缓存的 POJO 对象**必须实现 `java.io.Serializable` 接口**。这是因为二级缓存的实现可能会将对象序列化到磁盘或通过网络传输（例如使用 Redis 作为二级缓存）。

#### 4. 工作原理

1.  当一个 `SqlSession` 执行完查询并**被关闭（`close()`）或提交（`commit()`）**时，MyBatis 会检查该查询是否配置了使用二级缓存。
2.  如果配置了，MyBatis 会将该 `SqlSession` 一级缓存中的查询结果刷新（flush）到对应的 Mapper Namespace 的二级缓存中。
3.  当另一个**新的 `SqlSession`** 来执行同一个 Mapper Namespace 下的相同查询时，它会先检查二级缓存。
4.  **如果命中二级缓存**，则直接从二级缓存中获取数据，避免了数据库查询。

#### 5. 缓存失效（Invalidation）

与一级缓存一样，在**同一个 Mapper Namespace** 下执行的任何 `INSERT`、`UPDATE`、`DELETE` 操作都会清空该 Namespace 的二级缓存。

#### 6. 潜在风险：脏读问题

二级缓存最大的风险在于**跨 Namespace 的数据一致性问题**。
**场景：** 假设你有一个多表关联查询，比如查询用户及其订单。这个查询在 `UserMapper.xml` 中，因此它的结果会被缓存在 `UserMapper` 的二级缓存里。如果此时，你通过 `OrderMapper.xml` 中的一个方法修改了某个订单的状态，由于这个操作发生在 `OrderMapper` 的 Namespace 下，它**不会**触发 `UserMapper` 二级缓存的清空。这时，当你再次通过 `UserMapper` 查询那个用户及其订单时，就会从缓存中读到包含旧订单信息的“脏数据”。

### 总结与对比

| 特性           | 一级缓存 (Local Cache)      | 二级缓存 (Global Cache)      |
| :------------- | :-------------------------- | :--------------------------- |
| **作用范围**   | `SqlSession` 级别           | Mapper Namespace 级别        |
| **生命周期**   | 与 `SqlSession` 同生共死    | 与应用程序相同               |
| **默认状态**   | **默认开启**，无法关闭      | **默认关闭**，需手动配置     |
| **数据共享**   | 不共享，`SqlSession` 间隔离 | 可在多个 `SqlSession` 间共享 |
| **实体类要求** | 无特殊要求                  | 必须实现 `Serializable` 接口 |
| **主要风险**   | 基本无风险，是安全的        | **存在脏读风险**，需谨慎使用 |

### 最佳实践与建议

1.  **一级缓存**是 MyBatis 默认提供的一个很好的优化，我们基本不用关心它，正常使用即可。
2.  **谨慎使用二级缓存**。它更适用于**读多写少**的场景，比如系统配置、数据字典、权限列表等，这些数据一旦加载，很少发生变化。
3.  对于业务逻辑复杂、表关联多、数据更新频繁的场景，**不推荐使用二级缓存**，因为它带来的数据一致性维护成本和潜在风险，可能远大于性能上的收益。
4.  在现代的分布式系统和微服务架构中，我们更倾向于使用专业的**分布式缓存解决方案**，如 **Redis** 或 **Memcached**，来作为应用级的缓存。它们提供了更强大、更灵活、更可控的缓存管理能力，可以有效避免 MyBatis 二级缓存的局限性。

---

## 能说说 MyBatis 的工作原理吗？

MyBatis 的工作原理可以分为两个主要阶段：**初始化阶段** 和 **运行时阶段**。

### 第一阶段：初始化阶段 (加载和解析)

这个阶段在应用程序启动时发生，MyBatis 会加载并解析配置文件，为后续的数据库操作做好所有准备工作。这个过程的核心是构建一个全局唯一的 `SqlSessionFactory` 对象。

1.  **加载配置文件：** 程序通过 `SqlSessionFactoryBuilder` 加载主配置文件 (`mybatis-config.xml`) 和所有的 Mapper 映射文件 (`*.xml`)。

2.  **解析配置文件：**

    - `SqlSessionFactoryBuilder` 会创建一个 `XMLConfigBuilder` 来解析 `mybatis-config.xml`。它会读取 `<settings>`, `<typeAliases>`, `<plugins>`, `<environments>`, `<mappers>` 等全局配置。
    - 所有解析出来的信息，会被封装到一个核心的 `Configuration` 对象中。这个 `Configuration` 对象可以看作是 MyBatis 的“大脑”，包含了所有的配置信息。

3.  **解析 Mapper 文件：**

    - MyBatis 会遍历所有 Mapper 映射文件。
    - 对于每一个 `<select>`, `<insert>`, `<update>`, `<delete>` 等标签，MyBatis 都会解析成一个 `MappedStatement` 对象。
    - **`MappedStatement` 是一个至关重要的内部对象**，它封装了关于一条 SQL 语句的所有信息，包括：
      - SQL 语句本身。
      - Statement 的 ID（即 Mapper 接口的方法名）。
      - 参数的类型 (`parameterType`)。
      - 返回值的类型 (`resultType` 或 `resultMap`)。
      - SQL 的类型（SELECT, INSERT 等）。
      - 缓存配置等。
    - 所有解析好的 `MappedStatement` 都会被存储在 `Configuration` 对象的 `mappedStatements` 这个 Map 中，键是 Statement ID (如 `com.example.mapper.UserMapper.findUserById`)，值就是 `MappedStatement` 对象本身。

4.  **构建 SqlSessionFactory：** 当所有的配置和 Mapper 文件都解析完毕后，`SqlSessionFactoryBuilder` 会根据这个内容丰富的 `Configuration` 对象，创建一个 `DefaultSqlSessionFactory` 实例。至此，`SqlSessionFactoryBuilder` 的任务完成，初始化阶段结束。`SqlSessionFactory` 是一个线程安全的工厂，作为单例在应用中存在。

### 第二阶段：运行时阶段 (SQL 执行)

这个阶段是当应用程序的业务代码调用 Mapper 接口的方法时触发的。

1.  **获取 SqlSession：** 业务代码通过 `SqlSessionFactory.openSession()` 方法获取一个 `SqlSession` 实例。`SqlSession` 是 MyBatis 中执行数据库操作的核心接口，它不是线程安全的，因此必须在每个线程中独立使用。

2.  **获取 Mapper 代理对象：**

    - 我们通过 `sqlSession.getMapper(UserMapper.class)` 来获取 Mapper 接口的实例。
    - **这一步是 MyBatis 的核心魔法所在**。MyBatis 并不会为我们提供这个接口的实现类，而是利用 **JDK 动态代理 (Dynamic Proxy)**，为 `UserMapper` 接口动态地生成一个代理对象 (Proxy)。
    - 这个代理对象实现了 `MapperProxy` 这个调用处理器。

3.  **执行 Mapper 接口方法：**

    - 当我们调用代理对象的任何方法时（例如 `userMapper.findUserById(1)`），这个调用实际上会被 `MapperProxy` 的 `invoke` 方法拦截。
    - `MapperProxy` 会根据被调用的方法名 (`findUserById`) 和所在的类名 (`com.example.mapper.UserMapper`)，拼接成一个 Statement ID。
    - 然后，它会调用 `SqlSession` 的相应方法（如 `selectOne`），并将 Statement ID 和参数传递过去。

4.  **Executor 执行 SQL：**

    - `SqlSession` 自身并不直接执行 SQL，而是将任务委托给内部的一个 **`Executor` (执行器)**。`Executor` 是 MyBatis 调度的核心，负责缓存维护和 SQL 的真正执行。
    - `Executor` 首先会检查**一级缓存**。如果缓存命中，则直接返回结果。
    - 如果缓存未命中，`Executor` 会与 **四个核心组件** 协作来完成数据库操作：
      - **`StatementHandler`**: 负责创建数据库的 `Statement` 或 `PreparedStatement` 对象。
      - **`ParameterHandler`**: 负责处理 SQL 的参数。它会解析 `#{}` 占位符，并将用户的输入参数安全地设置到 `PreparedStatement` 中，有效防止 SQL 注入。
      - **`ResultSetHandler`**: 负责处理数据库返回的 `ResultSet` 结果集。它会将结果集中的数据，根据 `resultType` 或 `<resultMap>` 的配置，映射成 Java POJO 对象。
      - **`TypeHandler`**: 负责 Java 类型与 JDBC 类型之间的转换。例如，`ParameterHandler` 设置参数和 `ResultSetHandler` 映射结果时，都需要它来处理 `java.lang.String` 与 `JDBC.VARCHAR` 等类型的转换。

5.  **返回结果：** `ResultSetHandler` 将映射好的 Java 对象返回给 `Executor`，`Executor` 再将其存入一级缓存，并最终返回给调用者。

### 流程图总结

**业务代码** -> **调用 Mapper 代理对象** -> **`MapperProxy` 拦截** -> **调用 `SqlSession`** -> **委托给 `Executor`** -> **`Executor` 协调四大组件 (ParameterHandler, StatementHandler, ResultSetHandler, TypeHandler)** -> **与数据库交互** -> **`ResultSetHandler` 封装结果** -> **返回给业务代码**

这个完整、清晰的流程，加上动态 SQL、插件、缓存等强大功能，共同构成了 MyBatis 高效、灵活的工作体系。

---

## MyBatis 的功能架构是什么样的？

MyBatis 的功能架构设计得非常优雅，层次分明，体现了良好的“关注点分离”（Separation of Concerns）原则。

我们可以将 MyBatis 的功能架构自顶向下分为三个主要层次：**API 接口层**、**核心处理层** 和 **基础支撑层**。

### 1. API 接口层 (Interface Layer)

这是 MyBatis 直接暴露给外部开发者使用的层次。它的主要职责是提供简单、易用的接口，让开发者可以方便地与 MyBatis 框架进行交互，同时将内部复杂的实现细节完全屏蔽起来。

- **`SqlSession`**: 这是 MyBatis 最核心的 API 接口。它提供了执行数据库操作（`select`, `insert`, `update`, `delete`）、获取 Mapper 代理对象（`getMapper`）以及管理事务（`commit`, `rollback`, `close`）的所有方法。`SqlSession` 是开发者与 MyBatis 交互的**主要门户**。

- **`SqlSessionFactory`**: 这是一个工厂接口，专门用于创建 `SqlSession` 实例。它通常在应用启动时被创建，并以单例形式存在，是线程安全的。

- **`SqlSessionFactoryBuilder`**: 这是一个构建器，它的唯一作用就是通过解析 XML 配置文件或 Java 配置来创建一个 `SqlSessionFactory` 实例。一旦 `SqlSessionFactory` 创建完成，它的使命就结束了。

**调用流程：** `SqlSessionFactoryBuilder` -> `SqlSessionFactory` -> `SqlSession`

### 2. 核心处理层 (Core Processing Layer)

这是 MyBatis 的“心脏”，负责处理所有内部的核心逻辑。当接口层接收到开发者的请求后，会将其转发给核心处理层来完成大部分的实际工作。

- **`Configuration`**: 这是 MyBatis 中最重要的一个类，是整个框架的“超级大脑”和“配置中心”。它包含了从配置文件中解析出的所有信息，如：全局设置（Settings）、类型别名（Type Aliases）、所有的 `MappedStatement`、结果映射（ResultMaps）、缓存（Caches）、插件（Plugins）等。核心处理层的其他组件都需要围绕 `Configuration` 对象来获取所需信息。

- **`Executor` (执行器)**: 这是 MyBatis 的调度核心。`SqlSession` 的所有数据库操作请求都会被委派给一个 `Executor` 来执行。`Executor` 负责 SQL 的动态解析、语句的执行、一级缓存的管理以及事务的控制。它有不同的实现，如 `SimpleExecutor`（默认）、`ReuseExecutor`（重用 `Statement`）、`BatchExecutor`（执行批量操作）。

- **`MappedStatement`**: 这个对象封装了 Mapper XML 文件中一个 SQL 标签（如 `<select>`）的所有信息，包括 SQL 语句、参数类型、返回值类型、Statement ID 等。核心层的工作，本质上就是找到并执行对应的 `MappedStatement`。

- **动态 SQL 解析**: 这一部分负责解析 `<if>`, `<foreach>` 等动态 SQL 标签，根据传入的参数动态地生成最终可执行的 SQL 语句。

- **插件 (`Interceptor` 拦截器)**: 这是 MyBatis 提供的一个非常强大的扩展点。通过插件，开发者可以在核心组件（如 `Executor`, `StatementHandler`, `ParameterHandler`, `ResultSetHandler`）的关键方法执行前后插入自己的逻辑，从而实现对 MyBatis 行为的修改和增强，比如实现分页、数据脱敏等功能。

### 3. 基础支撑层 (Foundation Support Layer)

这一层为上面的核心处理层提供了各种基础的、可复用的技术支持和服务。它们是构成整个框架的基石。

- **事务管理 (`Transaction`)**: 提供了统一的事务管理接口，用于封装数据库连接的创建、提交和回滚等操作。MyBatis 提供了针对 JDBC 和 JTA（Java Transaction API）的实现。

- **数据源 (`DataSource`)**: 提供了标准的数据库连接池功能，负责创建和管理数据库连接。MyBatis 提供了 UNPOOLED、POOLED 和 JNDI 三种数据源实现。

- **四大核心处理器**:

  - **`StatementHandler`**: 封装了对 JDBC `Statement` 的操作，如创建 `Statement` 对象、设置超时时间等。
  - **`ParameterHandler`**: 负责将用户传入的参数安全地设置到 `PreparedStatement` 中。
  - **`ResultSetHandler`**: 负责将 JDBC 返回的 `ResultSet` 结果集，根据 `<resultMap>` 或 `resultType` 的配置，转换成 Java 对象。
  - **`TypeHandler`**: 负责在 Java 类型和 JDBC 类型之间进行转换。

- **对象绑定与反射 (`Binding` & `Reflection`)**:

  - `Binding` 模块负责将 Mapper 接口与 XML 映射文件动态地绑定起来，通过动态代理生成 Mapper 接口的实现类。
  - `Reflection` 模块提供了一套强大的反射工具类，使得 MyBatis 能够方便地操作 Java 对象的属性，极大地简化了结果集的映射过程。

- **缓存 (`Cache`)**: 提供了对一级缓存和二级缓存的支持，是 MyBatis 性能优化的重要组成部分。

### 架构总结

您可以将这三层想象成一个公司：

- **API 接口层**：是公司的“客服部”，直接面对客户（开发者），接收需求。
- **核心处理层**：是公司的“项目管理部”，负责调度和指挥，将客服的需求分解成具体的任务。
- **基础支撑层**：是公司的“技术专家团队”（如数据库专家、网络专家、安全专家），提供完成具体任务所需的专业技能和工具。

---

## 为什么 Mapper 接口不需要实现类？

答案的核心在于两个字：**代理 (Proxy)**。更具体地说，是 **MyBatis 利用了 Java 的动态代理（Dynamic Proxy）技术，在运行时为 Mapper 接口动态地创建了一个实现类。**

下面我将详细解释这个过程以及这种设计的巧妙之处。

### 详细的实现机制

我们从不写 Mapper 接口的实现类，但我们却能直接调用它的方法，这个“魔法”发生在 `sqlSession.getMapper(UserMapper.class)` 这一行代码执行的时候。

1.  **接口的定义：** 我们首先定义一个 `UserMapper` 接口，里面包含了我们需要的数据库操作方法，比如 `User findUserById(int id);`。这个接口本身只是一个契约，一个方法的集合。

2.  **XML 的映射：** 我们在 `UserMapper.xml` 文件中，为接口中的每个方法编写了对应的 SQL 语句。通过命名空间（namespace）将 XML 文件和 Mapper 接口关联起来，通过语句的 ID 将 SQL 标签和接口中的方法名关联起来。

3.  **获取 Mapper 实例：** 当我们调用 `sqlSession.getMapper(UserMapper.class)` 时，MyBatis 内部会执行以下操作：

    - 它并不会去扫描 classpath 寻找一个名为 `UserMapperImpl` 的类。
    - 相反，它会使用 **JDK 动态代理** 为 `UserMapper` 接口**动态地生成一个代理对象**。这个代理对象是在内存中即时创建的，我们看不到它的 `.java` 或 `.class` 文件。
    - 这个代理对象内部有一个非常重要的组件，叫做 `MapperProxy`，它是一个 `InvocationHandler`（调用处理器）。

4.  **调用接口方法：** 当我们拿到这个代理对象，并调用它的方法时，比如 `userMapper.findUserById(1)`，这个调用并不会执行我们写的任何代码，而是会被代理对象**拦截**。

5.  **`MapperProxy` 的工作：** 拦截到方法调用后，`MapperProxy` 会：
    - 解析出被调用的方法名（`findUserById`）和它所属的接口（`com.example.mapper.UserMapper`）。
    - 将接口名和方法名拼接成一个完整的 **Statement ID**，即 `com.example.mapper.UserMapper.findUserById`。
    - 这个 Statement ID 正是我们在 XML 文件中定义的 SQL 语句的唯一标识。
    - 然后，`MapperProxy` 会调用 `SqlSession` 内部的相应方法（如 `selectOne`、`selectList`、`insert` 等），并将这个 Statement ID 和传入的参数（`1`）传递过去。
    - 后续就进入了 MyBatis 的标准执行流程：`Executor` 去执行，`ParameterHandler` 设置参数，`ResultSetHandler` 处理结果等。

**简单来说，我们调用的 Mapper 接口方法，最终都被转换成了对 `SqlSession` 底层方法的调用。MyBatis 为我们生成的那个代理对象，就是一个“聪明的传话筒”，它知道要把我们对接口方法的调用，翻译成哪一句具体的 SQL 去执行。**

### 为什么这种设计如此优秀？

这种基于接口和动态代理的设计，是 MyBatis 框架优雅和成功的关键，它带来了诸多好处：

1.  **简化开发，解放开发者：** 最直接的好处就是我们不再需要编写大量冗余、模板化的 JDBC 实现代码。开发者只需要关注接口定义和 SQL 编写这两个核心任务，极大地提升了开发效率。

2.  **类型安全 (Type Safe)：** 我们是直接调用 Java 接口的方法，而不是像早期 iBatis 那样通过字符串 ID 去执行 SQL (`sqlSession.selectOne("findUserById", 1)`)。这意味着编译器可以帮助我们检查方法名是否正确、参数类型和数量是否匹配，大大减少了运行时错误。

3.  **更好的解耦：** 业务逻辑层完全依赖于 Mapper 接口，而不需要关心底层的实现细节。这种面向接口的编程，使得系统的层次结构更加清晰，可维护性和可测试性也更强。

4.  **清晰的职责分离：**
    - **Mapper 接口**：定义了数据访问的“能力”和“契约”。
    - **Mapper XML**：负责 SQL 语句的“实现”。
    - **MyBatis 框架**：负责将两者“粘合”起来。
      这种分离使得 SQL 的优化和业务代码的开发可以并行，互不干扰。

总结来说，**Mapper 接口之所以不需要实现类，是因为 MyBatis 框架在背后通过动态代理技术，为我们自动创建了一个代理实现。这个代理类充当了连接业务代码和底层 SQL 执行的桥梁，从而实现了既简化开发又保证类型安全的设计目标。**

---

## Mybatis 都有哪些 Executor 执行器？

MyBatis 中共有四种类型的 `Executor` 执行器，但它们可以分为两大类：**三种基础执行器** 和 **一种特殊的装饰器执行器**。

`Executor` 是 MyBatis 中所有数据库操作的最终执行者，它负责调度 `StatementHandler`、`ParameterHandler`、`ResultSetHandler` 等组件来完成对数据库的访问。

### 三种基础执行器

这三种执行器实现了 `Executor` 接口，它们的核心区别在于**如何管理和重用 `Statement` 对象**。

#### 1. `SimpleExecutor` (简单执行器)

- **核心思想：** 这是 MyBatis **默认**的执行器。它的策略非常简单直接：**每次执行 `select` 或 `update` 操作，都会创建一个新的 `PreparedStatement` 对象，用完之后立即关闭它。**

- **工作原理：**

  1.  接收到 SQL 执行请求。
  2.  通过数据库连接创建一个新的 `PreparedStatement`。
  3.  执行 SQL。
  4.  关闭 `PreparedStatement`。

- **特点：**
  - **优点：** 实现简单，绝对不会有 `Statement` 资源被长时间占用的问题，非常安全。
  - **缺点：** 每次都创建和销毁 `Statement` 对象会带来一定的性能开销，尤其是在需要频繁执行相同 SQL 的场景下。

#### 2. `ReuseExecutor` (可重用执行器)

- **核心思想：** 它的策略是**尽可能地重用 `PreparedStatement` 对象**。它会在内部维护一个 `Map`，键是 SQL 语句，值是 `PreparedStatement` 对象。

- **工作原理：**

  1.  接收到 SQL 执行请求。
  2.  以 SQL 语句为键，去内部的 `Map` 中查找 `PreparedStatement`。
  3.  **如果找到**，就直接使用这个已存在的 `PreparedStatement` 对象，只需清空参数并重新设置即可。
  4.  **如果没找到**，就创建一个新的 `PreparedStatement`，并将其存入 `Map` 中以备下次使用。
  5.  `Statement` 对象只有在事务提交、回滚或 `SqlSession` 关闭时才会被真正关闭。

- **特点：**
  - **优点：** 避免了频繁创建和销毁 `Statement` 对象的开销，对于在同一个 `SqlSession` 中需要多次执行相同 SQL 的场景，能显著提升性能。
  - **缺点：** `SqlSession` 的生命周期内会一直持有 `Statement` 对象的引用，可能会占用更多的数据库资源。

#### 3. `BatchExecutor` (批量执行器)

- **核心思想：** 这是专门用于**执行批量操作**的执行器。它不会立即执行每一条 `update` 语句（`insert`, `update`, `delete`），而是利用 JDBC 的 `addBatch()` 功能将它们缓存起来。

- **工作原理：**

  1.  接收到 `update` 请求时，它会调用 `PreparedStatement.addBatch()` 将这条 SQL 添加到批处理队列中。
  2.  SQL 语句并不会立即发送到数据库。
  3.  只有当 `SqlSession` 被提交（`commit`）、刷新（`flushStatements`）或关闭时，`BatchExecutor` 才会调用 `PreparedStatement.executeBatch()`，将缓存的所有 SQL 语句一次性地发送给数据库执行。

- **特点：**
  - **优点：** 性能极高。通过一次网络交互执行多条 SQL，极大地减少了数据库的通信开销，是进行海量数据插入、更新时的不二之选。
  - **缺点：** 在执行 `executeBatch()` 之前，你无法获取到每条语句的执行结果（比如自增主键），除非数据库驱动支持。

### 一种特殊的装饰器执行器

#### `CachingExecutor` (二级缓存执行器)

- **核心思想：** 它本身并不直接执行 SQL，而是一个**装饰器 (Decorator)**。它的唯一职责是**实现二级缓存**的功能。

- **工作原理：**

  - `CachingExecutor` 会**包装**一个基础执行器（如 `SimpleExecutor`）。
  - 当接收到 `select` 请求时，它会先检查与该 SQL 对应的**二级缓存**是否存在。
  - **如果命中缓存**，它会直接将缓存结果返回，**不会**再将请求传递给被它包装的那个基础执行器，从而避免了数据库查询。
  - **如果未命中缓存**，它会将请求**委托（delegate）**给被包装的基础执行器去执行查询。
  - 当基础执行器返回结果后，`CachingExecutor` 会先将这个结果放入二级缓存中，然后再返回给调用者。

- **特点：**
  - 它不是一个独立的执行器，而是像一个“插件”或“切面”，为基础执行器增加了二级缓存的能力。
  - 只有在全局配置和 Mapper 中都开启了二级缓存 (`<cache/>`) 时，MyBatis 才会使用 `CachingExecutor` 来包装默认的执行器。

### 如何配置和选择？

1.  **全局配置：**
    可以在 `mybatis-config.xml` 中设置默认的执行器类型：

    ```xml
    <settings>
        <!-- 可选值为 SIMPLE, REUSE, BATCH -->
        <setting name="defaultExecutorType" value="SIMPLE"/>
    </settings>
    ```

2.  **代码中指定：**
    在需要时，可以手动创建指定类型的 `SqlSession`，这种方式最常用于批量操作：
    ```java
    // 手动开启一个使用 BATCH 执行器的 SqlSession
    try (SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH)) {
        // ... 执行批量操作 ...
    }
    ```

### 总结

| 执行器                | 核心特点               | 适用场景                              |
| :-------------------- | :--------------------- | :------------------------------------ |
| **`SimpleExecutor`**  | 每次都创建新 Statement | **默认选项**，适用于绝大多数常规操作  |
| **`ReuseExecutor`**   | 重用 Statement         | 同一个会话中，频繁执行相同 SQL 的场景 |
| **`BatchExecutor`**   | 批量执行 SQL           | **海量数据**的插入、更新或删除        |
| **`CachingExecutor`** | 实现二级缓存（装饰器） | 当开启二级缓存时自动启用              |

---

## 说说 Mybatis 插件的运行原理，如何编写一个插件？

### 第一部分：插件的运行原理

MyBatis 插件的运行原理，核心就是**拦截器链**和**动态代理**。

**1. 拦截目标 (The Four Interceptible Points)**

MyBatis 并非允许我们拦截任意内部对象的方法。出于对稳定性和性能的考虑，它只开放了四个**最核心、最关键**的接口作为可拦截的目标。它们分别是：

- **`Executor` (执行器)**: 负责执行 SQL 语句，是 MyBatis 的调度核心。可以拦截它的 `update`, `query`, `commit` 等方法。
  - **应用场景**：性能监控、缓存处理、读写分离等。
- **`StatementHandler` (语句处理器)**: 负责在数据库中执行 SQL，封装了对 `Statement` 的操作。可以拦截它的 `prepare`, `parameterize`, `query` 等方法。
  - **应用场景**：**SQL 重写**（如物理分页）、日志记录。
- **`ParameterHandler` (参数处理器)**: 负责将用户传入的参数设置到 `PreparedStatement` 中。可以拦截它的 `setParameters` 方法。
  - **应用场景**：参数的加密、自定义类型处理等。
- **`ResultSetHandler` (结果集处理器)**: 负责将数据库返回的 `ResultSet` 转换为 Java 对象。可以拦截它的 `handleResultSets` 方法。
  - **应用场景**：结果的解密、数据脱敏、自定义对象映射等。

**2. 核心机制：动态代理 (Dynamic Proxy)**

当 MyBatis 启动并加载配置时，如果发现配置了插件（Interceptor），它并不会直接使用原生的核心对象（如 `SimpleExecutor`），而是会执行以下操作：

1.  MyBatis 会遍历所有配置的插件。
2.  对于每一个需要被拦截的核心对象（如 `Executor`），MyBatis 会调用插件的 `plugin(target)` 方法。
3.  `plugin(target)` 方法内部会使用 JDK 动态代理，为这个目标对象（`target`）**创建一个代理对象**。
4.  如果配置了多个插件，它们会形成一个**责任链（Chain of Responsibility）**模式。后一个插件会为前一个插件生成的代理对象再创建一个代理，形成一个层层嵌套的**代理链**。
5.  最终，MyBatis 使用的是这个被层层代理之后的对象。

**3. 调用流程**

当应用程序调用一个被拦截的方法时（例如 `executor.query(...)`）：

1.  调用请求首先会打到最外层的代理对象上。
2.  代理对象会执行插件中 `intercept(Invocation invocation)` 方法的逻辑。
3.  在 `intercept` 方法中，开发者可以选择：
    - 在原始方法执行前，进行一些预处理。
    - 调用 `invocation.proceed()` 来**放行**，将调用传递给链上的下一个拦截器，或者最终传递给原始的目标对象。
    - 在原始方法执行后，对返回结果进行加工处理。
4.  就这样，一个调用请求会依次穿过所有插件的 `intercept` 方法，最终到达原始对象，然后结果再反向穿过所有插件返回。

### 第二部分：如何编写一个插件

编写一个自定义插件，通常需要遵循以下三个步骤：

**Step 1: 创建插件类并实现 `Interceptor` 接口**

`Interceptor` 接口定义了三个必须实现的方法：

```java
public interface Interceptor {
    // 核心拦截逻辑
    Object intercept(Invocation invocation) throws Throwable;

    // 为目标对象生成代理
    Object plugin(Object target);

    // 设置插件属性
    void setProperties(Properties properties);
}
```

**Step 2: 使用注解声明拦截签名**

我们需要使用 `@Intercepts` 和 `@Signature` 注解来告诉 MyBatis，我们的这个插件到底要拦截哪个对象的哪个方法。

- `@Intercepts`: 标记这是一个拦截器。
- `@Signature`: 定义一个具体的拦截点，它有三个属性：
  - `type`: 要拦截的接口类型（如 `Executor.class`）。
  - `method`: 要拦截的方法名（如 `"query"`）。
  - `args`: 要拦截的方法的参数类型数组，用于精确定位重载的方法。

**Step 3: 在 `mybatis-config.xml` 中注册插件**

**示例：编写一个简单的 SQL 执行耗时监控插件**

```java
import org.apache.ibatis.executor.Executor;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.plugin.*;
import org.apache.ibatis.session.ResultHandler;
import org.apache.ibatis.session.RowBounds;

import java.util.Properties;

// 1. 使用注解声明拦截点
@Intercepts({
    @Signature(
        type = Executor.class,
        method = "query",
        args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}
    )
})
public class ExecutionTimeInterceptor implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        long startTime = System.currentTimeMillis();
        try {
            // 2. 调用 invocation.proceed() 执行原始方法
            return invocation.proceed();
        } finally {
            long endTime = System.currentTimeMillis();
            long executionTime = endTime - startTime;

            // 获取 MappedStatement 对象，从而拿到 SQL 的 ID
            MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[0];
            String sqlId = mappedStatement.getId();

            System.out.println("[MyBatis-Plugin] SQL ID [" + sqlId + "] executed in " + executionTime + "ms.");
        }
    }

    @Override
    public Object plugin(Object target) {
        // 3. 使用 MyBatis 提供的 Plugin.wrap 工具类来生成代理对象
        return Plugin.wrap(target, this);
    }

    @Override
    public void setProperties(Properties properties) {
        // 4. 可以在此接收配置文件中传入的属性
        System.out.println("Plugin properties: " + properties);
    }
}
```

**在 `mybatis-config.xml` 中注册：**

```xml
<plugins>
    <plugin interceptor="com.example.plugin.ExecutionTimeInterceptor">
        <property name="someProperty" value="someValue"/>
    </plugin>
</plugins>
```

通过以上步骤，我们就完成了一个功能完备的 MyBatis 插件。这个机制非常强大，像 PageHelper、Mybatis-Plus 的许多高级功能，都是基于插件机制来实现的。

---

## MyBatis 是如何进行分页的？分页插件的原理是什么？

首先，我要澄清一个常见的误解：**MyBatis 框架本身并不直接提供一个“开箱即用”的物理分页功能。** 它提供的分页能力，可以分为两种截然不同的方式：**逻辑分页** 和 **物理分页**。而我们通常所说的、在生产环境中使用的分页，都是指**物理分页**，这通常需要借助**分页插件**来实现。

### 一、MyBatis 的两种分页方式

#### 1. 逻辑分页 (RowBounds) - 内存分页

这是 MyBatis **原生支持**的一种方式，通过 `RowBounds` 对象来实现。

- **工作原理：** MyBatis 会使用我们编写的原始 SQL（**不带任何分页关键字**）去数据库中查询出**所有**符合条件的数据，然后将这些数据加载到 JVM 内存中。最后，再通过 `RowBounds` 对象中指定的 `offset` (偏移量) 和 `limit` (数量) 参数，在内存中对结果集进行切割，只返回我们需要的那一页数据。

- **如何使用：**

  ```java
  // 在业务代码中
  int offset = 10; // 从第11条记录开始
  int limit = 5;   // 取5条
  RowBounds rowBounds = new RowBounds(offset, limit);
  // 调用 Mapper 方法时，将 RowBounds 作为参数传入
  List<User> userList = sqlSession.selectList("com.example.mapper.UserMapper.findAllUsers", null, rowBounds);
  ```

- **缺点（致命的）：**
  - **性能极差，极易导致 OOM (Out Of Memory)：** 如果查询结果有几百万条，这种方式会试图将这几百万条数据全部加载到内存中，这会瞬间耗尽应用内存，导致系统崩溃。
  - **因此，`RowBounds` 的逻辑分页方式，在生产环境中是绝对禁止使用的！** 它只适用于数据量极小、可预见的场景。

#### 2. 物理分页 - SQL 层面分页 (推荐)

这是**正确且唯一推荐**的分页方式。

- **工作原理：** 不再查询所有数据，而是在执行 SQL 时，就直接带上数据库支持的分页关键字（如 MySQL 的 `LIMIT`，Oracle 的 `ROWNUM`），只从数据库中查询出我们需要的那一页数据。这样数据库返回给应用的数据量就非常小，性能极高。

- **如何实现（手动方式）：**
  我们可以在 Mapper XML 中手动编写带分页参数的 SQL。
  ```xml
  <select id="findUsersByPage" resultType="com.example.model.User">
      SELECT * FROM users
      LIMIT #{offset}, #{pageSize}
  </select>
  ```
  **缺点：** 这种方式不通用。如果更换数据库（比如从 MySQL 迁移到 Oracle），所有的分页 SQL 都需要重写。而且，每个需要分页的查询都要重复写分页逻辑，非常繁琐。

### 二、分页插件的原理

为了解决手动实现物理分页的痛点，社区中诞生了许多优秀的分页插件（最著名的如 **PageHelper**）。这些插件的原理都是一致的，即**利用 MyBatis 的插件（Interceptor）机制，在运行时动态地对原始 SQL 进行拦截和改写**。

分页插件的原理可以概括为以下几个核心步骤：

1.  **设置分页参数：**
    在执行真正的数据库查询之前，开发者通过静态方法调用，将分页信息（如 `pageNum`, `pageSize`）保存到一个线程安全的 `ThreadLocal` 变量中。

    ```java
    // 典型的 PageHelper 用法
    PageHelper.startPage(1, 10); // 第1页，每页10条
    // 紧跟其后的第一条 MyBatis 查询会自动被分页
    List<User> userList = userMapper.findAll();
    ```

2.  **拦截 SQL 执行：**
    插件作为一个 MyBatis 的**拦截器 (`Interceptor`)**，会注册并拦截 `Executor` 的 `query` 方法或 `StatementHandler` 的 `prepare` 方法。这是 MyBatis 执行 SQL 的必经之路。

3.  **判断是否需要分页：**
    在 `intercept` 方法中，插件会首先检查当前 `ThreadLocal` 中是否存在分页参数。

    - 如果不存在，说明这个查询不需要分页，插件直接调用 `invocation.proceed()` 放行，不做任何处理。
    - 如果存在，说明需要进行分页处理，插件开始执行核心逻辑。

4.  **SQL 改写与执行：**

    - **获取原始 SQL：** 插件从 `Invocation` 对象中获取到即将要执行的原始 SQL 语句。
    - **拼接分页 SQL：** 插件会根据当前数据库的方言（在插件配置时指定，如 `mysql`, `oracle`），将分页关键字和参数动态地拼接到原始 SQL 的末尾，生成一个**物理分页 SQL**（例如，`SELECT * FROM users` -> `SELECT * FROM users LIMIT 0, 10`）。
    - **替换原始 SQL：** 插件利用**反射**机制，将 `BoundSql` 对象中存储的原始 SQL 字符串，替换为刚刚拼接好的分页 SQL。
    - **执行分页查询：** 调用 `invocation.proceed()`，此时 MyBatis 真正执行的是被插件改写后的分页 SQL。

5.  **执行 Count 查询（可选但重要）：**
    一个优秀的分页插件，不仅要查出分页数据，还要查出**总记录数**。插件会在执行分页查询之前，对原始 SQL 进行解析，生成一条 `SELECT COUNT(*)` 的查询语句，并执行它，从而得到总记录数。这个结果会被保存起来。

6.  **封装分页结果：**
    插件会将查询到的分页数据列表、总记录数、页码、总页数等信息，封装到一个自定义的 `Page` 对象中（例如 PageHelper 的 `PageInfo`），并最终返回给调用者。

7.  **清理 ThreadLocal：**
    在 `finally` 块中，插件必须清空 `ThreadLocal` 中的分页参数，以防止内存泄漏，并避免对后续的其他查询产生影响。

### 总结

| 分页方式                 | 原理                                                     | 优点                                       | 缺点                   | 适用场景                   |
| :----------------------- | :------------------------------------------------------- | :----------------------------------------- | :--------------------- | :------------------------- |
| **逻辑分页 (RowBounds)** | 查出全部数据，在**内存**中分页                           | 实现简单，MyBatis 原生支持                 | **性能灾难，极易 OOM** | **禁止在生产环境使用**     |
| **物理分页 (插件)**      | 利用**拦截器**动态**改写 SQL**，在**数据库**层面完成分页 | **性能高**，对业务代码**无侵入**，通用性强 | 需引入第三方插件并配置 | **所有生产环境的分页场景** |

因此，当被问及 MyBatis 如何分页时，最专业、最完整的回答应该是：**通过引入分页插件（如 PageHelper），利用其基于 `Interceptor` 实现的物理分页功能。其原理是在运行时拦截并动态改写 SQL，将普通查询变为带有数据库分页关键字的查询，从而实现真正高效、安全的分页。**

---

## 说说 JDBC 的执行步骤？

这是一个非常基础但又极其重要的问题，它是理解所有 Java 持久化框架（包括 MyBatis）工作基础的关键。任何持久化框架，无论封装得多么高级，其底层都离不开对 JDBC API 的调用。

使用原生 JDBC 操作数据库，其步骤是固定且严谨的。主要可以分为以下六个核心步骤：

### 1. 加载数据库驱动 (Load the Driver)

这是与数据库建立通信的第一步。我们需要告诉 JVM 我们要使用哪个数据库的驱动程序。

- **传统方式 (JDBC 4.0 之前):**

  ```java
  Class.forName("com.mysql.cj.jdbc.Driver");
  ```

  这行代码使用 Java 的反射机制，将指定驱动类的 `.class` 文件加载到 JVM 内存中。在这个驱动类的静态代码块中，它会调用 `DriverManager.registerDriver()` 方法将自己注册到 `DriverManager` 中。

- **现代方式 (JDBC 4.0 及以后):**
  这一步通常是**可选的、自动的**。现代的 JDBC 驱动都遵循 SPI (Service Provider Interface) 规范。驱动的 JAR 包中会包含一个 `META-INF/services/java.sql.Driver` 文件，`DriverManager` 会自动扫描 classpath，找到这个文件并加载其中指定的驱动类，从而无需我们手动 `Class.forName()`。

### 2. 建立数据库连接 (Establish the Connection)

驱动加载后，我们就可以通过 `DriverManager` 来获取一个到数据库的物理连接。

```java
String url = "jdbc:mysql://localhost:3306/mydatabase?useSSL=false&serverTimezone=UTC";
String user = "root";
String password = "your_password";

Connection connection = DriverManager.getConnection(url, user, password);
```

- `Connection` 对象代表了一个与数据库的会话，它是一个非常**昂贵**的资源。所有的数据库操作都将在这个连接上进行。
- URL 的格式是固定的：`jdbc:<subprotocol>:<subname>`，其中 `subprotocol` 是数据库产品的名称（如 `mysql`），`subname` 是数据库的地址、端口和库名等信息。

### 3. 创建执行 SQL 的对象 (Create a Statement Object)

`Connection` 本身不能直接执行 SQL，它需要创建一个 `Statement` 类型的对象来作为 SQL 语句的载体和执行者。主要有三种类型：

- **`Statement`**: 用于执行简单的、静态的 SQL 语句。它容易引发 **SQL 注入**风险。
  ```java
  Statement statement = connection.createStatement();
  ```
- **`PreparedStatement` (推荐)**: 它是 `Statement` 的子接口，用于执行预编译的、可以带参数（`?` 占位符）的 SQL 语句。它是**防止 SQL 注入**的最佳手段，并且由于预编译的特性，在多次执行相同结构的 SQL 时性能更好。
  ```java
  String sql = "SELECT * FROM users WHERE id = ?";
  PreparedStatement preparedStatement = connection.prepareStatement(sql);
  preparedStatement.setInt(1, 123); // 设置参数
  ```
- **`CallableStatement`**: `PreparedStatement` 的子接口，专门用于执行数据库的**存储过程**。

### 4. 执行 SQL 语句 (Execute the SQL)

通过上一步创建的 `Statement` 对象，我们可以执行 SQL 了。主要有三个执行方法：

- **`ResultSet executeQuery(String sql)`**: 专门用于执行 `SELECT` 查询语句。它会返回一个 `ResultSet` 对象，其中包含了查询的结果集。
- **`int executeUpdate(String sql)`**: 用于执行 `INSERT`, `UPDATE`, `DELETE` 等数据操作语句（DML），以及 `CREATE TABLE` 等数据定义语句（DDL）。它返回一个 `int` 值，表示受影响的行数。
- **`boolean execute(String sql)`**: 一个通用的执行方法，可以执行任何类型的 SQL。

### 5. 处理结果集 (Process the ResultSet)

如果执行的是 `executeQuery`，我们就会得到一个 `ResultSet` 对象。我们需要遍历这个结果集来获取查询到的数据。

```java
ResultSet resultSet = preparedStatement.executeQuery();

// 使用 while 循环遍历结果集
while (resultSet.next()) {
    // .next() 将光标移动到下一行，如果有下一行则返回 true

    // 通过列名或列索引获取数据
    int id = resultSet.getInt("id");
    String name = resultSet.getString("username");

    System.out.println("ID: " + id + ", Username: " + name);
}
```

`ResultSet` 就像一个指向数据库查询结果表格的指针，初始时它指向第一行之前。

### 6. 关闭资源 (Close the Resources)

这是 JDBC 编程中**最关键、也最容易出错**的一步。数据库连接和 `Statement` 等都是非常宝贵的系统资源，使用完毕后**必须显式关闭**，否则会导致严重的资源泄漏，最终拖垮整个应用。

- **关闭顺序：** 必须遵循“**后开先关**”的原则，即按照与创建时相反的顺序进行关闭：`ResultSet` -> `Statement` -> `Connection`。
- **关闭位置：** 关闭操作必须放在 `finally` 块中，以确保无论 `try` 块中是否发生异常，资源都能被释放。

**传统 `finally` 写法：**

```java
finally {
    try {
        if (resultSet != null) resultSet.close();
    } catch (SQLException e) { e.printStackTrace(); }
    try {
        if (preparedStatement != null) preparedStatement.close();
    } catch (SQLException e) { e.printStackTrace(); }
    try {
        if (connection != null) connection.close();
    } catch (SQLException e) { e.printStackTrace(); }
}
```

**现代 `try-with-resources` 写法 (Java 7+，强烈推荐):**
这种语法更加简洁和安全，编译器会自动为我们生成 `finally` 块和关闭逻辑。

```java
try (Connection connection = DriverManager.getConnection(url, user, password);
     PreparedStatement preparedStatement = connection.prepareStatement(sql)) {

    // ... 设置参数和执行查询 ...

    try (ResultSet resultSet = preparedStatement.executeQuery()) {
        // ... 处理结果集 ...
    }
} catch (SQLException e) {
    e.printStackTrace();
}
// connection, preparedStatement, resultSet 会在这里被自动关闭
```

**总结一下**，JDBC 的六个步骤：**加载驱动、建立连接、创建语句、执行 SQL、处理结果、关闭资源**，每一步都必不可少。而像 MyBatis 这样的框架，其核心价值之一就是将这些繁琐、重复且易错的步骤（特别是 3-6 步）进行了完美的封装，让开发者可以更专注于业务逻辑和 SQL 本身。

---

## Statement 与 PreparedStatement 的区别？

`Statement` 和 `PreparedStatement` 都是 Java 中用于执行 SQL 语句的接口，但它们在**执行机制、性能、安全性以及代码可读性**方面存在着显著的差异。总体来说，`PreparedStatement` 在大多数情况下是更优的选择。

下面将从几个核心维度来详细阐述它们的区别：

### 1. **执行与效率**

- **Statement**: 每次执行 SQL 查询时，`Statement` 都会将完整的 SQL 语句（包括查询条件）发送到数据库。数据库管理系统（DBMS）需要对这条新的 SQL 语句进行完整的解析、编译和执行。如果多次执行结构相同但条件不同的 SQL，这个过程会重复进行，效率较低。
- **PreparedStatement**: `PreparedStatement` 采用了预编译的机制。它会先将 SQL 语句的模板（包含 `?` 占位符）发送给数据库进行预编译和缓存。当执行时，只需要将参数（`?` 的值）传递给数据库。对于需要多次执行的同一条 SQL 语句，`PreparedStatement` 只需编译一次，之后每次执行都直接使用编译好的版本，只需替换参数即可，从而大大提升了执行效率。

### 2. **安全性**

- **Statement**: 使用 `Statement` 时，我们通常需要通过字符串拼接的方式将变量值嵌入到 SQL 语句中。如果不对用户的输入进行严格的过滤和转义，这种方式极易引发**SQL 注入攻击**。攻击者可以通过构造恶意的输入，改变原有 SQL 的语义，从而执行未经授权的数据库操作，比如窃取数据或删除表格。
- **PreparedStatement**: 这是 `PreparedStatement` 最突出的优势之一。它通过使用参数化查询（即 `?` 占位符）来设置参数，而不是通过字符串拼接。JDBC 驱动程序会负责对传入的参数进行正确的类型转换和转义，从根本上杜绝了 SQL 注入攻击的风险。 传递给 `PreparedStatement` 的参数被视为纯粹的数据，而不是可执行的 SQL 命令的一部分。

### 3. **代码可读性与可维护性**

- **Statement**: 字符串拼接的方式会使 SQL 语句变得混乱，特别是当参数很多或者包含复杂的字符串时，代码会显得冗长且难以阅读和维护。
- **PreparedStatement**: 使用占位符 `?` 的方式使得 SQL 语句的结构非常清晰，SQL 逻辑与参数值分离，代码更加整洁、易于理解和维护。

### 4. **功能与使用**

- `PreparedStatement` 提供了 `setObject()`、`setString()`、`setInt()` 等一系列 `set` 方法来设置不同类型的参数，功能更强大，类型处理也更安全。
- `Statement` 通常只适用于执行完全静态、无参数的 SQL 语句，或者只执行一次的简单动态查询。

### **总结**

| 特性           | Statement              | PreparedStatement            |
| -------------- | ---------------------- | ---------------------------- |
| **编译机制**   | 每次执行时编译         | 预编译，一次编译，多次执行   |
| **执行效率**   | 较低，尤其在循环执行时 | 更高，重用执行计划           |
| **安全性**     | 存在 SQL 注入风险      | **有效防止 SQL 注入**        |
| **代码可读性** | 较差，SQL 与参数混杂   | 优秀，SQL 模板与参数分离     |
| **适用场景**   | 执行一次性的静态 SQL   | 频繁执行的、带参数的动态 SQL |

综上所述，除非是执行一次性的、不包含任何用户输入的静态 SQL 语句，否则在任何情况下都应该优先考虑使用 `PreparedStatement`。这不仅是为了性能，更是为了保证应用程序的安全性，这在企业级开发中是至关重要的。

---

## 什么是 SQL 注入？如何防止 SQL 注入？

### **什么是 SQL 注入 (SQL Injection)？**

SQL 注入（SQLi）是一种常见的网络攻击手段，属于**代码注入**的一种。它发生在应用程序从用户那里获取输入，并 **以不安全的方式（通常是字符串拼接）** 将这些输入合并到 SQL 查询中时。

攻击者可以利用这个漏洞，在输入字段中插入恶意的 SQL 代码片段。当这些代码被后端的数据库执行时，它们会改变原始 SQL 查询的语义，从而让攻击者能够：

- **绕过身份验证**：例如，无需密码即可登录系统。
- **窃取数据**：获取数据库中所有的数据，包括用户信息、信用卡号等敏感信息。
- **篡改数据**：修改或删除数据库中的记录。
- **甚至控制服务器**：在某些数据库系统中，高级的 SQL 注入攻击可能允许执行操作系统命令，从而完全控制底层服务器。

#### **一个经典的例子**

让我们来看一个用户登录验证的场景。假设后台有一段验证用户身份的 SQL 查询，它是这样通过字符串拼接生成的：

```java
// 这是极其不安全的反面教材
String userName = request.getParameter("user");
String password = request.getParameter("pass");

String sql = "SELECT * FROM users WHERE username = '" + userName + "' AND password = '" + password + "'";

// 然后执行这条SQL...
```

- **正常情况**：用户输入用户名为 `admin`，密码为 `admin123`。
  拼接后的 SQL 为：
  `SELECT * FROM users WHERE username = 'admin' AND password = 'admin123'`
  这看起来没有问题。

- **攻击发生时**：一个攻击者在用户名输入框中输入了 `' OR '1'='1`，密码框随便输入。
  拼接后的 SQL 就变成了：
  `SELECT * FROM users WHERE username = '' OR '1'='1' AND password = 'somepassword'`

  在 SQL 中，`'1'='1'` 永远为真（TRUE）。由于 `OR` 的存在，`WHERE` 子句的条件 (`username = '' OR '1'='1'`) 整体就变成了真，无论密码是什么。这条 SQL 语句会查询出 `users` 表中的所有用户，程序逻辑如果判断查询到了结果就算登录成功，那么攻击者就成功绕过了密码验证，以第一个用户的身份（通常是管理员）登录了系统。

### **如何防止 SQL 注入？**

防止 SQL 注入需要采取多层次的防御策略，但最核心、最有效的方法是在代码层面进行处理。以下是几种关键的防御手段，按照重要性排序：

#### **1. 使用预编译语句 (PreparedStatement) - 首选方案**

这是防止 SQL 注入**最根本、最有效**的方法，也是我们在上一个问题中详细讨论过的。

- **原理**：`PreparedStatement` 将 SQL 查询的结构和数据分离开来。查询模板（包含 `?` 占位符）首先被发送到数据库进行预编译。之后，用户输入的数据作为参数被独立发送。数据库会将这些参数视为纯粹的数据值，而不是可执行的 SQL 命令的一部分。
- **示例**：

  ```java
  // 这是安全的写法
  String sql = "SELECT * FROM users WHERE username = ? AND password = ?";
  PreparedStatement pstmt = connection.prepareStatement(sql);
  pstmt.setString(1, userName); // 第1个问号是用户名
  pstmt.setString(2, password); // 第2个问号是密码
  ResultSet rs = pstmt.executeQuery();
  ```

  在这种方式下，即便攻击者输入 `' OR '1'='1'`，数据库也只会把它当成一个普通的字符串去寻找一个用户名叫 `' OR '1'='1'` 的用户，而不会执行它。

#### **2. 输入验证**

永远不要相信用户的任何输入。

- **白名单验证**：对于输入内容，应采用白名单的方式进行严格的格式验证。例如，如果一个字段只应包含数字，就应验证它是否为纯数字。如果一个字段是邮箱，就用正则表达式验证其格式。这可以过滤掉大量不合规的、可能是恶意的输入。
- **黑名单验证**：过滤掉已知的危险字符（如 `'`, `;`, `--` 等），但这通常被认为是不够可靠的，因为攻击者总能找到新的方式绕过黑名单。**白名单远比黑名单安全。**

#### **3. 转义用户输入**

如果由于某些历史原因或框架限制，无法使用预编译语句，那么下一个选择就是对所有传入 SQL 查询的用户输入进行转义。这意味着在可能引起问题的特殊字符（如单引号 `'`）前添加转义符（如 `\`）。许多数据库的 API 库都提供了执行此操作的函数。但这非常容易出错，一旦有所遗漏，就会产生漏洞。**它只应作为备用方案。**

#### **4. 使用存储过程**

将 SQL 逻辑封装在数据库的存储过程中，应用程序只调用存储过程并传递参数。只要存储过程内部没有使用不安全的动态 SQL 拼接，它就能像 `PreparedStatement` 一样有效防止 SQL 注入。

#### **5. 最小权限原则**

为应用程序连接数据库的账户授予**最小必需的权限**。例如，一个只负责查询和展示数据的 Web 应用，其数据库账户就不应该有 `UPDATE`, `DELETE`, `DROP` 等权限。这样即使 SQL 注入攻击成功，攻击者能够造成的损害也会被大大限制。

#### **6. 使用 ORM 框架**

像 Hibernate、MyBatis 等现代对象关系映射（ORM）框架，在正确使用的情况下，其内部通常会使用参数化查询来处理数据，从而天然地帮助开发者避免 SQL 注入问题。但需要注意的是，一些框架也提供了执行原生 SQL 的接口，如果在这里进行字符串拼接，同样会产生漏洞。

**总结一下**：防止 SQL 注入最核心的原则是 **“代码与数据分离”**。`PreparedStatement` 是实践这一原则的最佳工具。结合严格的输入验证和最小权限原则，可以构建起坚固的防线，有效抵御 SQL 注入攻击。
