---
title: "Java 集合框架"
date: 2025-05-28 00:00:03 +0800
categories: [JAVA, JAVA 基础]
tags: [JAVA, 集合框架]
pin: false
toc: true
math: true
---

## 1. 集合框架概述

Java 集合框架是一套统一的架构，用于表示和操作集合数据。它包含了接口、实现类和算法，主要分为三大类：

- **Collection 接口**：单一元素的集合
- **Map 接口**：键值对的集合
- **Iterator 接口**：遍历集合的迭代器

### 集合框架层次结构

```
Collection
├── List (有序，可重复)
│   ├── ArrayList
│   ├── LinkedList
│   └── Vector
├── Set (无重复元素)
│   ├── HashSet
│   ├── LinkedHashSet
│   └── TreeSet
└── Queue (队列)
    ├── PriorityQueue
    └── ArrayDeque

Map (键值对)
├── HashMap
├── LinkedHashMap
├── TreeMap
└── Hashtable
```

## 2. Collection 接口

Collection 是所有集合类的根接口，定义了集合的基本操作。

```java
import java.util.*;

public class CollectionExample {
    public static void main(String[] args) {
        // Collection是接口，不能直接实例化
        // 使用ArrayList作为Collection的实现
        Collection<String> collection = new ArrayList<>();

        // 添加元素
        collection.add("Apple");
        collection.add("Banana");
        collection.add("Cherry");

        // 检查大小
        System.out.println("集合大小: " + collection.size());

        // 检查是否包含某元素
        System.out.println("是否包含Apple: " + collection.contains("Apple"));

        // 删除元素
        collection.remove("Banana");

        // 遍历集合
        for (String item : collection) {
            System.out.println(item);
        }

        // 检查是否为空
        System.out.println("集合是否为空: " + collection.isEmpty());

        // 清空集合
        collection.clear();
    }
}
```

## 3. List 接口

List 是有序集合，允许重复元素，支持索引访问。

### 3.1 ArrayList

ArrayList 是基于动态数组的实现，查找快，插入删除慢。

```java
import java.util.*;

public class ArrayListExample {
    public static void main(String[] args) {
        // 创建ArrayList
        List<String> arrayList = new ArrayList<>();

        // 添加元素
        arrayList.add("Java");
        arrayList.add("Python");
        arrayList.add("JavaScript");
        arrayList.add("Java"); // 允许重复

        // 在指定位置插入元素
        arrayList.add(1, "C++");

        // 获取元素
        System.out.println("索引0的元素: " + arrayList.get(0));

        // 修改元素
        arrayList.set(0, "Kotlin");

        // 获取元素索引
        System.out.println("Java的索引: " + arrayList.indexOf("Java"));
        System.out.println("Java最后出现的索引: " + arrayList.lastIndexOf("Java"));

        // 获取子列表
        List<String> subList = arrayList.subList(1, 3);
        System.out.println("子列表: " + subList);

        // 排序
        Collections.sort(arrayList);
        System.out.println("排序后: " + arrayList);

        // 转换为数组
        String[] array = arrayList.toArray(new String[0]);
        System.out.println("转换为数组: " + Arrays.toString(array));

        // 遍历方式
        System.out.println("=== 遍历方式 ===");

        // 1. 传统for循环
        for (int i = 0; i < arrayList.size(); i++) {
            System.out.println("传统for: " + arrayList.get(i));
        }

        // 2. 增强for循环
        for (String item : arrayList) {
            System.out.println("增强for: " + item);
        }

        // 3. 迭代器
        Iterator<String> iterator = arrayList.iterator();
        while (iterator.hasNext()) {
            System.out.println("迭代器: " + iterator.next());
        }

        // 4. Lambda表达式
        arrayList.forEach(item -> System.out.println("Lambda: " + item));
    }
}
```

### 3.2 LinkedList

LinkedList 是基于双向链表的实现，插入删除快，查找慢。

```java
import java.util.*;

public class LinkedListExample {
    public static void main(String[] args) {
        // LinkedList既实现了List接口，也实现了Deque接口
        LinkedList<String> linkedList = new LinkedList<>();

        // List接口方法
        linkedList.add("First");
        linkedList.add("Second");
        linkedList.add("Third");

        // LinkedList特有方法
        linkedList.addFirst("头部元素");  // 在开头添加
        linkedList.addLast("尾部元素");   // 在末尾添加

        System.out.println("LinkedList: " + linkedList);

        // 获取元素
        System.out.println("第一个元素: " + linkedList.getFirst());
        System.out.println("最后一个元素: " + linkedList.getLast());

        // 删除元素
        String removedFirst = linkedList.removeFirst();
        String removedLast = linkedList.removeLast();
        System.out.println("删除的第一个元素: " + removedFirst);
        System.out.println("删除的最后一个元素: " + removedLast);

        // 作为栈使用
        linkedList.push("栈顶元素");  // 入栈
        System.out.println("栈顶元素: " + linkedList.peek());
        String popped = linkedList.pop();  // 出栈
        System.out.println("弹出的元素: " + popped);

        // 作为队列使用
        linkedList.offer("队列元素");  // 入队
        System.out.println("队列头元素: " + linkedList.poll()); // 出队

        System.out.println("最终LinkedList: " + linkedList);
    }
}
```

### 3.3 Vector

Vector 是线程安全的动态数组，但性能较差，现在很少使用。

```java
import java.util.*;

public class VectorExample {
    public static void main(String[] args) {
        // Vector是线程安全的，但性能较ArrayList差
        Vector<String> vector = new Vector<>();

        // 基本操作和ArrayList类似
        vector.add("Element1");
        vector.add("Element2");
        vector.add("Element3");

        // Vector特有方法
        vector.addElement("Element4");  // 添加元素

        // 获取容量信息
        System.out.println("大小: " + vector.size());
        System.out.println("容量: " + vector.capacity());

        // 线程安全的遍历
        synchronized (vector) {
            for (String element : vector) {
                System.out.println(element);
            }
        }

        // 使用Enumeration遍历（Vector特有）
        Enumeration<String> enumeration = vector.elements();
        while (enumeration.hasMoreElements()) {
            System.out.println("Enumeration: " + enumeration.nextElement());
        }
    }
}
```

## 4. Set 接口

Set 是不允许重复元素的集合。

### 4.1 HashSet

HashSet 基于哈希表实现，无序，查找效率高。

```java
import java.util.*;

public class HashSetExample {
    public static void main(String[] args) {
        // 创建HashSet
        Set<String> hashSet = new HashSet<>();

        // 添加元素
        hashSet.add("Apple");
        hashSet.add("Banana");
        hashSet.add("Cherry");
        hashSet.add("Apple"); // 重复元素不会被添加

        System.out.println("HashSet: " + hashSet);
        System.out.println("大小: " + hashSet.size());

        // 检查元素
        System.out.println("是否包含Apple: " + hashSet.contains("Apple"));

        // 删除元素
        hashSet.remove("Banana");
        System.out.println("删除后: " + hashSet);

        // 集合运算
        Set<String> set1 = new HashSet<>(Arrays.asList("A", "B", "C"));
        Set<String> set2 = new HashSet<>(Arrays.asList("B", "C", "D"));

        // 交集
        Set<String> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        System.out.println("交集: " + intersection);

        // 并集
        Set<String> union = new HashSet<>(set1);
        union.addAll(set2);
        System.out.println("并集: " + union);

        // 差集
        Set<String> difference = new HashSet<>(set1);
        difference.removeAll(set2);
        System.out.println("差集: " + difference);

        // 使用自定义对象
        Set<Person> personSet = new HashSet<>();
        personSet.add(new Person("Alice", 25));
        personSet.add(new Person("Bob", 30));
        personSet.add(new Person("Alice", 25)); // 需要重写equals和hashCode

        System.out.println("Person集合: " + personSet);
    }
}

// 自定义类需要重写equals和hashCode方法
class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return age == person.age && Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }
}
```

### 4.2 LinkedHashSet

LinkedHashSet 保持插入顺序的 HashSet。

```java
import java.util.*;

public class LinkedHashSetExample {
    public static void main(String[] args) {
        // LinkedHashSet保持插入顺序
        Set<String> linkedHashSet = new LinkedHashSet<>();

        linkedHashSet.add("First");
        linkedHashSet.add("Second");
        linkedHashSet.add("Third");
        linkedHashSet.add("First"); // 重复元素不会被添加

        System.out.println("LinkedHashSet: " + linkedHashSet);

        // 对比HashSet（无序）
        Set<String> hashSet = new HashSet<>();
        hashSet.add("First");
        hashSet.add("Second");
        hashSet.add("Third");

        System.out.println("HashSet: " + hashSet);

        // 遍历保持插入顺序
        System.out.println("=== LinkedHashSet遍历 ===");
        for (String item : linkedHashSet) {
            System.out.println(item);
        }
    }
}
```

### 4.3 TreeSet

TreeSet 基于红黑树实现，自动排序。

```java
import java.util.*;

public class TreeSetExample {
    public static void main(String[] args) {
        // TreeSet自动排序
        Set<String> treeSet = new TreeSet<>();

        treeSet.add("Banana");
        treeSet.add("Apple");
        treeSet.add("Cherry");
        treeSet.add("Date");

        System.out.println("TreeSet: " + treeSet); // 自动排序

        // NavigableSet接口方法
        NavigableSet<String> navigableSet = new TreeSet<>(treeSet);

        System.out.println("第一个元素: " + navigableSet.first());
        System.out.println("最后一个元素: " + navigableSet.last());

        // 范围查询
        System.out.println("小于Cherry的元素: " + navigableSet.headSet("Cherry"));
        System.out.println("大于等于Cherry的元素: " + navigableSet.tailSet("Cherry"));
        System.out.println("B到D之间的元素: " + navigableSet.subSet("B", "D"));

        // 邻近元素
        System.out.println("小于Cherry的最大元素: " + navigableSet.lower("Cherry"));
        System.out.println("大于Cherry的最小元素: " + navigableSet.higher("Cherry"));

        // 使用自定义比较器
        Set<String> customTreeSet = new TreeSet<>(new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {
                // 按长度排序，长度相同则按字典序
                int lengthCompare = Integer.compare(s1.length(), s2.length());
                return lengthCompare != 0 ? lengthCompare : s1.compareTo(s2);
            }
        });

        customTreeSet.add("A");
        customTreeSet.add("BB");
        customTreeSet.add("CCC");
        customTreeSet.add("DD");

        System.out.println("自定义排序TreeSet: " + customTreeSet);

        // 数字TreeSet
        Set<Integer> numberSet = new TreeSet<>();
        numberSet.add(5);
        numberSet.add(2);
        numberSet.add(8);
        numberSet.add(1);

        System.out.println("数字TreeSet: " + numberSet);
    }
}
```

## 5. Queue 接口

Queue 表示队列，遵循 FIFO（先进先出）原则。

### 5.1 PriorityQueue

PriorityQueue 是优先级队列，元素按优先级排序。

```java
import java.util.*;

public class PriorityQueueExample {
    public static void main(String[] args) {
        // 默认是最小堆（小的元素优先级高）
        Queue<Integer> priorityQueue = new PriorityQueue<>();

        // 添加元素
        priorityQueue.offer(5);
        priorityQueue.offer(2);
        priorityQueue.offer(8);
        priorityQueue.offer(1);

        System.out.println("PriorityQueue: " + priorityQueue);

        // 取出元素（按优先级）
        while (!priorityQueue.isEmpty()) {
            System.out.println("取出元素: " + priorityQueue.poll());
        }

        // 使用自定义比较器（最大堆）
        Queue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
        maxHeap.offer(5);
        maxHeap.offer(2);
        maxHeap.offer(8);
        maxHeap.offer(1);

        System.out.println("=== 最大堆 ===");
        while (!maxHeap.isEmpty()) {
            System.out.println("取出元素: " + maxHeap.poll());
        }

        // 自定义对象的优先级队列
        Queue<Task> taskQueue = new PriorityQueue<>();
        taskQueue.offer(new Task("任务C", 1));
        taskQueue.offer(new Task("任务A", 3));
        taskQueue.offer(new Task("任务B", 2));

        System.out.println("=== 任务队列 ===");
        while (!taskQueue.isEmpty()) {
            System.out.println("执行任务: " + taskQueue.poll());
        }
    }
}

// 实现Comparable接口的任务类
class Task implements Comparable<Task> {
    private String name;
    private int priority; // 数字越小优先级越高

    public Task(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }

    @Override
    public int compareTo(Task other) {
        return Integer.compare(this.priority, other.priority);
    }

    @Override
    public String toString() {
        return "Task{name='" + name + "', priority=" + priority + "}";
    }
}
```

### 5.2 ArrayDeque

ArrayDeque 是基于数组的双端队列，可以在两端进行操作。

```java
import java.util.*;

public class ArrayDequeExample {
    public static void main(String[] args) {
        // ArrayDeque可以作为栈、队列、双端队列使用
        ArrayDeque<String> deque = new ArrayDeque<>();

        // 作为队列使用（FIFO）
        System.out.println("=== 作为队列使用 ===");
        deque.offer("First");   // 入队
        deque.offer("Second");
        deque.offer("Third");

        System.out.println("队列: " + deque);

        while (!deque.isEmpty()) {
            System.out.println("出队: " + deque.poll());
        }

        // 作为栈使用（LIFO）
        System.out.println("=== 作为栈使用 ===");
        deque.push("First");    // 入栈
        deque.push("Second");
        deque.push("Third");

        System.out.println("栈: " + deque);

        while (!deque.isEmpty()) {
            System.out.println("出栈: " + deque.pop());
        }

        // 作为双端队列使用
        System.out.println("=== 作为双端队列使用 ===");
        deque.addFirst("头部1");
        deque.addLast("尾部1");
        deque.addFirst("头部2");
        deque.addLast("尾部2");

        System.out.println("双端队列: " + deque);

        System.out.println("从头部取出: " + deque.removeFirst());
        System.out.println("从尾部取出: " + deque.removeLast());

        System.out.println("剩余元素: " + deque);

        // 查看元素但不移除
        System.out.println("头部元素: " + deque.peekFirst());
        System.out.println("尾部元素: " + deque.peekLast());
    }
}
```

## 6. Map 接口

Map 存储键值对，键不能重复。

### 6.1 HashMap

HashMap 基于哈希表实现，无序，查找效率高。

```java
import java.util.*;

public class HashMapExample {
    public static void main(String[] args) {
        // 创建HashMap
        Map<String, Integer> hashMap = new HashMap<>();

        // 添加键值对
        hashMap.put("Apple", 5);
        hashMap.put("Banana", 3);
        hashMap.put("Cherry", 8);
        hashMap.put("Date", 2);

        System.out.println("HashMap: " + hashMap);

        // 获取值
        System.out.println("Apple的数量: " + hashMap.get("Apple"));
        System.out.println("Grape的数量: " + hashMap.get("Grape")); // 返回null

        // 使用getOrDefault
        System.out.println("Grape的数量: " + hashMap.getOrDefault("Grape", 0));

        // 检查键和值
        System.out.println("是否包含Apple: " + hashMap.containsKey("Apple"));
        System.out.println("是否包含值5: " + hashMap.containsValue(5));

        // 更新值
        hashMap.put("Apple", 10); // 更新现有键的值
        System.out.println("更新后的HashMap: " + hashMap);

        // 如果键不存在才添加
        hashMap.putIfAbsent("Grape", 6);
        hashMap.putIfAbsent("Apple", 15); // 不会更新，因为键已存在

        System.out.println("putIfAbsent后: " + hashMap);

        // 遍历Map
        System.out.println("=== 遍历方式 ===");

        // 1. 遍历键
        for (String key : hashMap.keySet()) {
            System.out.println("键: " + key + ", 值: " + hashMap.get(key));
        }

        // 2. 遍历值
        for (Integer value : hashMap.values()) {
            System.out.println("值: " + value);
        }

        // 3. 遍历键值对
        for (Map.Entry<String, Integer> entry : hashMap.entrySet()) {
            System.out.println("键值对: " + entry.getKey() + " = " + entry.getValue());
        }

        // 4. 使用forEach（Lambda表达式）
        hashMap.forEach((key, value) ->
            System.out.println("Lambda: " + key + " = " + value));

        // 高级操作
        System.out.println("=== 高级操作 ===");

        // compute方法：计算新值
        hashMap.compute("Apple", (key, value) -> value != null ? value * 2 : 1);
        System.out.println("compute后: " + hashMap);

        // computeIfAbsent：如果键不存在则计算
        hashMap.computeIfAbsent("Orange", key -> key.length());
        System.out.println("computeIfAbsent后: " + hashMap);

        // merge方法：合并值
        hashMap.merge("Apple", 5, (oldValue, newValue) -> oldValue + newValue);
        System.out.println("merge后: " + hashMap);

        // replace方法
        hashMap.replace("Banana", 100);
        hashMap.replace("Cherry", 8, 12); // 只有当前值为8时才替换
        System.out.println("replace后: " + hashMap);

        // 删除操作
        hashMap.remove("Date");
        hashMap.remove("Cherry", 12); // 只有当前值为12时才删除
        System.out.println("删除后: " + hashMap);
    }
}
```

### 6.2 LinkedHashMap

LinkedHashMap 保持插入顺序的 HashMap。

```java
import java.util.*;

public class LinkedHashMapExample {
    public static void main(String[] args) {
        // LinkedHashMap保持插入顺序
        Map<String, Integer> linkedHashMap = new LinkedHashMap<>();

        linkedHashMap.put("Third", 3);
        linkedHashMap.put("First", 1);
        linkedHashMap.put("Second", 2);
        linkedHashMap.put("Fourth", 4);

        System.out.println("LinkedHashMap (插入顺序): " + linkedHashMap);

        // 对比HashMap（无序）
        Map<String, Integer> hashMap = new HashMap<>();
        hashMap.put("Third", 3);
        hashMap.put("First", 1);
        hashMap.put("Second", 2);
        hashMap.put("Fourth", 4);

        System.out.println("HashMap (无序): " + hashMap);

        // 创建访问顺序的LinkedHashMap
        Map<String, Integer> accessOrderMap = new LinkedHashMap<>(16, 0.75f, true);
        accessOrderMap.put("A", 1);
        accessOrderMap.put("B", 2);
        accessOrderMap.put("C", 3);

        System.out.println("访问前: " + accessOrderMap);

        // 访问元素B
        accessOrderMap.get("B");
        System.out.println("访问B后: " + accessOrderMap);

        // 实现LRU缓存
        Map<String, String> lruCache = new LinkedHashMap<String, String>(16, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<String, String> eldest) {
                return size() > 3; // 最多保存3个元素
            }
        };

        lruCache.put("1", "One");
        lruCache.put("2", "Two");
        lruCache.put("3", "Three");
        System.out.println("LRU缓存: " + lruCache);

        lruCache.put("4", "Four"); // 会移除最老的元素
        System.out.println("添加第4个元素后: " + lruCache);

        lruCache.get("2"); // 访问元素2
        lruCache.put("5", "Five"); // 会移除最老的元素3
        System.out.println("访问2并添加5后: " + lruCache);
    }
}
```

### 6.3 TreeMap

TreeMap 基于红黑树实现，按键排序。

```java
import java.util.*;

public class TreeMapExample {
    public static void main(String[] args) {
        // TreeMap按键自动排序
        Map<String, Integer> treeMap = new TreeMap<>();

        treeMap.put("Charlie", 3);
        treeMap.put("Alice", 1);
        treeMap.put("Bob", 2);
        treeMap.put("David", 4);

        System.out.println("TreeMap: " + treeMap);

        // NavigableMap接口方法
        NavigableMap<String, Integer> navigableMap = new TreeMap<>(treeMap);

        System.out.println("第一个键: " + navigableMap.firstKey());
        System.out.println("最后一个键: " + navigableMap.lastKey());

        // 范围查询
        System.out.println("小于Charlie的键: " + navigableMap.headMap("Charlie"));
        System.out.println("大于等于Charlie的键: " + navigableMap.tailMap("Charlie"));
        System.out.println("Bob到David之间的键: " + navigableMap.subMap("Bob", "David"));

        // 邻近键
        System.out.println("小于Charlie的最大键: " + navigableMap.lowerKey("Charlie"));
        System.out.println("大于Charlie的最小键: " + navigableMap.higherKey("Charlie"));

        // 使用自定义比较器
        Map<String, Integer> customTreeMap = new TreeMap<>(new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {
                // 按长度排序，长度相同则按字典序
                int lengthCompare = Integer.compare(s1.length(), s2.length());
                return lengthCompare != 0 ? lengthCompare : s1.compareTo(s2);
            }
        });

        customTreeMap.put("A", 1);
        customTreeMap.put("BB", 2);
        customTreeMap.put("CCC", 3);
        customTreeMap.put("DD", 4);

        System.out.println("自定义排序TreeMap: " + customTreeMap);

        // 数字键的TreeMap
        Map<Integer, String> numberMap = new TreeMap<>();
        numberMap.put(5, "Five");
        numberMap.put(2, "Two");
        numberMap.put(8, "Eight");
        numberMap.put(1, "One");

        System.out.println("数字键TreeMap: " + numberMap);
    }
}
```

## 7. Iterator 接口

Iterator 提供了遍历集合的统一方式。

```java
import java.util.*;

public class IteratorExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C", "D"));

        // 基本Iterator
        System.out.println("=== 基本Iterator ===");
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            String element = iterator.next();
            System.out.println("元素: " + element);

            // 删除元素B
            if ("B".equals(element)) {
                iterator.remove(); // 安全删除
            }
        }
        System.out.println("删除B后: " + list);

        // ListIterator（双向遍历）
        System.out.println("=== ListIterator ===");
        ListIterator<String> listIterator = list.listIterator();

        // 正向遍历
        System.out.println("正向遍历:");
        while (listIterator.hasNext()) {
            int index = listIterator.nextIndex();
            String element = listIterator.next();
            System.out.println("索引" + index + ": " + element);
        }

        // 反向遍历
        System.out.println("反向遍历:");
        while (listIterator.hasPrevious()) {
            int index = listIterator.previousIndex();
            String element = listIterator.previous();
            System.out.println("索引" + index + ": " + element);
        }

        // 在遍历过程中修改
        listIterator = list.listIterator();
        while (listIterator.hasNext()) {
            String element = listIterator.next();
            if ("A".equals(element)) {
                listIterator.set("AA"); // 修改当前元素
            }
            if ("C".equals(element)) {
                listIterator.add("CC"); // 在当前位置后添加元素
            }
        }
        System.out.println("修改后的列表: " + list);

        // 增强for循环的限制
        System.out.println("=== 增强for循环的限制 ===");
        try {
            for (String element : list) {
                if ("AA".equals(element)) {
                    list.remove(element); // 这会抛出ConcurrentModificationException
                }
            }
        } catch (ConcurrentModificationException e) {
            System.out.println("增强for循环中不能修改集合: " + e.getMessage());
        }

        // 正确的删除方式
        System.out.println("=== 正确的删除方式 ===");
        Iterator<String> safeIterator = list.iterator();
        while (safeIterator.hasNext()) {
            String element = safeIterator.next();
            if ("AA".equals(element)) {
                safeIterator.remove(); // 使用Iterator的remove方法
            }
        }
        System.out.println("安全删除后: " + list);

        // 使用removeIf方法（Java 8+）
        list.add("X");
        list.add("Y");
        list.add("Z");
        list.removeIf(element -> element.startsWith("C"));
        System.out.println("使用removeIf后: " + list);
    }
}
```

## 8. Collections 工具类

Collections 类提供了许多静态方法来操作集合。

```java
import java.util.*;

public class CollectionsExample {
    public static void main(String[] args) {
        // 创建测试列表
        List<String> list = new ArrayList<>(Arrays.asList("Banana", "Apple", "Cherry", "Date"));
        System.out.println("原始列表: " + list);

        // 排序
        Collections.sort(list);
        System.out.println("排序后: " + list);

        // 逆序
        Collections.reverse(list);
        System.out.println("逆序后: " + list);

        // 随机打乱
        Collections.shuffle(list);
        System.out.println("打乱后: " + list);

        // 填充
        Collections.fill(list, "X");
        System.out.println("填充后: " + list);

        // 重新创建列表
        list = new ArrayList<>(Arrays.asList("Banana", "Apple", "Cherry", "Date"));
        Collections.sort(list);

        // 二分查找
        int index = Collections.binarySearch(list, "Cherry");
        System.out.println("Cherry的索引: " + index);

        // 查找最大值和最小值
        System.out.println("最大值: " + Collections.max(list));
        System.out.println("最小值: " + Collections.min(list));

        // 统计元素出现次数
        list.add("Apple");
        System.out.println("Apple出现次数: " + Collections.frequency(list, "Apple"));

        // 替换元素
        Collections.replaceAll(list, "Apple", "Orange");
        System.out.println("替换后: " + list);

        // 创建不可变集合
        List<String> immutableList = Collections.unmodifiableList(list);
        System.out.println("不可变列表: " + immutableList);

        try {
            immutableList.add("New"); // 这会抛出异常
        } catch (UnsupportedOperationException e) {
            System.out.println("不可变列表不能修改: " + e.getMessage());
        }

        // 创建同步集合
        List<String> synchronizedList = Collections.synchronizedList(new ArrayList<>());
        synchronizedList.add("Thread-Safe");
        System.out.println("同步列表: " + synchronizedList);

        // 创建单例集合
        Set<String> singletonSet = Collections.singleton("Only");
        System.out.println("单例集合: " + singletonSet);

        // 创建空集合
        List<String> emptyList = Collections.emptyList();
        Set<String> emptySet = Collections.emptySet();
        Map<String, String> emptyMap = Collections.emptyMap();

        System.out.println("空列表: " + emptyList);
        System.out.println("空集合: " + emptySet);
        System.out.println("空映射: " + emptyMap);

        // 检查集合是否有交集
        List<String> list1 = Arrays.asList("A", "B", "C");
        List<String> list2 = Arrays.asList("C", "D", "E");

        boolean hasIntersection = !Collections.disjoint(list1, list2);
        System.out.println("两个列表有交集: " + hasIntersection);

        // 复制列表
        List<String> dest = new ArrayList<>(Collections.nCopies(list1.size(), ""));
        Collections.copy(dest, list1);
        System.out.println("复制的列表: " + dest);

        // 创建指定大小的列表
        List<String> nCopies = Collections.nCopies(3, "Hello");
        System.out.println("nCopies: " + nCopies);
    }
}
```

## 9. 泛型在集合中的应用

```java
import java.util.*;

public class GenericsExample {
    public static void main(String[] args) {
        // 泛型的基本使用
        List<String> stringList = new ArrayList<>();
        stringList.add("Hello");
        // stringList.add(123); // 编译错误，类型不匹配

        // 泛型通配符
        System.out.println("=== 泛型通配符 ===");

        // 上界通配符 <? extends T>
        List<Integer> intList = Arrays.asList(1, 2, 3, 4, 5);
        List<Double> doubleList = Arrays.asList(1.1, 2.2, 3.3);

        printNumbers(intList);
        printNumbers(doubleList);

        // 下界通配符 <? super T>
        List<Number> numberList = new ArrayList<>();
        addNumbers(numberList);
        System.out.println("Number列表: " + numberList);

        // 无界通配符 <?>
        List<?> unknownList = new ArrayList<String>();
        printSize(unknownList);

        // 泛型方法
        String[] stringArray = {"A", "B", "C"};
        Integer[] intArray = {1, 2, 3};

        List<String> stringListFromArray = arrayToList(stringArray);
        List<Integer> intListFromArray = arrayToList(intArray);

        System.out.println("字符串列表: " + stringListFromArray);
        System.out.println("整数列表: " + intListFromArray);

        // 泛型类的使用
        Pair<String, Integer> pair = new Pair<>("Age", 25);
        System.out.println("键值对: " + pair.getKey() + " = " + pair.getValue());

        // 类型擦除的影响
        List<String> stringList2 = new ArrayList<>();
        List<Integer> intList2 = new ArrayList<>();

        // 运行时类型都是List
        System.out.println("stringList2类型: " + stringList2.getClass());
        System.out.println("intList2类型: " + intList2.getClass());
        System.out.println("类型相同: " + (stringList2.getClass() == intList2.getClass()));
    }

    // 上界通配符示例
    public static void printNumbers(List<? extends Number> numbers) {
        for (Number number : numbers) {
            System.out.println("数字: " + number);
        }
    }

    // 下界通配符示例
    public static void addNumbers(List<? super Integer> numbers) {
        numbers.add(1);
        numbers.add(2);
        numbers.add(3);
    }

    // 无界通配符示例
    public static void printSize(List<?> list) {
        System.out.println("列表大小: " + list.size());
    }

    // 泛型方法示例
    public static <T> List<T> arrayToList(T[] array) {
        List<T> list = new ArrayList<>();
        for (T item : array) {
            list.add(item);
        }
        return list;
    }
}

// 泛型类示例
class Pair<K, V> {
    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public K getKey() {
        return key;
    }

    public V getValue() {
        return value;
    }

    public void setKey(K key) {
        this.key = key;
    }

    public void setValue(V value) {
        this.value = value;
    }
}
```

## 10. 集合的性能比较

```java
import java.util.*;

public class PerformanceComparison {
    public static void main(String[] args) {
        int size = 100000;

        // List性能比较
        System.out.println("=== List性能比较 ===");
        compareListPerformance(size);

        // Set性能比较
        System.out.println("\n=== Set性能比较 ===");
        compareSetPerformance(size);

        // Map性能比较
        System.out.println("\n=== Map性能比较 ===");
        compareMapPerformance(size);
    }

    public static void compareListPerformance(int size) {
        // ArrayList vs LinkedList 添加性能
        List<Integer> arrayList = new ArrayList<>();
        List<Integer> linkedList = new LinkedList<>();

        // 尾部添加
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < size; i++) {
            arrayList.add(i);
        }
        long arrayListAddTime = System.currentTimeMillis() - startTime;

        startTime = System.currentTimeMillis();
        for (int i = 0; i < size; i++) {
            linkedList.add(i);
        }
        long linkedListAddTime = System.currentTimeMillis() - startTime;

        System.out.println("ArrayList尾部添加时间: " + arrayListAddTime + "ms");
        System.out.println("LinkedList尾部添加时间: " + linkedListAddTime + "ms");

        // 随机访问
        Random random = new Random();
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            arrayList.get(random.nextInt(size));
        }
        long arrayListGetTime = System.currentTimeMillis() - startTime;

        startTime = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            linkedList.get(random.nextInt(size));
        }
        long linkedListGetTime = System.currentTimeMillis() - startTime;

        System.out.println("ArrayList随机访问时间: " + arrayListGetTime + "ms");
        System.out.println("LinkedList随机访问时间: " + linkedListGetTime + "ms");
    }

    public static void compareSetPerformance(int size) {
        Set<Integer> hashSet = new HashSet<>();
        Set<Integer> linkedHashSet = new LinkedHashSet<>();
        Set<Integer> treeSet = new TreeSet<>();

        // 添加性能
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < size; i++) {
            hashSet.add(i);
        }
        long hashSetAddTime = System.currentTimeMillis() - startTime;

        startTime = System.currentTimeMillis();
        for (int i = 0; i < size; i++) {
            linkedHashSet.add(i);
        }
        long linkedHashSetAddTime = System.currentTimeMillis() - startTime;

        startTime = System.currentTimeMillis();
        for (int i = 0; i < size; i++) {
            treeSet.add(i);
        }
        long treeSetAddTime = System.currentTimeMillis() - startTime;

        System.out.println("HashSet添加时间: " + hashSetAddTime + "ms");
        System.out.println("LinkedHashSet添加时间: " + linkedHashSetAddTime + "ms");
        System.out.println("TreeSet添加时间: " + treeSetAddTime + "ms");

        // 查找性能
        Random random = new Random();
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            hashSet.contains(random.nextInt(size));
        }
        long hashSetContainsTime = System.currentTimeMillis() - startTime;

        startTime = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            treeSet.contains(random.nextInt(size));
        }
        long treeSetContainsTime = System.currentTimeMillis() - startTime;

        System.out.println("HashSet查找时间: " + hashSetContainsTime + "ms");
        System.out.println("TreeSet查找时间: " + treeSetContainsTime + "ms");
    }

    public static void compareMapPerformance(int size) {
        Map<Integer, String> hashMap = new HashMap<>();
        Map<Integer, String> linkedHashMap = new LinkedHashMap<>();
        Map<Integer, String> treeMap = new TreeMap<>();

        // 添加性能
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < size; i++) {
            hashMap.put(i, "Value" + i);
        }
        long hashMapPutTime = System.currentTimeMillis() - startTime;

        startTime = System.currentTimeMillis();
        for (int i = 0; i < size; i++) {
            linkedHashMap.put(i, "Value" + i);
        }
        long linkedHashMapPutTime = System.currentTimeMillis() - startTime;

        startTime = System.currentTimeMillis();
        for (int i = 0; i < size; i++) {
            treeMap.put(i, "Value" + i);
        }
        long treeMapPutTime = System.currentTimeMillis() - startTime;

        System.out.println("HashMap添加时间: " + hashMapPutTime + "ms");
        System.out.println("LinkedHashMap添加时间: " + linkedHashMapPutTime + "ms");
        System.out.println("TreeMap添加时间: " + treeMapPutTime + "ms");

        // 查找性能
        Random random = new Random();
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            hashMap.get(random.nextInt(size));
        }
        long hashMapGetTime = System.currentTimeMillis() - startTime;

        startTime = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            treeMap.get(random.nextInt(size));
        }
        long treeMapGetTime = System.currentTimeMillis() - startTime;

        System.out.println("HashMap查找时间: " + hashMapGetTime + "ms");
        System.out.println("TreeMap查找时间: " + treeMapGetTime + "ms");
    }
}
```

## 11. 集合的选择指南

### 11.1 选择标准

| 需求                       | 推荐集合      | 理由                 |
| -------------------------- | ------------- | -------------------- |
| 有序、可重复、支持索引     | ArrayList     | 查找快，适合频繁读取 |
| 有序、可重复、频繁插入删除 | LinkedList    | 插入删除快           |
| 无重复、查找快             | HashSet       | 哈希表，O(1)查找     |
| 无重复、保持插入顺序       | LinkedHashSet | 有序的 HashSet       |
| 无重复、自动排序           | TreeSet       | 红黑树，自动排序     |
| 键值对、查找快             | HashMap       | 哈希表，O(1)查找     |
| 键值对、保持插入顺序       | LinkedHashMap | 有序的 HashMap       |
| 键值对、按键排序           | TreeMap       | 红黑树，按键排序     |
| 队列操作                   | ArrayDeque    | 双端队列             |
| 优先级队列                 | PriorityQueue | 堆实现               |

### 11.2 性能特点

| 集合类型   | 查找     | 插入              | 删除     | 特点               |
| ---------- | -------- | ----------------- | -------- | ------------------ |
| ArrayList  | O(1)     | O(1)尾部/O(n)中间 | O(n)     | 基于数组，连续内存 |
| LinkedList | O(n)     | O(1)              | O(1)     | 基于链表，内存分散 |
| HashSet    | O(1)     | O(1)              | O(1)     | 基于哈希表         |
| TreeSet    | O(log n) | O(log n)          | O(log n) | 基于红黑树         |
| HashMap    | O(1)     | O(1)              | O(1)     | 基于哈希表         |
| TreeMap    | O(log n) | O(log n)          | O(log n) | 基于红黑树         |

## 12. 最佳实践

### 12.1 集合使用建议

```java
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class BestPractices {
    public static void main(String[] args) {
        // 1. 优先使用接口类型声明变量
        List<String> list = new ArrayList<>(); // 好
        // ArrayList<String> list = new ArrayList<>(); // 不推荐

        // 2. 选择合适的初始容量
        List<String> largeList = new ArrayList<>(1000); // 避免频繁扩容
        Map<String, String> largeMap = new HashMap<>(1000, 0.75f);

        // 3. 使用泛型确保类型安全
        List<String> typedList = new ArrayList<>(); // 好
        // List rawList = new ArrayList(); // 不推荐

        // 4. 优先使用增强for循环
        List<String> items = Arrays.asList("A", "B", "C");
        for (String item : items) { // 好
            System.out.println(item);
        }

        // 5. 在需要时使用不可变集合
        List<String> immutableList = Collections.unmodifiableList(items);

        // 6. 多线程环境下使用线程安全的集合
        Map<String, String> threadSafeMap = new ConcurrentHashMap<>();

        // 7. 正确实现equals和hashCode
        Set<Student> students = new HashSet<>();
        students.add(new Student("Alice", 20));
        students.add(new Student("Alice", 20)); // 不会重复添加

        // 8. 使用合适的比较器
        List<String> words = Arrays.asList("apple", "Banana", "cherry");
        Collections.sort(words, String.CASE_INSENSITIVE_ORDER);

        // 9. 避免在循环中使用容器的size()方法
        List<String> data = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            data.add("Item" + i);
        }

        // 好的做法
        int size = data.size();
        for (int i = 0; i < size; i++) {
            // 处理data.get(i)
        }

        // 10. 使用合适的删除方法
        List<String> listToModify = new ArrayList<>(Arrays.asList("A", "B", "C", "D"));

        // 使用Iterator安全删除
        Iterator<String> it = listToModify.iterator();
        while (it.hasNext()) {
            String item = it.next();
            if ("B".equals(item)) {
                it.remove();
            }
        }

        // 或使用removeIf（Java 8+）
        listToModify.removeIf(item -> "C".equals(item));

        System.out.println("修改后的列表: " + listToModify);
    }
}

// 正确实现equals和hashCode的示例
class Student {
    private String name;
    private int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Student student = (Student) obj;
        return age == student.age && Objects.equals(name, student.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }

    @Override
    public String toString() {
        return "Student{name='" + name + "', age=" + age + "}";
    }
}
```

### 12.2 常见陷阱和解决方案

```java
import java.util.*;

public class CommonPitfalls {
    public static void main(String[] args) {
        // 1. 避免在foreach中修改集合
        List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));

        // 错误做法
        try {
            for (String item : list) {
                if ("B".equals(item)) {
                    list.remove(item); // ConcurrentModificationException
                }
            }
        } catch (ConcurrentModificationException e) {
            System.out.println("错误: " + e.getMessage());
        }

        // 正确做法
        list.removeIf(item -> "B".equals(item));

        // 2. 注意Arrays.asList()的限制
        List<String> fixedList = Arrays.asList("X", "Y", "Z");
        try {
            fixedList.add("W"); // UnsupportedOperationException
        } catch (UnsupportedOperationException e) {
            System.out.println("Arrays.asList返回固定大小的列表");
        }

        // 正确做法
        List<String> mutableList = new ArrayList<>(Arrays.asList("X", "Y", "Z"));
        mutableList.add("W");

        // 3. 小心null值
        List<String> nullList = new ArrayList<>();
        nullList.add(null);
        nullList.add("NotNull");

        // 安全的遍历
        for (String item : nullList) {
            if (item != null) {
                System.out.println("Item: " + item);
            }
        }

        // 4. 理解浅拷贝和深拷贝
        List<StringBuilder> original = new ArrayList<>();
        original.add(new StringBuilder("Hello"));

        List<StringBuilder> shallowCopy = new ArrayList<>(original);
        shallowCopy.get(0).append(" World"); // 影响原始列表

        System.out.println("原始列表: " + original.get(0));
        System.out.println("浅拷贝列表: " + shallowCopy.get(0));

        // 5. 注意集合的容量和大小
        List<String> capacityList = new ArrayList<>(100);
        System.out.println("容量为100的列表大小: " + capacityList.size()); // 0

        // 6. 使用正确的比较方法
        List<String> strings1 = Arrays.asList("A", "B", "C");
        List<String> strings2 = Arrays.asList("A", "B", "C");

        System.out.println("列表内容相等: " + strings1.equals(strings2)); // true
        System.out.println("列表引用相等: " + (strings1 == strings2)); // false
    }
}
```
