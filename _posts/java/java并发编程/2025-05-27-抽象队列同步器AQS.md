---
title: "抽象队列同步器 AQS"
date: 2025-05-27 12:12:12 +0800
categories: [JAVA, JAVA 并发编程]
tags: [并发编程, JUC]
pin: false
toc: true
math: true
---

AQS 是 Java 并发包（`java.util.concurrent`）中的核心组件之一，全称为 `AbstractQueuedSynchronizer`，即抽象队列同步器。它是一个用于构建锁和同步器的基础框架，提供了基于先进先出（FIFO）队列的同步机制，用于管理线程的排队等待和唤醒。

## AQS 的核心组件：

### 同步状态（`state`）：

AQS 使用一个整数（`state`）来表示同步状态，这个状态的含义取决于具体的同步器实现。例如，在 `ReentrantLock`（可重入锁）中，`state` 表示锁被当前线程持有的次数；在 `CountDownLatch`（倒计时锁存器）中，`state` 表示还需要等待的计数。

AQS 提供了对 `state` 的操作方法，如 `compareAndSetState`（通过 CAS 操作更新 `state`，保证操作的原子性），`getState`（获取当前 `state` 值）和 `setState`（设置 `state` 值）。

### CLH 队列：

AQS 内部维护了一个先进先出的队列，用于管理那些获取同步状态失败的线程。这个队列是基于单向链表实现的，队列中的每个节点（Node）代表一个线程。CLH（Craig、Landin 和 Hagersten）队列是一种自旋锁队列，AQS 对其进行了改进，使其适用于阻塞和唤醒线程的场景。

队列中的节点有几种状态：

- `CANCELLED（1）`：表示线程的等待被取消，可能是由于线程中断或者等待时间过长等原因。
- `SIGNAL（-1）`：表示当前节点的线程已经被唤醒，需要唤醒它的后继节点。
- `CONDITION（-2）`：表示节点在等待某个条件（如在 `ConditionObject` 中使用）。
- `PROPAGATE（-3）`：用于共享模式，表示当前节点的线程获取了资源，需要通知后续节点。
- `INITIAL（0）`：初始状态，表示节点刚加入队列时的状态。

AQS 提供了对队列的操作，如 `enq`（将节点加入队列尾部）、`deq`（从队列头部移除节点）等。当线程尝试获取同步状态失败时，会被包装成一个节点并加入队列等待；当同步状态变为可用时，会从队列头部开始唤醒线程。

## AQS 的同步模式：

### 独占模式：

独占模式是指一次只有一个线程可以获取同步状态。例如，`ReentrantLock` 就是基于 AQS 的独占模式实现的。在这种模式下，线程获取同步状态后，其他线程必须等待，直到当前线程释放同步状态。

实现逻辑：

- 获取锁：线程尝试获取同步状态，如果获取成功，直接返回；如果获取失败，线程会被包装成一个节点并加入队列。AQS 会通过循环尝试获取锁，并在合适的时候将线程阻塞。当线程被唤醒时，再次尝试获取锁，直到成功为止。
- 释放锁：线程释放同步状态后，会唤醒队列头部的节点，让下一个线程有机会获取锁。

### 共享模式：

共享模式允许多个线程同时获取同步状态。例如，`Semaphore`（信号量）和 `CountDownLatch` 就是基于共享模式实现的。在这种模式下，线程获取同步状态时，只要当前状态满足条件，就可以成功获取，并且可以有多个线程同时持有同步状态。

**实现逻辑：**

- 获取锁：线程尝试获取同步状态，如果当前状态满足条件，线程可以直接获取锁；如果获取失败，线程会被包装成一个节点并加入队列。与独占模式不同的是，共享模式下，当一个线程获取锁后，可能会通知队列中的多个节点，让它们尝试获取锁。
- 释放锁：线程释放同步状态后，会更新同步状态，并通知队列中的节点。如果当前状态已经满足多个线程获取锁的条件，可能会唤醒多个节点。

## AQS 的子类实现：

### `ReentrantLock`（可重入锁）：

- 特点：`ReentrantLock` 是一个可重入的互斥锁，它基于 AQS 的独占模式实现。可重入是指一个线程可以多次获取同一个锁，而不会导致死锁。`ReentrantLock` 提供了比 `synchronized` 更灵活的锁操作，例如可以尝试非阻塞地获取锁（`tryLock`）、设置锁的等待时间等。
- 实现原理：`ReentrantLock` 通过 AQS 的 `state` 来记录锁被当前线程持有的次数。当线程第一次获取锁时，`state` 加 1；每次重入锁时，`state` 再加 1。释放锁时，`state` 减 1，直到 `state` 为 0，表示锁被完全释放。如果线程尝试获取锁而失败，会被包装成一个节点并加入 AQS 的队列等待。

### `CountDownLatch`（倒计时锁存器）：

- 特点：`CountDownLatch` 是一个同步辅助工具，它允许一个或多个线程等待其他线程完成操作。它通过一个计数器来实现，当计数器的值减到 0 时，所有等待的线程会被唤醒。
- 实现原理：`CountDownLatch` 基于 AQS 的共享模式实现。它的 `state` 表示计数器的值。当线程调用 `countDown` 方法时，`state` 减 1；当线程调用 `await` 方法时，会尝试获取共享锁。如果 `state` 大于 0，线程会被阻塞；当 `state` 减到 0 时，所有等待的线程都会被唤醒。

### `Semaphore`（信号量）：

- 特点：`Semaphore` 是一个基于计数的同步器，它可以控制同时访问某个资源的线程数量。它通过维护一个许可（`permit`）的数量来实现，线程可以通过获取许可来访问资源，释放许可后其他线程可以获取。
- 实现原理：`Semaphore` 基于 AQS 的共享模式实现。它的 `state` 表示可用的许可数量。当线程调用 `acquire` 方法时，会尝试获取许可；如果许可数量大于 0，`state` 减 1，线程获取许可；如果许可数量为 0，线程会被阻塞。当线程调用 `release` 方法时，`state` 加 1，释放许可，并可能唤醒队列中的线程。

### `CyclicBarrier`（循环栅栏）：

- 特点：`CyclicBarrier` 是一个同步辅助工具，它允许一组线程到达一个屏障点后全部被阻塞，直到最后一个线程到达屏障点，然后所有线程一起继续执行。它支持重置，可以重复使用。
- 实现原理：`CyclicBarrier` 通过 AQS 的共享模式实现。它内部维护一个计数器，记录到达屏障点的线程数量。当线程调用 `await` 方法时，会尝试获取共享锁；如果当前线程数量未达到屏障点，线程会被阻塞；当所有线程都到达屏障点时，所有线程会被唤醒并继续执行。
