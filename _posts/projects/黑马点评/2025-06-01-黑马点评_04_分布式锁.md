---
title: "黑马点评_04_分布式锁"
date: 2025-06-01 04:04:04 +0800
categories: [JAVA后端项目, 黑马点评]
tags: [分布式, Redis]
pin: false
toc: true
math: true
---

# 黑马点评*04*分布式锁

## S (Situation - 情景):

在秒杀场景中，为了防止一个用户发起多个并发请求导致重复下单，需要对“用户下单”这个操作加锁。在分布式集群环境下，Java 的 synchronized 或 Lock 只能锁定单个 JVM 进程内的线程，无法起到跨服务器锁定的作用。

## T (Task - 任务):

实现一个可靠的分布式锁，确保在集群环境中，同一时间只有一个线程能执行特定用户的下单逻辑。

## A (Action - 行动):

1. **V1 - 基础实现 (SETNX):** 使用 SETNX key value。能实现互斥，但如果持有锁的客户端崩溃，锁无法被释放，导致死锁。
2. **V2 - 超时释放 (SETNX + EXPIRE):** 在 SETNX 成功后，再用 EXPIRE 设置超时时间。但这两步操作非原子，如果 SETNX 成功后客户端崩溃，EXPIRE 没来得及执行，依然会死锁。
3. **V3 - 原子加锁 (SET ... NX EX):** 使用 SET key value NX EX timeout 命令，将加锁和设置过期时间合并为一步原子操作，解决了死锁问题。
4. **V4 - 防止误删 (标识+Lua):** V3 引入了新问题：如果线程 A 的业务执行时间超过了锁的超时时间，锁会自动释放。此时线程 B 获取了锁。随后线程 A 执行完毕，它会执行 DEL 命令，错误地删除了线程 B 的锁。

   - 解决方案： 在加锁时，将 value 设置为一个唯一的线程标识（如 UUID）。释放锁时，先 GET 锁的 value，判断是否与自己的标识相等，相等才 DEL。
   - 原子性保障： “GET、判断、DEL”这三步又不是原子的。因此，将这套逻辑写入一个 Lua 脚本，利用 Redis 执行 Lua 脚本的原子性，彻底解决了误删问题。

5. **V5 - 最终方案 (Redisson):** 放弃手写锁，直接引入 Redisson Java 客户端。

   - 使用 `redissonClient.getLock("key")` 获取一个 RLock 对象。
   - Redisson 的锁是可重入的，并且内置了**“看门狗”（watchdog）机制**：当一个线程成功获取锁后，一个后台线程会定时（默认每 10 秒）检查持锁线程是否还存活，如果存活，就自动为锁续期（默认续期到 30 秒）。这完美解决了业务执行超时导致锁被动释放的问题。

## R (Result - 结果):

1. 通过逐步迭代，最终采用 Redisson 实现了一个工业级的、健壮的分布式锁。
2. 成功地保证了秒杀业务在分布式高并发环境下的数据一致性和正确性，避免了核心的业务逻辑错误。
