---
title: "黑马点评_01_短信登录"
date: 2025-06-01 00:00:01 +0800
categories: [JAVA后端项目, 黑马点评]
tags: [分布式, Redis]
pin: false
toc: true
math: true
---

# 黑马点评\_01\_短信登录

## S (Situation - 情景):

项目初期使用单个 Tomcat 服务器，其登录功能依赖于标准的 HTTP Session。但在部署到生产环境的 Nginx 集群后（包含多个 Tomcat 实例），问题出现了：用户的登录请求被 Nginx 负载均衡到不同的 Tomcat 服务器上，而 Session 信息在各个 Tomcat 实例之间不共享。这导致用户在服务器 A 登录后，下一次请求被转发到服务器 B 时，系统会判定其为未登录状态，严重影响用户体验。

## T (Task - 任务):

改造现有的登录认证体系，**解决分布式环境下的 Session 共享问题**，确保用户在任何一个服务器实例上登录后，其登录状态在整个集群中都有效。

## A (Action - 行动):

1. **替换 Session 存储：** 放弃使用 Tomcat 内置的 Session，选择使用 Redis 作为统一的 Session 存储中心。因为 Redis 是独立于应用服务器的内存数据库，所有 Tomcat 实例都可以访问它。
2. **存储验证码：** 用户请求发送短信验证码时，不再将验证码存入 Session，而是以手机号为关键标识（如 `login:code:手机号`），将验证码存入 Redis 并设置一个较短的有效期。
3. **存储登录状态：** 用户验证通过后：

   - 生成一个全局唯一的随机 Token（使用 UUID），这个 Token 将作为用户登录凭证。
   - 将用户的核心信息（使用 UserDTO 对象以隐藏密码等敏感数据）转换成 Map 格式，存入 Redis 的 Hash 结构中。Key 为 `login:user:TOKEN`。
   - 为这个 Token 设置一个较长的有效期（例如 30 分钟），实现自动过期。

4. **实现登录拦截：**
   - 编写一个 `RefreshTokenInterceptor` 拦截器，它会拦截所有请求。
   - 该拦截器检查请求头中是否携带 Token。如果携带，就用这个 Token 去 Redis 查询用户信息。
   - 如果查询成功，说明用户已登录。此时，将用户信息存入 `ThreadLocal` 中，方便后续业务逻辑直接获取，并刷新 Token 的有效期（这是关键，实现了用户活跃时自动续期）。
   - 编写第二个 `LoginInterceptor` 拦截器，它只拦截需要登录才能访问的路径。它的逻辑非常简单：直接检查 `ThreadLocal` 中是否有用户信息。如果没有，就拦截请求并返回 401 未授权状态。

## R (Result - 结果):

1. 成功解决了分布式 Session 共享问题，用户登录状态在整个集群中保持一致，体验流畅。
2. 通过 Token 机制，实现了客户端与服务端的无状态通信，有利于系统的水平扩展。
3. 实现了登录状态的自动续期，只要用户保持活跃，就不会被强制下线，提升了用户体验。
4. 将敏感信息通过 DTO 进行了隔离，增强了系统的安全性。
