---
title: "黑马点评_03_优惠劵秒杀"
date: 2025-06-01 02:02:02 +0800
categories: [JAVA后端项目, 黑马点评]
tags: [分布式, Redis]
pin: false
toc: true
math: true
---

## S (Situation - 情景):

优惠券秒杀活动具有瞬时高并发的特点。最初的实现方案直接操作数据库，存在严重的并发安全问题：库存超卖（多个线程同时判断库存充足并扣减）和一人多单（多个请求同时判断用户未下单并创建订单）。此外，同步处理所有逻辑导致响应时间长，用户体验差。

## T (Task - 任务):

构建一个高性能、高可用的秒杀系统，必须确保：1) 库存不被超卖；2) 每个用户只能成功抢购一张券；3) 在高并发下系统能快速响应，不崩溃。

## A (Action - 行动):

1. 解决库存超卖：

   - 乐观锁： 优化扣减库存的 SQL 语句，利用数据库的原子性。将 UPDATE ... SET stock = stock - 1 WHERE voucher_id = ?改为 UPDATE ... SET stock = stock - 1 WHERE voucher_id = ? AND stock > 0。只有在库存大于 0 时，更新才会成功，从而在数据库层面防止了超卖。

2. 解决一人多单（集群模式）：
   - 引入分布式锁： 由于 synchronized 在集群环境下失效，引入了基于 Redis 的分布式锁（详见功能点 11）。在用户下单的业务逻辑外层，对用户 ID 加锁 lock("order:" + userId)，确保同一时间只有一个线程能处理该用户的下单请求。最终采用 Redisson 客户端，因为它提供了带“看门狗”机制的可重入锁，更加健壮。
3. 性能异步优化：
   - 资格预判断： 将秒杀的核心判断逻辑（查库存、查是否已下单）完全移到 Redis 中执行，避免了对数据库的直接访问。
   - Lua 脚本保证原子性： 编写一个 Lua 脚本，将“判断库存是否充足”、“判断用户是否已在 Set 中”、“扣减库存”、“将用户 ID 加入 Set”这几个步骤合并成一个原子操作。这避免了在应用层面做这些判断时可能出现的并发问题。
   - 引入消息队列 (Redis Stream)： 当 Lua 脚本判断用户有抢购资格后，不再同步地去数据库创建订单。而是将订单信息（voucherId, userId, orderId）作为一个消息，通过 XADD 命令发送到 Redis Stream 中。
   - 异步下单： 在系统启动时，开启一个独立的后台线程。这个线程作为一个消费者，循环地从 Redis Stream 中拉取订单消息，然后慢慢地、异步地将订单数据写入数据库。

## R (Result - 结果):

1. 秒杀接口的响应速度从几百毫秒优化到几十毫秒，能够承受极高的并发请求，用户体验极佳。
2. 通过 Lua 脚本和异步消息队列，成功地将流量洪峰削平，保护了后端的 MySQL 数据库。
3. 通过乐观锁和分布式锁，彻底解决了库存超卖和一人多单的问题，保证了业务的正确性和公平性。
