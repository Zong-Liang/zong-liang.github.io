---
title: "黑马点评_02_商户查询缓存"
date: 2025-06-01 01:01:01 +0800
categories: [JAVA后端项目, 黑马点评]
tags: [分布式, Redis]
pin: false
toc: true
math: true
---

# 黑马点评\_02\_商户查询缓存

## S (Situation - 情景):

商户查询功能是应用的核心功能之一，访问量巨大。每次查询都直接请求 MySQL 数据库，导致数据库压力过大，且响应速度较慢。在高并发场景下，还可能遇到缓存穿透、缓存击穿和缓存雪崩等经典问题，对系统稳定性构成巨大威胁。

## T (Task - 任务):

为商户查询功能增加缓存层，以提升查询性能、降低数据库负载，并设计一套完整的方案来应对缓存穿透、击穿和雪崩问题。

## A (Action - 行动):

1. **缓存基本策略 (Cache Aside Pattern):** 查询时，先查 Redis 缓存。如果缓存命中，则直接返回数据。如果未命中，则查询 MySQL 数据库，然后将查询结果写入 Redis 缓存（并设置 TTL），最后再返回给用户。
2. **解决缓存穿透 (查询不存在的数据):**
   - **缓存空对象：** 当从数据库查询一个不存在的商户时（返回 null），不直接返回，而是在 Redis 中缓存一个特殊的空字符串，并设置一个较短的 TTL。这样，后续对同一个不存在商户的查询请求就会命中这个“空缓存”，直接返回，避免了对数据库的重复攻击。
3. **解决缓存击穿 (热点 Key 失效):**
   - **方案一：互斥锁 (Mutex)：** 当一个热点商户的缓存失效时，第一个查询请求会获取一个基于商户 ID 的分布式锁（使用 Redis 的 SETNX 实现）。获取锁成功的线程负责查询数据库并重建缓存，其他线程则短暂休眠后重试。这样可以确保只有一个线程去访问数据库，防止并发冲击。
   - **方案二：逻辑过期：** 数据存入 Redis 时不设置物理过期时间，而是在 Value 中包含一个逻辑过期时间字段。查询时，如果发现数据已逻辑过期，当前线程不会等待，而是直接返回旧数据，同时尝试获取锁。获取锁成功的线程会开启一个新线程去异步重建缓存。此方案以短暂的数据不一致性换取了极高的可用性。
4. **解决缓存雪崩 (大量 Key 同时失效):**
   - **随机化 TTL：** 在设置缓存的过期时间时，增加一个随机值，打散过期时间点，避免大量 Key 在同一时刻集中失效。
5. **数据一致性：** 更新商户信息时，采用**先更新数据库，再删除缓存**的策略。这能最大程度保证数据一致性。
6. **工具类封装：** 将上述解决缓存问题的复杂逻辑统一封装到一个名为 CacheClient 的工具类中，使得业务代码调用缓存时非常简洁。

## R (Result - 结果):

1. 系统查询性能得到极大提升，数据库压力显著降低。
2. 通过缓存空对象和互斥锁/逻辑过期，有效防止了缓存穿透和缓存击穿，增强了系统在高并发下的稳定性和鲁棒性。
3. 代码通过工具类封装后，结构清晰，可复用性高，便于维护和扩展。
